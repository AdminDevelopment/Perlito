;; Do not edit this file - Generated by MiniPerl6 4.1
(defpackage mp-MiniPerl6-Grammar
  (:use common-lisp mp-Main))
(if (not (ignore-errors (find-class 'mp-MiniPerl6-Grammar)))
  (defclass mp-MiniPerl6-Grammar () ()))
;; method ident
(if (not (ignore-errors (find-method 'sv-ident () ())))
  (defgeneric sv-ident (sv-grammar &optional sv-str sv-pos)
      (:documentation "a method")))
;; method full_ident
(if (not (ignore-errors (find-method 'sv-full_ident () ())))
  (defgeneric sv-full_ident (sv-grammar &optional sv-str sv-pos)
      (:documentation "a method")))
;; method namespace_before_ident
(if (not (ignore-errors (find-method 'sv-namespace_before_ident () ())))
  (defgeneric sv-namespace_before_ident (sv-grammar &optional sv-str sv-pos)
      (:documentation "a method")))
;; method optional_namespace_before_ident
(if (not (ignore-errors (find-method 'sv-optional_namespace_before_ident () ())))
  (defgeneric sv-optional_namespace_before_ident (sv-grammar &optional sv-str sv-pos)
      (:documentation "a method")))
;; method pod_begin
(if (not (ignore-errors (find-method 'sv-pod_begin () ())))
  (defgeneric sv-pod_begin (sv-grammar &optional sv-str sv-pos)
      (:documentation "a method")))
;; method ws
(if (not (ignore-errors (find-method 'sv-ws () ())))
  (defgeneric sv-ws (sv-grammar &optional sv-str sv-pos)
      (:documentation "a method")))
;; method opt_ws
(if (not (ignore-errors (find-method 'sv-opt_ws () ())))
  (defgeneric sv-opt_ws (sv-grammar &optional sv-str sv-pos)
      (:documentation "a method")))
;; method opt_ws2
(if (not (ignore-errors (find-method 'sv-opt_ws2 () ())))
  (defgeneric sv-opt_ws2 (sv-grammar &optional sv-str sv-pos)
      (:documentation "a method")))
;; method opt_ws3
(if (not (ignore-errors (find-method 'sv-opt_ws3 () ())))
  (defgeneric sv-opt_ws3 (sv-grammar &optional sv-str sv-pos)
      (:documentation "a method")))
;; method parse
(if (not (ignore-errors (find-method 'sv-parse () ())))
  (defgeneric sv-parse (sv-grammar &optional sv-str sv-pos)
      (:documentation "a method")))
;; method comp_unit
(if (not (ignore-errors (find-method 'sv-comp_unit () ())))
  (defgeneric sv-comp_unit (sv-grammar &optional sv-str sv-pos)
      (:documentation "a method")))
;; method infix_op
(if (not (ignore-errors (find-method 'sv-infix_op () ())))
  (defgeneric sv-infix_op (sv-grammar &optional sv-str sv-pos)
      (:documentation "a method")))
;; method hyper_op
(if (not (ignore-errors (find-method 'sv-hyper_op () ())))
  (defgeneric sv-hyper_op (sv-grammar &optional sv-str sv-pos)
      (:documentation "a method")))
;; method prefix_op
(if (not (ignore-errors (find-method 'sv-prefix_op () ())))
  (defgeneric sv-prefix_op (sv-grammar &optional sv-str sv-pos)
      (:documentation "a method")))
;; method declarator
(if (not (ignore-errors (find-method 'sv-declarator () ())))
  (defgeneric sv-declarator (sv-grammar &optional sv-str sv-pos)
      (:documentation "a method")))
;; method exp2
(if (not (ignore-errors (find-method 'sv-exp2 () ())))
  (defgeneric sv-exp2 (sv-grammar &optional sv-str sv-pos)
      (:documentation "a method")))
;; method exp_stmts2
(if (not (ignore-errors (find-method 'sv-exp_stmts2 () ())))
  (defgeneric sv-exp_stmts2 (sv-grammar &optional sv-str sv-pos)
      (:documentation "a method")))
;; method exp
(if (not (ignore-errors (find-method 'sv-exp () ())))
  (defgeneric sv-exp (sv-grammar &optional sv-str sv-pos)
      (:documentation "a method")))
;; method opt_ident
(if (not (ignore-errors (find-method 'sv-opt_ident () ())))
  (defgeneric sv-opt_ident (sv-grammar &optional sv-str sv-pos)
      (:documentation "a method")))
;; method term_meth
(if (not (ignore-errors (find-method 'sv-term_meth () ())))
  (defgeneric sv-term_meth (sv-grammar &optional sv-str sv-pos)
      (:documentation "a method")))
;; method sub_or_method_name
(if (not (ignore-errors (find-method 'sv-sub_or_method_name () ())))
  (defgeneric sv-sub_or_method_name (sv-grammar &optional sv-str sv-pos)
      (:documentation "a method")))
;; method opt_type
(if (not (ignore-errors (find-method 'sv-opt_type () ())))
  (defgeneric sv-opt_type (sv-grammar &optional sv-str sv-pos)
      (:documentation "a method")))
;; method exp_term
(if (not (ignore-errors (find-method 'sv-exp_term () ())))
  (defgeneric sv-exp_term (sv-grammar &optional sv-str sv-pos)
      (:documentation "a method")))
;; method var_sigil
(if (not (ignore-errors (find-method 'sv-var_sigil () ())))
  (defgeneric sv-var_sigil (sv-grammar &optional sv-str sv-pos)
      (:documentation "a method")))
;; method var_twigil
(if (not (ignore-errors (find-method 'sv-var_twigil () ())))
  (defgeneric sv-var_twigil (sv-grammar &optional sv-str sv-pos)
      (:documentation "a method")))
;; method var_name
(if (not (ignore-errors (find-method 'sv-var_name () ())))
  (defgeneric sv-var_name (sv-grammar &optional sv-str sv-pos)
      (:documentation "a method")))
;; method var_ident
(if (not (ignore-errors (find-method 'sv-var_ident () ())))
  (defgeneric sv-var_ident (sv-grammar &optional sv-str sv-pos)
      (:documentation "a method")))
;; method val
(if (not (ignore-errors (find-method 'sv-val () ())))
  (defgeneric sv-val (sv-grammar &optional sv-str sv-pos)
      (:documentation "a method")))
;; method val_bit
(if (not (ignore-errors (find-method 'sv-val_bit () ())))
  (defgeneric sv-val_bit (sv-grammar &optional sv-str sv-pos)
      (:documentation "a method")))
;; method digits
(if (not (ignore-errors (find-method 'sv-digits () ())))
  (defgeneric sv-digits (sv-grammar &optional sv-str sv-pos)
      (:documentation "a method")))
;; method val_undef
(if (not (ignore-errors (find-method 'sv-val_undef () ())))
  (defgeneric sv-val_undef (sv-grammar &optional sv-str sv-pos)
      (:documentation "a method")))
;; method val_num
(if (not (ignore-errors (find-method 'sv-val_num () ())))
  (defgeneric sv-val_num (sv-grammar &optional sv-str sv-pos)
      (:documentation "a method")))
;; method char_any
(if (not (ignore-errors (find-method 'sv-char_any () ())))
  (defgeneric sv-char_any (sv-grammar &optional sv-str sv-pos)
      (:documentation "a method")))
;; method single_quoted_unescape
(if (not (ignore-errors (find-method 'sv-single_quoted_unescape () ())))
  (defgeneric sv-single_quoted_unescape (sv-grammar &optional sv-str sv-pos)
      (:documentation "a method")))
;; method double_quoted_unescape
(if (not (ignore-errors (find-method 'sv-double_quoted_unescape () ())))
  (defgeneric sv-double_quoted_unescape (sv-grammar &optional sv-str sv-pos)
      (:documentation "a method")))
;; method val_buf
(if (not (ignore-errors (find-method 'sv-val_buf () ())))
  (defgeneric sv-val_buf (sv-grammar &optional sv-str sv-pos)
      (:documentation "a method")))
;; method val_int
(if (not (ignore-errors (find-method 'sv-val_int () ())))
  (defgeneric sv-val_int (sv-grammar &optional sv-str sv-pos)
      (:documentation "a method")))
;; method exp_stmts
(if (not (ignore-errors (find-method 'sv-exp_stmts () ())))
  (defgeneric sv-exp_stmts (sv-grammar &optional sv-str sv-pos)
      (:documentation "a method")))
;; method exp_seq
(if (not (ignore-errors (find-method 'sv-exp_seq () ())))
  (defgeneric sv-exp_seq (sv-grammar &optional sv-str sv-pos)
      (:documentation "a method")))
;; method lit
(if (not (ignore-errors (find-method 'sv-lit () ())))
  (defgeneric sv-lit (sv-grammar &optional sv-str sv-pos)
      (:documentation "a method")))
;; method lit_object
(if (not (ignore-errors (find-method 'sv-lit_object () ())))
  (defgeneric sv-lit_object (sv-grammar &optional sv-str sv-pos)
      (:documentation "a method")))
;; method bind
(if (not (ignore-errors (find-method 'sv-bind () ())))
  (defgeneric sv-bind (sv-grammar &optional sv-str sv-pos)
      (:documentation "a method")))
;; method call
(if (not (ignore-errors (find-method 'sv-call () ())))
  (defgeneric sv-call (sv-grammar &optional sv-str sv-pos)
      (:documentation "a method")))
;; method apply
(if (not (ignore-errors (find-method 'sv-apply () ())))
  (defgeneric sv-apply (sv-grammar &optional sv-str sv-pos)
      (:documentation "a method")))
;; method opt_name
(if (not (ignore-errors (find-method 'sv-opt_name () ())))
  (defgeneric sv-opt_name (sv-grammar &optional sv-str sv-pos)
      (:documentation "a method")))
;; method var_invocant
(if (not (ignore-errors (find-method 'sv-var_invocant () ())))
  (defgeneric sv-var_invocant (sv-grammar &optional sv-str sv-pos)
      (:documentation "a method")))
;; method args_sig
(if (not (ignore-errors (find-method 'sv-args_sig () ())))
  (defgeneric sv-args_sig (sv-grammar &optional sv-str sv-pos)
      (:documentation "a method")))
;; method method_sig
(if (not (ignore-errors (find-method 'sv-method_sig () ())))
  (defgeneric sv-method_sig (sv-grammar &optional sv-str sv-pos)
      (:documentation "a method")))
;; method method_def
(if (not (ignore-errors (find-method 'sv-method_def () ())))
  (defgeneric sv-method_def (sv-grammar &optional sv-str sv-pos)
      (:documentation "a method")))
;; method sub_def
(if (not (ignore-errors (find-method 'sv-sub_def () ())))
  (defgeneric sv-sub_def (sv-grammar &optional sv-str sv-pos)
      (:documentation "a method")))
;; method token
(if (not (ignore-errors (find-method 'sv-token () ())))
  (defgeneric sv-token (sv-grammar &optional sv-str sv-pos)
      (:documentation "a method")))
;; class MiniPerl6::Grammar
(let ((sv-Class_name (sv-undef)))
(let (x) 
  (setq x (make-instance 'mp-MiniPerl6-Grammar))
  (defun proto-mp-MiniPerl6-Grammar () x))
(defun mp-MiniPerl6-Grammar-sv-get_class_name ()
  (block mp6-function (progn sv-Class_name)))
(in-package mp-MiniPerl6-Grammar)
  (defun sv-get_class_name ()
    (mp-Main::mp-MiniPerl6-Grammar-sv-get_class_name ))
(in-package mp-Main)
;; method ident
(defmethod sv-ident ((sv-grammar mp-MiniPerl6-Grammar) &optional sv-str sv-pos)
  (block mp6-function
    (let ((sv-MATCH (sv-undef))) (setf sv-MATCH (let ((m (make-instance 'mp-MiniPerl6-Match))) (setf (sv-str m) sv-str)(setf (sv-from m) sv-pos)(setf (sv-to m) sv-pos)(setf (sv-bool m) 1) m))(setf (sv-bool sv-MATCH ) (let ((sv-pos1 (sv-undef))) (setf sv-pos1 (sv-to sv-MATCH ))(progn (sv-and (let ((sv-pos1 (sv-undef))) (setf sv-pos1 (sv-to sv-MATCH ))(sv-or (progn (sv-and (let ((sv-tmp (sv-undef))) (setf sv-tmp sv-MATCH)(setf sv-MATCH (let ((m (make-instance 'mp-MiniPerl6-Match))) (setf (sv-str m) sv-str)(setf (sv-from m) (sv-to sv-tmp ))(setf (sv-to m) (sv-to sv-tmp ))(setf (sv-bool m) 1) m))(setf (sv-bool sv-MATCH ) (let ((sv-pos1 (sv-undef))) (setf sv-pos1 (sv-to sv-MATCH ))(progn (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-digit sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn nil))))))(setf (sv-bool sv-tmp ) (not (sv-bool sv-MATCH)))(setf sv-MATCH sv-tmp)(sv-bool sv-MATCH)) (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-word sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn nil))))) (progn (setf (sv-to sv-MATCH ) sv-pos1)(if (sv-bool (sv-eq "_" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (sv-add 1 (setf (sv-to sv-MATCH ) (sv-add 1 (sv-to sv-MATCH )))) nil)))) (let ((sv-last_match_null (sv-undef))(sv-last_pos (sv-undef))) (setf sv-last_match_null 0)(setf sv-last_pos (sv-to sv-MATCH ))(loop while (sv-bool (sv-and (let ((sv-pos1 (sv-undef))) (setf sv-pos1 (sv-to sv-MATCH ))(sv-or (progn (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-word sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn nil)))) (sv-or (progn (setf (sv-to sv-MATCH ) sv-pos1)(if (sv-bool (sv-eq "_" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (sv-add 1 (setf (sv-to sv-MATCH ) (sv-add 1 (sv-to sv-MATCH )))) nil)) (progn (setf (sv-to sv-MATCH ) sv-pos1)(let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-digit sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn nil))))))) (sv-numeric-smaller sv-last_match_null 2))) do (progn (if (sv-bool (sv-numeric-equal sv-last_pos (sv-to sv-MATCH ))) (progn (setf sv-last_match_null (sv-add sv-last_match_null 1))) (progn (setf sv-last_match_null 0)))(setf sv-last_pos (sv-to sv-MATCH ))))(setf (sv-to sv-MATCH ) sv-last_pos)1)))))sv-MATCH)))

;; method full_ident
(defmethod sv-full_ident ((sv-grammar mp-MiniPerl6-Grammar) &optional sv-str sv-pos)
  (block mp6-function
    (let ((sv-MATCH (sv-undef))) (setf sv-MATCH (let ((m (make-instance 'mp-MiniPerl6-Match))) (setf (sv-str m) sv-str)(setf (sv-from m) sv-pos)(setf (sv-to m) sv-pos)(setf (sv-bool m) 1) m))(setf (sv-bool sv-MATCH ) (let ((sv-pos1 (sv-undef))) (setf sv-pos1 (sv-to sv-MATCH ))(progn (sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-ident sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn nil))) (let ((sv-last_match_null (sv-undef))(sv-last_pos (sv-undef))) (setf sv-last_match_null 0)(setf sv-last_pos (sv-to sv-MATCH ))(loop while (sv-bool (sv-and (let ((sv-pos1 (sv-undef))) (setf sv-pos1 (sv-to sv-MATCH ))(progn (sv-and (if (sv-bool (sv-eq "::" (sv-substr sv-str (sv-to sv-MATCH ) 2))) (sv-add 1 (setf (sv-to sv-MATCH ) (sv-add 2 (sv-to sv-MATCH )))) nil) (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-ident sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn nil)))))) (sv-numeric-smaller sv-last_match_null 2))) do (progn (if (sv-bool (sv-numeric-equal sv-last_pos (sv-to sv-MATCH ))) (progn (setf sv-last_match_null (sv-add sv-last_match_null 1))) (progn (setf sv-last_match_null 0)))(setf sv-last_pos (sv-to sv-MATCH ))))(setf (sv-to sv-MATCH ) sv-last_pos)1)))))sv-MATCH)))

;; method namespace_before_ident
(defmethod sv-namespace_before_ident ((sv-grammar mp-MiniPerl6-Grammar) &optional sv-str sv-pos)
  (block mp6-function
    (let ((sv-MATCH (sv-undef))) (setf sv-MATCH (let ((m (make-instance 'mp-MiniPerl6-Match))) (setf (sv-str m) sv-str)(setf (sv-from m) sv-pos)(setf (sv-to m) sv-pos)(setf (sv-bool m) 1) m))(setf (sv-bool sv-MATCH ) (let ((sv-pos1 (sv-undef))) (setf sv-pos1 (sv-to sv-MATCH ))(progn (sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-ident sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn nil))) (sv-and (let ((sv-tmp (sv-undef))) (setf sv-tmp sv-MATCH)(setf sv-MATCH (let ((m (make-instance 'mp-MiniPerl6-Match))) (setf (sv-str m) sv-str)(setf (sv-from m) (sv-to sv-tmp ))(setf (sv-to m) (sv-to sv-tmp ))(setf (sv-bool m) 1) m))(setf (sv-bool sv-MATCH ) (let ((sv-pos1 (sv-undef))) (setf sv-pos1 (sv-to sv-MATCH ))(progn (if (sv-bool (sv-eq "::" (sv-substr sv-str (sv-to sv-MATCH ) 2))) (sv-add 1 (setf (sv-to sv-MATCH ) (sv-add 2 (sv-to sv-MATCH )))) nil))))(setf (sv-bool sv-tmp ) (sv-bool sv-MATCH))(setf sv-MATCH sv-tmp)(sv-bool sv-MATCH)) (let ((sv-last_match_null (sv-undef))(sv-last_pos (sv-undef))) (setf sv-last_match_null 0)(setf sv-last_pos (sv-to sv-MATCH ))(loop while (sv-bool (sv-and (let ((sv-pos1 (sv-undef))) (setf sv-pos1 (sv-to sv-MATCH ))(progn (sv-and (if (sv-bool (sv-eq "::" (sv-substr sv-str (sv-to sv-MATCH ) 2))) (sv-add 1 (setf (sv-to sv-MATCH ) (sv-add 2 (sv-to sv-MATCH )))) nil) (sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-ident sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn nil))) (let ((sv-tmp (sv-undef))) (setf sv-tmp sv-MATCH)(setf sv-MATCH (let ((m (make-instance 'mp-MiniPerl6-Match))) (setf (sv-str m) sv-str)(setf (sv-from m) (sv-to sv-tmp ))(setf (sv-to m) (sv-to sv-tmp ))(setf (sv-bool m) 1) m))(setf (sv-bool sv-MATCH ) (let ((sv-pos1 (sv-undef))) (setf sv-pos1 (sv-to sv-MATCH ))(progn (if (sv-bool (sv-eq "::" (sv-substr sv-str (sv-to sv-MATCH ) 2))) (sv-add 1 (setf (sv-to sv-MATCH ) (sv-add 2 (sv-to sv-MATCH )))) nil))))(setf (sv-bool sv-tmp ) (sv-bool sv-MATCH))(setf sv-MATCH sv-tmp)(sv-bool sv-MATCH)))))) (sv-numeric-smaller sv-last_match_null 2))) do (progn (if (sv-bool (sv-numeric-equal sv-last_pos (sv-to sv-MATCH ))) (progn (setf sv-last_match_null (sv-add sv-last_match_null 1))) (progn (setf sv-last_match_null 0)))(setf sv-last_pos (sv-to sv-MATCH ))))(setf (sv-to sv-MATCH ) sv-last_pos)1))))))sv-MATCH)))

;; method optional_namespace_before_ident
(defmethod sv-optional_namespace_before_ident ((sv-grammar mp-MiniPerl6-Grammar) &optional sv-str sv-pos)
  (block mp6-function
    (let ((sv-MATCH (sv-undef))) (setf sv-MATCH (let ((m (make-instance 'mp-MiniPerl6-Match))) (setf (sv-str m) sv-str)(setf (sv-from m) sv-pos)(setf (sv-to m) sv-pos)(setf (sv-bool m) 1) m))(setf (sv-bool sv-MATCH ) (let ((sv-pos1 (sv-undef))) (setf sv-pos1 (sv-to sv-MATCH ))(sv-or (progn (sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-namespace_before_ident sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (mp-Main::sv-hash-lookup "namespace_before_ident" sv-MATCH) sv-m2)1) (progn nil))) (sv-and (if (sv-bool (sv-eq "::" (sv-substr sv-str (sv-to sv-MATCH ) 2))) (sv-add 1 (setf (sv-to sv-MATCH ) (sv-add 2 (sv-to sv-MATCH )))) nil) (sv-or (progn (setf (sv-capture sv-MATCH) (sv-string (mp-Main::sv-hash-lookup "namespace_before_ident" sv-MATCH)))) 1)))) (progn (setf (sv-to sv-MATCH ) sv-pos1)(sv-and 1 (sv-or (progn (setf (sv-capture sv-MATCH) "")) 1))))))sv-MATCH)))

;; method pod_begin
(defmethod sv-pod_begin ((sv-grammar mp-MiniPerl6-Grammar) &optional sv-str sv-pos)
  (block mp6-function
    (let ((sv-MATCH (sv-undef))) (setf sv-MATCH (let ((m (make-instance 'mp-MiniPerl6-Match))) (setf (sv-str m) sv-str)(setf (sv-from m) sv-pos)(setf (sv-to m) sv-pos)(setf (sv-bool m) 1) m))(setf (sv-bool sv-MATCH ) (let ((sv-pos1 (sv-undef))) (setf sv-pos1 (sv-to sv-MATCH ))(sv-or (progn (sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-is_newline sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn nil))) (sv-and (if (sv-bool (sv-eq "=end" (sv-substr sv-str (sv-to sv-MATCH ) 4))) (sv-add 1 (setf (sv-to sv-MATCH ) (sv-add 4 (sv-to sv-MATCH )))) nil) (let ((sv-last_match_null (sv-undef))(sv-last_pos (sv-undef))) (setf sv-last_match_null 0)(setf sv-last_pos (sv-to sv-MATCH ))(loop while (sv-bool (sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-not_newline sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn nil))) (sv-numeric-smaller sv-last_match_null 2))) do (progn (if (sv-bool (sv-numeric-equal sv-last_pos (sv-to sv-MATCH ))) (progn (setf sv-last_match_null (sv-add sv-last_match_null 1))) (progn (setf sv-last_match_null 0)))(setf sv-last_pos (sv-to sv-MATCH ))))(setf (sv-to sv-MATCH ) sv-last_pos)1)))) (progn (setf (sv-to sv-MATCH ) sv-pos1)(sv-and (if (sv-bool (not (sv-eq "" (sv-substr sv-str (sv-to sv-MATCH ) 1)))) (sv-add 1 (setf (sv-to sv-MATCH ) (sv-add 1 (sv-to sv-MATCH )))) nil) (sv-and (let ((sv-last_match_null (sv-undef))(sv-last_pos (sv-undef))) (setf sv-last_match_null 0)(setf sv-last_pos (sv-to sv-MATCH ))(loop while (sv-bool (sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-not_newline sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn nil))) (sv-numeric-smaller sv-last_match_null 2))) do (progn (if (sv-bool (sv-numeric-equal sv-last_pos (sv-to sv-MATCH ))) (progn (setf sv-last_match_null (sv-add sv-last_match_null 1))) (progn (setf sv-last_match_null 0)))(setf sv-last_pos (sv-to sv-MATCH ))))(setf (sv-to sv-MATCH ) sv-last_pos)1) (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-pod_begin sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn nil)))))))))sv-MATCH)))

;; method ws
(defmethod sv-ws ((sv-grammar mp-MiniPerl6-Grammar) &optional sv-str sv-pos)
  (block mp6-function
    (let ((sv-MATCH (sv-undef))) (setf sv-MATCH (let ((m (make-instance 'mp-MiniPerl6-Match))) (setf (sv-str m) sv-str)(setf (sv-from m) sv-pos)(setf (sv-to m) sv-pos)(setf (sv-bool m) 1) m))(setf (sv-bool sv-MATCH ) (let ((sv-pos1 (sv-undef))) (setf sv-pos1 (sv-to sv-MATCH ))(progn (let ((sv-last_match_null (sv-undef))(sv-last_pos (sv-undef))(sv-count (sv-undef))) (setf sv-last_match_null 0)(setf sv-last_pos (sv-to sv-MATCH ))(setf sv-count 0)(loop while (sv-bool (sv-and (let ((sv-pos1 (sv-undef))) (setf sv-pos1 (sv-to sv-MATCH ))(sv-or (progn (sv-and (if (sv-bool (sv-eq "#" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (sv-add 1 (setf (sv-to sv-MATCH ) (sv-add 1 (sv-to sv-MATCH )))) nil) (let ((sv-last_match_null (sv-undef))(sv-last_pos (sv-undef))) (setf sv-last_match_null 0)(setf sv-last_pos (sv-to sv-MATCH ))(loop while (sv-bool (sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-not_newline sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn nil))) (sv-numeric-smaller sv-last_match_null 2))) do (progn (if (sv-bool (sv-numeric-equal sv-last_pos (sv-to sv-MATCH ))) (progn (setf sv-last_match_null (sv-add sv-last_match_null 1))) (progn (setf sv-last_match_null 0)))(setf sv-last_pos (sv-to sv-MATCH ))))(setf (sv-to sv-MATCH ) sv-last_pos)1))) (sv-or (progn (setf (sv-to sv-MATCH ) sv-pos1)(sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-is_newline sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn nil))) (let ((sv-pos1 (sv-undef))) (setf sv-pos1 (sv-to sv-MATCH ))(sv-or (progn (sv-and (if (sv-bool (sv-eq "=begin" (sv-substr sv-str (sv-to sv-MATCH ) 6))) (sv-add 1 (setf (sv-to sv-MATCH ) (sv-add 6 (sv-to sv-MATCH )))) nil) (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-pod_begin sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn nil))))) (sv-or (progn (setf (sv-to sv-MATCH ) sv-pos1)(sv-and (if (sv-bool (sv-eq "=for" (sv-substr sv-str (sv-to sv-MATCH ) 4))) (sv-add 1 (setf (sv-to sv-MATCH ) (sv-add 4 (sv-to sv-MATCH )))) nil) (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-pod_begin sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn nil))))) (progn (setf (sv-to sv-MATCH ) sv-pos1)1)))))) (progn (setf (sv-to sv-MATCH ) sv-pos1)(let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-space sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn nil))))))) (sv-numeric-smaller sv-last_match_null 2))) do (progn (if (sv-bool (sv-numeric-equal sv-last_pos (sv-to sv-MATCH ))) (progn (setf sv-last_match_null (sv-add sv-last_match_null 1))) (progn (setf sv-last_match_null 0)))(setf sv-last_pos (sv-to sv-MATCH ))(setf sv-count (sv-add sv-count 1))))(setf (sv-to sv-MATCH ) sv-last_pos)(sv-numeric-bigger sv-count 0)))))sv-MATCH)))

;; method opt_ws
(defmethod sv-opt_ws ((sv-grammar mp-MiniPerl6-Grammar) &optional sv-str sv-pos)
  (block mp6-function
    (let ((sv-MATCH (sv-undef))) (setf sv-MATCH (let ((m (make-instance 'mp-MiniPerl6-Match))) (setf (sv-str m) sv-str)(setf (sv-from m) sv-pos)(setf (sv-to m) sv-pos)(setf (sv-bool m) 1) m))(setf (sv-bool sv-MATCH ) (let ((sv-pos1 (sv-undef))) (setf sv-pos1 (sv-to sv-MATCH ))(progn (let ((sv-last_pos (sv-undef))) (setf sv-last_pos (sv-to sv-MATCH ))(if (sv-bool (not (sv-bool (progn (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-ws sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn nil))))))) (progn (setf (sv-to sv-MATCH ) sv-last_pos)) nil)1))))sv-MATCH)))

;; method opt_ws2
(defmethod sv-opt_ws2 ((sv-grammar mp-MiniPerl6-Grammar) &optional sv-str sv-pos)
  (block mp6-function
    (let ((sv-MATCH (sv-undef))) (setf sv-MATCH (let ((m (make-instance 'mp-MiniPerl6-Match))) (setf (sv-str m) sv-str)(setf (sv-from m) sv-pos)(setf (sv-to m) sv-pos)(setf (sv-bool m) 1) m))(setf (sv-bool sv-MATCH ) (let ((sv-pos1 (sv-undef))) (setf sv-pos1 (sv-to sv-MATCH ))(progn (let ((sv-last_pos (sv-undef))) (setf sv-last_pos (sv-to sv-MATCH ))(if (sv-bool (not (sv-bool (progn (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-ws sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn nil))))))) (progn (setf (sv-to sv-MATCH ) sv-last_pos)) nil)1))))sv-MATCH)))

;; method opt_ws3
(defmethod sv-opt_ws3 ((sv-grammar mp-MiniPerl6-Grammar) &optional sv-str sv-pos)
  (block mp6-function
    (let ((sv-MATCH (sv-undef))) (setf sv-MATCH (let ((m (make-instance 'mp-MiniPerl6-Match))) (setf (sv-str m) sv-str)(setf (sv-from m) sv-pos)(setf (sv-to m) sv-pos)(setf (sv-bool m) 1) m))(setf (sv-bool sv-MATCH ) (let ((sv-pos1 (sv-undef))) (setf sv-pos1 (sv-to sv-MATCH ))(progn (let ((sv-last_pos (sv-undef))) (setf sv-last_pos (sv-to sv-MATCH ))(if (sv-bool (not (sv-bool (progn (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-ws sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn nil))))))) (progn (setf (sv-to sv-MATCH ) sv-last_pos)) nil)1))))sv-MATCH)))

;; method parse
(defmethod sv-parse ((sv-grammar mp-MiniPerl6-Grammar) &optional sv-str sv-pos)
  (block mp6-function
    (let ((sv-MATCH (sv-undef))) (setf sv-MATCH (let ((m (make-instance 'mp-MiniPerl6-Match))) (setf (sv-str m) sv-str)(setf (sv-from m) sv-pos)(setf (sv-to m) sv-pos)(setf (sv-bool m) 1) m))(setf (sv-bool sv-MATCH ) (let ((sv-pos1 (sv-undef))) (setf sv-pos1 (sv-to sv-MATCH ))(sv-or (progn (sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-comp_unit sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (mp-Main::sv-hash-lookup "comp_unit" sv-MATCH) sv-m2)1) (progn nil))) (let ((sv-pos1 (sv-undef))) (setf sv-pos1 (sv-to sv-MATCH ))(sv-or (progn (sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-parse sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (mp-Main::sv-hash-lookup "parse" sv-MATCH) sv-m2)1) (progn nil))) (sv-or (progn (setf (sv-capture sv-MATCH) (let ((_tmp_ (concatenate 'list  (list (sv-scalar (mp-Main::sv-hash-lookup "comp_unit" sv-MATCH))) (coerce (sv-scalar (mp-Main::sv-hash-lookup "parse" sv-MATCH)) 'list)))) (make-array (length _tmp_) :adjustable 1 :fill-pointer t :initial-contents _tmp_)))) 1))) (progn (setf (sv-to sv-MATCH ) sv-pos1)(sv-or (progn (setf (sv-capture sv-MATCH) (let ((_tmp_ (concatenate 'list  (list (sv-scalar (mp-Main::sv-hash-lookup "comp_unit" sv-MATCH)))))) (make-array (length _tmp_) :adjustable 1 :fill-pointer t :initial-contents _tmp_)))) 1)))))) (progn (setf (sv-to sv-MATCH ) sv-pos1)(sv-or (progn (setf (sv-capture sv-MATCH) (make-array 0 :adjustable 1 :fill-pointer t))) 1)))))sv-MATCH)))

;; method comp_unit
(defmethod sv-comp_unit ((sv-grammar mp-MiniPerl6-Grammar) &optional sv-str sv-pos)
  (block mp6-function
    (let ((sv-MATCH (sv-undef))) (setf sv-MATCH (let ((m (make-instance 'mp-MiniPerl6-Match))) (setf (sv-str m) sv-str)(setf (sv-from m) sv-pos)(setf (sv-to m) sv-pos)(setf (sv-bool m) 1) m))(setf (sv-bool sv-MATCH ) (let ((sv-pos1 (sv-undef))) (setf sv-pos1 (sv-to sv-MATCH ))(progn (sv-and (let ((sv-last_pos (sv-undef))) (setf sv-last_pos (sv-to sv-MATCH ))(if (sv-bool (not (sv-bool (progn (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-ws sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn nil))))))) (progn (setf (sv-to sv-MATCH ) sv-last_pos)) nil)1) (sv-and (let ((sv-last_pos (sv-undef))) (setf sv-last_pos (sv-to sv-MATCH ))(if (sv-bool (not (sv-bool (progn (let ((sv-pos1 (sv-undef))) (setf sv-pos1 (sv-to sv-MATCH ))(progn (sv-and (if (sv-bool (sv-eq ";" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (sv-add 1 (setf (sv-to sv-MATCH ) (sv-add 1 (sv-to sv-MATCH )))) nil) (let ((sv-last_pos (sv-undef))) (setf sv-last_pos (sv-to sv-MATCH ))(if (sv-bool (not (sv-bool (progn (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-ws sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn nil))))))) (progn (setf (sv-to sv-MATCH ) sv-last_pos)) nil)1)))))))) (progn (setf (sv-to sv-MATCH ) sv-last_pos)) nil)1) (sv-and (let ((sv-last_pos (sv-undef))) (setf sv-last_pos (sv-to sv-MATCH ))(if (sv-bool (not (sv-bool (progn (let ((sv-pos1 (sv-undef))) (setf sv-pos1 (sv-to sv-MATCH ))(progn (sv-and (if (sv-bool (sv-eq "use" (sv-substr sv-str (sv-to sv-MATCH ) 3))) (sv-add 1 (setf (sv-to sv-MATCH ) (sv-add 3 (sv-to sv-MATCH )))) nil) (sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-ws sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn nil))) (sv-and (if (sv-bool (sv-eq "v6" (sv-substr sv-str (sv-to sv-MATCH ) 2))) (sv-add 1 (setf (sv-to sv-MATCH ) (sv-add 2 (sv-to sv-MATCH )))) nil) (sv-and (let ((sv-last_pos (sv-undef))) (setf sv-last_pos (sv-to sv-MATCH ))(if (sv-bool (not (sv-bool (progn (let ((sv-pos1 (sv-undef))) (setf sv-pos1 (sv-to sv-MATCH ))(progn (sv-and (if (sv-bool (sv-eq "-" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (sv-add 1 (setf (sv-to sv-MATCH ) (sv-add 1 (sv-to sv-MATCH )))) nil) (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-ident sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(if (sv-bool (nth-value 1 (mp-Main::sv-hash-lookup "ident" sv-MATCH))) (progn (sv-push (mp-Main::sv-hash-lookup "ident" sv-MATCH) sv-m2)) (progn (setf (mp-Main::sv-hash-lookup "ident" sv-MATCH) (let ((_tmp_ (concatenate 'list  (list sv-m2)))) (make-array (length _tmp_) :adjustable 1 :fill-pointer t :initial-contents _tmp_)))))1) (progn nil)))))))))) (progn (setf (sv-to sv-MATCH ) sv-last_pos)) nil)1) (sv-and (let ((sv-last_pos (sv-undef))) (setf sv-last_pos (sv-to sv-MATCH ))(if (sv-bool (not (sv-bool (progn (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-ws sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn nil))))))) (progn (setf (sv-to sv-MATCH ) sv-last_pos)) nil)1) (sv-and (if (sv-bool (sv-eq ";" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (sv-add 1 (setf (sv-to sv-MATCH ) (sv-add 1 (sv-to sv-MATCH )))) nil) (let ((sv-last_pos (sv-undef))) (setf sv-last_pos (sv-to sv-MATCH ))(if (sv-bool (not (sv-bool (progn (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-ws sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn nil))))))) (progn (setf (sv-to sv-MATCH ) sv-last_pos)) nil)1))))))))))))) (progn (setf (sv-to sv-MATCH ) sv-last_pos)) nil)1) (sv-and (let ((sv-pos1 (sv-undef))) (setf sv-pos1 (sv-to sv-MATCH ))(sv-or (progn (if (sv-bool (sv-eq "class" (sv-substr sv-str (sv-to sv-MATCH ) 5))) (sv-add 1 (setf (sv-to sv-MATCH ) (sv-add 5 (sv-to sv-MATCH )))) nil)) (progn (setf (sv-to sv-MATCH ) sv-pos1)(if (sv-bool (sv-eq "grammar" (sv-substr sv-str (sv-to sv-MATCH ) 7))) (sv-add 1 (setf (sv-to sv-MATCH ) (sv-add 7 (sv-to sv-MATCH )))) nil)))) (sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-ws sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn nil))) (sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-full_ident sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (mp-Main::sv-hash-lookup "full_ident" sv-MATCH) sv-m2)1) (progn nil))) (sv-and (let ((sv-last_pos (sv-undef))) (setf sv-last_pos (sv-to sv-MATCH ))(if (sv-bool (not (sv-bool (progn (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-ws sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn nil))))))) (progn (setf (sv-to sv-MATCH ) sv-last_pos)) nil)1) (sv-and (if (sv-bool (sv-eq "{" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (sv-add 1 (setf (sv-to sv-MATCH ) (sv-add 1 (sv-to sv-MATCH )))) nil) (sv-and (sv-or (progn (setf sv-Class_name (sv-string (mp-Main::sv-hash-lookup "full_ident" sv-MATCH)))) 1) (sv-and (let ((sv-last_pos (sv-undef))) (setf sv-last_pos (sv-to sv-MATCH ))(if (sv-bool (not (sv-bool (progn (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-ws sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn nil))))))) (progn (setf (sv-to sv-MATCH ) sv-last_pos)) nil)1) (sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-exp_stmts sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (mp-Main::sv-hash-lookup "exp_stmts" sv-MATCH) sv-m2)1) (progn nil))) (sv-and (let ((sv-last_pos (sv-undef))) (setf sv-last_pos (sv-to sv-MATCH ))(if (sv-bool (not (sv-bool (progn (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-ws sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn nil))))))) (progn (setf (sv-to sv-MATCH ) sv-last_pos)) nil)1) (sv-and (if (sv-bool (sv-eq "}" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (sv-add 1 (setf (sv-to sv-MATCH ) (sv-add 1 (sv-to sv-MATCH )))) nil) (sv-and (let ((sv-last_pos (sv-undef))) (setf sv-last_pos (sv-to sv-MATCH ))(if (sv-bool (not (sv-bool (progn (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-ws sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn nil))))))) (progn (setf (sv-to sv-MATCH ) sv-last_pos)) nil)1) (sv-and (let ((sv-last_pos (sv-undef))) (setf sv-last_pos (sv-to sv-MATCH ))(if (sv-bool (not (sv-bool (progn (let ((sv-pos1 (sv-undef))) (setf sv-pos1 (sv-to sv-MATCH ))(progn (sv-and (if (sv-bool (sv-eq ";" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (sv-add 1 (setf (sv-to sv-MATCH ) (sv-add 1 (sv-to sv-MATCH )))) nil) (let ((sv-last_pos (sv-undef))) (setf sv-last_pos (sv-to sv-MATCH ))(if (sv-bool (not (sv-bool (progn (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-ws sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn nil))))))) (progn (setf (sv-to sv-MATCH ) sv-last_pos)) nil)1)))))))) (progn (setf (sv-to sv-MATCH ) sv-last_pos)) nil)1) (sv-or (progn (setf (sv-capture sv-MATCH) (let ((m (make-instance 'mp-CompUnit))) (setf (sv-name m) (sv-scalar (mp-Main::sv-hash-lookup "full_ident" sv-MATCH)))(setf (sv-attributes m) (make-hash-table :test 'equal))(setf (sv-methods m) (make-hash-table :test 'equal))(setf (sv-body m) (sv-scalar (mp-Main::sv-hash-lookup "exp_stmts" sv-MATCH))) m))) 1)))))))))))))))))))sv-MATCH)))

;; method infix_op
(defmethod sv-infix_op ((sv-grammar mp-MiniPerl6-Grammar) &optional sv-str sv-pos)
  (block mp6-function
    (let ((sv-MATCH (sv-undef))) (setf sv-MATCH (let ((m (make-instance 'mp-MiniPerl6-Match))) (setf (sv-str m) sv-str)(setf (sv-from m) sv-pos)(setf (sv-to m) sv-pos)(setf (sv-bool m) 1) m))(setf (sv-bool sv-MATCH ) (let ((sv-pos1 (sv-undef))) (setf sv-pos1 (sv-to sv-MATCH ))(sv-or (progn (if (sv-bool (sv-eq "+" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (sv-add 1 (setf (sv-to sv-MATCH ) (sv-add 1 (sv-to sv-MATCH )))) nil)) (sv-or (progn (setf (sv-to sv-MATCH ) sv-pos1)(if (sv-bool (sv-eq "-" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (sv-add 1 (setf (sv-to sv-MATCH ) (sv-add 1 (sv-to sv-MATCH )))) nil)) (sv-or (progn (setf (sv-to sv-MATCH ) sv-pos1)(if (sv-bool (sv-eq "*" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (sv-add 1 (setf (sv-to sv-MATCH ) (sv-add 1 (sv-to sv-MATCH )))) nil)) (sv-or (progn (setf (sv-to sv-MATCH ) sv-pos1)(if (sv-bool (sv-eq "/" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (sv-add 1 (setf (sv-to sv-MATCH ) (sv-add 1 (sv-to sv-MATCH )))) nil)) (sv-or (progn (setf (sv-to sv-MATCH ) sv-pos1)(sv-and (if (sv-bool (sv-eq "e" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (sv-add 1 (setf (sv-to sv-MATCH ) (sv-add 1 (sv-to sv-MATCH )))) nil) (if (sv-bool (sv-eq "q" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (sv-add 1 (setf (sv-to sv-MATCH ) (sv-add 1 (sv-to sv-MATCH )))) nil))) (sv-or (progn (setf (sv-to sv-MATCH ) sv-pos1)(sv-and (if (sv-bool (sv-eq "n" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (sv-add 1 (setf (sv-to sv-MATCH ) (sv-add 1 (sv-to sv-MATCH )))) nil) (if (sv-bool (sv-eq "e" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (sv-add 1 (setf (sv-to sv-MATCH ) (sv-add 1 (sv-to sv-MATCH )))) nil))) (sv-or (progn (setf (sv-to sv-MATCH ) sv-pos1)(if (sv-bool (sv-eq "==" (sv-substr sv-str (sv-to sv-MATCH ) 2))) (sv-add 1 (setf (sv-to sv-MATCH ) (sv-add 2 (sv-to sv-MATCH )))) nil)) (sv-or (progn (setf (sv-to sv-MATCH ) sv-pos1)(if (sv-bool (sv-eq "!=" (sv-substr sv-str (sv-to sv-MATCH ) 2))) (sv-add 1 (setf (sv-to sv-MATCH ) (sv-add 2 (sv-to sv-MATCH )))) nil)) (sv-or (progn (setf (sv-to sv-MATCH ) sv-pos1)(if (sv-bool (sv-eq "&&" (sv-substr sv-str (sv-to sv-MATCH ) 2))) (sv-add 1 (setf (sv-to sv-MATCH ) (sv-add 2 (sv-to sv-MATCH )))) nil)) (sv-or (progn (setf (sv-to sv-MATCH ) sv-pos1)(if (sv-bool (sv-eq "||" (sv-substr sv-str (sv-to sv-MATCH ) 2))) (sv-add 1 (setf (sv-to sv-MATCH ) (sv-add 2 (sv-to sv-MATCH )))) nil)) (sv-or (progn (setf (sv-to sv-MATCH ) sv-pos1)(if (sv-bool (sv-eq "~~" (sv-substr sv-str (sv-to sv-MATCH ) 2))) (sv-add 1 (setf (sv-to sv-MATCH ) (sv-add 2 (sv-to sv-MATCH )))) nil)) (sv-or (progn (setf (sv-to sv-MATCH ) sv-pos1)(if (sv-bool (sv-eq "~" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (sv-add 1 (setf (sv-to sv-MATCH ) (sv-add 1 (sv-to sv-MATCH )))) nil)) (sv-or (progn (setf (sv-to sv-MATCH ) sv-pos1)(if (sv-bool (sv-eq ">=" (sv-substr sv-str (sv-to sv-MATCH ) 2))) (sv-add 1 (setf (sv-to sv-MATCH ) (sv-add 2 (sv-to sv-MATCH )))) nil)) (sv-or (progn (setf (sv-to sv-MATCH ) sv-pos1)(if (sv-bool (sv-eq ">" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (sv-add 1 (setf (sv-to sv-MATCH ) (sv-add 1 (sv-to sv-MATCH )))) nil)) (sv-or (progn (setf (sv-to sv-MATCH ) sv-pos1)(if (sv-bool (sv-eq "<=" (sv-substr sv-str (sv-to sv-MATCH ) 2))) (sv-add 1 (setf (sv-to sv-MATCH ) (sv-add 2 (sv-to sv-MATCH )))) nil)) (sv-or (progn (setf (sv-to sv-MATCH ) sv-pos1)(if (sv-bool (sv-eq "<" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (sv-add 1 (setf (sv-to sv-MATCH ) (sv-add 1 (sv-to sv-MATCH )))) nil)) (progn (setf (sv-to sv-MATCH ) sv-pos1)(if (sv-bool (sv-eq "x" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (sv-add 1 (setf (sv-to sv-MATCH ) (sv-add 1 (sv-to sv-MATCH )))) nil))))))))))))))))))))sv-MATCH)))

;; method hyper_op
(defmethod sv-hyper_op ((sv-grammar mp-MiniPerl6-Grammar) &optional sv-str sv-pos)
  (block mp6-function
    (let ((sv-MATCH (sv-undef))) (setf sv-MATCH (let ((m (make-instance 'mp-MiniPerl6-Match))) (setf (sv-str m) sv-str)(setf (sv-from m) sv-pos)(setf (sv-to m) sv-pos)(setf (sv-bool m) 1) m))(setf (sv-bool sv-MATCH ) (let ((sv-pos1 (sv-undef))) (setf sv-pos1 (sv-to sv-MATCH ))(progn (let ((sv-last_pos (sv-undef))) (setf sv-last_pos (sv-to sv-MATCH ))(if (sv-bool (not (sv-bool (progn (if (sv-bool (sv-eq ">>" (sv-substr sv-str (sv-to sv-MATCH ) 2))) (sv-add 1 (setf (sv-to sv-MATCH ) (sv-add 2 (sv-to sv-MATCH )))) nil))))) (progn (setf (sv-to sv-MATCH ) sv-last_pos)) nil)1))))sv-MATCH)))

;; method prefix_op
(defmethod sv-prefix_op ((sv-grammar mp-MiniPerl6-Grammar) &optional sv-str sv-pos)
  (block mp6-function
    (let ((sv-MATCH (sv-undef))) (setf sv-MATCH (let ((m (make-instance 'mp-MiniPerl6-Match))) (setf (sv-str m) sv-str)(setf (sv-from m) sv-pos)(setf (sv-to m) sv-pos)(setf (sv-bool m) 1) m))(setf (sv-bool sv-MATCH ) (let ((sv-pos1 (sv-undef))) (setf sv-pos1 (sv-to sv-MATCH ))(progn (sv-and (let ((sv-pos1 (sv-undef))) (setf sv-pos1 (sv-to sv-MATCH ))(sv-or (progn (if (sv-bool (sv-eq "$" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (sv-add 1 (setf (sv-to sv-MATCH ) (sv-add 1 (sv-to sv-MATCH )))) nil)) (sv-or (progn (setf (sv-to sv-MATCH ) sv-pos1)(if (sv-bool (sv-eq "@" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (sv-add 1 (setf (sv-to sv-MATCH ) (sv-add 1 (sv-to sv-MATCH )))) nil)) (sv-or (progn (setf (sv-to sv-MATCH ) sv-pos1)(if (sv-bool (sv-eq "%" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (sv-add 1 (setf (sv-to sv-MATCH ) (sv-add 1 (sv-to sv-MATCH )))) nil)) (sv-or (progn (setf (sv-to sv-MATCH ) sv-pos1)(if (sv-bool (sv-eq "?" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (sv-add 1 (setf (sv-to sv-MATCH ) (sv-add 1 (sv-to sv-MATCH )))) nil)) (sv-or (progn (setf (sv-to sv-MATCH ) sv-pos1)(if (sv-bool (sv-eq "!" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (sv-add 1 (setf (sv-to sv-MATCH ) (sv-add 1 (sv-to sv-MATCH )))) nil)) (sv-or (progn (setf (sv-to sv-MATCH ) sv-pos1)(if (sv-bool (sv-eq "++" (sv-substr sv-str (sv-to sv-MATCH ) 2))) (sv-add 1 (setf (sv-to sv-MATCH ) (sv-add 2 (sv-to sv-MATCH )))) nil)) (sv-or (progn (setf (sv-to sv-MATCH ) sv-pos1)(if (sv-bool (sv-eq "--" (sv-substr sv-str (sv-to sv-MATCH ) 2))) (sv-add 1 (setf (sv-to sv-MATCH ) (sv-add 2 (sv-to sv-MATCH )))) nil)) (sv-or (progn (setf (sv-to sv-MATCH ) sv-pos1)(if (sv-bool (sv-eq "+" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (sv-add 1 (setf (sv-to sv-MATCH ) (sv-add 1 (sv-to sv-MATCH )))) nil)) (sv-or (progn (setf (sv-to sv-MATCH ) sv-pos1)(if (sv-bool (sv-eq "-" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (sv-add 1 (setf (sv-to sv-MATCH ) (sv-add 1 (sv-to sv-MATCH )))) nil)) (progn (setf (sv-to sv-MATCH ) sv-pos1)(if (sv-bool (sv-eq "~" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (sv-add 1 (setf (sv-to sv-MATCH ) (sv-add 1 (sv-to sv-MATCH )))) nil)))))))))))) (let ((sv-tmp (sv-undef))) (setf sv-tmp sv-MATCH)(setf sv-MATCH (let ((m (make-instance 'mp-MiniPerl6-Match))) (setf (sv-str m) sv-str)(setf (sv-from m) (sv-to sv-tmp ))(setf (sv-to m) (sv-to sv-tmp ))(setf (sv-bool m) 1) m))(setf (sv-bool sv-MATCH ) (let ((sv-pos1 (sv-undef))) (setf sv-pos1 (sv-to sv-MATCH ))(sv-or (progn (if (sv-bool (sv-eq "(" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (sv-add 1 (setf (sv-to sv-MATCH ) (sv-add 1 (sv-to sv-MATCH )))) nil)) (progn (setf (sv-to sv-MATCH ) sv-pos1)(if (sv-bool (sv-eq "$" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (sv-add 1 (setf (sv-to sv-MATCH ) (sv-add 1 (sv-to sv-MATCH )))) nil)))))(setf (sv-bool sv-tmp ) (sv-bool sv-MATCH))(setf sv-MATCH sv-tmp)(sv-bool sv-MATCH))))))sv-MATCH)))

;; method declarator
(defmethod sv-declarator ((sv-grammar mp-MiniPerl6-Grammar) &optional sv-str sv-pos)
  (block mp6-function
    (let ((sv-MATCH (sv-undef))) (setf sv-MATCH (let ((m (make-instance 'mp-MiniPerl6-Match))) (setf (sv-str m) sv-str)(setf (sv-from m) sv-pos)(setf (sv-to m) sv-pos)(setf (sv-bool m) 1) m))(setf (sv-bool sv-MATCH ) (let ((sv-pos1 (sv-undef))) (setf sv-pos1 (sv-to sv-MATCH ))(sv-or (progn (if (sv-bool (sv-eq "my" (sv-substr sv-str (sv-to sv-MATCH ) 2))) (sv-add 1 (setf (sv-to sv-MATCH ) (sv-add 2 (sv-to sv-MATCH )))) nil)) (sv-or (progn (setf (sv-to sv-MATCH ) sv-pos1)(if (sv-bool (sv-eq "state" (sv-substr sv-str (sv-to sv-MATCH ) 5))) (sv-add 1 (setf (sv-to sv-MATCH ) (sv-add 5 (sv-to sv-MATCH )))) nil)) (progn (setf (sv-to sv-MATCH ) sv-pos1)(if (sv-bool (sv-eq "has" (sv-substr sv-str (sv-to sv-MATCH ) 3))) (sv-add 1 (setf (sv-to sv-MATCH ) (sv-add 3 (sv-to sv-MATCH )))) nil))))))sv-MATCH)))

;; method exp2
(defmethod sv-exp2 ((sv-grammar mp-MiniPerl6-Grammar) &optional sv-str sv-pos)
  (block mp6-function
    (let ((sv-MATCH (sv-undef))) (setf sv-MATCH (let ((m (make-instance 'mp-MiniPerl6-Match))) (setf (sv-str m) sv-str)(setf (sv-from m) sv-pos)(setf (sv-to m) sv-pos)(setf (sv-bool m) 1) m))(setf (sv-bool sv-MATCH ) (let ((sv-pos1 (sv-undef))) (setf sv-pos1 (sv-to sv-MATCH ))(progn (sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-exp sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (mp-Main::sv-hash-lookup "exp" sv-MATCH) sv-m2)1) (progn nil))) (sv-or (progn (setf (sv-capture sv-MATCH) (sv-scalar (mp-Main::sv-hash-lookup "exp" sv-MATCH)))) 1)))))sv-MATCH)))

;; method exp_stmts2
(defmethod sv-exp_stmts2 ((sv-grammar mp-MiniPerl6-Grammar) &optional sv-str sv-pos)
  (block mp6-function
    (let ((sv-MATCH (sv-undef))) (setf sv-MATCH (let ((m (make-instance 'mp-MiniPerl6-Match))) (setf (sv-str m) sv-str)(setf (sv-from m) sv-pos)(setf (sv-to m) sv-pos)(setf (sv-bool m) 1) m))(setf (sv-bool sv-MATCH ) (let ((sv-pos1 (sv-undef))) (setf sv-pos1 (sv-to sv-MATCH ))(progn (sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-exp_stmts sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (mp-Main::sv-hash-lookup "exp_stmts" sv-MATCH) sv-m2)1) (progn nil))) (sv-or (progn (setf (sv-capture sv-MATCH) (sv-scalar (mp-Main::sv-hash-lookup "exp_stmts" sv-MATCH)))) 1)))))sv-MATCH)))

;; method exp
(defmethod sv-exp ((sv-grammar mp-MiniPerl6-Grammar) &optional sv-str sv-pos)
  (block mp6-function
    (let ((sv-MATCH (sv-undef))) (setf sv-MATCH (let ((m (make-instance 'mp-MiniPerl6-Match))) (setf (sv-str m) sv-str)(setf (sv-from m) sv-pos)(setf (sv-to m) sv-pos)(setf (sv-bool m) 1) m))(setf (sv-bool sv-MATCH ) (let ((sv-pos1 (sv-undef))) (setf sv-pos1 (sv-to sv-MATCH ))(progn (sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-term_meth sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (mp-Main::sv-hash-lookup "term_meth" sv-MATCH) sv-m2)1) (progn nil))) (let ((sv-pos1 (sv-undef))) (setf sv-pos1 (sv-to sv-MATCH ))(sv-or (progn (sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-opt_ws sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn nil))) (sv-and (if (sv-bool (sv-eq "??" (sv-substr sv-str (sv-to sv-MATCH ) 2))) (sv-add 1 (setf (sv-to sv-MATCH ) (sv-add 2 (sv-to sv-MATCH )))) nil) (let ((sv-pos1 (sv-undef))) (setf sv-pos1 (sv-to sv-MATCH ))(sv-or (progn (sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-opt_ws sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn nil))) (sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-exp sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (mp-Main::sv-hash-lookup "exp" sv-MATCH) sv-m2)1) (progn nil))) (sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-opt_ws sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn nil))) (sv-and (if (sv-bool (sv-eq "!!" (sv-substr sv-str (sv-to sv-MATCH ) 2))) (sv-add 1 (setf (sv-to sv-MATCH ) (sv-add 2 (sv-to sv-MATCH )))) nil) (sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-opt_ws sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn nil))) (sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-exp2 sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (mp-Main::sv-hash-lookup "exp2" sv-MATCH) sv-m2)1) (progn nil))) (sv-or (progn (setf (sv-capture sv-MATCH) (let ((m (make-instance 'mp-Apply))) (setf (sv-namespace m) "")(setf (sv-code m) "ternary:<?? !!>")(setf (sv-arguments m) (let ((_tmp_ (concatenate 'list  (list (sv-scalar (mp-Main::sv-hash-lookup "term_meth" sv-MATCH))) (list (sv-scalar (mp-Main::sv-hash-lookup "exp" sv-MATCH))) (list (sv-scalar (mp-Main::sv-hash-lookup "exp2" sv-MATCH)))))) (make-array (length _tmp_) :adjustable 1 :fill-pointer t :initial-contents _tmp_))) m))) 1)))))))) (progn (setf (sv-to sv-MATCH ) sv-pos1)(sv-or (progn (mp-Main::sv-say (list "*** Syntax error in ternary operation"))) 1))))))) (sv-or (progn (setf (sv-to sv-MATCH ) sv-pos1)(sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-opt_ws sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn nil))) (sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-infix_op sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (mp-Main::sv-hash-lookup "infix_op" sv-MATCH) sv-m2)1) (progn nil))) (sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-opt_ws sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn nil))) (sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-exp sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (mp-Main::sv-hash-lookup "exp" sv-MATCH) sv-m2)1) (progn nil))) (sv-or (progn (setf (sv-capture sv-MATCH) (let ((m (make-instance 'mp-Apply))) (setf (sv-namespace m) "")(setf (sv-code m) (concatenate 'string (sv-string "infix:<") (sv-string (concatenate 'string (sv-string (mp-Main::sv-hash-lookup "infix_op" sv-MATCH)) (sv-string ">")))))(setf (sv-arguments m) (let ((_tmp_ (concatenate 'list  (list (sv-scalar (mp-Main::sv-hash-lookup "term_meth" sv-MATCH))) (list (sv-scalar (mp-Main::sv-hash-lookup "exp" sv-MATCH)))))) (make-array (length _tmp_) :adjustable 1 :fill-pointer t :initial-contents _tmp_))) m))) 1)))))) (sv-or (progn (setf (sv-to sv-MATCH ) sv-pos1)(sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-opt_ws sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn nil))) (sv-and (if (sv-bool (sv-eq ":=" (sv-substr sv-str (sv-to sv-MATCH ) 2))) (sv-add 1 (setf (sv-to sv-MATCH ) (sv-add 2 (sv-to sv-MATCH )))) nil) (sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-opt_ws sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn nil))) (sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-exp sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (mp-Main::sv-hash-lookup "exp" sv-MATCH) sv-m2)1) (progn nil))) (sv-or (progn (setf (sv-capture sv-MATCH) (let ((m (make-instance 'mp-Bind))) (setf (sv-parameters m) (sv-scalar (mp-Main::sv-hash-lookup "term_meth" sv-MATCH)))(setf (sv-arguments m) (sv-scalar (mp-Main::sv-hash-lookup "exp" sv-MATCH))) m))) 1)))))) (sv-or (progn (setf (sv-to sv-MATCH ) sv-pos1)(sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-opt_ws sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn nil))) (sv-and (if (sv-bool (sv-eq "=" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (sv-add 1 (setf (sv-to sv-MATCH ) (sv-add 1 (sv-to sv-MATCH )))) nil) (sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-opt_ws sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn nil))) (sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-exp sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (mp-Main::sv-hash-lookup "exp" sv-MATCH) sv-m2)1) (progn nil))) (sv-or (progn (progn (write-line (format nil "~{~a~}" (list "*** Error in assignment operation: infix<=> not implemented; use infix<:=> instead")) *error-output*) (sb-ext:quit))) 1)))))) (progn (setf (sv-to sv-MATCH ) sv-pos1)(sv-or (progn (setf (sv-capture sv-MATCH) (sv-scalar (mp-Main::sv-hash-lookup "term_meth" sv-MATCH)))) 1)))))))))))sv-MATCH)))

;; method opt_ident
(defmethod sv-opt_ident ((sv-grammar mp-MiniPerl6-Grammar) &optional sv-str sv-pos)
  (block mp6-function
    (let ((sv-MATCH (sv-undef))) (setf sv-MATCH (let ((m (make-instance 'mp-MiniPerl6-Match))) (setf (sv-str m) sv-str)(setf (sv-from m) sv-pos)(setf (sv-to m) sv-pos)(setf (sv-bool m) 1) m))(setf (sv-bool sv-MATCH ) (let ((sv-pos1 (sv-undef))) (setf sv-pos1 (sv-to sv-MATCH ))(sv-or (progn (sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-ident sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (mp-Main::sv-hash-lookup "ident" sv-MATCH) sv-m2)1) (progn nil))) (sv-or (progn (setf (sv-capture sv-MATCH) (sv-scalar (mp-Main::sv-hash-lookup "ident" sv-MATCH)))) 1))) (progn (setf (sv-to sv-MATCH ) sv-pos1)(sv-and 1 (sv-or (progn (setf (sv-capture sv-MATCH) "postcircumfix:<( )>")) 1))))))sv-MATCH)))

;; method term_meth
(defmethod sv-term_meth ((sv-grammar mp-MiniPerl6-Grammar) &optional sv-str sv-pos)
  (block mp6-function
    (let ((sv-MATCH (sv-undef))) (setf sv-MATCH (let ((m (make-instance 'mp-MiniPerl6-Match))) (setf (sv-str m) sv-str)(setf (sv-from m) sv-pos)(setf (sv-to m) sv-pos)(setf (sv-bool m) 1) m))(setf (sv-bool sv-MATCH ) (let ((sv-pos1 (sv-undef))) (setf sv-pos1 (sv-to sv-MATCH ))(sv-or (progn (sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-full_ident sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (mp-Main::sv-hash-lookup "full_ident" sv-MATCH) sv-m2)1) (progn nil))) (let ((sv-pos1 (sv-undef))) (setf sv-pos1 (sv-to sv-MATCH ))(sv-or (progn (let ((sv-pos1 (sv-undef))) (setf sv-pos1 (sv-to sv-MATCH ))(progn (sv-and (if (sv-bool (sv-eq ".new(" (sv-substr sv-str (sv-to sv-MATCH ) 5))) (sv-add 1 (setf (sv-to sv-MATCH ) (sv-add 5 (sv-to sv-MATCH )))) nil) (let ((sv-pos1 (sv-undef))) (setf sv-pos1 (sv-to sv-MATCH ))(sv-or (progn (sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-opt_ws sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn nil))) (sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-exp_mapping sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (mp-Main::sv-hash-lookup "exp_mapping" sv-MATCH) sv-m2)1) (progn nil))) (sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-opt_ws sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn nil))) (sv-and (if (sv-bool (sv-eq ")" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (sv-add 1 (setf (sv-to sv-MATCH ) (sv-add 1 (sv-to sv-MATCH )))) nil) (sv-or (progn (setf (sv-capture sv-MATCH) (let ((m (make-instance 'mp-Lit-Object))) (setf (sv-class m) (sv-scalar (mp-Main::sv-hash-lookup "full_ident" sv-MATCH)))(setf (sv-fields m) (sv-scalar (mp-Main::sv-hash-lookup "exp_mapping" sv-MATCH))) m))) 1)))))) (progn (setf (sv-to sv-MATCH ) sv-pos1)(sv-or (progn (mp-Main::sv-say (list "*** Syntax Error parsing Constructor"))(progn (write-line (format nil "~{~a~}" (list )) *error-output*) (sb-ext:quit))) 1)))))))) (progn (setf (sv-to sv-MATCH ) sv-pos1)(let ((sv-pos1 (sv-undef))) (setf sv-pos1 (sv-to sv-MATCH ))(progn (sv-and (if (sv-bool (sv-eq "." (sv-substr sv-str (sv-to sv-MATCH ) 1))) (sv-add 1 (setf (sv-to sv-MATCH ) (sv-add 1 (sv-to sv-MATCH )))) nil) (sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-hyper_op sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (mp-Main::sv-hash-lookup "hyper_op" sv-MATCH) sv-m2)1) (progn nil))) (sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-ident sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (mp-Main::sv-hash-lookup "ident" sv-MATCH) sv-m2)1) (progn nil))) (let ((sv-pos1 (sv-undef))) (setf sv-pos1 (sv-to sv-MATCH ))(sv-or (progn (sv-and (if (sv-bool (sv-eq "(" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (sv-add 1 (setf (sv-to sv-MATCH ) (sv-add 1 (sv-to sv-MATCH )))) nil) (sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-opt_ws sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn nil))) (sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-exp_seq sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (mp-Main::sv-hash-lookup "exp_seq" sv-MATCH) sv-m2)1) (progn nil))) (sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-opt_ws sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn nil))) (sv-and (if (sv-bool (sv-eq ")" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (sv-add 1 (setf (sv-to sv-MATCH ) (sv-add 1 (sv-to sv-MATCH )))) nil) (sv-or (progn (setf (sv-capture sv-MATCH) (let ((m (make-instance 'mp-Call))) (setf (sv-invocant m) (let ((m (make-instance 'mp-Proto))) (setf (sv-name m) (sv-string (mp-Main::sv-hash-lookup "full_ident" sv-MATCH))) m))(setf (sv-method m) (sv-scalar (mp-Main::sv-hash-lookup "ident" sv-MATCH)))(setf (sv-arguments m) (sv-scalar (mp-Main::sv-hash-lookup "exp_seq" sv-MATCH)))(setf (sv-hyper m) (sv-scalar (mp-Main::sv-hash-lookup "hyper_op" sv-MATCH))) m))) 1))))))) (sv-or (progn (setf (sv-to sv-MATCH ) sv-pos1)(sv-and (if (sv-bool (sv-eq ":" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (sv-add 1 (setf (sv-to sv-MATCH ) (sv-add 1 (sv-to sv-MATCH )))) nil) (sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-ws sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn nil))) (sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-exp_seq sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (mp-Main::sv-hash-lookup "exp_seq" sv-MATCH) sv-m2)1) (progn nil))) (sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-opt_ws sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn nil))) (sv-or (progn (setf (sv-capture sv-MATCH) (let ((m (make-instance 'mp-Call))) (setf (sv-invocant m) (let ((m (make-instance 'mp-Proto))) (setf (sv-name m) (sv-string (mp-Main::sv-hash-lookup "full_ident" sv-MATCH))) m))(setf (sv-method m) (sv-scalar (mp-Main::sv-hash-lookup "ident" sv-MATCH)))(setf (sv-arguments m) (sv-scalar (mp-Main::sv-hash-lookup "exp_seq" sv-MATCH)))(setf (sv-hyper m) (sv-scalar (mp-Main::sv-hash-lookup "hyper_op" sv-MATCH))) m))) 1)))))) (progn (setf (sv-to sv-MATCH ) sv-pos1)(sv-or (progn (setf (sv-capture sv-MATCH) (let ((m (make-instance 'mp-Call))) (setf (sv-invocant m) (let ((m (make-instance 'mp-Proto))) (setf (sv-name m) (sv-string (mp-Main::sv-hash-lookup "full_ident" sv-MATCH))) m))(setf (sv-method m) (sv-scalar (mp-Main::sv-hash-lookup "ident" sv-MATCH)))(setf (sv-arguments m) (make-array 0 :adjustable 1 :fill-pointer t))(setf (sv-hyper m) (sv-scalar (mp-Main::sv-hash-lookup "hyper_op" sv-MATCH))) m))) 1))))))))))))))) (progn (setf (sv-to sv-MATCH ) sv-pos1)(sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-exp_term sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (mp-Main::sv-hash-lookup "exp_term" sv-MATCH) sv-m2)1) (progn nil))) (let ((sv-pos1 (sv-undef))) (setf sv-pos1 (sv-to sv-MATCH ))(sv-or (progn (sv-and (if (sv-bool (sv-eq "." (sv-substr sv-str (sv-to sv-MATCH ) 1))) (sv-add 1 (setf (sv-to sv-MATCH ) (sv-add 1 (sv-to sv-MATCH )))) nil) (sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-hyper_op sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (mp-Main::sv-hash-lookup "hyper_op" sv-MATCH) sv-m2)1) (progn nil))) (sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-opt_ident sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (mp-Main::sv-hash-lookup "opt_ident" sv-MATCH) sv-m2)1) (progn nil))) (let ((sv-pos1 (sv-undef))) (setf sv-pos1 (sv-to sv-MATCH ))(sv-or (progn (sv-and (let ((sv-pos1 (sv-undef))) (setf sv-pos1 (sv-to sv-MATCH ))(sv-or (progn (sv-and (if (sv-bool (sv-eq "(" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (sv-add 1 (setf (sv-to sv-MATCH ) (sv-add 1 (sv-to sv-MATCH )))) nil) (sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-opt_ws sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn nil))) (sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-exp_seq sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (mp-Main::sv-hash-lookup "exp_seq" sv-MATCH) sv-m2)1) (progn nil))) (sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-opt_ws sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn nil))) (if (sv-bool (sv-eq ")" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (sv-add 1 (setf (sv-to sv-MATCH ) (sv-add 1 (sv-to sv-MATCH )))) nil)))))) (progn (setf (sv-to sv-MATCH ) sv-pos1)(sv-and (if (sv-bool (sv-eq ":" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (sv-add 1 (setf (sv-to sv-MATCH ) (sv-add 1 (sv-to sv-MATCH )))) nil) (sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-ws sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn nil))) (sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-exp_seq sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (mp-Main::sv-hash-lookup "exp_seq" sv-MATCH) sv-m2)1) (progn nil))) (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-opt_ws sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn nil))))))))) (sv-or (progn (setf (sv-capture sv-MATCH) (let ((m (make-instance 'mp-Call))) (setf (sv-invocant m) (sv-scalar (mp-Main::sv-hash-lookup "exp_term" sv-MATCH)))(setf (sv-method m) (sv-scalar (mp-Main::sv-hash-lookup "opt_ident" sv-MATCH)))(setf (sv-arguments m) (sv-scalar (mp-Main::sv-hash-lookup "exp_seq" sv-MATCH)))(setf (sv-hyper m) (sv-scalar (mp-Main::sv-hash-lookup "hyper_op" sv-MATCH))) m))) 1))) (progn (setf (sv-to sv-MATCH ) sv-pos1)(sv-or (progn (setf (sv-capture sv-MATCH) (let ((m (make-instance 'mp-Call))) (setf (sv-invocant m) (sv-scalar (mp-Main::sv-hash-lookup "exp_term" sv-MATCH)))(setf (sv-method m) (sv-scalar (mp-Main::sv-hash-lookup "opt_ident" sv-MATCH)))(setf (sv-arguments m) (make-array 0 :adjustable 1 :fill-pointer t))(setf (sv-hyper m) (sv-scalar (mp-Main::sv-hash-lookup "hyper_op" sv-MATCH))) m))) 1)))))))) (sv-or (progn (setf (sv-to sv-MATCH ) sv-pos1)(sv-and (if (sv-bool (sv-eq "[" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (sv-add 1 (setf (sv-to sv-MATCH ) (sv-add 1 (sv-to sv-MATCH )))) nil) (sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-opt_ws sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn nil))) (sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-exp sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (mp-Main::sv-hash-lookup "exp" sv-MATCH) sv-m2)1) (progn nil))) (sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-opt_ws sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn nil))) (sv-and (if (sv-bool (sv-eq "]" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (sv-add 1 (setf (sv-to sv-MATCH ) (sv-add 1 (sv-to sv-MATCH )))) nil) (sv-or (progn (setf (sv-capture sv-MATCH) (let ((m (make-instance 'mp-Index))) (setf (sv-obj m) (sv-scalar (mp-Main::sv-hash-lookup "exp_term" sv-MATCH)))(setf (sv-index_exp m) (sv-scalar (mp-Main::sv-hash-lookup "exp" sv-MATCH))) m))) 1))))))) (sv-or (progn (setf (sv-to sv-MATCH ) sv-pos1)(sv-and (if (sv-bool (sv-eq "{" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (sv-add 1 (setf (sv-to sv-MATCH ) (sv-add 1 (sv-to sv-MATCH )))) nil) (sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-opt_ws sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn nil))) (sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-exp sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (mp-Main::sv-hash-lookup "exp" sv-MATCH) sv-m2)1) (progn nil))) (sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-opt_ws sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn nil))) (sv-and (if (sv-bool (sv-eq "}" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (sv-add 1 (setf (sv-to sv-MATCH ) (sv-add 1 (sv-to sv-MATCH )))) nil) (sv-or (progn (setf (sv-capture sv-MATCH) (let ((m (make-instance 'mp-Lookup))) (setf (sv-obj m) (sv-scalar (mp-Main::sv-hash-lookup "exp_term" sv-MATCH)))(setf (sv-index_exp m) (sv-scalar (mp-Main::sv-hash-lookup "exp" sv-MATCH))) m))) 1))))))) (progn (setf (sv-to sv-MATCH ) sv-pos1)(sv-or (progn (setf (sv-capture sv-MATCH) (sv-scalar (mp-Main::sv-hash-lookup "exp_term" sv-MATCH)))) 1)))))))))))sv-MATCH)))

;; method sub_or_method_name
(defmethod sv-sub_or_method_name ((sv-grammar mp-MiniPerl6-Grammar) &optional sv-str sv-pos)
  (block mp6-function
    (let ((sv-MATCH (sv-undef))) (setf sv-MATCH (let ((m (make-instance 'mp-MiniPerl6-Match))) (setf (sv-str m) sv-str)(setf (sv-from m) sv-pos)(setf (sv-to m) sv-pos)(setf (sv-bool m) 1) m))(setf (sv-bool sv-MATCH ) (let ((sv-pos1 (sv-undef))) (setf sv-pos1 (sv-to sv-MATCH ))(progn (sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-full_ident sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (mp-Main::sv-hash-lookup "full_ident" sv-MATCH) sv-m2)1) (progn nil))) (let ((sv-last_pos (sv-undef))) (setf sv-last_pos (sv-to sv-MATCH ))(if (sv-bool (not (sv-bool (progn (let ((sv-pos1 (sv-undef))) (setf sv-pos1 (sv-to sv-MATCH ))(progn (sv-and (if (sv-bool (sv-eq "." (sv-substr sv-str (sv-to sv-MATCH ) 1))) (sv-add 1 (setf (sv-to sv-MATCH ) (sv-add 1 (sv-to sv-MATCH )))) nil) (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-ident sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(if (sv-bool (nth-value 1 (mp-Main::sv-hash-lookup "ident" sv-MATCH))) (progn (sv-push (mp-Main::sv-hash-lookup "ident" sv-MATCH) sv-m2)) (progn (setf (mp-Main::sv-hash-lookup "ident" sv-MATCH) (let ((_tmp_ (concatenate 'list  (list sv-m2)))) (make-array (length _tmp_) :adjustable 1 :fill-pointer t :initial-contents _tmp_)))))1) (progn nil)))))))))) (progn (setf (sv-to sv-MATCH ) sv-last_pos)) nil)1)))))sv-MATCH)))

;; method opt_type
(defmethod sv-opt_type ((sv-grammar mp-MiniPerl6-Grammar) &optional sv-str sv-pos)
  (block mp6-function
    (let ((sv-MATCH (sv-undef))) (setf sv-MATCH (let ((m (make-instance 'mp-MiniPerl6-Match))) (setf (sv-str m) sv-str)(setf (sv-from m) sv-pos)(setf (sv-to m) sv-pos)(setf (sv-bool m) 1) m))(setf (sv-bool sv-MATCH ) (let ((sv-pos1 (sv-undef))) (setf sv-pos1 (sv-to sv-MATCH ))(sv-or (progn (sv-and (let ((sv-last_pos (sv-undef))) (setf sv-last_pos (sv-to sv-MATCH ))(if (sv-bool (not (sv-bool (progn (if (sv-bool (sv-eq "::" (sv-substr sv-str (sv-to sv-MATCH ) 2))) (sv-add 1 (setf (sv-to sv-MATCH ) (sv-add 2 (sv-to sv-MATCH )))) nil))))) (progn (setf (sv-to sv-MATCH ) sv-last_pos)) nil)1) (sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-full_ident sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (mp-Main::sv-hash-lookup "full_ident" sv-MATCH) sv-m2)1) (progn nil))) (sv-or (progn (setf (sv-capture sv-MATCH) (sv-scalar (mp-Main::sv-hash-lookup "full_ident" sv-MATCH)))) 1)))) (progn (setf (sv-to sv-MATCH ) sv-pos1)(sv-and 1 (sv-or (progn (setf (sv-capture sv-MATCH) "")) 1))))))sv-MATCH)))

;; method exp_term
(defmethod sv-exp_term ((sv-grammar mp-MiniPerl6-Grammar) &optional sv-str sv-pos)
  (block mp6-function
    (let ((sv-MATCH (sv-undef))) (setf sv-MATCH (let ((m (make-instance 'mp-MiniPerl6-Match))) (setf (sv-str m) sv-str)(setf (sv-from m) sv-pos)(setf (sv-to m) sv-pos)(setf (sv-bool m) 1) m))(setf (sv-bool sv-MATCH ) (let ((sv-pos1 (sv-undef))) (setf sv-pos1 (sv-to sv-MATCH ))(sv-or (progn (sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-var_ident sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (mp-Main::sv-hash-lookup "var_ident" sv-MATCH) sv-m2)1) (progn nil))) (sv-or (progn (setf (sv-capture sv-MATCH) (sv-scalar (mp-Main::sv-hash-lookup "var_ident" sv-MATCH)))) 1))) (sv-or (progn (setf (sv-to sv-MATCH ) sv-pos1)(sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-prefix_op sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (mp-Main::sv-hash-lookup "prefix_op" sv-MATCH) sv-m2)1) (progn nil))) (sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-exp sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (mp-Main::sv-hash-lookup "exp" sv-MATCH) sv-m2)1) (progn nil))) (sv-or (progn (setf (sv-capture sv-MATCH) (let ((m (make-instance 'mp-Apply))) (setf (sv-namespace m) "")(setf (sv-code m) (concatenate 'string (sv-string "prefix:<") (sv-string (concatenate 'string (sv-string (mp-Main::sv-hash-lookup "prefix_op" sv-MATCH)) (sv-string ">")))))(setf (sv-arguments m) (let ((_tmp_ (concatenate 'list  (list (sv-scalar (mp-Main::sv-hash-lookup "exp" sv-MATCH)))))) (make-array (length _tmp_) :adjustable 1 :fill-pointer t :initial-contents _tmp_))) m))) 1)))) (sv-or (progn (setf (sv-to sv-MATCH ) sv-pos1)(sv-and (if (sv-bool (sv-eq "(" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (sv-add 1 (setf (sv-to sv-MATCH ) (sv-add 1 (sv-to sv-MATCH )))) nil) (sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-opt_ws sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn nil))) (sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-exp sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (mp-Main::sv-hash-lookup "exp" sv-MATCH) sv-m2)1) (progn nil))) (sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-opt_ws sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn nil))) (sv-and (if (sv-bool (sv-eq ")" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (sv-add 1 (setf (sv-to sv-MATCH ) (sv-add 1 (sv-to sv-MATCH )))) nil) (sv-or (progn (setf (sv-capture sv-MATCH) (sv-scalar (mp-Main::sv-hash-lookup "exp" sv-MATCH)))) 1))))))) (sv-or (progn (setf (sv-to sv-MATCH ) sv-pos1)(sv-and (if (sv-bool (sv-eq "{" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (sv-add 1 (setf (sv-to sv-MATCH ) (sv-add 1 (sv-to sv-MATCH )))) nil) (sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-opt_ws sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn nil))) (sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-exp_mapping sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (mp-Main::sv-hash-lookup "exp_mapping" sv-MATCH) sv-m2)1) (progn nil))) (sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-opt_ws sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn nil))) (sv-and (if (sv-bool (sv-eq "}" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (sv-add 1 (setf (sv-to sv-MATCH ) (sv-add 1 (sv-to sv-MATCH )))) nil) (sv-or (progn (setf (sv-capture sv-MATCH) (let ((m (make-instance 'mp-Lit-Hash))) (setf (sv-hash1 m) (sv-scalar (mp-Main::sv-hash-lookup "exp_mapping" sv-MATCH))) m))) 1))))))) (sv-or (progn (setf (sv-to sv-MATCH ) sv-pos1)(sv-and (if (sv-bool (sv-eq "[" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (sv-add 1 (setf (sv-to sv-MATCH ) (sv-add 1 (sv-to sv-MATCH )))) nil) (sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-opt_ws sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn nil))) (sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-exp_seq sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (mp-Main::sv-hash-lookup "exp_seq" sv-MATCH) sv-m2)1) (progn nil))) (sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-opt_ws sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn nil))) (sv-and (if (sv-bool (sv-eq "]" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (sv-add 1 (setf (sv-to sv-MATCH ) (sv-add 1 (sv-to sv-MATCH )))) nil) (sv-or (progn (setf (sv-capture sv-MATCH) (let ((m (make-instance 'mp-Lit-Array))) (setf (sv-array1 m) (sv-scalar (mp-Main::sv-hash-lookup "exp_seq" sv-MATCH))) m))) 1))))))) (sv-or (progn (setf (sv-to sv-MATCH ) sv-pos1)(sv-and (if (sv-bool (sv-eq "$" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (sv-add 1 (setf (sv-to sv-MATCH ) (sv-add 1 (sv-to sv-MATCH )))) nil) (sv-and (if (sv-bool (sv-eq "<" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (sv-add 1 (setf (sv-to sv-MATCH ) (sv-add 1 (sv-to sv-MATCH )))) nil) (sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-sub_or_method_name sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (mp-Main::sv-hash-lookup "sub_or_method_name" sv-MATCH) sv-m2)1) (progn nil))) (sv-and (if (sv-bool (sv-eq ">" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (sv-add 1 (setf (sv-to sv-MATCH ) (sv-add 1 (sv-to sv-MATCH )))) nil) (sv-or (progn (setf (sv-capture sv-MATCH) (let ((m (make-instance 'mp-Lookup))) (setf (sv-obj m) (let ((m (make-instance 'mp-Var))) (setf (sv-sigil m) "$")(setf (sv-twigil m) "")(setf (sv-name m) "/") m))(setf (sv-index_exp m) (let ((m (make-instance 'mp-Val-Buf))) (setf (sv-buf m) (sv-scalar (mp-Main::sv-hash-lookup "sub_or_method_name" sv-MATCH))) m)) m))) 1)))))) (sv-or (progn (setf (sv-to sv-MATCH ) sv-pos1)(sv-and (if (sv-bool (sv-eq "d" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (sv-add 1 (setf (sv-to sv-MATCH ) (sv-add 1 (sv-to sv-MATCH )))) nil) (sv-and (if (sv-bool (sv-eq "o" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (sv-add 1 (setf (sv-to sv-MATCH ) (sv-add 1 (sv-to sv-MATCH )))) nil) (sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-opt_ws sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn nil))) (sv-and (if (sv-bool (sv-eq "{" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (sv-add 1 (setf (sv-to sv-MATCH ) (sv-add 1 (sv-to sv-MATCH )))) nil) (sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-opt_ws sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn nil))) (sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-exp_stmts sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (mp-Main::sv-hash-lookup "exp_stmts" sv-MATCH) sv-m2)1) (progn nil))) (sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-opt_ws sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn nil))) (sv-and (if (sv-bool (sv-eq "}" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (sv-add 1 (setf (sv-to sv-MATCH ) (sv-add 1 (sv-to sv-MATCH )))) nil) (sv-or (progn (setf (sv-capture sv-MATCH) (let ((m (make-instance 'mp-Do))) (setf (sv-block m) (sv-scalar (mp-Main::sv-hash-lookup "exp_stmts" sv-MATCH))) m))) 1)))))))))) (sv-or (progn (setf (sv-to sv-MATCH ) sv-pos1)(sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-declarator sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (mp-Main::sv-hash-lookup "declarator" sv-MATCH) sv-m2)1) (progn nil))) (sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-ws sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn nil))) (sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-opt_type sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (mp-Main::sv-hash-lookup "opt_type" sv-MATCH) sv-m2)1) (progn nil))) (sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-opt_ws sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn nil))) (sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-var_ident sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (mp-Main::sv-hash-lookup "var_ident" sv-MATCH) sv-m2)1) (progn nil))) (sv-or (progn (setf (sv-capture sv-MATCH) (let ((m (make-instance 'mp-Decl))) (setf (sv-decl m) (sv-scalar (mp-Main::sv-hash-lookup "declarator" sv-MATCH)))(setf (sv-type m) (sv-scalar (mp-Main::sv-hash-lookup "opt_type" sv-MATCH)))(setf (sv-var m) (sv-scalar (mp-Main::sv-hash-lookup "var_ident" sv-MATCH))) m))) 1))))))) (sv-or (progn (setf (sv-to sv-MATCH ) sv-pos1)(sv-and (if (sv-bool (sv-eq "u" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (sv-add 1 (setf (sv-to sv-MATCH ) (sv-add 1 (sv-to sv-MATCH )))) nil) (sv-and (if (sv-bool (sv-eq "s" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (sv-add 1 (setf (sv-to sv-MATCH ) (sv-add 1 (sv-to sv-MATCH )))) nil) (sv-and (if (sv-bool (sv-eq "e" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (sv-add 1 (setf (sv-to sv-MATCH ) (sv-add 1 (sv-to sv-MATCH )))) nil) (sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-ws sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn nil))) (sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-full_ident sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (mp-Main::sv-hash-lookup "full_ident" sv-MATCH) sv-m2)1) (progn nil))) (sv-and (let ((sv-last_pos (sv-undef))) (setf sv-last_pos (sv-to sv-MATCH ))(if (sv-bool (not (sv-bool (progn (let ((sv-pos1 (sv-undef))) (setf sv-pos1 (sv-to sv-MATCH ))(progn (sv-and (if (sv-bool (sv-eq "-" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (sv-add 1 (setf (sv-to sv-MATCH ) (sv-add 1 (sv-to sv-MATCH )))) nil) (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-ident sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(if (sv-bool (nth-value 1 (mp-Main::sv-hash-lookup "ident" sv-MATCH))) (progn (sv-push (mp-Main::sv-hash-lookup "ident" sv-MATCH) sv-m2)) (progn (setf (mp-Main::sv-hash-lookup "ident" sv-MATCH) (let ((_tmp_ (concatenate 'list  (list sv-m2)))) (make-array (length _tmp_) :adjustable 1 :fill-pointer t :initial-contents _tmp_)))))1) (progn nil)))))))))) (progn (setf (sv-to sv-MATCH ) sv-last_pos)) nil)1) (sv-or (progn (setf (sv-capture sv-MATCH) (let ((m (make-instance 'mp-Use))) (setf (sv-mod m) (sv-scalar (mp-Main::sv-hash-lookup "full_ident" sv-MATCH))) m))) 1)))))))) (sv-or (progn (setf (sv-to sv-MATCH ) sv-pos1)(sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-val sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (mp-Main::sv-hash-lookup "val" sv-MATCH) sv-m2)1) (progn nil))) (sv-or (progn (setf (sv-capture sv-MATCH) (sv-scalar (mp-Main::sv-hash-lookup "val" sv-MATCH)))) 1))) (sv-or (progn (setf (sv-to sv-MATCH ) sv-pos1)(sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-lit sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (mp-Main::sv-hash-lookup "lit" sv-MATCH) sv-m2)1) (progn nil))) (sv-or (progn (setf (sv-capture sv-MATCH) (sv-scalar (mp-Main::sv-hash-lookup "lit" sv-MATCH)))) 1))) (sv-or (progn (setf (sv-to sv-MATCH ) sv-pos1)(sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-token sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (mp-Main::sv-hash-lookup "token" sv-MATCH) sv-m2)1) (progn nil))) (sv-or (progn (setf (sv-capture sv-MATCH) (sv-scalar (mp-Main::sv-hash-lookup "token" sv-MATCH)))) 1))) (sv-or (progn (setf (sv-to sv-MATCH ) sv-pos1)(sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-method_def sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (mp-Main::sv-hash-lookup "method_def" sv-MATCH) sv-m2)1) (progn nil))) (sv-or (progn (setf (sv-capture sv-MATCH) (sv-scalar (mp-Main::sv-hash-lookup "method_def" sv-MATCH)))) 1))) (sv-or (progn (setf (sv-to sv-MATCH ) sv-pos1)(sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-sub_def sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (mp-Main::sv-hash-lookup "sub_def" sv-MATCH) sv-m2)1) (progn nil))) (sv-or (progn (setf (sv-capture sv-MATCH) (sv-scalar (mp-Main::sv-hash-lookup "sub_def" sv-MATCH)))) 1))) (sv-or (progn (setf (sv-to sv-MATCH ) sv-pos1)(sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-control sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (mp-Main::sv-hash-lookup "control" sv-MATCH) sv-m2)1) (progn nil))) (sv-or (progn (setf (sv-capture sv-MATCH) (sv-scalar (mp-Main::sv-hash-lookup "control" sv-MATCH)))) 1))) (progn (setf (sv-to sv-MATCH ) sv-pos1)(sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-apply sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (mp-Main::sv-hash-lookup "apply" sv-MATCH) sv-m2)1) (progn nil))) (sv-or (progn (setf (sv-capture sv-MATCH) (sv-scalar (mp-Main::sv-hash-lookup "apply" sv-MATCH)))) 1))))))))))))))))))))sv-MATCH)))

;; method var_sigil
(defmethod sv-var_sigil ((sv-grammar mp-MiniPerl6-Grammar) &optional sv-str sv-pos)
  (block mp6-function
    (let ((sv-MATCH (sv-undef))) (setf sv-MATCH (let ((m (make-instance 'mp-MiniPerl6-Match))) (setf (sv-str m) sv-str)(setf (sv-from m) sv-pos)(setf (sv-to m) sv-pos)(setf (sv-bool m) 1) m))(setf (sv-bool sv-MATCH ) (let ((sv-pos1 (sv-undef))) (setf sv-pos1 (sv-to sv-MATCH ))(sv-or (progn (if (sv-bool (sv-eq "$" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (sv-add 1 (setf (sv-to sv-MATCH ) (sv-add 1 (sv-to sv-MATCH )))) nil)) (sv-or (progn (setf (sv-to sv-MATCH ) sv-pos1)(if (sv-bool (sv-eq "%" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (sv-add 1 (setf (sv-to sv-MATCH ) (sv-add 1 (sv-to sv-MATCH )))) nil)) (sv-or (progn (setf (sv-to sv-MATCH ) sv-pos1)(if (sv-bool (sv-eq "@" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (sv-add 1 (setf (sv-to sv-MATCH ) (sv-add 1 (sv-to sv-MATCH )))) nil)) (progn (setf (sv-to sv-MATCH ) sv-pos1)(if (sv-bool (sv-eq "&" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (sv-add 1 (setf (sv-to sv-MATCH ) (sv-add 1 (sv-to sv-MATCH )))) nil)))))))sv-MATCH)))

;; method var_twigil
(defmethod sv-var_twigil ((sv-grammar mp-MiniPerl6-Grammar) &optional sv-str sv-pos)
  (block mp6-function
    (let ((sv-MATCH (sv-undef))) (setf sv-MATCH (let ((m (make-instance 'mp-MiniPerl6-Match))) (setf (sv-str m) sv-str)(setf (sv-from m) sv-pos)(setf (sv-to m) sv-pos)(setf (sv-bool m) 1) m))(setf (sv-bool sv-MATCH ) (let ((sv-pos1 (sv-undef))) (setf sv-pos1 (sv-to sv-MATCH ))(progn (let ((sv-last_pos (sv-undef))) (setf sv-last_pos (sv-to sv-MATCH ))(if (sv-bool (not (sv-bool (progn (let ((sv-pos1 (sv-undef))) (setf sv-pos1 (sv-to sv-MATCH ))(sv-or (progn (if (sv-bool (sv-eq "." (sv-substr sv-str (sv-to sv-MATCH ) 1))) (sv-add 1 (setf (sv-to sv-MATCH ) (sv-add 1 (sv-to sv-MATCH )))) nil)) (sv-or (progn (setf (sv-to sv-MATCH ) sv-pos1)(if (sv-bool (sv-eq "!" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (sv-add 1 (setf (sv-to sv-MATCH ) (sv-add 1 (sv-to sv-MATCH )))) nil)) (sv-or (progn (setf (sv-to sv-MATCH ) sv-pos1)(if (sv-bool (sv-eq "^" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (sv-add 1 (setf (sv-to sv-MATCH ) (sv-add 1 (sv-to sv-MATCH )))) nil)) (progn (setf (sv-to sv-MATCH ) sv-pos1)(if (sv-bool (sv-eq "*" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (sv-add 1 (setf (sv-to sv-MATCH ) (sv-add 1 (sv-to sv-MATCH )))) nil)))))))))) (progn (setf (sv-to sv-MATCH ) sv-last_pos)) nil)1))))sv-MATCH)))

;; method var_name
(defmethod sv-var_name ((sv-grammar mp-MiniPerl6-Grammar) &optional sv-str sv-pos)
  (block mp6-function
    (let ((sv-MATCH (sv-undef))) (setf sv-MATCH (let ((m (make-instance 'mp-MiniPerl6-Match))) (setf (sv-str m) sv-str)(setf (sv-from m) sv-pos)(setf (sv-to m) sv-pos)(setf (sv-bool m) 1) m))(setf (sv-bool sv-MATCH ) (let ((sv-pos1 (sv-undef))) (setf sv-pos1 (sv-to sv-MATCH ))(sv-or (progn (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-full_ident sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (mp-Main::sv-hash-lookup "full_ident" sv-MATCH) sv-m2)1) (progn nil)))) (sv-or (progn (setf (sv-to sv-MATCH ) sv-pos1)(if (sv-bool (sv-eq "/" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (sv-add 1 (setf (sv-to sv-MATCH ) (sv-add 1 (sv-to sv-MATCH )))) nil)) (progn (setf (sv-to sv-MATCH ) sv-pos1)(let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-digit sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (mp-Main::sv-hash-lookup "digit" sv-MATCH) sv-m2)1) (progn nil))))))))sv-MATCH)))

;; method var_ident
(defmethod sv-var_ident ((sv-grammar mp-MiniPerl6-Grammar) &optional sv-str sv-pos)
  (block mp6-function
    (let ((sv-MATCH (sv-undef))) (setf sv-MATCH (let ((m (make-instance 'mp-MiniPerl6-Match))) (setf (sv-str m) sv-str)(setf (sv-from m) sv-pos)(setf (sv-to m) sv-pos)(setf (sv-bool m) 1) m))(setf (sv-bool sv-MATCH ) (let ((sv-pos1 (sv-undef))) (setf sv-pos1 (sv-to sv-MATCH ))(progn (sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-var_sigil sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (mp-Main::sv-hash-lookup "var_sigil" sv-MATCH) sv-m2)1) (progn nil))) (sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-var_twigil sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (mp-Main::sv-hash-lookup "var_twigil" sv-MATCH) sv-m2)1) (progn nil))) (sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-optional_namespace_before_ident sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (mp-Main::sv-hash-lookup "optional_namespace_before_ident" sv-MATCH) sv-m2)1) (progn nil))) (sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-var_name sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (mp-Main::sv-hash-lookup "var_name" sv-MATCH) sv-m2)1) (progn nil))) (sv-or (progn (setf (sv-capture sv-MATCH) (let ((m (make-instance 'mp-Var))) (setf (sv-sigil m) (sv-string (mp-Main::sv-hash-lookup "var_sigil" sv-MATCH)))(setf (sv-twigil m) (sv-string (mp-Main::sv-hash-lookup "var_twigil" sv-MATCH)))(setf (sv-namespace m) (sv-scalar (mp-Main::sv-hash-lookup "optional_namespace_before_ident" sv-MATCH)))(setf (sv-name m) (sv-string (mp-Main::sv-hash-lookup "var_name" sv-MATCH))) m))) 1))))))))sv-MATCH)))

;; method val
(defmethod sv-val ((sv-grammar mp-MiniPerl6-Grammar) &optional sv-str sv-pos)
  (block mp6-function
    (let ((sv-MATCH (sv-undef))) (setf sv-MATCH (let ((m (make-instance 'mp-MiniPerl6-Match))) (setf (sv-str m) sv-str)(setf (sv-from m) sv-pos)(setf (sv-to m) sv-pos)(setf (sv-bool m) 1) m))(setf (sv-bool sv-MATCH ) (let ((sv-pos1 (sv-undef))) (setf sv-pos1 (sv-to sv-MATCH ))(sv-or (progn (sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-val_undef sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (mp-Main::sv-hash-lookup "val_undef" sv-MATCH) sv-m2)1) (progn nil))) (sv-or (progn (setf (sv-capture sv-MATCH) (sv-scalar (mp-Main::sv-hash-lookup "val_undef" sv-MATCH)))) 1))) (sv-or (progn (setf (sv-to sv-MATCH ) sv-pos1)(sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-val_num sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (mp-Main::sv-hash-lookup "val_num" sv-MATCH) sv-m2)1) (progn nil))) (sv-or (progn (setf (sv-capture sv-MATCH) (sv-scalar (mp-Main::sv-hash-lookup "val_num" sv-MATCH)))) 1))) (sv-or (progn (setf (sv-to sv-MATCH ) sv-pos1)(sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-val_int sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (mp-Main::sv-hash-lookup "val_int" sv-MATCH) sv-m2)1) (progn nil))) (sv-or (progn (setf (sv-capture sv-MATCH) (sv-scalar (mp-Main::sv-hash-lookup "val_int" sv-MATCH)))) 1))) (sv-or (progn (setf (sv-to sv-MATCH ) sv-pos1)(sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-val_bit sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (mp-Main::sv-hash-lookup "val_bit" sv-MATCH) sv-m2)1) (progn nil))) (sv-or (progn (setf (sv-capture sv-MATCH) (sv-scalar (mp-Main::sv-hash-lookup "val_bit" sv-MATCH)))) 1))) (progn (setf (sv-to sv-MATCH ) sv-pos1)(sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-val_buf sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (mp-Main::sv-hash-lookup "val_buf" sv-MATCH) sv-m2)1) (progn nil))) (sv-or (progn (setf (sv-capture sv-MATCH) (sv-scalar (mp-Main::sv-hash-lookup "val_buf" sv-MATCH)))) 1)))))))))sv-MATCH)))

;; method val_bit
(defmethod sv-val_bit ((sv-grammar mp-MiniPerl6-Grammar) &optional sv-str sv-pos)
  (block mp6-function
    (let ((sv-MATCH (sv-undef))) (setf sv-MATCH (let ((m (make-instance 'mp-MiniPerl6-Match))) (setf (sv-str m) sv-str)(setf (sv-from m) sv-pos)(setf (sv-to m) sv-pos)(setf (sv-bool m) 1) m))(setf (sv-bool sv-MATCH ) (let ((sv-pos1 (sv-undef))) (setf sv-pos1 (sv-to sv-MATCH ))(sv-or (progn (sv-and (if (sv-bool (sv-eq "True" (sv-substr sv-str (sv-to sv-MATCH ) 4))) (sv-add 1 (setf (sv-to sv-MATCH ) (sv-add 4 (sv-to sv-MATCH )))) nil) (sv-or (progn (setf (sv-capture sv-MATCH) (let ((m (make-instance 'mp-Val-Bit))) (setf (sv-bit m) 1) m))) 1))) (progn (setf (sv-to sv-MATCH ) sv-pos1)(sv-and (if (sv-bool (sv-eq "False" (sv-substr sv-str (sv-to sv-MATCH ) 5))) (sv-add 1 (setf (sv-to sv-MATCH ) (sv-add 5 (sv-to sv-MATCH )))) nil) (sv-or (progn (setf (sv-capture sv-MATCH) (let ((m (make-instance 'mp-Val-Bit))) (setf (sv-bit m) 0) m))) 1))))))sv-MATCH)))

;; method digits
(defmethod sv-digits ((sv-grammar mp-MiniPerl6-Grammar) &optional sv-str sv-pos)
  (block mp6-function
    (let ((sv-MATCH (sv-undef))) (setf sv-MATCH (let ((m (make-instance 'mp-MiniPerl6-Match))) (setf (sv-str m) sv-str)(setf (sv-from m) sv-pos)(setf (sv-to m) sv-pos)(setf (sv-bool m) 1) m))(setf (sv-bool sv-MATCH ) (let ((sv-pos1 (sv-undef))) (setf sv-pos1 (sv-to sv-MATCH ))(progn (let ((sv-last_match_null (sv-undef))(sv-last_pos (sv-undef))(sv-count (sv-undef))) (setf sv-last_match_null 0)(setf sv-last_pos (sv-to sv-MATCH ))(setf sv-count 0)(loop while (sv-bool (sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-digit sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn nil))) (sv-numeric-smaller sv-last_match_null 2))) do (progn (if (sv-bool (sv-numeric-equal sv-last_pos (sv-to sv-MATCH ))) (progn (setf sv-last_match_null (sv-add sv-last_match_null 1))) (progn (setf sv-last_match_null 0)))(setf sv-last_pos (sv-to sv-MATCH ))(setf sv-count (sv-add sv-count 1))))(setf (sv-to sv-MATCH ) sv-last_pos)(sv-numeric-bigger sv-count 0)))))sv-MATCH)))

;; method val_undef
(defmethod sv-val_undef ((sv-grammar mp-MiniPerl6-Grammar) &optional sv-str sv-pos)
  (block mp6-function
    (let ((sv-MATCH (sv-undef))) (setf sv-MATCH (let ((m (make-instance 'mp-MiniPerl6-Match))) (setf (sv-str m) sv-str)(setf (sv-from m) sv-pos)(setf (sv-to m) sv-pos)(setf (sv-bool m) 1) m))(setf (sv-bool sv-MATCH ) (let ((sv-pos1 (sv-undef))) (setf sv-pos1 (sv-to sv-MATCH ))(progn (sv-and (if (sv-bool (sv-eq "u" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (sv-add 1 (setf (sv-to sv-MATCH ) (sv-add 1 (sv-to sv-MATCH )))) nil) (sv-and (if (sv-bool (sv-eq "n" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (sv-add 1 (setf (sv-to sv-MATCH ) (sv-add 1 (sv-to sv-MATCH )))) nil) (sv-and (if (sv-bool (sv-eq "d" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (sv-add 1 (setf (sv-to sv-MATCH ) (sv-add 1 (sv-to sv-MATCH )))) nil) (sv-and (if (sv-bool (sv-eq "e" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (sv-add 1 (setf (sv-to sv-MATCH ) (sv-add 1 (sv-to sv-MATCH )))) nil) (sv-and (if (sv-bool (sv-eq "f" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (sv-add 1 (setf (sv-to sv-MATCH ) (sv-add 1 (sv-to sv-MATCH )))) nil) (sv-and (let ((sv-tmp (sv-undef))) (setf sv-tmp sv-MATCH)(setf sv-MATCH (let ((m (make-instance 'mp-MiniPerl6-Match))) (setf (sv-str m) sv-str)(setf (sv-from m) (sv-to sv-tmp ))(setf (sv-to m) (sv-to sv-tmp ))(setf (sv-bool m) 1) m))(setf (sv-bool sv-MATCH ) (let ((sv-pos1 (sv-undef))) (setf sv-pos1 (sv-to sv-MATCH ))(progn (if (sv-bool (sv-eq "w" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (sv-add 1 (setf (sv-to sv-MATCH ) (sv-add 1 (sv-to sv-MATCH )))) nil))))(setf (sv-bool sv-tmp ) (not (sv-bool sv-MATCH)))(setf sv-MATCH sv-tmp)(sv-bool sv-MATCH)) (sv-or (progn (setf (sv-capture sv-MATCH) (make-instance 'mp-Val-Undef))) 1))))))))))sv-MATCH)))

;; method val_num
(defmethod sv-val_num ((sv-grammar mp-MiniPerl6-Grammar) &optional sv-str sv-pos)
  (block mp6-function
    (let ((sv-MATCH (sv-undef))) (setf sv-MATCH (let ((m (make-instance 'mp-MiniPerl6-Match))) (setf (sv-str m) sv-str)(setf (sv-from m) sv-pos)(setf (sv-to m) sv-pos)(setf (sv-bool m) 1) m))(setf (sv-bool sv-MATCH ) (let ((sv-pos1 (sv-undef))) (setf sv-pos1 (sv-to sv-MATCH ))(progn (sv-and (let ((sv-last_match_null (sv-undef))(sv-last_pos (sv-undef))(sv-count (sv-undef))) (setf sv-last_match_null 0)(setf sv-last_pos (sv-to sv-MATCH ))(setf sv-count 0)(loop while (sv-bool (sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-digit sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn nil))) (sv-numeric-smaller sv-last_match_null 2))) do (progn (if (sv-bool (sv-numeric-equal sv-last_pos (sv-to sv-MATCH ))) (progn (setf sv-last_match_null (sv-add sv-last_match_null 1))) (progn (setf sv-last_match_null 0)))(setf sv-last_pos (sv-to sv-MATCH ))(setf sv-count (sv-add sv-count 1))))(setf (sv-to sv-MATCH ) sv-last_pos)(sv-numeric-bigger sv-count 0)) (sv-and (let ((sv-pos1 (sv-undef))) (setf sv-pos1 (sv-to sv-MATCH ))(sv-or (progn (sv-and (let ((sv-pos1 (sv-undef))) (setf sv-pos1 (sv-to sv-MATCH ))(sv-or (progn (if (sv-bool (sv-eq "e" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (sv-add 1 (setf (sv-to sv-MATCH ) (sv-add 1 (sv-to sv-MATCH )))) nil)) (progn (setf (sv-to sv-MATCH ) sv-pos1)(if (sv-bool (sv-eq "E" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (sv-add 1 (setf (sv-to sv-MATCH ) (sv-add 1 (sv-to sv-MATCH )))) nil)))) (sv-and (let ((sv-pos1 (sv-undef))) (setf sv-pos1 (sv-to sv-MATCH ))(sv-or (progn (if (sv-bool (sv-eq "+" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (sv-add 1 (setf (sv-to sv-MATCH ) (sv-add 1 (sv-to sv-MATCH )))) nil)) (sv-or (progn (setf (sv-to sv-MATCH ) sv-pos1)(if (sv-bool (sv-eq "-" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (sv-add 1 (setf (sv-to sv-MATCH ) (sv-add 1 (sv-to sv-MATCH )))) nil)) (progn (setf (sv-to sv-MATCH ) sv-pos1)1)))) (let ((sv-last_match_null (sv-undef))(sv-last_pos (sv-undef))(sv-count (sv-undef))) (setf sv-last_match_null 0)(setf sv-last_pos (sv-to sv-MATCH ))(setf sv-count 0)(loop while (sv-bool (sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-digit sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn nil))) (sv-numeric-smaller sv-last_match_null 2))) do (progn (if (sv-bool (sv-numeric-equal sv-last_pos (sv-to sv-MATCH ))) (progn (setf sv-last_match_null (sv-add sv-last_match_null 1))) (progn (setf sv-last_match_null 0)))(setf sv-last_pos (sv-to sv-MATCH ))(setf sv-count (sv-add sv-count 1))))(setf (sv-to sv-MATCH ) sv-last_pos)(sv-numeric-bigger sv-count 0))))) (progn (setf (sv-to sv-MATCH ) sv-pos1)(sv-and (if (sv-bool (sv-eq "." (sv-substr sv-str (sv-to sv-MATCH ) 1))) (sv-add 1 (setf (sv-to sv-MATCH ) (sv-add 1 (sv-to sv-MATCH )))) nil) (sv-and (let ((sv-last_match_null (sv-undef))(sv-last_pos (sv-undef))(sv-count (sv-undef))) (setf sv-last_match_null 0)(setf sv-last_pos (sv-to sv-MATCH ))(setf sv-count 0)(loop while (sv-bool (sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-digit sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn nil))) (sv-numeric-smaller sv-last_match_null 2))) do (progn (if (sv-bool (sv-numeric-equal sv-last_pos (sv-to sv-MATCH ))) (progn (setf sv-last_match_null (sv-add sv-last_match_null 1))) (progn (setf sv-last_match_null 0)))(setf sv-last_pos (sv-to sv-MATCH ))(setf sv-count (sv-add sv-count 1))))(setf (sv-to sv-MATCH ) sv-last_pos)(sv-numeric-bigger sv-count 0)) (let ((sv-last_pos (sv-undef))) (setf sv-last_pos (sv-to sv-MATCH ))(if (sv-bool (not (sv-bool (progn (let ((sv-pos1 (sv-undef))) (setf sv-pos1 (sv-to sv-MATCH ))(progn (sv-and (let ((sv-pos1 (sv-undef))) (setf sv-pos1 (sv-to sv-MATCH ))(sv-or (progn (if (sv-bool (sv-eq "e" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (sv-add 1 (setf (sv-to sv-MATCH ) (sv-add 1 (sv-to sv-MATCH )))) nil)) (progn (setf (sv-to sv-MATCH ) sv-pos1)(if (sv-bool (sv-eq "E" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (sv-add 1 (setf (sv-to sv-MATCH ) (sv-add 1 (sv-to sv-MATCH )))) nil)))) (sv-and (let ((sv-pos1 (sv-undef))) (setf sv-pos1 (sv-to sv-MATCH ))(sv-or (progn (if (sv-bool (sv-eq "+" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (sv-add 1 (setf (sv-to sv-MATCH ) (sv-add 1 (sv-to sv-MATCH )))) nil)) (sv-or (progn (setf (sv-to sv-MATCH ) sv-pos1)(if (sv-bool (sv-eq "-" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (sv-add 1 (setf (sv-to sv-MATCH ) (sv-add 1 (sv-to sv-MATCH )))) nil)) (progn (setf (sv-to sv-MATCH ) sv-pos1)1)))) (let ((sv-last_match_null (sv-undef))(sv-last_pos (sv-undef))(sv-count (sv-undef))) (setf sv-last_match_null 0)(setf sv-last_pos (sv-to sv-MATCH ))(setf sv-count 0)(loop while (sv-bool (sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-digit sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn nil))) (sv-numeric-smaller sv-last_match_null 2))) do (progn (if (sv-bool (sv-numeric-equal sv-last_pos (sv-to sv-MATCH ))) (progn (setf sv-last_match_null (sv-add sv-last_match_null 1))) (progn (setf sv-last_match_null 0)))(setf sv-last_pos (sv-to sv-MATCH ))(setf sv-count (sv-add sv-count 1))))(setf (sv-to sv-MATCH ) sv-last_pos)(sv-numeric-bigger sv-count 0)))))))))) (progn (setf (sv-to sv-MATCH ) sv-last_pos)) nil)1)))))) (sv-or (progn (setf (sv-capture sv-MATCH) (let ((m (make-instance 'mp-Val-Num))) (setf (sv-num m) (sv-string sv-MATCH)) m))) 1))))))sv-MATCH)))

;; method char_any
(defmethod sv-char_any ((sv-grammar mp-MiniPerl6-Grammar) &optional sv-str sv-pos)
  (block mp6-function
    (let ((sv-MATCH (sv-undef))) (setf sv-MATCH (let ((m (make-instance 'mp-MiniPerl6-Match))) (setf (sv-str m) sv-str)(setf (sv-from m) sv-pos)(setf (sv-to m) sv-pos)(setf (sv-bool m) 1) m))(setf (sv-bool sv-MATCH ) (let ((sv-pos1 (sv-undef))) (setf sv-pos1 (sv-to sv-MATCH ))(progn (if (sv-bool (not (sv-eq "" (sv-substr sv-str (sv-to sv-MATCH ) 1)))) (sv-add 1 (setf (sv-to sv-MATCH ) (sv-add 1 (sv-to sv-MATCH )))) nil))))sv-MATCH)))

;; method single_quoted_unescape
(defmethod sv-single_quoted_unescape ((sv-grammar mp-MiniPerl6-Grammar) &optional sv-str sv-pos)
  (block mp6-function
    (let ((sv-MATCH (sv-undef))) (setf sv-MATCH (let ((m (make-instance 'mp-MiniPerl6-Match))) (setf (sv-str m) sv-str)(setf (sv-from m) sv-pos)(setf (sv-to m) sv-pos)(setf (sv-bool m) 1) m))(setf (sv-bool sv-MATCH ) (let ((sv-pos1 (sv-undef))) (setf sv-pos1 (sv-to sv-MATCH ))(sv-or (progn (sv-and (if (sv-bool (sv-eq "\\" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (sv-add 1 (setf (sv-to sv-MATCH ) (sv-add 1 (sv-to sv-MATCH )))) nil) (sv-and (if (sv-bool (sv-eq "'" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (sv-add 1 (setf (sv-to sv-MATCH ) (sv-add 1 (sv-to sv-MATCH )))) nil) (sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-single_quoted_unescape sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (mp-Main::sv-hash-lookup "single_quoted_unescape" sv-MATCH) sv-m2)1) (progn nil))) (sv-or (progn (setf (sv-capture sv-MATCH) (concatenate 'string (sv-string "'") (sv-string (mp-Main::sv-hash-lookup "single_quoted_unescape" sv-MATCH))))) 1))))) (sv-or (progn (setf (sv-to sv-MATCH ) sv-pos1)(sv-and (if (sv-bool (sv-eq "\\" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (sv-add 1 (setf (sv-to sv-MATCH ) (sv-add 1 (sv-to sv-MATCH )))) nil) (sv-and (if (sv-bool (sv-eq "\"" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (sv-add 1 (setf (sv-to sv-MATCH ) (sv-add 1 (sv-to sv-MATCH )))) nil) (sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-single_quoted_unescape sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (mp-Main::sv-hash-lookup "single_quoted_unescape" sv-MATCH) sv-m2)1) (progn nil))) (sv-or (progn (setf (sv-capture sv-MATCH) (concatenate 'string (sv-string "\"") (sv-string (mp-Main::sv-hash-lookup "single_quoted_unescape" sv-MATCH))))) 1))))) (sv-or (progn (setf (sv-to sv-MATCH ) sv-pos1)(sv-and (if (sv-bool (sv-eq "\\" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (sv-add 1 (setf (sv-to sv-MATCH ) (sv-add 1 (sv-to sv-MATCH )))) nil) (sv-and (if (sv-bool (sv-eq "\\" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (sv-add 1 (setf (sv-to sv-MATCH ) (sv-add 1 (sv-to sv-MATCH )))) nil) (sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-single_quoted_unescape sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (mp-Main::sv-hash-lookup "single_quoted_unescape" sv-MATCH) sv-m2)1) (progn nil))) (sv-or (progn (setf (sv-capture sv-MATCH) (concatenate 'string (sv-string "\\") (sv-string (mp-Main::sv-hash-lookup "single_quoted_unescape" sv-MATCH))))) 1))))) (sv-or (progn (setf (sv-to sv-MATCH ) sv-pos1)(sv-and (let ((sv-tmp (sv-undef))) (setf sv-tmp sv-MATCH)(setf sv-MATCH (let ((m (make-instance 'mp-MiniPerl6-Match))) (setf (sv-str m) sv-str)(setf (sv-from m) (sv-to sv-tmp ))(setf (sv-to m) (sv-to sv-tmp ))(setf (sv-bool m) 1) m))(setf (sv-bool sv-MATCH ) (let ((sv-pos1 (sv-undef))) (setf sv-pos1 (sv-to sv-MATCH ))(progn (if (sv-bool (sv-eq "'" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (sv-add 1 (setf (sv-to sv-MATCH ) (sv-add 1 (sv-to sv-MATCH )))) nil))))(setf (sv-bool sv-tmp ) (not (sv-bool sv-MATCH)))(setf sv-MATCH sv-tmp)(sv-bool sv-MATCH)) (sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-char_any sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (mp-Main::sv-hash-lookup "char_any" sv-MATCH) sv-m2)1) (progn nil))) (sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-single_quoted_unescape sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (mp-Main::sv-hash-lookup "single_quoted_unescape" sv-MATCH) sv-m2)1) (progn nil))) (sv-or (progn (setf (sv-capture sv-MATCH) (concatenate 'string (sv-string (mp-Main::sv-hash-lookup "char_any" sv-MATCH)) (sv-string (mp-Main::sv-hash-lookup "single_quoted_unescape" sv-MATCH))))) 1))))) (progn (setf (sv-to sv-MATCH ) sv-pos1)1)))))))sv-MATCH)))

;; method double_quoted_unescape
(defmethod sv-double_quoted_unescape ((sv-grammar mp-MiniPerl6-Grammar) &optional sv-str sv-pos)
  (block mp6-function
    (let ((sv-MATCH (sv-undef))) (setf sv-MATCH (let ((m (make-instance 'mp-MiniPerl6-Match))) (setf (sv-str m) sv-str)(setf (sv-from m) sv-pos)(setf (sv-to m) sv-pos)(setf (sv-bool m) 1) m))(setf (sv-bool sv-MATCH ) (let ((sv-pos1 (sv-undef))) (setf sv-pos1 (sv-to sv-MATCH ))(sv-or (progn (sv-and (if (sv-bool (sv-eq "\\" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (sv-add 1 (setf (sv-to sv-MATCH ) (sv-add 1 (sv-to sv-MATCH )))) nil) (sv-and (if (sv-bool (sv-eq "'" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (sv-add 1 (setf (sv-to sv-MATCH ) (sv-add 1 (sv-to sv-MATCH )))) nil) (sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-double_quoted_unescape sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (mp-Main::sv-hash-lookup "double_quoted_unescape" sv-MATCH) sv-m2)1) (progn nil))) (sv-or (progn (setf (sv-capture sv-MATCH) (concatenate 'string (sv-string "'") (sv-string (mp-Main::sv-hash-lookup "double_quoted_unescape" sv-MATCH))))) 1))))) (sv-or (progn (setf (sv-to sv-MATCH ) sv-pos1)(sv-and (if (sv-bool (sv-eq "\\" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (sv-add 1 (setf (sv-to sv-MATCH ) (sv-add 1 (sv-to sv-MATCH )))) nil) (sv-and (if (sv-bool (sv-eq "\"" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (sv-add 1 (setf (sv-to sv-MATCH ) (sv-add 1 (sv-to sv-MATCH )))) nil) (sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-double_quoted_unescape sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (mp-Main::sv-hash-lookup "double_quoted_unescape" sv-MATCH) sv-m2)1) (progn nil))) (sv-or (progn (setf (sv-capture sv-MATCH) (concatenate 'string (sv-string "\"") (sv-string (mp-Main::sv-hash-lookup "double_quoted_unescape" sv-MATCH))))) 1))))) (sv-or (progn (setf (sv-to sv-MATCH ) sv-pos1)(sv-and (if (sv-bool (sv-eq "\\" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (sv-add 1 (setf (sv-to sv-MATCH ) (sv-add 1 (sv-to sv-MATCH )))) nil) (sv-and (if (sv-bool (sv-eq "\\" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (sv-add 1 (setf (sv-to sv-MATCH ) (sv-add 1 (sv-to sv-MATCH )))) nil) (sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-double_quoted_unescape sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (mp-Main::sv-hash-lookup "double_quoted_unescape" sv-MATCH) sv-m2)1) (progn nil))) (sv-or (progn (setf (sv-capture sv-MATCH) (concatenate 'string (sv-string "\\") (sv-string (mp-Main::sv-hash-lookup "double_quoted_unescape" sv-MATCH))))) 1))))) (sv-or (progn (setf (sv-to sv-MATCH ) sv-pos1)(sv-and (if (sv-bool (sv-eq "\\" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (sv-add 1 (setf (sv-to sv-MATCH ) (sv-add 1 (sv-to sv-MATCH )))) nil) (sv-and (if (sv-bool (sv-eq "n" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (sv-add 1 (setf (sv-to sv-MATCH ) (sv-add 1 (sv-to sv-MATCH )))) nil) (sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-double_quoted_unescape sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (mp-Main::sv-hash-lookup "double_quoted_unescape" sv-MATCH) sv-m2)1) (progn nil))) (sv-or (progn (setf (sv-capture sv-MATCH) (concatenate 'string (sv-string (sv-newline (proto-mp-Main) )) (sv-string (mp-Main::sv-hash-lookup "double_quoted_unescape" sv-MATCH))))) 1))))) (sv-or (progn (setf (sv-to sv-MATCH ) sv-pos1)(sv-and (let ((sv-tmp (sv-undef))) (setf sv-tmp sv-MATCH)(setf sv-MATCH (let ((m (make-instance 'mp-MiniPerl6-Match))) (setf (sv-str m) sv-str)(setf (sv-from m) (sv-to sv-tmp ))(setf (sv-to m) (sv-to sv-tmp ))(setf (sv-bool m) 1) m))(setf (sv-bool sv-MATCH ) (let ((sv-pos1 (sv-undef))) (setf sv-pos1 (sv-to sv-MATCH ))(progn (if (sv-bool (sv-eq "\"" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (sv-add 1 (setf (sv-to sv-MATCH ) (sv-add 1 (sv-to sv-MATCH )))) nil))))(setf (sv-bool sv-tmp ) (not (sv-bool sv-MATCH)))(setf sv-MATCH sv-tmp)(sv-bool sv-MATCH)) (sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-char_any sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (mp-Main::sv-hash-lookup "char_any" sv-MATCH) sv-m2)1) (progn nil))) (sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-double_quoted_unescape sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (mp-Main::sv-hash-lookup "double_quoted_unescape" sv-MATCH) sv-m2)1) (progn nil))) (sv-or (progn (setf (sv-capture sv-MATCH) (concatenate 'string (sv-string (mp-Main::sv-hash-lookup "char_any" sv-MATCH)) (sv-string (mp-Main::sv-hash-lookup "double_quoted_unescape" sv-MATCH))))) 1))))) (progn (setf (sv-to sv-MATCH ) sv-pos1)1))))))))sv-MATCH)))

;; method val_buf
(defmethod sv-val_buf ((sv-grammar mp-MiniPerl6-Grammar) &optional sv-str sv-pos)
  (block mp6-function
    (let ((sv-MATCH (sv-undef))) (setf sv-MATCH (let ((m (make-instance 'mp-MiniPerl6-Match))) (setf (sv-str m) sv-str)(setf (sv-from m) sv-pos)(setf (sv-to m) sv-pos)(setf (sv-bool m) 1) m))(setf (sv-bool sv-MATCH ) (let ((sv-pos1 (sv-undef))) (setf sv-pos1 (sv-to sv-MATCH ))(sv-or (progn (sv-and (if (sv-bool (sv-eq "\"" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (sv-add 1 (setf (sv-to sv-MATCH ) (sv-add 1 (sv-to sv-MATCH )))) nil) (sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-double_quoted_unescape sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (mp-Main::sv-hash-lookup "double_quoted_unescape" sv-MATCH) sv-m2)1) (progn nil))) (sv-and (if (sv-bool (sv-eq "\"" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (sv-add 1 (setf (sv-to sv-MATCH ) (sv-add 1 (sv-to sv-MATCH )))) nil) (sv-or (progn (setf (sv-capture sv-MATCH) (let ((m (make-instance 'mp-Val-Buf))) (setf (sv-buf m) (sv-scalar (mp-Main::sv-hash-lookup "double_quoted_unescape" sv-MATCH))) m))) 1))))) (progn (setf (sv-to sv-MATCH ) sv-pos1)(sv-and (if (sv-bool (sv-eq "'" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (sv-add 1 (setf (sv-to sv-MATCH ) (sv-add 1 (sv-to sv-MATCH )))) nil) (sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-single_quoted_unescape sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (mp-Main::sv-hash-lookup "single_quoted_unescape" sv-MATCH) sv-m2)1) (progn nil))) (sv-and (if (sv-bool (sv-eq "'" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (sv-add 1 (setf (sv-to sv-MATCH ) (sv-add 1 (sv-to sv-MATCH )))) nil) (sv-or (progn (setf (sv-capture sv-MATCH) (let ((m (make-instance 'mp-Val-Buf))) (setf (sv-buf m) (sv-scalar (mp-Main::sv-hash-lookup "single_quoted_unescape" sv-MATCH))) m))) 1))))))))sv-MATCH)))

;; method val_int
(defmethod sv-val_int ((sv-grammar mp-MiniPerl6-Grammar) &optional sv-str sv-pos)
  (block mp6-function
    (let ((sv-MATCH (sv-undef))) (setf sv-MATCH (let ((m (make-instance 'mp-MiniPerl6-Match))) (setf (sv-str m) sv-str)(setf (sv-from m) sv-pos)(setf (sv-to m) sv-pos)(setf (sv-bool m) 1) m))(setf (sv-bool sv-MATCH ) (let ((sv-pos1 (sv-undef))) (setf sv-pos1 (sv-to sv-MATCH ))(progn (sv-and (let ((sv-last_match_null (sv-undef))(sv-last_pos (sv-undef))(sv-count (sv-undef))) (setf sv-last_match_null 0)(setf sv-last_pos (sv-to sv-MATCH ))(setf sv-count 0)(loop while (sv-bool (sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-digit sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn nil))) (sv-numeric-smaller sv-last_match_null 2))) do (progn (if (sv-bool (sv-numeric-equal sv-last_pos (sv-to sv-MATCH ))) (progn (setf sv-last_match_null (sv-add sv-last_match_null 1))) (progn (setf sv-last_match_null 0)))(setf sv-last_pos (sv-to sv-MATCH ))(setf sv-count (sv-add sv-count 1))))(setf (sv-to sv-MATCH ) sv-last_pos)(sv-numeric-bigger sv-count 0)) (sv-or (progn (setf (sv-capture sv-MATCH) (let ((m (make-instance 'mp-Val-Int))) (setf (sv-int m) (sv-string sv-MATCH)) m))) 1)))))sv-MATCH)))

;; method exp_stmts
(defmethod sv-exp_stmts ((sv-grammar mp-MiniPerl6-Grammar) &optional sv-str sv-pos)
  (block mp6-function
    (let ((sv-MATCH (sv-undef))) (setf sv-MATCH (let ((m (make-instance 'mp-MiniPerl6-Match))) (setf (sv-str m) sv-str)(setf (sv-from m) sv-pos)(setf (sv-to m) sv-pos)(setf (sv-bool m) 1) m))(setf (sv-bool sv-MATCH ) (let ((sv-pos1 (sv-undef))) (setf sv-pos1 (sv-to sv-MATCH ))(sv-or (progn (sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-exp sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (mp-Main::sv-hash-lookup "exp" sv-MATCH) sv-m2)1) (progn nil))) (let ((sv-pos1 (sv-undef))) (setf sv-pos1 (sv-to sv-MATCH ))(sv-or (progn (sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-opt_ws sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn nil))) (sv-and (let ((sv-pos1 (sv-undef))) (setf sv-pos1 (sv-to sv-MATCH ))(sv-or (progn (if (sv-bool (sv-eq ";" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (sv-add 1 (setf (sv-to sv-MATCH ) (sv-add 1 (sv-to sv-MATCH )))) nil)) (progn (setf (sv-to sv-MATCH ) sv-pos1)1))) (sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-opt_ws sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn nil))) (sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-exp_stmts sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (mp-Main::sv-hash-lookup "exp_stmts" sv-MATCH) sv-m2)1) (progn nil))) (sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-opt_ws sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn nil))) (sv-and (let ((sv-pos1 (sv-undef))) (setf sv-pos1 (sv-to sv-MATCH ))(sv-or (progn (sv-and (if (sv-bool (sv-eq ";" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (sv-add 1 (setf (sv-to sv-MATCH ) (sv-add 1 (sv-to sv-MATCH )))) nil) (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-opt_ws sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn nil))))) (progn (setf (sv-to sv-MATCH ) sv-pos1)1))) (sv-or (progn (setf (sv-capture sv-MATCH) (let ((_tmp_ (concatenate 'list  (list (sv-scalar (mp-Main::sv-hash-lookup "exp" sv-MATCH))) (coerce (sv-scalar (mp-Main::sv-hash-lookup "exp_stmts" sv-MATCH)) 'list)))) (make-array (length _tmp_) :adjustable 1 :fill-pointer t :initial-contents _tmp_)))) 1)))))))) (progn (setf (sv-to sv-MATCH ) sv-pos1)(sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-opt_ws sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn nil))) (sv-and (let ((sv-pos1 (sv-undef))) (setf sv-pos1 (sv-to sv-MATCH ))(sv-or (progn (sv-and (if (sv-bool (sv-eq ";" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (sv-add 1 (setf (sv-to sv-MATCH ) (sv-add 1 (sv-to sv-MATCH )))) nil) (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-opt_ws sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn nil))))) (progn (setf (sv-to sv-MATCH ) sv-pos1)1))) (sv-or (progn (setf (sv-capture sv-MATCH) (let ((_tmp_ (concatenate 'list  (list (sv-scalar (mp-Main::sv-hash-lookup "exp" sv-MATCH)))))) (make-array (length _tmp_) :adjustable 1 :fill-pointer t :initial-contents _tmp_)))) 1)))))))) (progn (setf (sv-to sv-MATCH ) sv-pos1)(sv-or (progn (setf (sv-capture sv-MATCH) (make-array 0 :adjustable 1 :fill-pointer t))) 1)))))sv-MATCH)))

;; method exp_seq
(defmethod sv-exp_seq ((sv-grammar mp-MiniPerl6-Grammar) &optional sv-str sv-pos)
  (block mp6-function
    (let ((sv-MATCH (sv-undef))) (setf sv-MATCH (let ((m (make-instance 'mp-MiniPerl6-Match))) (setf (sv-str m) sv-str)(setf (sv-from m) sv-pos)(setf (sv-to m) sv-pos)(setf (sv-bool m) 1) m))(setf (sv-bool sv-MATCH ) (let ((sv-pos1 (sv-undef))) (setf sv-pos1 (sv-to sv-MATCH ))(sv-or (progn (sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-exp sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (mp-Main::sv-hash-lookup "exp" sv-MATCH) sv-m2)1) (progn nil))) (let ((sv-pos1 (sv-undef))) (setf sv-pos1 (sv-to sv-MATCH ))(sv-or (progn (sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-opt_ws sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn nil))) (sv-and (if (sv-bool (sv-eq "," (sv-substr sv-str (sv-to sv-MATCH ) 1))) (sv-add 1 (setf (sv-to sv-MATCH ) (sv-add 1 (sv-to sv-MATCH )))) nil) (sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-opt_ws sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn nil))) (sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-exp_seq sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (mp-Main::sv-hash-lookup "exp_seq" sv-MATCH) sv-m2)1) (progn nil))) (sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-opt_ws sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn nil))) (sv-and (let ((sv-pos1 (sv-undef))) (setf sv-pos1 (sv-to sv-MATCH ))(sv-or (progn (sv-and (if (sv-bool (sv-eq "," (sv-substr sv-str (sv-to sv-MATCH ) 1))) (sv-add 1 (setf (sv-to sv-MATCH ) (sv-add 1 (sv-to sv-MATCH )))) nil) (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-opt_ws sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn nil))))) (progn (setf (sv-to sv-MATCH ) sv-pos1)1))) (sv-or (progn (setf (sv-capture sv-MATCH) (let ((_tmp_ (concatenate 'list  (list (sv-scalar (mp-Main::sv-hash-lookup "exp" sv-MATCH))) (coerce (sv-scalar (mp-Main::sv-hash-lookup "exp_seq" sv-MATCH)) 'list)))) (make-array (length _tmp_) :adjustable 1 :fill-pointer t :initial-contents _tmp_)))) 1)))))))) (progn (setf (sv-to sv-MATCH ) sv-pos1)(sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-opt_ws sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn nil))) (sv-and (let ((sv-pos1 (sv-undef))) (setf sv-pos1 (sv-to sv-MATCH ))(sv-or (progn (sv-and (if (sv-bool (sv-eq "," (sv-substr sv-str (sv-to sv-MATCH ) 1))) (sv-add 1 (setf (sv-to sv-MATCH ) (sv-add 1 (sv-to sv-MATCH )))) nil) (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-opt_ws sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn nil))))) (progn (setf (sv-to sv-MATCH ) sv-pos1)1))) (sv-or (progn (setf (sv-capture sv-MATCH) (let ((_tmp_ (concatenate 'list  (list (sv-scalar (mp-Main::sv-hash-lookup "exp" sv-MATCH)))))) (make-array (length _tmp_) :adjustable 1 :fill-pointer t :initial-contents _tmp_)))) 1)))))))) (progn (setf (sv-to sv-MATCH ) sv-pos1)(sv-or (progn (setf (sv-capture sv-MATCH) (make-array 0 :adjustable 1 :fill-pointer t))) 1)))))sv-MATCH)))

;; method lit
(defmethod sv-lit ((sv-grammar mp-MiniPerl6-Grammar) &optional sv-str sv-pos)
  (block mp6-function
    (let ((sv-MATCH (sv-undef))) (setf sv-MATCH (let ((m (make-instance 'mp-MiniPerl6-Match))) (setf (sv-str m) sv-str)(setf (sv-from m) sv-pos)(setf (sv-to m) sv-pos)(setf (sv-bool m) 1) m))(setf (sv-bool sv-MATCH ) (let ((sv-pos1 (sv-undef))) (setf sv-pos1 (sv-to sv-MATCH ))(progn (sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-lit_object sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (mp-Main::sv-hash-lookup "lit_object" sv-MATCH) sv-m2)1) (progn nil))) (sv-or (progn (setf (sv-capture sv-MATCH) (sv-scalar (mp-Main::sv-hash-lookup "lit_object" sv-MATCH)))) 1)))))sv-MATCH)))

;; method lit_object
(defmethod sv-lit_object ((sv-grammar mp-MiniPerl6-Grammar) &optional sv-str sv-pos)
  (block mp6-function
    (let ((sv-MATCH (sv-undef))) (setf sv-MATCH (let ((m (make-instance 'mp-MiniPerl6-Match))) (setf (sv-str m) sv-str)(setf (sv-from m) sv-pos)(setf (sv-to m) sv-pos)(setf (sv-bool m) 1) m))(setf (sv-bool sv-MATCH ) (let ((sv-pos1 (sv-undef))) (setf sv-pos1 (sv-to sv-MATCH ))(progn (sv-and (if (sv-bool (sv-eq "::" (sv-substr sv-str (sv-to sv-MATCH ) 2))) (sv-add 1 (setf (sv-to sv-MATCH ) (sv-add 2 (sv-to sv-MATCH )))) nil) (sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-full_ident sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (mp-Main::sv-hash-lookup "full_ident" sv-MATCH) sv-m2)1) (progn nil))) (sv-and (if (sv-bool (sv-eq "(" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (sv-add 1 (setf (sv-to sv-MATCH ) (sv-add 1 (sv-to sv-MATCH )))) nil) (let ((sv-pos1 (sv-undef))) (setf sv-pos1 (sv-to sv-MATCH ))(sv-or (progn (sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-opt_ws sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn nil))) (sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-exp_mapping sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (mp-Main::sv-hash-lookup "exp_mapping" sv-MATCH) sv-m2)1) (progn nil))) (sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-opt_ws sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn nil))) (sv-and (if (sv-bool (sv-eq ")" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (sv-add 1 (setf (sv-to sv-MATCH ) (sv-add 1 (sv-to sv-MATCH )))) nil) (sv-or (progn (setf (sv-capture sv-MATCH) (let ((m (make-instance 'mp-Lit-Object))) (setf (sv-class m) (sv-scalar (mp-Main::sv-hash-lookup "full_ident" sv-MATCH)))(setf (sv-fields m) (sv-scalar (mp-Main::sv-hash-lookup "exp_mapping" sv-MATCH))) m))) 1)))))) (progn (setf (sv-to sv-MATCH ) sv-pos1)(sv-or (progn (mp-Main::sv-say (list "*** Syntax Error parsing Constructor"))(progn (write-line (format nil "~{~a~}" (list )) *error-output*) (sb-ext:quit))) 1))))))))))sv-MATCH)))

;; method bind
(defmethod sv-bind ((sv-grammar mp-MiniPerl6-Grammar) &optional sv-str sv-pos)
  (block mp6-function
    (let ((sv-MATCH (sv-undef))) (setf sv-MATCH (let ((m (make-instance 'mp-MiniPerl6-Match))) (setf (sv-str m) sv-str)(setf (sv-from m) sv-pos)(setf (sv-to m) sv-pos)(setf (sv-bool m) 1) m))(setf (sv-bool sv-MATCH ) (let ((sv-pos1 (sv-undef))) (setf sv-pos1 (sv-to sv-MATCH ))(progn (sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-exp sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (mp-Main::sv-hash-lookup "exp" sv-MATCH) sv-m2)1) (progn nil))) (sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-opt_ws sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn nil))) (sv-and (if (sv-bool (sv-eq ":=" (sv-substr sv-str (sv-to sv-MATCH ) 2))) (sv-add 1 (setf (sv-to sv-MATCH ) (sv-add 2 (sv-to sv-MATCH )))) nil) (sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-opt_ws sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn nil))) (sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-exp2 sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (mp-Main::sv-hash-lookup "exp2" sv-MATCH) sv-m2)1) (progn nil))) (sv-or (progn (setf (sv-capture sv-MATCH) (let ((m (make-instance 'mp-Bind))) (setf (sv-parameters m) (sv-scalar (mp-Main::sv-hash-lookup "exp" sv-MATCH)))(setf (sv-arguments m) (sv-scalar (mp-Main::sv-hash-lookup "exp2" sv-MATCH))) m))) 1)))))))))sv-MATCH)))

;; method call
(defmethod sv-call ((sv-grammar mp-MiniPerl6-Grammar) &optional sv-str sv-pos)
  (block mp6-function
    (let ((sv-MATCH (sv-undef))) (setf sv-MATCH (let ((m (make-instance 'mp-MiniPerl6-Match))) (setf (sv-str m) sv-str)(setf (sv-from m) sv-pos)(setf (sv-to m) sv-pos)(setf (sv-bool m) 1) m))(setf (sv-bool sv-MATCH ) (let ((sv-pos1 (sv-undef))) (setf sv-pos1 (sv-to sv-MATCH ))(progn (sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-exp sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (mp-Main::sv-hash-lookup "exp" sv-MATCH) sv-m2)1) (progn nil))) (sv-and (if (sv-bool (sv-eq "." (sv-substr sv-str (sv-to sv-MATCH ) 1))) (sv-add 1 (setf (sv-to sv-MATCH ) (sv-add 1 (sv-to sv-MATCH )))) nil) (sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-ident sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (mp-Main::sv-hash-lookup "ident" sv-MATCH) sv-m2)1) (progn nil))) (sv-and (if (sv-bool (sv-eq "(" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (sv-add 1 (setf (sv-to sv-MATCH ) (sv-add 1 (sv-to sv-MATCH )))) nil) (sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-opt_ws sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn nil))) (sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-exp_seq sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (mp-Main::sv-hash-lookup "exp_seq" sv-MATCH) sv-m2)1) (progn nil))) (sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-opt_ws sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn nil))) (sv-and (if (sv-bool (sv-eq ")" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (sv-add 1 (setf (sv-to sv-MATCH ) (sv-add 1 (sv-to sv-MATCH )))) nil) (sv-or (progn (setf (sv-capture sv-MATCH) (let ((m (make-instance 'mp-Call))) (setf (sv-invocant m) (sv-scalar (mp-Main::sv-hash-lookup "exp" sv-MATCH)))(setf (sv-method m) (sv-scalar (mp-Main::sv-hash-lookup "ident" sv-MATCH)))(setf (sv-arguments m) (sv-scalar (mp-Main::sv-hash-lookup "exp_seq" sv-MATCH)))(setf (sv-hyper m) "") m))) 1))))))))))))sv-MATCH)))

;; method apply
(defmethod sv-apply ((sv-grammar mp-MiniPerl6-Grammar) &optional sv-str sv-pos)
  (block mp6-function
    (let ((sv-MATCH (sv-undef))) (setf sv-MATCH (let ((m (make-instance 'mp-MiniPerl6-Match))) (setf (sv-str m) sv-str)(setf (sv-from m) sv-pos)(setf (sv-to m) sv-pos)(setf (sv-bool m) 1) m))(setf (sv-bool sv-MATCH ) (let ((sv-pos1 (sv-undef))) (setf sv-pos1 (sv-to sv-MATCH ))(progn (sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-optional_namespace_before_ident sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (mp-Main::sv-hash-lookup "optional_namespace_before_ident" sv-MATCH) sv-m2)1) (progn nil))) (sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-full_ident sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (mp-Main::sv-hash-lookup "full_ident" sv-MATCH) sv-m2)1) (progn nil))) (let ((sv-pos1 (sv-undef))) (setf sv-pos1 (sv-to sv-MATCH ))(sv-or (progn (sv-and (let ((sv-pos1 (sv-undef))) (setf sv-pos1 (sv-to sv-MATCH ))(sv-or (progn (sv-and (if (sv-bool (sv-eq "(" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (sv-add 1 (setf (sv-to sv-MATCH ) (sv-add 1 (sv-to sv-MATCH )))) nil) (sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-opt_ws sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn nil))) (sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-exp_seq sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (mp-Main::sv-hash-lookup "exp_seq" sv-MATCH) sv-m2)1) (progn nil))) (sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-opt_ws sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn nil))) (if (sv-bool (sv-eq ")" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (sv-add 1 (setf (sv-to sv-MATCH ) (sv-add 1 (sv-to sv-MATCH )))) nil)))))) (progn (setf (sv-to sv-MATCH ) sv-pos1)(sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-ws sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn nil))) (sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-exp_seq sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (mp-Main::sv-hash-lookup "exp_seq" sv-MATCH) sv-m2)1) (progn nil))) (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-opt_ws sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn nil)))))))) (sv-or (progn (setf (sv-capture sv-MATCH) (let ((m (make-instance 'mp-Apply))) (setf (sv-namespace m) (sv-scalar (mp-Main::sv-hash-lookup "optional_namespace_before_ident" sv-MATCH)))(setf (sv-code m) (sv-scalar (mp-Main::sv-hash-lookup "full_ident" sv-MATCH)))(setf (sv-arguments m) (sv-scalar (mp-Main::sv-hash-lookup "exp_seq" sv-MATCH))) m))) 1))) (progn (setf (sv-to sv-MATCH ) sv-pos1)(sv-or (progn (setf (sv-capture sv-MATCH) (let ((m (make-instance 'mp-Apply))) (setf (sv-namespace m) (sv-scalar (mp-Main::sv-hash-lookup "optional_namespace_before_ident" sv-MATCH)))(setf (sv-code m) (sv-scalar (mp-Main::sv-hash-lookup "full_ident" sv-MATCH)))(setf (sv-arguments m) (make-array 0 :adjustable 1 :fill-pointer t)) m))) 1)))))))))sv-MATCH)))

;; method opt_name
(defmethod sv-opt_name ((sv-grammar mp-MiniPerl6-Grammar) &optional sv-str sv-pos)
  (block mp6-function
    (let ((sv-MATCH (sv-undef))) (setf sv-MATCH (let ((m (make-instance 'mp-MiniPerl6-Match))) (setf (sv-str m) sv-str)(setf (sv-from m) sv-pos)(setf (sv-to m) sv-pos)(setf (sv-bool m) 1) m))(setf (sv-bool sv-MATCH ) (let ((sv-pos1 (sv-undef))) (setf sv-pos1 (sv-to sv-MATCH ))(progn (let ((sv-last_pos (sv-undef))) (setf sv-last_pos (sv-to sv-MATCH ))(if (sv-bool (not (sv-bool (progn (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-ident sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(if (sv-bool (nth-value 1 (mp-Main::sv-hash-lookup "ident" sv-MATCH))) (progn (sv-push (mp-Main::sv-hash-lookup "ident" sv-MATCH) sv-m2)) (progn (setf (mp-Main::sv-hash-lookup "ident" sv-MATCH) (let ((_tmp_ (concatenate 'list  (list sv-m2)))) (make-array (length _tmp_) :adjustable 1 :fill-pointer t :initial-contents _tmp_)))))1) (progn nil))))))) (progn (setf (sv-to sv-MATCH ) sv-last_pos)) nil)1))))sv-MATCH)))

;; method var_invocant
(defmethod sv-var_invocant ((sv-grammar mp-MiniPerl6-Grammar) &optional sv-str sv-pos)
  (block mp6-function
    (let ((sv-MATCH (sv-undef))) (setf sv-MATCH (let ((m (make-instance 'mp-MiniPerl6-Match))) (setf (sv-str m) sv-str)(setf (sv-from m) sv-pos)(setf (sv-to m) sv-pos)(setf (sv-bool m) 1) m))(setf (sv-bool sv-MATCH ) (let ((sv-pos1 (sv-undef))) (setf sv-pos1 (sv-to sv-MATCH ))(sv-or (progn (sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-var_ident sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (mp-Main::sv-hash-lookup "var_ident" sv-MATCH) sv-m2)1) (progn nil))) (sv-and (if (sv-bool (sv-eq ":" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (sv-add 1 (setf (sv-to sv-MATCH ) (sv-add 1 (sv-to sv-MATCH )))) nil) (sv-or (progn (setf (sv-capture sv-MATCH) (sv-scalar (mp-Main::sv-hash-lookup "var_ident" sv-MATCH)))) 1)))) (progn (setf (sv-to sv-MATCH ) sv-pos1)(sv-or (progn (setf (sv-capture sv-MATCH) (let ((m (make-instance 'mp-Var))) (setf (sv-sigil m) "$")(setf (sv-twigil m) "")(setf (sv-name m) "self") m))) 1)))))sv-MATCH)))

;; method args_sig
(defmethod sv-args_sig ((sv-grammar mp-MiniPerl6-Grammar) &optional sv-str sv-pos)
  (block mp6-function
    (let ((sv-MATCH (sv-undef))) (setf sv-MATCH (let ((m (make-instance 'mp-MiniPerl6-Match))) (setf (sv-str m) sv-str)(setf (sv-from m) sv-pos)(setf (sv-to m) sv-pos)(setf (sv-bool m) 1) m))(setf (sv-bool sv-MATCH ) (let ((sv-pos1 (sv-undef))) (setf sv-pos1 (sv-to sv-MATCH ))(progn (sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-var_invocant sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (mp-Main::sv-hash-lookup "var_invocant" sv-MATCH) sv-m2)1) (progn nil))) (sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-opt_ws sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn nil))) (sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-exp_seq sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (mp-Main::sv-hash-lookup "exp_seq" sv-MATCH) sv-m2)1) (progn nil))) (sv-or (progn (setf (sv-capture sv-MATCH) (let ((m (make-instance 'mp-Sig))) (setf (sv-invocant m) (sv-scalar (mp-Main::sv-hash-lookup "var_invocant" sv-MATCH)))(setf (sv-positional m) (sv-scalar (mp-Main::sv-hash-lookup "exp_seq" sv-MATCH)))(setf (sv-named m) (make-hash-table :test 'equal)) m))) 1)))))))sv-MATCH)))

;; method method_sig
(defmethod sv-method_sig ((sv-grammar mp-MiniPerl6-Grammar) &optional sv-str sv-pos)
  (block mp6-function
    (let ((sv-MATCH (sv-undef))) (setf sv-MATCH (let ((m (make-instance 'mp-MiniPerl6-Match))) (setf (sv-str m) sv-str)(setf (sv-from m) sv-pos)(setf (sv-to m) sv-pos)(setf (sv-bool m) 1) m))(setf (sv-bool sv-MATCH ) (let ((sv-pos1 (sv-undef))) (setf sv-pos1 (sv-to sv-MATCH ))(sv-or (progn (sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-opt_ws sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn nil))) (sv-and (if (sv-bool (sv-eq "(" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (sv-add 1 (setf (sv-to sv-MATCH ) (sv-add 1 (sv-to sv-MATCH )))) nil) (sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-opt_ws sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn nil))) (sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-args_sig sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (mp-Main::sv-hash-lookup "args_sig" sv-MATCH) sv-m2)1) (progn nil))) (sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-opt_ws sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn nil))) (sv-and (if (sv-bool (sv-eq ")" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (sv-add 1 (setf (sv-to sv-MATCH ) (sv-add 1 (sv-to sv-MATCH )))) nil) (sv-or (progn (setf (sv-capture sv-MATCH) (sv-scalar (mp-Main::sv-hash-lookup "args_sig" sv-MATCH)))) 1)))))))) (progn (setf (sv-to sv-MATCH ) sv-pos1)(sv-or (progn (setf (sv-capture sv-MATCH) (let ((m (make-instance 'mp-Sig))) (setf (sv-invocant m) (let ((m (make-instance 'mp-Var))) (setf (sv-sigil m) "$")(setf (sv-twigil m) "")(setf (sv-name m) "self") m))(setf (sv-positional m) (make-array 0 :adjustable 1 :fill-pointer t))(setf (sv-named m) (make-hash-table :test 'equal)) m))) 1)))))sv-MATCH)))

;; method method_def
(defmethod sv-method_def ((sv-grammar mp-MiniPerl6-Grammar) &optional sv-str sv-pos)
  (block mp6-function
    (let ((sv-MATCH (sv-undef))) (setf sv-MATCH (let ((m (make-instance 'mp-MiniPerl6-Match))) (setf (sv-str m) sv-str)(setf (sv-from m) sv-pos)(setf (sv-to m) sv-pos)(setf (sv-bool m) 1) m))(setf (sv-bool sv-MATCH ) (let ((sv-pos1 (sv-undef))) (setf sv-pos1 (sv-to sv-MATCH ))(progn (sv-and (if (sv-bool (sv-eq "m" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (sv-add 1 (setf (sv-to sv-MATCH ) (sv-add 1 (sv-to sv-MATCH )))) nil) (sv-and (if (sv-bool (sv-eq "e" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (sv-add 1 (setf (sv-to sv-MATCH ) (sv-add 1 (sv-to sv-MATCH )))) nil) (sv-and (if (sv-bool (sv-eq "t" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (sv-add 1 (setf (sv-to sv-MATCH ) (sv-add 1 (sv-to sv-MATCH )))) nil) (sv-and (if (sv-bool (sv-eq "h" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (sv-add 1 (setf (sv-to sv-MATCH ) (sv-add 1 (sv-to sv-MATCH )))) nil) (sv-and (if (sv-bool (sv-eq "o" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (sv-add 1 (setf (sv-to sv-MATCH ) (sv-add 1 (sv-to sv-MATCH )))) nil) (sv-and (if (sv-bool (sv-eq "d" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (sv-add 1 (setf (sv-to sv-MATCH ) (sv-add 1 (sv-to sv-MATCH )))) nil) (sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-ws sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn nil))) (sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-opt_name sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (mp-Main::sv-hash-lookup "opt_name" sv-MATCH) sv-m2)1) (progn nil))) (sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-opt_ws sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn nil))) (sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-method_sig sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (mp-Main::sv-hash-lookup "method_sig" sv-MATCH) sv-m2)1) (progn nil))) (sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-opt_ws sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn nil))) (sv-and (if (sv-bool (sv-eq "{" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (sv-add 1 (setf (sv-to sv-MATCH ) (sv-add 1 (sv-to sv-MATCH )))) nil) (sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-opt_ws sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn nil))) (sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-exp_stmts sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (mp-Main::sv-hash-lookup "exp_stmts" sv-MATCH) sv-m2)1) (progn nil))) (sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-opt_ws sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn nil))) (sv-and (let ((sv-pos1 (sv-undef))) (setf sv-pos1 (sv-to sv-MATCH ))(sv-or (progn (if (sv-bool (sv-eq "}" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (sv-add 1 (setf (sv-to sv-MATCH ) (sv-add 1 (sv-to sv-MATCH )))) nil)) (progn (setf (sv-to sv-MATCH ) sv-pos1)(sv-or (progn (mp-Main::sv-say (list "*** Syntax Error in method '" (sv-get_class_name ) "." (sv-scalar (mp-Main::sv-hash-lookup "name" sv-MATCH)) "' near pos=" (sv-to sv-MATCH )))(progn (write-line (format nil "~{~a~}" (list "error in Block")) *error-output*) (sb-ext:quit))) 1)))) (sv-or (progn (setf (sv-capture sv-MATCH) (let ((m (make-instance 'mp-Method))) (setf (sv-name m) (sv-scalar (mp-Main::sv-hash-lookup "opt_name" sv-MATCH)))(setf (sv-sig m) (sv-scalar (mp-Main::sv-hash-lookup "method_sig" sv-MATCH)))(setf (sv-block m) (sv-scalar (mp-Main::sv-hash-lookup "exp_stmts" sv-MATCH))) m))) 1))))))))))))))))))))sv-MATCH)))

;; method sub_def
(defmethod sv-sub_def ((sv-grammar mp-MiniPerl6-Grammar) &optional sv-str sv-pos)
  (block mp6-function
    (let ((sv-MATCH (sv-undef))) (setf sv-MATCH (let ((m (make-instance 'mp-MiniPerl6-Match))) (setf (sv-str m) sv-str)(setf (sv-from m) sv-pos)(setf (sv-to m) sv-pos)(setf (sv-bool m) 1) m))(setf (sv-bool sv-MATCH ) (let ((sv-pos1 (sv-undef))) (setf sv-pos1 (sv-to sv-MATCH ))(progn (sv-and (if (sv-bool (sv-eq "s" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (sv-add 1 (setf (sv-to sv-MATCH ) (sv-add 1 (sv-to sv-MATCH )))) nil) (sv-and (if (sv-bool (sv-eq "u" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (sv-add 1 (setf (sv-to sv-MATCH ) (sv-add 1 (sv-to sv-MATCH )))) nil) (sv-and (if (sv-bool (sv-eq "b" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (sv-add 1 (setf (sv-to sv-MATCH ) (sv-add 1 (sv-to sv-MATCH )))) nil) (sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-ws sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn nil))) (sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-opt_name sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (mp-Main::sv-hash-lookup "opt_name" sv-MATCH) sv-m2)1) (progn nil))) (sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-opt_ws sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn nil))) (sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-method_sig sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (mp-Main::sv-hash-lookup "method_sig" sv-MATCH) sv-m2)1) (progn nil))) (sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-opt_ws sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn nil))) (sv-and (if (sv-bool (sv-eq "{" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (sv-add 1 (setf (sv-to sv-MATCH ) (sv-add 1 (sv-to sv-MATCH )))) nil) (sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-opt_ws sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn nil))) (sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-exp_stmts sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (mp-Main::sv-hash-lookup "exp_stmts" sv-MATCH) sv-m2)1) (progn nil))) (sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-opt_ws sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn nil))) (sv-and (let ((sv-pos1 (sv-undef))) (setf sv-pos1 (sv-to sv-MATCH ))(sv-or (progn (if (sv-bool (sv-eq "}" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (sv-add 1 (setf (sv-to sv-MATCH ) (sv-add 1 (sv-to sv-MATCH )))) nil)) (progn (setf (sv-to sv-MATCH ) sv-pos1)(sv-or (progn (mp-Main::sv-say (list "*** Syntax Error in sub '" (sv-scalar (mp-Main::sv-hash-lookup "name" sv-MATCH)) "'"))(progn (write-line (format nil "~{~a~}" (list "error in Block")) *error-output*) (sb-ext:quit))) 1)))) (sv-or (progn (setf (sv-capture sv-MATCH) (let ((m (make-instance 'mp-Sub))) (setf (sv-name m) (sv-scalar (mp-Main::sv-hash-lookup "opt_name" sv-MATCH)))(setf (sv-sig m) (sv-scalar (mp-Main::sv-hash-lookup "method_sig" sv-MATCH)))(setf (sv-block m) (sv-scalar (mp-Main::sv-hash-lookup "exp_stmts" sv-MATCH))) m))) 1)))))))))))))))))sv-MATCH)))

;; method token
(defmethod sv-token ((sv-grammar mp-MiniPerl6-Grammar) &optional sv-str sv-pos)
  (block mp6-function
    (let ((sv-MATCH (sv-undef))) (setf sv-MATCH (let ((m (make-instance 'mp-MiniPerl6-Match))) (setf (sv-str m) sv-str)(setf (sv-from m) sv-pos)(setf (sv-to m) sv-pos)(setf (sv-bool m) 1) m))(setf (sv-bool sv-MATCH ) (let ((sv-pos1 (sv-undef))) (setf sv-pos1 (sv-to sv-MATCH ))(progn (sv-and (if (sv-bool (sv-eq "t" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (sv-add 1 (setf (sv-to sv-MATCH ) (sv-add 1 (sv-to sv-MATCH )))) nil) (sv-and (if (sv-bool (sv-eq "o" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (sv-add 1 (setf (sv-to sv-MATCH ) (sv-add 1 (sv-to sv-MATCH )))) nil) (sv-and (if (sv-bool (sv-eq "k" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (sv-add 1 (setf (sv-to sv-MATCH ) (sv-add 1 (sv-to sv-MATCH )))) nil) (sv-and (if (sv-bool (sv-eq "e" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (sv-add 1 (setf (sv-to sv-MATCH ) (sv-add 1 (sv-to sv-MATCH )))) nil) (sv-and (if (sv-bool (sv-eq "n" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (sv-add 1 (setf (sv-to sv-MATCH ) (sv-add 1 (sv-to sv-MATCH )))) nil) (sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-ws sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn nil))) (sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-opt_name sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (mp-Main::sv-hash-lookup "opt_name" sv-MATCH) sv-m2)1) (progn nil))) (sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-opt_ws sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn nil))) (sv-and (if (sv-bool (sv-eq "{" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (sv-add 1 (setf (sv-to sv-MATCH ) (sv-add 1 (sv-to sv-MATCH )))) nil) (sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-rule (proto-mp-MiniPerl6-Grammar-Regex) sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (mp-Main::sv-hash-lookup "MiniPerl6::Grammar::Regex.rule" sv-MATCH) sv-m2)1) (progn nil))) (sv-and (if (sv-bool (sv-eq "}" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (sv-add 1 (setf (sv-to sv-MATCH ) (sv-add 1 (sv-to sv-MATCH )))) nil) (sv-or (let ((sv-source (sv-undef))(sv-ast (sv-undef))) (setf sv-source (concatenate 'string (sv-string "method ") (sv-string (concatenate 'string (sv-string (mp-Main::sv-hash-lookup "opt_name" sv-MATCH)) (sv-string (concatenate 'string (sv-string " ( $grammar: $str, $pos ) { ") (sv-string (concatenate 'string (sv-string "my $MATCH; $MATCH := MiniPerl6::Match.new( 'str' => $str, 'from' => $pos, 'to' => $pos, 'bool' => 1 ); ") (sv-string (concatenate 'string (sv-string "$MATCH.bool := ( ") (sv-string (concatenate 'string (sv-string (sv-emit (sv-scalar (mp-Main::sv-hash-lookup "MiniPerl6::Grammar::Regex.rule" sv-MATCH)) )) (sv-string (concatenate 'string (sv-string "); ") (sv-string "$MATCH }")))))))))))))))(setf sv-ast (sv-exp_term (proto-mp-MiniPerl6-Grammar) sv-source 0))(setf (sv-capture sv-MATCH) (sv-scalar sv-ast))) 1)))))))))))))))sv-MATCH)))

(defmethod sv-perl ((self mp-MiniPerl6-Grammar))
  (mp-Main::sv-lisp_dump_object "MiniPerl6::Grammar" (list )))

(defun run-mp-MiniPerl6-Grammar ()

;; use mp-MiniPerl6-Grammar-Regex


;; use mp-MiniPerl6-Grammar-Mapping


;; use mp-MiniPerl6-Grammar-Control

)
)


(run-mp-MiniPerl6-Grammar)
