;; Do not edit this file - Generated by MiniPerl6 3.0
;; class EvalFunction
(defpackage mp-EvalFunction
  (:use common-lisp mp-Main))
;; (in-package mp-EvalFunction)
(if (not (ignore-errors (find-class 'mp-EvalFunction)))
  (defclass mp-EvalFunction () ()))

(let (x) 
  (setq x (make-instance 'mp-EvalFunction))
  (defun proto-mp-EvalFunction () x))
;; has $.func
(let ((new-slots (list (list :name 'sv-func
  :readers '(sv-func)
  :writers '((setf sv-func))
  :initform '(sv-undef)
  :initfunction (constantly (sv-undef))))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-EvalFunction)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-EvalFunction :direct-slots new-slots))

;; method apply
(if (not (ignore-errors (find-method 'sv-apply () ())))
  (defgeneric sv-apply (sv-self &optional sv-env sv-args)
      (:documentation "a method")))
(defmethod sv-apply ((sv-self mp-EvalFunction) &optional sv-env sv-args)
  (block mp6-function
    (progn ((sv-func sv-self) sv-env sv-args))))

(defmethod sv-perl ((self mp-EvalFunction))
  (mp-Main::sv-lisp_dump_object "::EvalFunction" (list (let ((m (make-instance 'mp-Pair))) (setf (sv-key m) "func") (setf (sv-value m) (sv-func self)) m) )))




;; class CompUnit
(defpackage mp-CompUnit
  (:use common-lisp mp-Main))
;; (in-package mp-CompUnit)
(if (not (ignore-errors (find-class 'mp-CompUnit)))
  (defclass mp-CompUnit () ()))

(let (x) 
  (setq x (make-instance 'mp-CompUnit))
  (defun proto-mp-CompUnit () x))
;; has $.name
(let ((new-slots (list (list :name 'sv-name
  :readers '(sv-name)
  :writers '((setf sv-name))
  :initform '(sv-undef)
  :initfunction (constantly (sv-undef))))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-CompUnit)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-CompUnit :direct-slots new-slots))

;; has $.attributes
(let ((new-slots (list (list :name 'sv-attributes
  :readers '(sv-attributes)
  :writers '((setf sv-attributes))
  :initform '(sv-undef)
  :initfunction (constantly (sv-undef))))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-CompUnit)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-CompUnit :direct-slots new-slots))

;; has $.methods
(let ((new-slots (list (list :name 'sv-methods
  :readers '(sv-methods)
  :writers '((setf sv-methods))
  :initform '(sv-undef)
  :initfunction (constantly (sv-undef))))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-CompUnit)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-CompUnit :direct-slots new-slots))

;; has $.body
(let ((new-slots (list (list :name 'sv-body
  :readers '(sv-body)
  :writers '((setf sv-body))
  :initform '(sv-undef)
  :initfunction (constantly (sv-undef))))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-CompUnit)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-CompUnit :direct-slots new-slots))

;; method eval
(if (not (ignore-errors (find-method 'sv-eval () ())))
  (defgeneric sv-eval (sv-self &optional sv-env)
      (:documentation "a method")))
(defmethod sv-eval ((sv-self mp-CompUnit) &optional sv-env)
  (block mp6-function
    (let ((sv-env1 (sv-undef))) (setf sv-env1 (concatenate 'list  (list (make-hash-table :test 'equal)) sv-env))(dolist (sv-stmt (sv-body sv-self)) (progn (sv-eval sv-stmt sv-env1))))))

(defmethod sv-perl ((self mp-CompUnit))
  (mp-Main::sv-lisp_dump_object "::CompUnit" (list (let ((m (make-instance 'mp-Pair))) (setf (sv-key m) "name") (setf (sv-value m) (sv-name self)) m) (let ((m (make-instance 'mp-Pair))) (setf (sv-key m) "attributes") (setf (sv-value m) (sv-attributes self)) m) (let ((m (make-instance 'mp-Pair))) (setf (sv-key m) "methods") (setf (sv-value m) (sv-methods self)) m) (let ((m (make-instance 'mp-Pair))) (setf (sv-key m) "body") (setf (sv-value m) (sv-body self)) m) )))




;; class Val::Int
(defpackage mp-Val-Int
  (:use common-lisp mp-Main))
;; (in-package mp-Val-Int)
(if (not (ignore-errors (find-class 'mp-Val-Int)))
  (defclass mp-Val-Int () ()))

(let (x) 
  (setq x (make-instance 'mp-Val-Int))
  (defun proto-mp-Val-Int () x))
;; has $.int
(let ((new-slots (list (list :name 'sv-int
  :readers '(sv-int)
  :writers '((setf sv-int))
  :initform '(sv-undef)
  :initfunction (constantly (sv-undef))))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-Val-Int)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-Val-Int :direct-slots new-slots))

;; method eval
(if (not (ignore-errors (find-method 'sv-eval () ())))
  (defgeneric sv-eval (sv-self &optional sv-env)
      (:documentation "a method")))
(defmethod sv-eval ((sv-self mp-Val-Int) &optional sv-env)
  (block mp6-function
    (progn (sv-Int (sv-int sv-self)))))

(defmethod sv-perl ((self mp-Val-Int))
  (mp-Main::sv-lisp_dump_object "::Val::Int" (list (let ((m (make-instance 'mp-Pair))) (setf (sv-key m) "int") (setf (sv-value m) (sv-int self)) m) )))




;; class Val::Bit
(defpackage mp-Val-Bit
  (:use common-lisp mp-Main))
;; (in-package mp-Val-Bit)
(if (not (ignore-errors (find-class 'mp-Val-Bit)))
  (defclass mp-Val-Bit () ()))

(let (x) 
  (setq x (make-instance 'mp-Val-Bit))
  (defun proto-mp-Val-Bit () x))
;; has $.bit
(let ((new-slots (list (list :name 'sv-bit
  :readers '(sv-bit)
  :writers '((setf sv-bit))
  :initform '(sv-undef)
  :initfunction (constantly (sv-undef))))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-Val-Bit)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-Val-Bit :direct-slots new-slots))

;; method eval
(if (not (ignore-errors (find-method 'sv-eval () ())))
  (defgeneric sv-eval (sv-self &optional sv-env)
      (:documentation "a method")))
(defmethod sv-eval ((sv-self mp-Val-Bit) &optional sv-env)
  (block mp6-function
    (progn (sv-bit sv-self))))

(defmethod sv-perl ((self mp-Val-Bit))
  (mp-Main::sv-lisp_dump_object "::Val::Bit" (list (let ((m (make-instance 'mp-Pair))) (setf (sv-key m) "bit") (setf (sv-value m) (sv-bit self)) m) )))




;; class Val::Num
(defpackage mp-Val-Num
  (:use common-lisp mp-Main))
;; (in-package mp-Val-Num)
(if (not (ignore-errors (find-class 'mp-Val-Num)))
  (defclass mp-Val-Num () ()))

(let (x) 
  (setq x (make-instance 'mp-Val-Num))
  (defun proto-mp-Val-Num () x))
;; has $.num
(let ((new-slots (list (list :name 'sv-num
  :readers '(sv-num)
  :writers '((setf sv-num))
  :initform '(sv-undef)
  :initfunction (constantly (sv-undef))))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-Val-Num)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-Val-Num :direct-slots new-slots))

;; method eval
(if (not (ignore-errors (find-method 'sv-eval () ())))
  (defgeneric sv-eval (sv-self &optional sv-env)
      (:documentation "a method")))
(defmethod sv-eval ((sv-self mp-Val-Num) &optional sv-env)
  (block mp6-function
    (progn (sv-Num (sv-num sv-self)))))

(defmethod sv-perl ((self mp-Val-Num))
  (mp-Main::sv-lisp_dump_object "::Val::Num" (list (let ((m (make-instance 'mp-Pair))) (setf (sv-key m) "num") (setf (sv-value m) (sv-num self)) m) )))




;; class Val::Buf
(defpackage mp-Val-Buf
  (:use common-lisp mp-Main))
;; (in-package mp-Val-Buf)
(if (not (ignore-errors (find-class 'mp-Val-Buf)))
  (defclass mp-Val-Buf () ()))

(let (x) 
  (setq x (make-instance 'mp-Val-Buf))
  (defun proto-mp-Val-Buf () x))
;; has $.buf
(let ((new-slots (list (list :name 'sv-buf
  :readers '(sv-buf)
  :writers '((setf sv-buf))
  :initform '(sv-undef)
  :initfunction (constantly (sv-undef))))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-Val-Buf)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-Val-Buf :direct-slots new-slots))

;; method eval
(if (not (ignore-errors (find-method 'sv-eval () ())))
  (defgeneric sv-eval (sv-self &optional sv-env)
      (:documentation "a method")))
(defmethod sv-eval ((sv-self mp-Val-Buf) &optional sv-env)
  (block mp6-function
    (progn (sv-buf sv-self))))

(defmethod sv-perl ((self mp-Val-Buf))
  (mp-Main::sv-lisp_dump_object "::Val::Buf" (list (let ((m (make-instance 'mp-Pair))) (setf (sv-key m) "buf") (setf (sv-value m) (sv-buf self)) m) )))




;; class Val::Undef
(defpackage mp-Val-Undef
  (:use common-lisp mp-Main))
;; (in-package mp-Val-Undef)
(if (not (ignore-errors (find-class 'mp-Val-Undef)))
  (defclass mp-Val-Undef () ()))

(let (x) 
  (setq x (make-instance 'mp-Val-Undef))
  (defun proto-mp-Val-Undef () x))
;; method eval
(if (not (ignore-errors (find-method 'sv-eval () ())))
  (defgeneric sv-eval (sv-self &optional sv-env)
      (:documentation "a method")))
(defmethod sv-eval ((sv-self mp-Val-Undef) &optional sv-env)
  (block mp6-function
    (progn (sv-undef))))

(defmethod sv-perl ((self mp-Val-Undef))
  (mp-Main::sv-lisp_dump_object "::Val::Undef" (list )))




;; class Val::Object
(defpackage mp-Val-Object
  (:use common-lisp mp-Main))
;; (in-package mp-Val-Object)
(if (not (ignore-errors (find-class 'mp-Val-Object)))
  (defclass mp-Val-Object () ()))

(let (x) 
  (setq x (make-instance 'mp-Val-Object))
  (defun proto-mp-Val-Object () x))
;; has $.class
(let ((new-slots (list (list :name 'sv-class
  :readers '(sv-class)
  :writers '((setf sv-class))
  :initform '(sv-undef)
  :initfunction (constantly (sv-undef))))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-Val-Object)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-Val-Object :direct-slots new-slots))

;; has $.fields
(let ((new-slots (list (list :name 'sv-fields
  :readers '(sv-fields)
  :writers '((setf sv-fields))
  :initform '(sv-undef)
  :initfunction (constantly (sv-undef))))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-Val-Object)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-Val-Object :direct-slots new-slots))

;; method eval
(if (not (ignore-errors (find-method 'sv-eval () ())))
  (defgeneric sv-eval (sv-self &optional sv-env)
      (:documentation "a method")))
(defmethod sv-eval ((sv-self mp-Val-Object) &optional sv-env)
  (block mp6-function
    (progn (write-line (format nil "~{~a~}" (list "Interpreter TODO: Val::Object")) *error-output*)(concatenate 'string (sv-string "bless(") (sv-string (concatenate 'string (sv-string (sv-perl (sv-fields sv-self) )) (sv-string (concatenate 'string (sv-string ", ") (sv-string (concatenate 'string (sv-string (sv-perl (sv-class sv-self) )) (sv-string ")")))))))))))

(defmethod sv-perl ((self mp-Val-Object))
  (mp-Main::sv-lisp_dump_object "::Val::Object" (list (let ((m (make-instance 'mp-Pair))) (setf (sv-key m) "class") (setf (sv-value m) (sv-class self)) m) (let ((m (make-instance 'mp-Pair))) (setf (sv-key m) "fields") (setf (sv-value m) (sv-fields self)) m) )))




;; class Lit::Seq
(defpackage mp-Lit-Seq
  (:use common-lisp mp-Main))
;; (in-package mp-Lit-Seq)
(if (not (ignore-errors (find-class 'mp-Lit-Seq)))
  (defclass mp-Lit-Seq () ()))

(let (x) 
  (setq x (make-instance 'mp-Lit-Seq))
  (defun proto-mp-Lit-Seq () x))
;; has $.seq
(let ((new-slots (list (list :name 'sv-seq
  :readers '(sv-seq)
  :writers '((setf sv-seq))
  :initform '(sv-undef)
  :initfunction (constantly (sv-undef))))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-Lit-Seq)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-Lit-Seq :direct-slots new-slots))

;; method eval
(if (not (ignore-errors (find-method 'sv-eval () ())))
  (defgeneric sv-eval (sv-self &optional sv-env)
      (:documentation "a method")))
(defmethod sv-eval ((sv-self mp-Lit-Seq) &optional sv-env)
  (block mp6-function
    (progn (write-line (format nil "~{~a~}" (list "Interpreter TODO: Lit::Seq")) *error-output*))))

(defmethod sv-perl ((self mp-Lit-Seq))
  (mp-Main::sv-lisp_dump_object "::Lit::Seq" (list (let ((m (make-instance 'mp-Pair))) (setf (sv-key m) "seq") (setf (sv-value m) (sv-seq self)) m) )))




;; class Lit::Array
(defpackage mp-Lit-Array
  (:use common-lisp mp-Main))
;; (in-package mp-Lit-Array)
(if (not (ignore-errors (find-class 'mp-Lit-Array)))
  (defclass mp-Lit-Array () ()))

(let (x) 
  (setq x (make-instance 'mp-Lit-Array))
  (defun proto-mp-Lit-Array () x))
;; has $.array1
(let ((new-slots (list (list :name 'sv-array1
  :readers '(sv-array1)
  :writers '((setf sv-array1))
  :initform '(sv-undef)
  :initfunction (constantly (sv-undef))))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-Lit-Array)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-Lit-Array :direct-slots new-slots))

;; method eval
(if (not (ignore-errors (find-method 'sv-eval () ())))
  (defgeneric sv-eval (sv-self &optional sv-env)
      (:documentation "a method")))
(defmethod sv-eval ((sv-self mp-Lit-Array) &optional sv-env)
  (block mp6-function
    (let ((sv-a (sv-undef))) (dolist (sv-v (sv-array1 sv-self)) (progn (sv-push sv-a (sv-eval sv-v sv-env))))(return-from mp6-function sv-a))))

(defmethod sv-perl ((self mp-Lit-Array))
  (mp-Main::sv-lisp_dump_object "::Lit::Array" (list (let ((m (make-instance 'mp-Pair))) (setf (sv-key m) "array1") (setf (sv-value m) (sv-array1 self)) m) )))




;; class Lit::Hash
(defpackage mp-Lit-Hash
  (:use common-lisp mp-Main))
;; (in-package mp-Lit-Hash)
(if (not (ignore-errors (find-class 'mp-Lit-Hash)))
  (defclass mp-Lit-Hash () ()))

(let (x) 
  (setq x (make-instance 'mp-Lit-Hash))
  (defun proto-mp-Lit-Hash () x))
;; has $.hash1
(let ((new-slots (list (list :name 'sv-hash1
  :readers '(sv-hash1)
  :writers '((setf sv-hash1))
  :initform '(sv-undef)
  :initfunction (constantly (sv-undef))))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-Lit-Hash)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-Lit-Hash :direct-slots new-slots))

;; method eval
(if (not (ignore-errors (find-method 'sv-eval () ())))
  (defgeneric sv-eval (sv-self &optional sv-env)
      (:documentation "a method")))
(defmethod sv-eval ((sv-self mp-Lit-Hash) &optional sv-env)
  (block mp6-function
    (let ((sv-h (sv-undef))) (dolist (sv-field (sv-hash1 sv-self)) (progn (setf (gethash (sv-eval (elt sv-field 0) sv-env) sv-h) (sv-eval (elt sv-field 1) sv-env))))(return-from mp6-function sv-h))))

(defmethod sv-perl ((self mp-Lit-Hash))
  (mp-Main::sv-lisp_dump_object "::Lit::Hash" (list (let ((m (make-instance 'mp-Pair))) (setf (sv-key m) "hash1") (setf (sv-value m) (sv-hash1 self)) m) )))




;; class Lit::Object
(defpackage mp-Lit-Object
  (:use common-lisp mp-Main))
;; (in-package mp-Lit-Object)
(if (not (ignore-errors (find-class 'mp-Lit-Object)))
  (defclass mp-Lit-Object () ()))

(let (x) 
  (setq x (make-instance 'mp-Lit-Object))
  (defun proto-mp-Lit-Object () x))
;; has $.class
(let ((new-slots (list (list :name 'sv-class
  :readers '(sv-class)
  :writers '((setf sv-class))
  :initform '(sv-undef)
  :initfunction (constantly (sv-undef))))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-Lit-Object)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-Lit-Object :direct-slots new-slots))

;; has $.fields
(let ((new-slots (list (list :name 'sv-fields
  :readers '(sv-fields)
  :writers '((setf sv-fields))
  :initform '(sv-undef)
  :initfunction (constantly (sv-undef))))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-Lit-Object)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-Lit-Object :direct-slots new-slots))

;; method eval
(if (not (ignore-errors (find-method 'sv-eval () ())))
  (defgeneric sv-eval (sv-self &optional sv-env)
      (:documentation "a method")))
(defmethod sv-eval ((sv-self mp-Lit-Object) &optional sv-env)
  (block mp6-function
    (let ((sv-fields (sv-undef))(sv-str (sv-undef))) (write-line (format nil "~{~a~}" (list "Interpreter TODO: Lit::Object")) *error-output*)(setf sv-fields (sv-fields sv-self))(setf sv-str "")(dolist (sv-field sv-fields) (progn (setf sv-str (concatenate 'string (sv-string sv-str) (sv-string (concatenate 'string (sv-string (sv-eval (elt sv-field 0) )) (sv-string (concatenate 'string (sv-string " => ") (sv-string (concatenate 'string (sv-string (sv-eval (elt sv-field 1) )) (sv-string ",")))))))))))(concatenate 'string (sv-string (sv-class sv-self)) (sv-string (concatenate 'string (sv-string "->new( ") (sv-string (concatenate 'string (sv-string sv-str) (sv-string " )")))))))))

(defmethod sv-perl ((self mp-Lit-Object))
  (mp-Main::sv-lisp_dump_object "::Lit::Object" (list (let ((m (make-instance 'mp-Pair))) (setf (sv-key m) "class") (setf (sv-value m) (sv-class self)) m) (let ((m (make-instance 'mp-Pair))) (setf (sv-key m) "fields") (setf (sv-value m) (sv-fields self)) m) )))




;; class Index
(defpackage mp-Index
  (:use common-lisp mp-Main))
;; (in-package mp-Index)
(if (not (ignore-errors (find-class 'mp-Index)))
  (defclass mp-Index () ()))

(let (x) 
  (setq x (make-instance 'mp-Index))
  (defun proto-mp-Index () x))
;; has $.obj
(let ((new-slots (list (list :name 'sv-obj
  :readers '(sv-obj)
  :writers '((setf sv-obj))
  :initform '(sv-undef)
  :initfunction (constantly (sv-undef))))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-Index)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-Index :direct-slots new-slots))

;; has $.index_exp
(let ((new-slots (list (list :name 'sv-index_exp
  :readers '(sv-index_exp)
  :writers '((setf sv-index_exp))
  :initform '(sv-undef)
  :initfunction (constantly (sv-undef))))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-Index)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-Index :direct-slots new-slots))

;; method eval
(if (not (ignore-errors (find-method 'sv-eval () ())))
  (defgeneric sv-eval (sv-self &optional sv-env)
      (:documentation "a method")))
(defmethod sv-eval ((sv-self mp-Index) &optional sv-env)
  (block mp6-function
    (progn (elt (sv-eval (sv-obj sv-self) sv-env) (sv-eval (sv-index_exp sv-self) sv-env)))))

(defmethod sv-perl ((self mp-Index))
  (mp-Main::sv-lisp_dump_object "::Index" (list (let ((m (make-instance 'mp-Pair))) (setf (sv-key m) "obj") (setf (sv-value m) (sv-obj self)) m) (let ((m (make-instance 'mp-Pair))) (setf (sv-key m) "index_exp") (setf (sv-value m) (sv-index_exp self)) m) )))




;; class Lookup
(defpackage mp-Lookup
  (:use common-lisp mp-Main))
;; (in-package mp-Lookup)
(if (not (ignore-errors (find-class 'mp-Lookup)))
  (defclass mp-Lookup () ()))

(let (x) 
  (setq x (make-instance 'mp-Lookup))
  (defun proto-mp-Lookup () x))
;; has $.obj
(let ((new-slots (list (list :name 'sv-obj
  :readers '(sv-obj)
  :writers '((setf sv-obj))
  :initform '(sv-undef)
  :initfunction (constantly (sv-undef))))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-Lookup)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-Lookup :direct-slots new-slots))

;; has $.index_exp
(let ((new-slots (list (list :name 'sv-index_exp
  :readers '(sv-index_exp)
  :writers '((setf sv-index_exp))
  :initform '(sv-undef)
  :initfunction (constantly (sv-undef))))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-Lookup)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-Lookup :direct-slots new-slots))

;; method eval
(if (not (ignore-errors (find-method 'sv-eval () ())))
  (defgeneric sv-eval (sv-self &optional sv-env)
      (:documentation "a method")))
(defmethod sv-eval ((sv-self mp-Lookup) &optional sv-env)
  (block mp6-function
    (progn (gethash (sv-eval (sv-index_exp sv-self) sv-env) (sv-eval (sv-obj sv-self) sv-env)))))

(defmethod sv-perl ((self mp-Lookup))
  (mp-Main::sv-lisp_dump_object "::Lookup" (list (let ((m (make-instance 'mp-Pair))) (setf (sv-key m) "obj") (setf (sv-value m) (sv-obj self)) m) (let ((m (make-instance 'mp-Pair))) (setf (sv-key m) "index_exp") (setf (sv-value m) (sv-index_exp self)) m) )))




;; class Var
(defpackage mp-Var
  (:use common-lisp mp-Main))
;; (in-package mp-Var)
(if (not (ignore-errors (find-class 'mp-Var)))
  (defclass mp-Var () ()))

(let (x) 
  (setq x (make-instance 'mp-Var))
  (defun proto-mp-Var () x))
;; has $.sigil
(let ((new-slots (list (list :name 'sv-sigil
  :readers '(sv-sigil)
  :writers '((setf sv-sigil))
  :initform '(sv-undef)
  :initfunction (constantly (sv-undef))))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-Var)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-Var :direct-slots new-slots))

;; has $.twigil
(let ((new-slots (list (list :name 'sv-twigil
  :readers '(sv-twigil)
  :writers '((setf sv-twigil))
  :initform '(sv-undef)
  :initfunction (constantly (sv-undef))))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-Var)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-Var :direct-slots new-slots))

;; has $.namespace
(let ((new-slots (list (list :name 'sv-namespace
  :readers '(sv-namespace)
  :writers '((setf sv-namespace))
  :initform '(sv-undef)
  :initfunction (constantly (sv-undef))))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-Var)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-Var :direct-slots new-slots))

;; has $.name
(let ((new-slots (list (list :name 'sv-name
  :readers '(sv-name)
  :writers '((setf sv-name))
  :initform '(sv-undef)
  :initfunction (constantly (sv-undef))))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-Var)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-Var :direct-slots new-slots))

;; method eval
(if (not (ignore-errors (find-method 'sv-eval () ())))
  (defgeneric sv-eval (sv-self &optional sv-env)
      (:documentation "a method")))
(defmethod sv-eval ((sv-self mp-Var) &optional sv-env)
  (block mp6-function
    (let ((sv-ns (sv-undef))(sv-name (sv-undef))) (setf sv-ns "")(if (sv-bool (sv-namespace sv-self)) (progn (setf sv-ns (concatenate 'string (sv-string (sv-namespace sv-self)) (sv-string "::")))) (progn (if (sv-bool (sv-and (sv-eq (sv-sigil sv-self) "@") (sv-and (sv-eq (sv-twigil sv-self) "*") (sv-eq (sv-name sv-self) "ARGS")))) (progn (return-from mp6-function COMMON-LISP-USER::*posix-argv*)) nil)(if (sv-bool (sv-eq (sv-twigil sv-self) ".")) (progn (write-line (format nil "~{~a~}" (list (concatenate 'string (sv-string "Interpreter TODO: $.") (sv-string (sv-name sv-self))))) *error-output*)(return-from mp6-function (concatenate 'string (sv-string "$self->{") (sv-string (concatenate 'string (sv-string (sv-name sv-self)) (sv-string "}")))))) nil)(if (sv-bool (sv-eq (sv-name sv-self) "/")) (progn (write-line (format nil "~{~a~}" (list "Interpreter TODO: $/")) *error-output*)(return-from mp6-function (concatenate 'string (sv-string (sv-sigil sv-self)) (sv-string "MATCH")))) nil)))(setf sv-name (concatenate 'string (sv-string (sv-sigil sv-self)) (sv-string (concatenate 'string (sv-string sv-ns) (sv-string (sv-name sv-self))))))(dolist (sv-e sv-env) (progn (if (sv-bool (sv-exists (gethash sv-name sv-e))) (progn (return-from mp6-function (gethash sv-name sv-e))) nil)))(write-line (format nil "~{~a~}" (list "Interpreter runtime error: variable '" sv-name "' not found")) *error-output*))))

;; method plain_name
(if (not (ignore-errors (find-method 'sv-plain_name () ())))
  (defgeneric sv-plain_name (sv-self)
      (:documentation "a method")))
(defmethod sv-plain_name ((sv-self mp-Var))
  (block mp6-function
    (progn (if (sv-bool (sv-namespace sv-self)) (progn (return-from mp6-function (concatenate 'string (sv-string (sv-sigil sv-self)) (sv-string (concatenate 'string (sv-string (sv-namespace sv-self)) (sv-string (concatenate 'string (sv-string "::") (sv-string (sv-name sv-self))))))))) nil)(return-from mp6-function (concatenate 'string (sv-string (sv-sigil sv-self)) (sv-string (sv-name sv-self)))))))

(defmethod sv-perl ((self mp-Var))
  (mp-Main::sv-lisp_dump_object "::Var" (list (let ((m (make-instance 'mp-Pair))) (setf (sv-key m) "sigil") (setf (sv-value m) (sv-sigil self)) m) (let ((m (make-instance 'mp-Pair))) (setf (sv-key m) "twigil") (setf (sv-value m) (sv-twigil self)) m) (let ((m (make-instance 'mp-Pair))) (setf (sv-key m) "namespace") (setf (sv-value m) (sv-namespace self)) m) (let ((m (make-instance 'mp-Pair))) (setf (sv-key m) "name") (setf (sv-value m) (sv-name self)) m) )))




;; class Bind
(defpackage mp-Bind
  (:use common-lisp mp-Main))
;; (in-package mp-Bind)
(if (not (ignore-errors (find-class 'mp-Bind)))
  (defclass mp-Bind () ()))

(let (x) 
  (setq x (make-instance 'mp-Bind))
  (defun proto-mp-Bind () x))
;; has $.parameters
(let ((new-slots (list (list :name 'sv-parameters
  :readers '(sv-parameters)
  :writers '((setf sv-parameters))
  :initform '(sv-undef)
  :initfunction (constantly (sv-undef))))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-Bind)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-Bind :direct-slots new-slots))

;; has $.arguments
(let ((new-slots (list (list :name 'sv-arguments
  :readers '(sv-arguments)
  :writers '((setf sv-arguments))
  :initform '(sv-undef)
  :initfunction (constantly (sv-undef))))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-Bind)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-Bind :direct-slots new-slots))

;; method eval
(if (not (ignore-errors (find-method 'sv-eval () ())))
  (defgeneric sv-eval (sv-self &optional sv-env)
      (:documentation "a method")))
(defmethod sv-eval ((sv-self mp-Bind) &optional sv-env)
  (block mp6-function
    (let ((sv-name (sv-undef))(sv-value (sv-undef))) (if (sv-bool (typep (sv-parameters sv-self) 'mp-Lit-Array)) (progn (write-line (format nil "~{~a~}" (list "Interpreter TODO: Bind")) *error-output*)) nil)(if (sv-bool (typep (sv-parameters sv-self) 'mp-Lit-Hash)) (progn (write-line (format nil "~{~a~}" (list "Interpreter TODO: Bind")) *error-output*)) nil)(if (sv-bool (typep (sv-parameters sv-self) 'mp-Lit-Object)) (progn (write-line (format nil "~{~a~}" (list "Interpreter TODO: Bind")) *error-output*)) nil)(if (sv-bool (typep (sv-parameters sv-self) 'mp-Decl)) (progn (sv-eval (sv-parameters sv-self) sv-env)) nil)(setf sv-name (sv-plain_name (sv-parameters sv-self) ))(setf sv-value (sv-eval (sv-arguments sv-self) sv-env))(dolist (sv-e sv-env) (progn (if (sv-bool (sv-exists (gethash sv-name sv-e))) (progn (setf (gethash sv-name sv-e) sv-value)(return-from mp6-function sv-value)) nil)))(write-line (format nil "~{~a~}" (list (concatenate 'string (sv-string "Interpreter Bind: variable '") (sv-string (concatenate 'string (sv-string sv-name) (sv-string "' not found")))))) *error-output*))))

(defmethod sv-perl ((self mp-Bind))
  (mp-Main::sv-lisp_dump_object "::Bind" (list (let ((m (make-instance 'mp-Pair))) (setf (sv-key m) "parameters") (setf (sv-value m) (sv-parameters self)) m) (let ((m (make-instance 'mp-Pair))) (setf (sv-key m) "arguments") (setf (sv-value m) (sv-arguments self)) m) )))




;; class Proto
(defpackage mp-Proto
  (:use common-lisp mp-Main))
;; (in-package mp-Proto)
(if (not (ignore-errors (find-class 'mp-Proto)))
  (defclass mp-Proto () ()))

(let (x) 
  (setq x (make-instance 'mp-Proto))
  (defun proto-mp-Proto () x))
;; has $.name
(let ((new-slots (list (list :name 'sv-name
  :readers '(sv-name)
  :writers '((setf sv-name))
  :initform '(sv-undef)
  :initfunction (constantly (sv-undef))))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-Proto)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-Proto :direct-slots new-slots))

;; method eval
(if (not (ignore-errors (find-method 'sv-eval () ())))
  (defgeneric sv-eval (sv-self &optional sv-env)
      (:documentation "a method")))
(defmethod sv-eval ((sv-self mp-Proto) &optional sv-env)
  (block mp6-function
    (progn (sv-string (sv-name sv-self)))))

(defmethod sv-perl ((self mp-Proto))
  (mp-Main::sv-lisp_dump_object "::Proto" (list (let ((m (make-instance 'mp-Pair))) (setf (sv-key m) "name") (setf (sv-value m) (sv-name self)) m) )))




;; class Call
(defpackage mp-Call
  (:use common-lisp mp-Main))
;; (in-package mp-Call)
(if (not (ignore-errors (find-class 'mp-Call)))
  (defclass mp-Call () ()))

(let (x) 
  (setq x (make-instance 'mp-Call))
  (defun proto-mp-Call () x))
;; has $.invocant
(let ((new-slots (list (list :name 'sv-invocant
  :readers '(sv-invocant)
  :writers '((setf sv-invocant))
  :initform '(sv-undef)
  :initfunction (constantly (sv-undef))))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-Call)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-Call :direct-slots new-slots))

;; has $.hyper
(let ((new-slots (list (list :name 'sv-hyper
  :readers '(sv-hyper)
  :writers '((setf sv-hyper))
  :initform '(sv-undef)
  :initfunction (constantly (sv-undef))))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-Call)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-Call :direct-slots new-slots))

;; has $.method
(let ((new-slots (list (list :name 'sv-method
  :readers '(sv-method)
  :writers '((setf sv-method))
  :initform '(sv-undef)
  :initfunction (constantly (sv-undef))))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-Call)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-Call :direct-slots new-slots))

;; has $.arguments
(let ((new-slots (list (list :name 'sv-arguments
  :readers '(sv-arguments)
  :writers '((setf sv-arguments))
  :initform '(sv-undef)
  :initfunction (constantly (sv-undef))))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-Call)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-Call :direct-slots new-slots))

;; method eval
(if (not (ignore-errors (find-method 'sv-eval () ())))
  (defgeneric sv-eval (sv-self &optional sv-env)
      (:documentation "a method")))
(defmethod sv-eval ((sv-self mp-Call) &optional sv-env)
  (block mp6-function
    (let ((sv-invocant (sv-undef))) (write-line (format nil "~{~a~}" (list "Interpreter TODO: Call")) *error-output*)(setf sv-invocant (sv-eval (sv-invocant sv-self) sv-env))(if (sv-bool (sv-eq sv-invocant "self")) (progn (setf sv-invocant "$self")) nil)(if (sv-bool (sv-hyper sv-self)) nil nil)(write-line (format nil "~{~a~}" (list "Interpreter runtime error: method '" (sv-method sv-self) "()' not found")) *error-output*))))

(defmethod sv-perl ((self mp-Call))
  (mp-Main::sv-lisp_dump_object "::Call" (list (let ((m (make-instance 'mp-Pair))) (setf (sv-key m) "invocant") (setf (sv-value m) (sv-invocant self)) m) (let ((m (make-instance 'mp-Pair))) (setf (sv-key m) "hyper") (setf (sv-value m) (sv-hyper self)) m) (let ((m (make-instance 'mp-Pair))) (setf (sv-key m) "method") (setf (sv-value m) (sv-method self)) m) (let ((m (make-instance 'mp-Pair))) (setf (sv-key m) "arguments") (setf (sv-value m) (sv-arguments self)) m) )))




;; class Apply
(defpackage mp-Apply
  (:use common-lisp mp-Main))
;; (in-package mp-Apply)
(if (not (ignore-errors (find-class 'mp-Apply)))
  (defclass mp-Apply () ()))

(let (x) 
  (setq x (make-instance 'mp-Apply))
  (defun proto-mp-Apply () x))
;; has $.code
(let ((new-slots (list (list :name 'sv-code
  :readers '(sv-code)
  :writers '((setf sv-code))
  :initform '(sv-undef)
  :initfunction (constantly (sv-undef))))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-Apply)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-Apply :direct-slots new-slots))

;; has $.arguments
(let ((new-slots (list (list :name 'sv-arguments
  :readers '(sv-arguments)
  :writers '((setf sv-arguments))
  :initform '(sv-undef)
  :initfunction (constantly (sv-undef))))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-Apply)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-Apply :direct-slots new-slots))

;; has $.namespace
(let ((new-slots (list (list :name 'sv-namespace
  :readers '(sv-namespace)
  :writers '((setf sv-namespace))
  :initform '(sv-undef)
  :initfunction (constantly (sv-undef))))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-Apply)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-Apply :direct-slots new-slots))

;; method eval
(if (not (ignore-errors (find-method 'sv-eval () ())))
  (defgeneric sv-eval (sv-self &optional sv-env)
      (:documentation "a method")))
(defmethod sv-eval ((sv-self mp-Apply) &optional sv-env)
  (block mp6-function
    (let ((sv-ns (sv-undef))(sv-code (sv-undef))) (setf sv-ns "")(if (sv-bool (sv-namespace sv-self)) (progn (setf sv-ns (concatenate 'string (sv-string (sv-namespace sv-self)) (sv-string "::")))) nil)(setf sv-code (concatenate 'string (sv-string sv-ns) (sv-string (sv-code sv-self))))(dolist (sv-e sv-env) (progn (if (sv-bool (sv-exists (gethash sv-code sv-e))) (progn (sv-apply (return-from mp6-function (gethash sv-code sv-e)) sv-env (sv-arguments sv-self))) nil)))(write-line (format nil "~{~a~}" (list "Interpreter runtime error: subroutine '" sv-code "()' not found")) *error-output*))))

(defmethod sv-perl ((self mp-Apply))
  (mp-Main::sv-lisp_dump_object "::Apply" (list (let ((m (make-instance 'mp-Pair))) (setf (sv-key m) "code") (setf (sv-value m) (sv-code self)) m) (let ((m (make-instance 'mp-Pair))) (setf (sv-key m) "arguments") (setf (sv-value m) (sv-arguments self)) m) (let ((m (make-instance 'mp-Pair))) (setf (sv-key m) "namespace") (setf (sv-value m) (sv-namespace self)) m) )))




;; class Return
(defpackage mp-Return
  (:use common-lisp mp-Main))
;; (in-package mp-Return)
(if (not (ignore-errors (find-class 'mp-Return)))
  (defclass mp-Return () ()))

(let (x) 
  (setq x (make-instance 'mp-Return))
  (defun proto-mp-Return () x))
;; has $.result
(let ((new-slots (list (list :name 'sv-result
  :readers '(sv-result)
  :writers '((setf sv-result))
  :initform '(sv-undef)
  :initfunction (constantly (sv-undef))))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-Return)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-Return :direct-slots new-slots))

;; method eval
(if (not (ignore-errors (find-method 'sv-eval () ())))
  (defgeneric sv-eval (sv-self &optional sv-env)
      (:documentation "a method")))
(defmethod sv-eval ((sv-self mp-Return) &optional sv-env)
  (block mp6-function
    (progn (write-line (format nil "~{~a~}" (list "Interpreter TODO: Return")) *error-output*)(return-from mp6-function (concatenate 'string (sv-string "return(") (sv-string (concatenate 'string (sv-string (sv-eval (sv-result sv-self) )) (sv-string ")"))))))))

(defmethod sv-perl ((self mp-Return))
  (mp-Main::sv-lisp_dump_object "::Return" (list (let ((m (make-instance 'mp-Pair))) (setf (sv-key m) "result") (setf (sv-value m) (sv-result self)) m) )))




;; class If
(defpackage mp-If
  (:use common-lisp mp-Main))
;; (in-package mp-If)
(if (not (ignore-errors (find-class 'mp-If)))
  (defclass mp-If () ()))

(let (x) 
  (setq x (make-instance 'mp-If))
  (defun proto-mp-If () x))
;; has $.cond
(let ((new-slots (list (list :name 'sv-cond
  :readers '(sv-cond)
  :writers '((setf sv-cond))
  :initform '(sv-undef)
  :initfunction (constantly (sv-undef))))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-If)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-If :direct-slots new-slots))

;; has $.body
(let ((new-slots (list (list :name 'sv-body
  :readers '(sv-body)
  :writers '((setf sv-body))
  :initform '(sv-undef)
  :initfunction (constantly (sv-undef))))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-If)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-If :direct-slots new-slots))

;; has $.otherwise
(let ((new-slots (list (list :name 'sv-otherwise
  :readers '(sv-otherwise)
  :writers '((setf sv-otherwise))
  :initform '(sv-undef)
  :initfunction (constantly (sv-undef))))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-If)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-If :direct-slots new-slots))

;; method eval
(if (not (ignore-errors (find-method 'sv-eval () ())))
  (defgeneric sv-eval (sv-self &optional sv-env)
      (:documentation "a method")))
(defmethod sv-eval ((sv-self mp-If) &optional sv-env)
  (block mp6-function
    (let ((sv-cond (sv-undef))) (setf sv-cond (sv-cond sv-self))(if (sv-bool (sv-and (typep sv-cond 'mp-Apply) (sv-eq (sv-code sv-cond ) "prefix:<!>"))) (let ((sv-if (sv-undef))) (setf sv-if (let ((m (make-instance 'mp-If))) (setf (sv-cond m) (elt (sv-arguments sv-cond ) 0))(setf (sv-body m) (sv-otherwise sv-self))(setf (sv-otherwise m) (sv-body sv-self)) m))(return-from mp6-function (sv-eval sv-if sv-env))) nil)(if (sv-bool (sv-eval sv-cond sv-env)) (let ((sv-env1 (sv-undef))) (setf sv-env1 (concatenate 'list  (list (make-hash-table :test 'equal)) sv-env))(dolist (sv-stmt (sv-body sv-self)) (progn (sv-eval sv-stmt sv-env1)))) (let ((sv-env1 (sv-undef))) (setf sv-env1 (concatenate 'list  (list (make-hash-table :test 'equal)) sv-env))(dolist (sv-stmt (sv-otherwise sv-self)) (progn (sv-eval sv-stmt sv-env1)))))(return-from mp6-function (sv-undef)))))

(defmethod sv-perl ((self mp-If))
  (mp-Main::sv-lisp_dump_object "::If" (list (let ((m (make-instance 'mp-Pair))) (setf (sv-key m) "cond") (setf (sv-value m) (sv-cond self)) m) (let ((m (make-instance 'mp-Pair))) (setf (sv-key m) "body") (setf (sv-value m) (sv-body self)) m) (let ((m (make-instance 'mp-Pair))) (setf (sv-key m) "otherwise") (setf (sv-value m) (sv-otherwise self)) m) )))




;; class For
(defpackage mp-For
  (:use common-lisp mp-Main))
;; (in-package mp-For)
(if (not (ignore-errors (find-class 'mp-For)))
  (defclass mp-For () ()))

(let (x) 
  (setq x (make-instance 'mp-For))
  (defun proto-mp-For () x))
;; has $.cond
(let ((new-slots (list (list :name 'sv-cond
  :readers '(sv-cond)
  :writers '((setf sv-cond))
  :initform '(sv-undef)
  :initfunction (constantly (sv-undef))))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-For)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-For :direct-slots new-slots))

;; has $.body
(let ((new-slots (list (list :name 'sv-body
  :readers '(sv-body)
  :writers '((setf sv-body))
  :initform '(sv-undef)
  :initfunction (constantly (sv-undef))))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-For)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-For :direct-slots new-slots))

;; has $.topic
(let ((new-slots (list (list :name 'sv-topic
  :readers '(sv-topic)
  :writers '((setf sv-topic))
  :initform '(sv-undef)
  :initfunction (constantly (sv-undef))))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-For)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-For :direct-slots new-slots))

;; method eval
(if (not (ignore-errors (find-method 'sv-eval () ())))
  (defgeneric sv-eval (sv-self &optional sv-env)
      (:documentation "a method")))
(defmethod sv-eval ((sv-self mp-For) &optional sv-env)
  (block mp6-function
    (let ((sv-cond (sv-undef))(sv-topic_name (sv-undef))(sv-env1 (sv-undef))) (setf sv-cond (sv-cond sv-self))(setf sv-topic_name (sv-plain_name (sv-topic sv-self) ))(setf sv-env1 (concatenate 'list  (list (make-hash-table :test 'equal)) sv-env))(dolist (sv-topic (sv-eval sv-cond sv-env)) (progn (setf (elt sv-env1 0) (let ((h (make-hash-table :test 'equal))) (setf (gethash sv-topic_name h) sv-topic) h))(dolist (sv-stmt (sv-body sv-self)) (progn (sv-eval sv-stmt sv-env1)))))(return-from mp6-function (sv-undef)))))

(defmethod sv-perl ((self mp-For))
  (mp-Main::sv-lisp_dump_object "::For" (list (let ((m (make-instance 'mp-Pair))) (setf (sv-key m) "cond") (setf (sv-value m) (sv-cond self)) m) (let ((m (make-instance 'mp-Pair))) (setf (sv-key m) "body") (setf (sv-value m) (sv-body self)) m) (let ((m (make-instance 'mp-Pair))) (setf (sv-key m) "topic") (setf (sv-value m) (sv-topic self)) m) )))




;; class When
(defpackage mp-When
  (:use common-lisp mp-Main))
;; (in-package mp-When)
(if (not (ignore-errors (find-class 'mp-When)))
  (defclass mp-When () ()))

(let (x) 
  (setq x (make-instance 'mp-When))
  (defun proto-mp-When () x))
;; has $.parameters
(let ((new-slots (list (list :name 'sv-parameters
  :readers '(sv-parameters)
  :writers '((setf sv-parameters))
  :initform '(sv-undef)
  :initfunction (constantly (sv-undef))))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-When)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-When :direct-slots new-slots))

;; has $.body
(let ((new-slots (list (list :name 'sv-body
  :readers '(sv-body)
  :writers '((setf sv-body))
  :initform '(sv-undef)
  :initfunction (constantly (sv-undef))))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-When)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-When :direct-slots new-slots))

;; method eval
(if (not (ignore-errors (find-method 'sv-eval () ())))
  (defgeneric sv-eval (sv-self)
      (:documentation "a method")))
(defmethod sv-eval ((sv-self mp-When))
  (block mp6-function
    (progn (progn (write-line (format nil "~{~a~}" (list "TODO - When")) *error-output*) (sb-ext:quit)))))

(defmethod sv-perl ((self mp-When))
  (mp-Main::sv-lisp_dump_object "::When" (list (let ((m (make-instance 'mp-Pair))) (setf (sv-key m) "parameters") (setf (sv-value m) (sv-parameters self)) m) (let ((m (make-instance 'mp-Pair))) (setf (sv-key m) "body") (setf (sv-value m) (sv-body self)) m) )))




;; class While
(defpackage mp-While
  (:use common-lisp mp-Main))
;; (in-package mp-While)
(if (not (ignore-errors (find-class 'mp-While)))
  (defclass mp-While () ()))

(let (x) 
  (setq x (make-instance 'mp-While))
  (defun proto-mp-While () x))
;; has $.cond
(let ((new-slots (list (list :name 'sv-cond
  :readers '(sv-cond)
  :writers '((setf sv-cond))
  :initform '(sv-undef)
  :initfunction (constantly (sv-undef))))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-While)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-While :direct-slots new-slots))

;; has $.body
(let ((new-slots (list (list :name 'sv-body
  :readers '(sv-body)
  :writers '((setf sv-body))
  :initform '(sv-undef)
  :initfunction (constantly (sv-undef))))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-While)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-While :direct-slots new-slots))

;; method eval
(if (not (ignore-errors (find-method 'sv-eval () ())))
  (defgeneric sv-eval (sv-self)
      (:documentation "a method")))
(defmethod sv-eval ((sv-self mp-While))
  (block mp6-function
    (progn (progn (write-line (format nil "~{~a~}" (list "TODO - While")) *error-output*) (sb-ext:quit)))))

(defmethod sv-perl ((self mp-While))
  (mp-Main::sv-lisp_dump_object "::While" (list (let ((m (make-instance 'mp-Pair))) (setf (sv-key m) "cond") (setf (sv-value m) (sv-cond self)) m) (let ((m (make-instance 'mp-Pair))) (setf (sv-key m) "body") (setf (sv-value m) (sv-body self)) m) )))




;; class Leave
(defpackage mp-Leave
  (:use common-lisp mp-Main))
;; (in-package mp-Leave)
(if (not (ignore-errors (find-class 'mp-Leave)))
  (defclass mp-Leave () ()))

(let (x) 
  (setq x (make-instance 'mp-Leave))
  (defun proto-mp-Leave () x))
;; method eval
(if (not (ignore-errors (find-method 'sv-eval () ())))
  (defgeneric sv-eval (sv-self)
      (:documentation "a method")))
(defmethod sv-eval ((sv-self mp-Leave))
  (block mp6-function
    (progn (progn (write-line (format nil "~{~a~}" (list "TODO - Leave")) *error-output*) (sb-ext:quit)))))

(defmethod sv-perl ((self mp-Leave))
  (mp-Main::sv-lisp_dump_object "::Leave" (list )))




;; class Decl
(defpackage mp-Decl
  (:use common-lisp mp-Main))
;; (in-package mp-Decl)
(if (not (ignore-errors (find-class 'mp-Decl)))
  (defclass mp-Decl () ()))

(let (x) 
  (setq x (make-instance 'mp-Decl))
  (defun proto-mp-Decl () x))
;; has $.decl
(let ((new-slots (list (list :name 'sv-decl
  :readers '(sv-decl)
  :writers '((setf sv-decl))
  :initform '(sv-undef)
  :initfunction (constantly (sv-undef))))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-Decl)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-Decl :direct-slots new-slots))

;; has $.type
(let ((new-slots (list (list :name 'sv-type
  :readers '(sv-type)
  :writers '((setf sv-type))
  :initform '(sv-undef)
  :initfunction (constantly (sv-undef))))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-Decl)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-Decl :direct-slots new-slots))

;; has $.var
(let ((new-slots (list (list :name 'sv-var
  :readers '(sv-var)
  :writers '((setf sv-var))
  :initform '(sv-undef)
  :initfunction (constantly (sv-undef))))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-Decl)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-Decl :direct-slots new-slots))

;; method eval
(if (not (ignore-errors (find-method 'sv-eval () ())))
  (defgeneric sv-eval (sv-self &optional sv-env)
      (:documentation "a method")))
(defmethod sv-eval ((sv-self mp-Decl) &optional sv-env)
  (block mp6-function
    (let ((sv-decl (sv-undef))(sv-name (sv-undef))) (setf sv-decl (sv-decl sv-self))(setf sv-name (sv-plain_name (sv-var sv-self) ))(if (sv-bool (sv-eq sv-decl "has")) (progn (write-line (format nil "~{~a~}" (list "Interpreter TODO: has")) *error-output*)) nil)(if (sv-bool (not (sv-bool (sv-exists (gethash sv-name (elt sv-env 0)))))) (progn (setf (gethash sv-name (elt sv-env 0)) (sv-undef))) nil)(return-from mp6-function (sv-undef)))))

;; method plain_name
(if (not (ignore-errors (find-method 'sv-plain_name () ())))
  (defgeneric sv-plain_name (sv-self)
      (:documentation "a method")))
(defmethod sv-plain_name ((sv-self mp-Decl))
  (block mp6-function
    (progn (sv-plain_name (sv-var sv-self) ))))

(defmethod sv-perl ((self mp-Decl))
  (mp-Main::sv-lisp_dump_object "::Decl" (list (let ((m (make-instance 'mp-Pair))) (setf (sv-key m) "decl") (setf (sv-value m) (sv-decl self)) m) (let ((m (make-instance 'mp-Pair))) (setf (sv-key m) "type") (setf (sv-value m) (sv-type self)) m) (let ((m (make-instance 'mp-Pair))) (setf (sv-key m) "var") (setf (sv-value m) (sv-var self)) m) )))




;; class Sig
(defpackage mp-Sig
  (:use common-lisp mp-Main))
;; (in-package mp-Sig)
(if (not (ignore-errors (find-class 'mp-Sig)))
  (defclass mp-Sig () ()))

(let (x) 
  (setq x (make-instance 'mp-Sig))
  (defun proto-mp-Sig () x))
;; has $.invocant
(let ((new-slots (list (list :name 'sv-invocant
  :readers '(sv-invocant)
  :writers '((setf sv-invocant))
  :initform '(sv-undef)
  :initfunction (constantly (sv-undef))))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-Sig)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-Sig :direct-slots new-slots))

;; has $.positional
(let ((new-slots (list (list :name 'sv-positional
  :readers '(sv-positional)
  :writers '((setf sv-positional))
  :initform '(sv-undef)
  :initfunction (constantly (sv-undef))))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-Sig)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-Sig :direct-slots new-slots))

;; has $.named
(let ((new-slots (list (list :name 'sv-named
  :readers '(sv-named)
  :writers '((setf sv-named))
  :initform '(sv-undef)
  :initfunction (constantly (sv-undef))))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-Sig)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-Sig :direct-slots new-slots))

;; method eval
(if (not (ignore-errors (find-method 'sv-eval () ())))
  (defgeneric sv-eval (sv-self &optional sv-env)
      (:documentation "a method")))
(defmethod sv-eval ((sv-self mp-Sig) &optional sv-env)
  (block mp6-function
    (progn (write-line (format nil "~{~a~}" (list "Interpreter TODO: Sig")) *error-output*))))

(defmethod sv-perl ((self mp-Sig))
  (mp-Main::sv-lisp_dump_object "::Sig" (list (let ((m (make-instance 'mp-Pair))) (setf (sv-key m) "invocant") (setf (sv-value m) (sv-invocant self)) m) (let ((m (make-instance 'mp-Pair))) (setf (sv-key m) "positional") (setf (sv-value m) (sv-positional self)) m) (let ((m (make-instance 'mp-Pair))) (setf (sv-key m) "named") (setf (sv-value m) (sv-named self)) m) )))




;; class Method
(defpackage mp-Method
  (:use common-lisp mp-Main))
;; (in-package mp-Method)
(if (not (ignore-errors (find-class 'mp-Method)))
  (defclass mp-Method () ()))

(let (x) 
  (setq x (make-instance 'mp-Method))
  (defun proto-mp-Method () x))
;; has $.name
(let ((new-slots (list (list :name 'sv-name
  :readers '(sv-name)
  :writers '((setf sv-name))
  :initform '(sv-undef)
  :initfunction (constantly (sv-undef))))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-Method)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-Method :direct-slots new-slots))

;; has $.sig
(let ((new-slots (list (list :name 'sv-sig
  :readers '(sv-sig)
  :writers '((setf sv-sig))
  :initform '(sv-undef)
  :initfunction (constantly (sv-undef))))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-Method)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-Method :direct-slots new-slots))

;; has $.block
(let ((new-slots (list (list :name 'sv-block
  :readers '(sv-block)
  :writers '((setf sv-block))
  :initform '(sv-undef)
  :initfunction (constantly (sv-undef))))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-Method)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-Method :direct-slots new-slots))

;; method eval
(if (not (ignore-errors (find-method 'sv-eval () ())))
  (defgeneric sv-eval (sv-self &optional sv-env)
      (:documentation "a method")))
(defmethod sv-eval ((sv-self mp-Method) &optional sv-env)
  (block mp6-function
    (let ((sv-sig (sv-undef))(sv-invocant (sv-undef))(sv-pos (sv-undef))(sv-str (sv-undef))) (write-line (format nil "~{~a~}" (list "Interpreter TODO: Method")) *error-output*)(setf sv-sig (sv-sig sv-self))(setf sv-invocant (sv-invocant sv-sig ))(setf sv-pos (sv-positional sv-sig ))(setf sv-str "my $List__ = \\@_; "))))

(defmethod sv-perl ((self mp-Method))
  (mp-Main::sv-lisp_dump_object "::Method" (list (let ((m (make-instance 'mp-Pair))) (setf (sv-key m) "name") (setf (sv-value m) (sv-name self)) m) (let ((m (make-instance 'mp-Pair))) (setf (sv-key m) "sig") (setf (sv-value m) (sv-sig self)) m) (let ((m (make-instance 'mp-Pair))) (setf (sv-key m) "block") (setf (sv-value m) (sv-block self)) m) )))




;; class Sub
(defpackage mp-Sub
  (:use common-lisp mp-Main))
;; (in-package mp-Sub)
(if (not (ignore-errors (find-class 'mp-Sub)))
  (defclass mp-Sub () ()))

(let (x) 
  (setq x (make-instance 'mp-Sub))
  (defun proto-mp-Sub () x))
;; has $.name
(let ((new-slots (list (list :name 'sv-name
  :readers '(sv-name)
  :writers '((setf sv-name))
  :initform '(sv-undef)
  :initfunction (constantly (sv-undef))))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-Sub)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-Sub :direct-slots new-slots))

;; has $.sig
(let ((new-slots (list (list :name 'sv-sig
  :readers '(sv-sig)
  :writers '((setf sv-sig))
  :initform '(sv-undef)
  :initfunction (constantly (sv-undef))))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-Sub)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-Sub :direct-slots new-slots))

;; has $.block
(let ((new-slots (list (list :name 'sv-block
  :readers '(sv-block)
  :writers '((setf sv-block))
  :initform '(sv-undef)
  :initfunction (constantly (sv-undef))))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-Sub)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-Sub :direct-slots new-slots))

;; method eval
(if (not (ignore-errors (find-method 'sv-eval () ())))
  (defgeneric sv-eval (sv-self &optional sv-env)
      (:documentation "a method")))
(defmethod sv-eval ((sv-self mp-Sub) &optional sv-env)
  (block mp6-function
    (let ((sv-param_name (sv-undef))(sv-sub (sv-undef))) (dolist (sv-field (sv-positional (sv-sig sv-self) )) (progn (sv-push sv-param_name (sv-plain_name sv-field ))))(setf sv-sub (let ((m (make-instance 'mp-EvalFunction))) (setf (sv-func m) (lambda  (&optional sv-env sv-args )
  (block mp6-function (let ((sv-context (sv-undef))(sv-n (sv-undef))(sv-env1 (sv-undef))(sv-r (sv-undef))) (setf sv-n 0)(setf (gethash "@_" sv-context) sv-args)(dolist (sv-name sv-param_name) (progn (setf (gethash sv-name sv-context) (sv-eval (elt sv-args sv-n) sv-env))(setf sv-n (+ sv-n 1))))(setf sv-env1 (concatenate 'list  (list sv-context) sv-env))(dolist (sv-stmt (sv-block sv-self)) (progn (setf sv-r (sv-eval sv-stmt sv-env1))))(return-from mp6-function sv-r))))
) m))(if (sv-bool (sv-name sv-self)) (progn (setf (gethash (sv-name sv-self) (elt sv-env 0)) sv-sub)) nil)(return-from mp6-function sv-sub))))

(defmethod sv-perl ((self mp-Sub))
  (mp-Main::sv-lisp_dump_object "::Sub" (list (let ((m (make-instance 'mp-Pair))) (setf (sv-key m) "name") (setf (sv-value m) (sv-name self)) m) (let ((m (make-instance 'mp-Pair))) (setf (sv-key m) "sig") (setf (sv-value m) (sv-sig self)) m) (let ((m (make-instance 'mp-Pair))) (setf (sv-key m) "block") (setf (sv-value m) (sv-block self)) m) )))




;; class Do
(defpackage mp-Do
  (:use common-lisp mp-Main))
;; (in-package mp-Do)
(if (not (ignore-errors (find-class 'mp-Do)))
  (defclass mp-Do () ()))

(let (x) 
  (setq x (make-instance 'mp-Do))
  (defun proto-mp-Do () x))
;; has $.block
(let ((new-slots (list (list :name 'sv-block
  :readers '(sv-block)
  :writers '((setf sv-block))
  :initform '(sv-undef)
  :initfunction (constantly (sv-undef))))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-Do)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-Do :direct-slots new-slots))

;; method eval
(if (not (ignore-errors (find-method 'sv-eval () ())))
  (defgeneric sv-eval (sv-self &optional sv-env)
      (:documentation "a method")))
(defmethod sv-eval ((sv-self mp-Do) &optional sv-env)
  (block mp6-function
    (let ((sv-env1 (sv-undef))) (setf sv-env1 (concatenate 'list  (list (make-hash-table :test 'equal)) sv-env))(dolist (sv-stmt (sv-block sv-self)) (progn (sv-eval sv-stmt sv-env1))))))

(defmethod sv-perl ((self mp-Do))
  (mp-Main::sv-lisp_dump_object "::Do" (list (let ((m (make-instance 'mp-Pair))) (setf (sv-key m) "block") (setf (sv-value m) (sv-block self)) m) )))




;; class Use
(defpackage mp-Use
  (:use common-lisp mp-Main))
;; (in-package mp-Use)
(if (not (ignore-errors (find-class 'mp-Use)))
  (defclass mp-Use () ()))

(let (x) 
  (setq x (make-instance 'mp-Use))
  (defun proto-mp-Use () x))
;; has $.mod
(let ((new-slots (list (list :name 'sv-mod
  :readers '(sv-mod)
  :writers '((setf sv-mod))
  :initform '(sv-undef)
  :initfunction (constantly (sv-undef))))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-Use)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-Use :direct-slots new-slots))

;; method eval
(if (not (ignore-errors (find-method 'sv-eval () ())))
  (defgeneric sv-eval (sv-self &optional sv-env)
      (:documentation "a method")))
(defmethod sv-eval ((sv-self mp-Use) &optional sv-env)
  (block mp6-function
    (progn (write-line (format nil "~{~a~}" (list "Interpreter TODO: Use")) *error-output*)(concatenate 'string (sv-string "use ") (sv-string (sv-mod sv-self))))))

(defmethod sv-perl ((self mp-Use))
  (mp-Main::sv-lisp_dump_object "::Use" (list (let ((m (make-instance 'mp-Pair))) (setf (sv-key m) "mod") (setf (sv-value m) (sv-mod self)) m) )))




