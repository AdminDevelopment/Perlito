;; Do not edit this file - Generated by MiniPerl6 4.1
(defpackage mp-MiniPerl6-Go-LexicalBlock
  (:use common-lisp mp-Main))
(defpackage mp-CompUnit
  (:use common-lisp mp-Main))
(defpackage mp-Val-Int
  (:use common-lisp mp-Main))
(defpackage mp-Val-Bit
  (:use common-lisp mp-Main))
(defpackage mp-Val-Num
  (:use common-lisp mp-Main))
(defpackage mp-Val-Buf
  (:use common-lisp mp-Main))
(defpackage mp-Val-Undef
  (:use common-lisp mp-Main))
(defpackage mp-Val-Object
  (:use common-lisp mp-Main))
(defpackage mp-Lit-Seq
  (:use common-lisp mp-Main))
(defpackage mp-Lit-Array
  (:use common-lisp mp-Main))
(defpackage mp-Lit-Hash
  (:use common-lisp mp-Main))
(defpackage mp-Lit-Code
  (:use common-lisp mp-Main))
(defpackage mp-Lit-Object
  (:use common-lisp mp-Main))
(defpackage mp-Index
  (:use common-lisp mp-Main))
(defpackage mp-Lookup
  (:use common-lisp mp-Main))
(defpackage mp-Var
  (:use common-lisp mp-Main))
(defpackage mp-Bind
  (:use common-lisp mp-Main))
(defpackage mp-Proto
  (:use common-lisp mp-Main))
(defpackage mp-Call
  (:use common-lisp mp-Main))
(defpackage mp-Apply
  (:use common-lisp mp-Main))
(defpackage mp-Return
  (:use common-lisp mp-Main))
(defpackage mp-If
  (:use common-lisp mp-Main))
(defpackage mp-For
  (:use common-lisp mp-Main))
(defpackage mp-When
  (:use common-lisp mp-Main))
(defpackage mp-While
  (:use common-lisp mp-Main))
(defpackage mp-Leave
  (:use common-lisp mp-Main))
(defpackage mp-Decl
  (:use common-lisp mp-Main))
(defpackage mp-Sig
  (:use common-lisp mp-Main))
(defpackage mp-Method
  (:use common-lisp mp-Main))
(defpackage mp-Sub
  (:use common-lisp mp-Main))
(defpackage mp-Do
  (:use common-lisp mp-Main))
(defpackage mp-Use
  (:use common-lisp mp-Main))
;; class MiniPerl6::Go::LexicalBlock
(if (not (ignore-errors (find-class 'mp-MiniPerl6-Go-LexicalBlock)))
  (defclass mp-MiniPerl6-Go-LexicalBlock () ()))

(let (x) 
  (setq x (make-instance 'mp-MiniPerl6-Go-LexicalBlock))
  (defun proto-mp-MiniPerl6-Go-LexicalBlock () x))
;; has $.block
(let ((new-slots (list (list :name 'sv-block
  :readers '(sv-block)
  :writers '((setf sv-block))
  :initform '(sv-undef)
  :initfunction (constantly (sv-undef))))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-MiniPerl6-Go-LexicalBlock)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-MiniPerl6-Go-LexicalBlock :direct-slots new-slots))

;; has $.needs_return
(let ((new-slots (list (list :name 'sv-needs_return
  :readers '(sv-needs_return)
  :writers '((setf sv-needs_return))
  :initform '(sv-undef)
  :initfunction (constantly (sv-undef))))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-MiniPerl6-Go-LexicalBlock)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-MiniPerl6-Go-LexicalBlock :direct-slots new-slots))

;; has $.top_level
(let ((new-slots (list (list :name 'sv-top_level
  :readers '(sv-top_level)
  :writers '((setf sv-top_level))
  :initform '(sv-undef)
  :initfunction (constantly (sv-undef))))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-MiniPerl6-Go-LexicalBlock)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-MiniPerl6-Go-LexicalBlock :direct-slots new-slots))

;; method emit_go
(if (not (ignore-errors (find-method 'sv-emit_go () ())))
  (defgeneric sv-emit_go (sv-self)
      (:documentation "a method")))
(defmethod sv-emit_go ((sv-self mp-MiniPerl6-Go-LexicalBlock))
  (block mp6-function
    (let ((sv-str (sv-undef))(sv-decl_seen (make-hash-table :test 'equal))(sv-last_statement (sv-undef))) (if (sv-bool (not (sv-bool (sv-block sv-self)))) (progn (return-from mp6-function "")) nil)(setf sv-str "")(loop for sv-decl1 across (sv-block sv-self) do (let ((sv-decl (sv-undef))) (setf sv-decl sv-decl1)(if (sv-bool (sv-and (typep sv-decl 'mp-Bind) (sv-and (typep (sv-parameters sv-decl ) 'mp-Decl) (sv-eq (sv-decl (sv-parameters sv-decl ) ) "my")))) (progn (setf sv-decl (sv-parameters sv-decl ))) nil)(if (sv-bool (sv-and (typep sv-decl 'mp-Decl) (sv-eq (sv-decl sv-decl ) "my"))) (let ((sv-var_name (sv-undef))) (setf sv-var_name (sv-emit_go (sv-var sv-decl ) ))(if (sv-bool (not (sv-bool (mp-Main::sv-hash-lookup sv-var_name sv-decl_seen)))) (progn (setf sv-str (concatenate 'string (sv-string sv-str) (sv-string (sv-emit_go_init sv-decl ))))(setf (mp-Main::sv-hash-lookup sv-var_name sv-decl_seen) 1)) nil)) nil)))(if (sv-bool (sv-needs_return sv-self)) (progn (setf sv-last_statement (sv-pop (sv-block sv-self)))) nil)(loop for sv-decl across (sv-block sv-self) do (progn (if (sv-bool (not (sv-bool (sv-and (typep sv-decl 'mp-Decl) (sv-eq (sv-decl sv-decl ) "my"))))) (progn (setf sv-str (concatenate 'string (sv-string sv-str) (sv-string (concatenate 'string (sv-string (sv-emit_go sv-decl )) (sv-string ";")))))) nil)))(if (sv-bool (sv-and (sv-needs_return sv-self) sv-last_statement)) (progn (if (sv-bool (typep sv-last_statement 'mp-If)) (let ((sv-cond (sv-undef))(sv-body (sv-undef))(sv-otherwise (sv-undef))) (setf sv-cond (sv-cond sv-last_statement ))(setf sv-body (sv-body sv-last_statement ))(setf sv-otherwise (sv-otherwise sv-last_statement ))(if (sv-bool (sv-and (typep sv-cond 'mp-Apply) (sv-eq (sv-code sv-cond ) "prefix:<!>"))) (progn (setf sv-cond (mp-Main::sv-array-index (sv-arguments sv-cond ) 0))(setf sv-body (sv-otherwise sv-last_statement ))(setf sv-otherwise (sv-body sv-last_statement ))) nil)(if (sv-bool (sv-and (typep sv-cond 'mp-Var) (sv-eq (sv-sigil sv-cond ) "@"))) (progn (setf sv-cond (let ((m (make-instance 'mp-Apply))) (setf (sv-code m) "prefix:<@>")(setf (sv-arguments m) (let ((_tmp_ (concatenate 'list  (list sv-cond)))) (make-array (length _tmp_) :adjustable 1 :fill-pointer t :initial-contents _tmp_))) m))) nil)(setf sv-body (let ((m (make-instance 'mp-MiniPerl6-Go-LexicalBlock))) (setf (sv-block m) sv-body)(setf (sv-needs_return m) 1)(setf (sv-top_level m) (sv-top_level sv-self)) m))(setf sv-otherwise (let ((m (make-instance 'mp-MiniPerl6-Go-LexicalBlock))) (setf (sv-block m) sv-otherwise)(setf (sv-needs_return m) 1)(setf (sv-top_level m) (sv-top_level sv-self)) m))(setf sv-str (concatenate 'string (sv-string sv-str) (sv-string (concatenate 'string (sv-string "if tobool( ") (sv-string (concatenate 'string (sv-string (mp-Call::sv-emit_go_call sv-cond "Bool")) (sv-string (concatenate 'string (sv-string " ) { ") (sv-string (concatenate 'string (sv-string (sv-emit_go sv-body )) (sv-string (concatenate 'string (sv-string " } else { ") (sv-string (concatenate 'string (sv-string (sv-emit_go sv-otherwise )) (sv-string " }")))))))))))))))) (progn (if (sv-bool (sv-or (typep sv-last_statement 'mp-Return) (typep sv-last_statement 'mp-For))) (progn (setf sv-str (concatenate 'string (sv-string sv-str) (sv-string (sv-emit_go sv-last_statement ))))) (progn (setf sv-last_statement (let ((m (make-instance 'mp-Return))) (setf (sv-result m) sv-last_statement) m))(if (sv-bool (sv-top_level sv-self)) (progn (setf sv-str (concatenate 'string (sv-string sv-str) (sv-string (sv-emit_go sv-last_statement ))))) (progn (setf sv-str (concatenate 'string (sv-string sv-str) (sv-string (sv-emit_go_simple sv-last_statement ))))))))))) nil)(return-from mp6-function sv-str))))

(defmethod sv-perl ((self mp-MiniPerl6-Go-LexicalBlock))
  (mp-Main::sv-lisp_dump_object "::MiniPerl6::Go::LexicalBlock" (list (let ((m (make-instance 'mp-Pair))) (setf (sv-key m) "block") (setf (sv-value m) (sv-block self)) m) (let ((m (make-instance 'mp-Pair))) (setf (sv-key m) "needs_return") (setf (sv-value m) (sv-needs_return self)) m) (let ((m (make-instance 'mp-Pair))) (setf (sv-key m) "top_level") (setf (sv-value m) (sv-top_level self)) m) )))




;; class CompUnit
(if (not (ignore-errors (find-class 'mp-CompUnit)))
  (defclass mp-CompUnit () ()))

(let (x) 
  (setq x (make-instance 'mp-CompUnit))
  (defun proto-mp-CompUnit () x))
;; has $.name
(let ((new-slots (list (list :name 'sv-name
  :readers '(sv-name)
  :writers '((setf sv-name))
  :initform '(sv-undef)
  :initfunction (constantly (sv-undef))))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-CompUnit)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-CompUnit :direct-slots new-slots))

;; has $.attributes
(let ((new-slots (list (list :name 'sv-attributes
  :readers '(sv-attributes)
  :writers '((setf sv-attributes))
  :initform '(sv-undef)
  :initfunction (constantly (sv-undef))))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-CompUnit)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-CompUnit :direct-slots new-slots))

;; has $.methods
(let ((new-slots (list (list :name 'sv-methods
  :readers '(sv-methods)
  :writers '((setf sv-methods))
  :initform '(sv-undef)
  :initfunction (constantly (sv-undef))))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-CompUnit)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-CompUnit :direct-slots new-slots))

;; has $.body
(let ((new-slots (list (list :name 'sv-body
  :readers '(sv-body)
  :writers '((setf sv-body))
  :initform '(sv-undef)
  :initfunction (constantly (sv-undef))))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-CompUnit)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-CompUnit :direct-slots new-slots))

;; method emit_go
(if (not (ignore-errors (find-method 'sv-emit_go () ())))
  (defgeneric sv-emit_go (sv-self)
      (:documentation "a method")))
(defmethod sv-emit_go ((sv-self mp-CompUnit))
  (block mp6-function
    (let ((sv-class_name (sv-undef))(sv-str (sv-undef))(sv-decl_seen (make-hash-table :test 'equal))) (setf sv-class_name (mp-Main::sv-to_go_namespace (sv-name sv-self)))(setf sv-str (concatenate 'string (sv-string "// instances of class ") (sv-string (concatenate 'string (sv-string (sv-name sv-self)) (sv-string (concatenate 'string (sv-string "
") (sv-string (concatenate 'string (sv-string "type ") (sv-string (concatenate 'string (sv-string sv-class_name) (sv-string (concatenate 'string (sv-string " struct {") (sv-string "
")))))))))))))(loop for sv-decl across (sv-values (sv-attributes sv-self) ) do (progn (if (sv-bool (sv-and (typep sv-decl 'mp-Decl) (sv-eq (sv-decl sv-decl ) "has"))) (progn (setf sv-str (concatenate 'string (sv-string sv-str) (sv-string (concatenate 'string (sv-string "  ") (sv-string (concatenate 'string (sv-string "v_") (sv-string (concatenate 'string (sv-string (sv-name (sv-var sv-decl ) )) (sv-string (concatenate 'string (sv-string " *Any;") (sv-string "
")))))))))))) nil)))(setf sv-str (concatenate 'string (sv-string sv-str) (sv-string (concatenate 'string (sv-string "}") (sv-string "
")))))(setf sv-str (concatenate 'string (sv-string sv-str) (sv-string (concatenate 'string (sv-string "// methods in class ") (sv-string (concatenate 'string (sv-string (sv-name sv-self)) (sv-string (concatenate 'string (sv-string "
") (sv-string (concatenate 'string (sv-string "var Method_") (sv-string (concatenate 'string (sv-string sv-class_name) (sv-string (concatenate 'string (sv-string " struct {") (sv-string "
")))))))))))))))(loop for sv-decl across (sv-values (sv-methods sv-self) ) do (progn (if (sv-bool (typep sv-decl 'mp-Method)) (progn (setf sv-str (concatenate 'string (sv-string sv-str) (sv-string (concatenate 'string (sv-string "  ") (sv-string (concatenate 'string (sv-string "f_") (sv-string (concatenate 'string (sv-string (sv-name sv-decl )) (sv-string (concatenate 'string (sv-string " func (*") (sv-string (concatenate 'string (sv-string sv-class_name) (sv-string (concatenate 'string (sv-string ", Capture) *Any;") (sv-string "
")))))))))))))))) nil)))(loop for sv-decl across (sv-values (sv-attributes sv-self) ) do (progn (if (sv-bool (sv-and (typep sv-decl 'mp-Decl) (sv-eq (sv-decl sv-decl ) "has"))) (progn (setf sv-str (concatenate 'string (sv-string sv-str) (sv-string (concatenate 'string (sv-string "  ") (sv-string (concatenate 'string (sv-string "f_") (sv-string (concatenate 'string (sv-string (sv-name (sv-var sv-decl ) )) (sv-string (concatenate 'string (sv-string " func (*") (sv-string (concatenate 'string (sv-string sv-class_name) (sv-string (concatenate 'string (sv-string ", Capture) *Any;") (sv-string "
")))))))))))))))) nil)))(setf sv-str (concatenate 'string (sv-string sv-str) (sv-string (concatenate 'string (sv-string "}") (sv-string "
")))))(setf sv-str (concatenate 'string (sv-string sv-str) (sv-string (concatenate 'string (sv-string "// namespace ") (sv-string (concatenate 'string (sv-string (sv-name sv-self)) (sv-string (concatenate 'string (sv-string "
") (sv-string (concatenate 'string (sv-string "var Namespace_") (sv-string (concatenate 'string (sv-string sv-class_name) (sv-string (concatenate 'string (sv-string " struct {") (sv-string "
")))))))))))))))(loop for sv-decl across (sv-body sv-self) do (progn (if (sv-bool (typep sv-decl 'mp-Sub)) (progn (setf sv-str (concatenate 'string (sv-string sv-str) (sv-string (concatenate 'string (sv-string "  ") (sv-string (concatenate 'string (sv-string "f_") (sv-string (concatenate 'string (sv-string (sv-name sv-decl )) (sv-string (concatenate 'string (sv-string " Function;") (sv-string "
")))))))))))) nil)))(setf sv-str (concatenate 'string (sv-string sv-str) (sv-string (concatenate 'string (sv-string "}") (sv-string "
")))))(setf sv-str (concatenate 'string (sv-string sv-str) (sv-string (concatenate 'string (sv-string "var Run_") (sv-string (concatenate 'string (sv-string sv-class_name) (sv-string (concatenate 'string (sv-string " func ();") (sv-string "
")))))))))(setf sv-str (concatenate 'string (sv-string sv-str) (sv-string (concatenate 'string (sv-string "// method wrappers for ") (sv-string (concatenate 'string (sv-string (sv-name sv-self)) (sv-string "
")))))))(loop for sv-decl across (sv-values (sv-methods sv-self) ) do (progn (if (sv-bool (typep sv-decl 'mp-Method)) (progn (setf sv-str (concatenate 'string (sv-string sv-str) (sv-string (concatenate 'string (sv-string "func (v_self *") (sv-string (concatenate 'string (sv-string sv-class_name) (sv-string (concatenate 'string (sv-string ") f_") (sv-string (concatenate 'string (sv-string (sv-name sv-decl )) (sv-string (concatenate 'string (sv-string " (v Capture) *Any {") (sv-string (concatenate 'string (sv-string "
") (sv-string (concatenate 'string (sv-string "  return Method_") (sv-string (concatenate 'string (sv-string sv-class_name) (sv-string (concatenate 'string (sv-string ".f_") (sv-string (concatenate 'string (sv-string (sv-name sv-decl )) (sv-string (concatenate 'string (sv-string "(v_self, v);") (sv-string (concatenate 'string (sv-string "
") (sv-string (concatenate 'string (sv-string "}") (sv-string "
")))))))))))))))))))))))))))))) nil)))(loop for sv-decl across (sv-values (sv-attributes sv-self) ) do (progn (if (sv-bool (sv-and (typep sv-decl 'mp-Decl) (sv-eq (sv-decl sv-decl ) "has"))) (progn (setf sv-str (concatenate 'string (sv-string sv-str) (sv-string (concatenate 'string (sv-string "func (v_self *") (sv-string (concatenate 'string (sv-string sv-class_name) (sv-string (concatenate 'string (sv-string ") f_") (sv-string (concatenate 'string (sv-string (sv-name (sv-var sv-decl ) )) (sv-string (concatenate 'string (sv-string " (v Capture) *Any {") (sv-string (concatenate 'string (sv-string "
") (sv-string (concatenate 'string (sv-string "  return Method_") (sv-string (concatenate 'string (sv-string sv-class_name) (sv-string (concatenate 'string (sv-string ".f_") (sv-string (concatenate 'string (sv-string (sv-name (sv-var sv-decl ) )) (sv-string (concatenate 'string (sv-string "(v_self, v);") (sv-string (concatenate 'string (sv-string "
") (sv-string (concatenate 'string (sv-string "}") (sv-string "
")))))))))))))))))))))))))))))) nil)))(if (sv-bool (not (sv-bool (mp-Main::sv-hash-lookup "isa" (sv-methods sv-self))))) (progn (setf sv-str (concatenate 'string (sv-string sv-str) (sv-string (concatenate 'string (sv-string "func (v_self *") (sv-string (concatenate 'string (sv-string sv-class_name) (sv-string (concatenate 'string (sv-string ") f_isa (v Capture) *Any { ") (sv-string (concatenate 'string (sv-string "return toBool( \"") (sv-string (concatenate 'string (sv-string (sv-name sv-self)) (sv-string (concatenate 'string (sv-string "\" == tostr( v.p[0] ) ) ") (sv-string (concatenate 'string (sv-string "}") (sv-string "
")))))))))))))))))) nil)(if (sv-bool (not (sv-bool (mp-Main::sv-hash-lookup "perl" (sv-methods sv-self))))) (let ((sv-sep (sv-undef))) (setf sv-str (concatenate 'string (sv-string sv-str) (sv-string (concatenate 'string (sv-string "func (v_self *") (sv-string (concatenate 'string (sv-string sv-class_name) (sv-string (concatenate 'string (sv-string ") f_perl (v Capture) *Any { ") (sv-string (concatenate 'string (sv-string "return toStr( \"::") (sv-string (concatenate 'string (sv-string (sv-name sv-self)) (sv-string "(\" ")))))))))))))(setf sv-sep "")(loop for sv-decl across (sv-values (sv-attributes sv-self) ) do (progn (if (sv-bool (sv-and (typep sv-decl 'mp-Decl) (sv-eq (sv-decl sv-decl ) "has"))) (progn (setf sv-str (concatenate 'string (sv-string sv-str) (sv-string (concatenate 'string (sv-string sv-sep) (sv-string (concatenate 'string (sv-string "+ \"") (sv-string (concatenate 'string (sv-string (sv-name (sv-var sv-decl ) )) (sv-string (concatenate 'string (sv-string " => \"") (sv-string (concatenate 'string (sv-string "+ tostr((*(*v_self).f_") (sv-string (concatenate 'string (sv-string (sv-name (sv-var sv-decl ) )) (sv-string "(Capture{})).(perl_er).f_perl(Capture{})) ")))))))))))))))(setf sv-sep "+ \", \" ")) nil)))(setf sv-str (concatenate 'string (sv-string sv-str) (sv-string (concatenate 'string (sv-string "+ \")\" ) }") (sv-string "
")))))) nil)(if (sv-bool (sv-and (not (sv-bool (mp-Main::sv-hash-lookup "Bool" (sv-methods sv-self)))) (not (sv-bool (mp-Main::sv-hash-lookup "Bool" (sv-attributes sv-self)))))) (progn (setf sv-str (concatenate 'string (sv-string sv-str) (sv-string (concatenate 'string (sv-string "func (v_self *") (sv-string (concatenate 'string (sv-string sv-class_name) (sv-string (concatenate 'string (sv-string ") f_Bool (v Capture) *Any { ") (sv-string (concatenate 'string (sv-string "return b_true() ") (sv-string (concatenate 'string (sv-string "}") (sv-string "
")))))))))))))) nil)(setf sv-str (concatenate 'string (sv-string sv-str) (sv-string (concatenate 'string (sv-string "// prototype of ") (sv-string (concatenate 'string (sv-string (sv-name sv-self)) (sv-string (concatenate 'string (sv-string "
") (sv-string (concatenate 'string (sv-string "var Proto_") (sv-string (concatenate 'string (sv-string sv-class_name) (sv-string (concatenate 'string (sv-string " *Any;") (sv-string "
")))))))))))))))(setf sv-str (concatenate 'string (sv-string sv-str) (sv-string (concatenate 'string (sv-string "func Init_") (sv-string (concatenate 'string (sv-string sv-class_name) (sv-string (concatenate 'string (sv-string "() {") (sv-string "
")))))))))(setf sv-str (concatenate 'string (sv-string sv-str) (sv-string (concatenate 'string (sv-string "  this_namespace := &Namespace_") (sv-string (concatenate 'string (sv-string sv-class_name) (sv-string (concatenate 'string (sv-string ";") (sv-string (concatenate 'string (sv-string "
") (sv-string (concatenate 'string (sv-string "  this_namespace = this_namespace;") (sv-string "
")))))))))))))(setf sv-str (concatenate 'string (sv-string sv-str) (sv-string (concatenate 'string (sv-string "  Proto_") (sv-string (concatenate 'string (sv-string sv-class_name) (sv-string (concatenate 'string (sv-string " = ") (sv-string (concatenate 'string (sv-string "func() *Any { ") (sv-string (concatenate 'string (sv-string "var m = new(") (sv-string (concatenate 'string (sv-string sv-class_name) (sv-string (concatenate 'string (sv-string "); ") (sv-string (concatenate 'string (sv-string "var m1 Any = m; ") (sv-string (concatenate 'string (sv-string "return &m1; ") (sv-string (concatenate 'string (sv-string "}();") (sv-string "
")))))))))))))))))))))))(loop for sv-decl1 across (sv-body sv-self) do (let ((sv-decl (sv-undef))) (setf sv-decl sv-decl1)(if (sv-bool (sv-and (typep sv-decl 'mp-Bind) (sv-and (typep (sv-parameters sv-decl ) 'mp-Decl) (sv-eq (sv-decl (sv-parameters sv-decl ) ) "my")))) (progn (setf sv-decl (sv-parameters sv-decl ))) nil)(if (sv-bool (sv-and (typep sv-decl 'mp-Decl) (sv-eq (sv-decl sv-decl ) "my"))) (let ((sv-var_name (sv-undef))) (setf sv-var_name (sv-emit_go (sv-var sv-decl ) ))(if (sv-bool (not (sv-bool (mp-Main::sv-hash-lookup sv-var_name sv-decl_seen)))) (progn (setf sv-str (concatenate 'string (sv-string sv-str) (sv-string (sv-emit_go_init sv-decl ))))(setf (mp-Main::sv-hash-lookup sv-var_name sv-decl_seen) 1)) nil)) nil)))(loop for sv-decl across (sv-body sv-self) do (progn (if (sv-bool (sv-and (typep sv-decl 'mp-Decl) (sv-eq (sv-decl sv-decl ) "has"))) (progn (setf sv-str (concatenate 'string (sv-string sv-str) (sv-string (concatenate 'string (sv-string "  // accessor ") (sv-string (concatenate 'string (sv-string (sv-name (sv-var sv-decl ) )) (sv-string (concatenate 'string (sv-string "
") (sv-string (concatenate 'string (sv-string "  Method_") (sv-string (concatenate 'string (sv-string sv-class_name) (sv-string (concatenate 'string (sv-string ".f_") (sv-string (concatenate 'string (sv-string (sv-name (sv-var sv-decl ) )) (sv-string (concatenate 'string (sv-string " = func (v_self *") (sv-string (concatenate 'string (sv-string sv-class_name) (sv-string (concatenate 'string (sv-string ", v Capture) *Any {") (sv-string "
")))))))))))))))))))))))(setf sv-str (concatenate 'string (sv-string sv-str) (sv-string (concatenate 'string (sv-string "    ") (sv-string (concatenate 'string (sv-string "if v_self.v_") (sv-string (concatenate 'string (sv-string (sv-name (sv-var sv-decl ) )) (sv-string (concatenate 'string (sv-string " == nil {") (sv-string (concatenate 'string (sv-string "
") (sv-string (concatenate 'string (sv-string "      ") (sv-string (concatenate 'string (sv-string (sv-emit_go_init (let ((m (make-instance 'mp-Decl))) (setf (sv-decl m) "my")(setf (sv-type m) (sv-undef))(setf (sv-var m) (let ((m (make-instance 'mp-Var))) (setf (sv-sigil m) (sv-sigil (sv-var sv-decl ) ))(setf (sv-twigil m) "")(setf (sv-namespace m) "")(setf (sv-name m) "tmp") m)) m) )) (sv-string (concatenate 'string (sv-string "      ") (sv-string (concatenate 'string (sv-string "v_self.v_") (sv-string (concatenate 'string (sv-string (sv-name (sv-var sv-decl ) )) (sv-string (concatenate 'string (sv-string " = ") (sv-string (concatenate 'string (sv-string (sv-emit_go (let ((m (make-instance 'mp-Var))) (setf (sv-sigil m) (sv-sigil (sv-var sv-decl ) ))(setf (sv-twigil m) "")(setf (sv-namespace m) "")(setf (sv-name m) "tmp") m) )) (sv-string (concatenate 'string (sv-string ";") (sv-string (concatenate 'string (sv-string "
") (sv-string (concatenate 'string (sv-string "    ") (sv-string (concatenate 'string (sv-string "}") (sv-string "
")))))))))))))))))))))))))))))))))))(setf sv-str (concatenate 'string (sv-string sv-str) (sv-string (concatenate 'string (sv-string "    ") (sv-string (concatenate 'string (sv-string "if *v_self.v_") (sv-string (concatenate 'string (sv-string (sv-name (sv-var sv-decl ) )) (sv-string (concatenate 'string (sv-string " == nil {") (sv-string (concatenate 'string (sv-string "
") (sv-string (concatenate 'string (sv-string "      ") (sv-string (concatenate 'string (sv-string (sv-emit_go_init (let ((m (make-instance 'mp-Decl))) (setf (sv-decl m) "my")(setf (sv-type m) (sv-undef))(setf (sv-var m) (let ((m (make-instance 'mp-Var))) (setf (sv-sigil m) (sv-sigil (sv-var sv-decl ) ))(setf (sv-twigil m) "")(setf (sv-namespace m) "")(setf (sv-name m) "tmp") m)) m) )) (sv-string (concatenate 'string (sv-string "      ") (sv-string (concatenate 'string (sv-string "v_self.v_") (sv-string (concatenate 'string (sv-string (sv-name (sv-var sv-decl ) )) (sv-string (concatenate 'string (sv-string " = ") (sv-string (concatenate 'string (sv-string (sv-emit_go (let ((m (make-instance 'mp-Var))) (setf (sv-sigil m) (sv-sigil (sv-var sv-decl ) ))(setf (sv-twigil m) "")(setf (sv-namespace m) "")(setf (sv-name m) "tmp") m) )) (sv-string (concatenate 'string (sv-string ";") (sv-string (concatenate 'string (sv-string "
") (sv-string (concatenate 'string (sv-string "    ") (sv-string (concatenate 'string (sv-string "}") (sv-string "
")))))))))))))))))))))))))))))))))))(setf sv-str (concatenate 'string (sv-string sv-str) (sv-string (concatenate 'string (sv-string "    ") (sv-string (concatenate 'string (sv-string "return v_self.v_") (sv-string (concatenate 'string (sv-string (sv-name (sv-var sv-decl ) )) (sv-string (concatenate 'string (sv-string "
") (sv-string (concatenate 'string (sv-string "  };") (sv-string "
")))))))))))))) nil)(if (sv-bool (typep sv-decl 'mp-Method)) (let ((sv-sig (sv-undef))(sv-block (sv-undef))) (setf sv-sig (sv-sig sv-decl ))(setf sv-block (let ((m (make-instance 'mp-MiniPerl6-Go-LexicalBlock))) (setf (sv-block m) (sv-block sv-decl ))(setf (sv-needs_return m) 1)(setf (sv-top_level m) 1) m))(setf sv-str (concatenate 'string (sv-string sv-str) (sv-string (concatenate 'string (sv-string "  // method ") (sv-string (concatenate 'string (sv-string (sv-name sv-decl )) (sv-string (concatenate 'string (sv-string "
") (sv-string (concatenate 'string (sv-string "  Method_") (sv-string (concatenate 'string (sv-string sv-class_name) (sv-string (concatenate 'string (sv-string ".f_") (sv-string (concatenate 'string (sv-string (sv-name sv-decl )) (sv-string (concatenate 'string (sv-string " = func (self *") (sv-string (concatenate 'string (sv-string sv-class_name) (sv-string (concatenate 'string (sv-string ", v Capture) *Any {") (sv-string "
")))))))))))))))))))))))(setf sv-str (concatenate 'string (sv-string sv-str) (sv-string (concatenate 'string (sv-string "    var self1 Any = self;") (sv-string (concatenate 'string (sv-string "
") (sv-string (concatenate 'string (sv-string "    var ") (sv-string (concatenate 'string (sv-string (sv-emit_go (sv-invocant sv-sig ) )) (sv-string (concatenate 'string (sv-string " *Any = &self1;") (sv-string (concatenate 'string (sv-string "
") (sv-string (concatenate 'string (sv-string "    ") (sv-string (concatenate 'string (sv-string (sv-emit_go (sv-invocant sv-sig ) )) (sv-string (concatenate 'string (sv-string " = ") (sv-string (concatenate 'string (sv-string (sv-emit_go (sv-invocant sv-sig ) )) (sv-string (concatenate 'string (sv-string ";") (sv-string (concatenate 'string (sv-string "
") (sv-string (concatenate 'string (sv-string "    ") (sv-string (concatenate 'string (sv-string (sv-emit_go_bind sv-sig )) (sv-string "
")))))))))))))))))))))))))))))))(setf sv-str (concatenate 'string (sv-string sv-str) (sv-string (concatenate 'string (sv-string "    p := make(chan *Any); go func () { ") (sv-string (concatenate 'string (sv-string "
") (sv-string (concatenate 'string (sv-string "        ") (sv-string (concatenate 'string (sv-string (sv-emit_go sv-block )) (sv-string (concatenate 'string (sv-string "; p <- nil }(); ") (sv-string (concatenate 'string (sv-string "
") (sv-string (concatenate 'string (sv-string "    return <-p; ") (sv-string (concatenate 'string (sv-string "
") (sv-string (concatenate 'string (sv-string "  };") (sv-string "
")))))))))))))))))))))) nil)(if (sv-bool (typep sv-decl 'mp-Sub)) (let ((sv-sig (sv-undef))(sv-block (sv-undef))) (setf sv-sig (sv-sig sv-decl ))(setf sv-block (let ((m (make-instance 'mp-MiniPerl6-Go-LexicalBlock))) (setf (sv-block m) (sv-block sv-decl ))(setf (sv-needs_return m) 1)(setf (sv-top_level m) 1) m))(setf sv-str (concatenate 'string (sv-string sv-str) (sv-string (concatenate 'string (sv-string "  // sub ") (sv-string (concatenate 'string (sv-string (sv-name sv-decl )) (sv-string (concatenate 'string (sv-string "
") (sv-string (concatenate 'string (sv-string "  Namespace_") (sv-string (concatenate 'string (sv-string sv-class_name) (sv-string (concatenate 'string (sv-string ".f_") (sv-string (concatenate 'string (sv-string (sv-name sv-decl )) (sv-string (concatenate 'string (sv-string " = Function( func (v Capture) *Any {") (sv-string "
")))))))))))))))))))(setf sv-str (concatenate 'string (sv-string sv-str) (sv-string (concatenate 'string (sv-string "    ") (sv-string (concatenate 'string (sv-string (sv-emit_go_bind sv-sig )) (sv-string (concatenate 'string (sv-string "
") (sv-string (concatenate 'string (sv-string "    p := make(chan *Any); go func () { ") (sv-string (concatenate 'string (sv-string "
") (sv-string (concatenate 'string (sv-string "        ") (sv-string (concatenate 'string (sv-string (sv-emit_go sv-block )) (sv-string (concatenate 'string (sv-string "; p <- nil }(); ") (sv-string "
")))))))))))))))))))(setf sv-str (concatenate 'string (sv-string sv-str) (sv-string (concatenate 'string (sv-string "    return <-p; ") (sv-string (concatenate 'string (sv-string "
") (sv-string (concatenate 'string (sv-string "  } );") (sv-string "
")))))))))) nil)))(setf sv-str (concatenate 'string (sv-string sv-str) (sv-string (concatenate 'string (sv-string "  // main runtime block of ") (sv-string (concatenate 'string (sv-string (sv-name sv-self)) (sv-string (concatenate 'string (sv-string "
") (sv-string (concatenate 'string (sv-string "  Run_") (sv-string (concatenate 'string (sv-string sv-class_name) (sv-string (concatenate 'string (sv-string " = func () {") (sv-string "
")))))))))))))))(loop for sv-decl across (sv-body sv-self) do (progn (if (sv-bool (sv-and (not (sv-bool (sv-and (typep sv-decl 'mp-Decl) (sv-or (sv-eq (sv-decl sv-decl ) "has") (sv-eq (sv-decl sv-decl ) "my"))))) (sv-and (not (sv-bool (typep sv-decl 'mp-Method))) (not (sv-bool (typep sv-decl 'mp-Sub)))))) (progn (setf sv-str (concatenate 'string (sv-string sv-str) (sv-string (concatenate 'string (sv-string "    ") (sv-string (concatenate 'string (sv-string (sv-emit_go sv-decl )) (sv-string (concatenate 'string (sv-string ";") (sv-string "
")))))))))) nil)))(setf sv-str (concatenate 'string (sv-string sv-str) (sv-string (concatenate 'string (sv-string "  }") (sv-string "
")))))(setf sv-str (concatenate 'string (sv-string sv-str) (sv-string (concatenate 'string (sv-string "}") (sv-string "
")))))(return-from mp6-function sv-str))))

(defun mp-CompUnit-sv-emit_go_program (&optional sv-comp_units )
  (block mp6-function (let ((sv-str (sv-undef))(sv-unit_seen (make-hash-table :test 'equal))(sv-tmp_comp_unit (make-array 0 :fill-pointer t :adjustable t))(sv-meth_seen (make-hash-table :test 'equal))) (setf sv-str "")(loop for sv-comp_unit across sv-comp_units do (let ((sv-name (sv-undef))) (setf sv-name (sv-name sv-comp_unit ))(if (sv-bool (mp-Main::sv-hash-lookup sv-name sv-unit_seen)) (progn (loop for sv-stmt across (sv-body sv-comp_unit ) do (progn (sv-push (sv-body (mp-Main::sv-hash-lookup sv-name sv-unit_seen) ) sv-stmt)))) (progn (setf (mp-Main::sv-hash-lookup sv-name sv-unit_seen) sv-comp_unit)(sv-push sv-tmp_comp_unit sv-comp_unit)))))(setf sv-comp_units sv-tmp_comp_unit)(loop for sv-comp_unit across sv-comp_units do (progn (loop for sv-stmt across (sv-body sv-comp_unit ) do (progn (if (sv-bool (typep sv-stmt 'mp-Method)) (progn (setf (mp-Main::sv-hash-lookup (sv-name sv-stmt ) (sv-methods sv-comp_unit )) sv-stmt)) nil)(if (sv-bool (sv-and (typep sv-stmt 'mp-Decl) (sv-eq (sv-decl sv-stmt ) "has"))) (progn (setf (mp-Main::sv-hash-lookup (sv-name (sv-var sv-stmt ) ) (sv-attributes sv-comp_unit )) sv-stmt)) nil)))))(loop for sv-comp_unit across sv-comp_units do (progn (setf sv-str (concatenate 'string (sv-string sv-str) (sv-string (sv-emit_go sv-comp_unit ))))))(if (sv-bool (not (sv-bool (mp-Main::sv-hash-lookup "MiniPerl6::Grammar" sv-unit_seen)))) (progn (setf sv-str (concatenate 'string (sv-string sv-str) (sv-string "type MiniPerl6__Grammar struct{}
")))) nil)(setf sv-str (concatenate 'string (sv-string sv-str) (sv-string "// interfaces for all methods
")))(setf sv-meth_seen (let ((h (make-hash-table :test 'equal))) (setf (mp-Main::sv-hash-lookup "join" h) 1)(setf (mp-Main::sv-hash-lookup "perl" h) 1)(setf (mp-Main::sv-hash-lookup "scalar" h) 1)(setf (mp-Main::sv-hash-lookup "isa" h) 1)(setf (mp-Main::sv-hash-lookup "values" h) 1)(setf (mp-Main::sv-hash-lookup "keys" h) 1)(setf (mp-Main::sv-hash-lookup "bind" h) 1)(setf (mp-Main::sv-hash-lookup "int" h) 1)(setf (mp-Main::sv-hash-lookup "num" h) 1)(setf (mp-Main::sv-hash-lookup "str" h) 1)(setf (mp-Main::sv-hash-lookup "Str" h) 1)(setf (mp-Main::sv-hash-lookup "bool" h) 1)(setf (mp-Main::sv-hash-lookup "Bool" h) 1)(setf (mp-Main::sv-hash-lookup "array" h) 1)(setf (mp-Main::sv-hash-lookup "hash" h) 1)(setf (mp-Main::sv-hash-lookup "push" h) 1)(setf (mp-Main::sv-hash-lookup "pop" h) 1)(setf (mp-Main::sv-hash-lookup "shift" h) 1)(setf (mp-Main::sv-hash-lookup "lookup" h) 1)(setf (mp-Main::sv-hash-lookup "index" h) 1)(setf (mp-Main::sv-hash-lookup "function" h) 1) h))(loop for sv-comp_unit across sv-comp_units do (progn (loop for sv-stmt across (sv-body sv-comp_unit ) do (progn (if (sv-bool (sv-and (typep sv-stmt 'mp-Method) (not (sv-bool (mp-Main::sv-hash-lookup (sv-name sv-stmt ) sv-meth_seen))))) (let ((sv-meth (sv-undef))) (setf sv-meth (sv-name sv-stmt ))(setf sv-str (concatenate 'string (sv-string sv-str) (sv-string (concatenate 'string (sv-string "type ") (sv-string (concatenate 'string (sv-string sv-meth) (sv-string (concatenate 'string (sv-string "_er interface { f_") (sv-string (concatenate 'string (sv-string sv-meth) (sv-string " (Capture) *Any }
")))))))))))(setf (mp-Main::sv-hash-lookup sv-meth sv-meth_seen) 1)) nil)(if (sv-bool (sv-and (typep sv-stmt 'mp-Decl) (sv-and (sv-eq (sv-decl sv-stmt ) "has") (not (sv-bool (mp-Main::sv-hash-lookup (sv-name (sv-var sv-stmt ) ) sv-meth_seen)))))) (let ((sv-meth (sv-undef))) (setf sv-meth (sv-name (sv-var sv-stmt ) ))(setf sv-str (concatenate 'string (sv-string sv-str) (sv-string (concatenate 'string (sv-string "type ") (sv-string (concatenate 'string (sv-string sv-meth) (sv-string (concatenate 'string (sv-string "_er interface { f_") (sv-string (concatenate 'string (sv-string sv-meth) (sv-string " (Capture) *Any }
")))))))))))(setf (mp-Main::sv-hash-lookup sv-meth sv-meth_seen) 1)) nil)))))(setf sv-str (concatenate 'string (sv-string sv-str) (sv-string (concatenate 'string (sv-string "
") (sv-string (concatenate 'string (sv-string "func main () {
") (sv-string "  Init_MiniPerl6__Match();
")))))))(loop for sv-comp_unit across sv-comp_units do (progn (setf sv-str (concatenate 'string (sv-string sv-str) (sv-string (concatenate 'string (sv-string "  Init_") (sv-string (concatenate 'string (sv-string (mp-Main::sv-to_go_namespace (sv-name sv-comp_unit ))) (sv-string "();
")))))))))(setf sv-str (concatenate 'string (sv-string sv-str) (sv-string "  Init_Prelude();
")))(loop for sv-comp_unit across sv-comp_units do (progn (setf sv-str (concatenate 'string (sv-string sv-str) (sv-string (concatenate 'string (sv-string "  Run_") (sv-string (concatenate 'string (sv-string (mp-Main::sv-to_go_namespace (sv-name sv-comp_unit ))) (sv-string "();
")))))))))(setf sv-str (concatenate 'string (sv-string sv-str) (sv-string (concatenate 'string (sv-string "}") (sv-string "
")))))(return-from mp6-function sv-str))))
(in-package mp-CompUnit)
  (defun sv-emit_go_program (&optional sv-comp_units )
    (mp-Main::mp-CompUnit-sv-emit_go_program sv-comp_units ))
(in-package mp-Main)
(defmethod sv-perl ((self mp-CompUnit))
  (mp-Main::sv-lisp_dump_object "::CompUnit" (list (let ((m (make-instance 'mp-Pair))) (setf (sv-key m) "name") (setf (sv-value m) (sv-name self)) m) (let ((m (make-instance 'mp-Pair))) (setf (sv-key m) "attributes") (setf (sv-value m) (sv-attributes self)) m) (let ((m (make-instance 'mp-Pair))) (setf (sv-key m) "methods") (setf (sv-value m) (sv-methods self)) m) (let ((m (make-instance 'mp-Pair))) (setf (sv-key m) "body") (setf (sv-value m) (sv-body self)) m) )))




;; class Val::Int
(if (not (ignore-errors (find-class 'mp-Val-Int)))
  (defclass mp-Val-Int () ()))

(let (x) 
  (setq x (make-instance 'mp-Val-Int))
  (defun proto-mp-Val-Int () x))
;; has $.int
(let ((new-slots (list (list :name 'sv-int
  :readers '(sv-int)
  :writers '((setf sv-int))
  :initform '(sv-undef)
  :initfunction (constantly (sv-undef))))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-Val-Int)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-Val-Int :direct-slots new-slots))

;; method emit_go
(if (not (ignore-errors (find-method 'sv-emit_go () ())))
  (defgeneric sv-emit_go (sv-self)
      (:documentation "a method")))
(defmethod sv-emit_go ((sv-self mp-Val-Int))
  (block mp6-function
    (progn (concatenate 'string (sv-string "toInt(") (sv-string (concatenate 'string (sv-string (sv-int sv-self)) (sv-string ")")))))))

(defmethod sv-perl ((self mp-Val-Int))
  (mp-Main::sv-lisp_dump_object "::Val::Int" (list (let ((m (make-instance 'mp-Pair))) (setf (sv-key m) "int") (setf (sv-value m) (sv-int self)) m) )))




;; class Val::Bit
(if (not (ignore-errors (find-class 'mp-Val-Bit)))
  (defclass mp-Val-Bit () ()))

(let (x) 
  (setq x (make-instance 'mp-Val-Bit))
  (defun proto-mp-Val-Bit () x))
;; has $.bit
(let ((new-slots (list (list :name 'sv-bit
  :readers '(sv-bit)
  :writers '((setf sv-bit))
  :initform '(sv-undef)
  :initfunction (constantly (sv-undef))))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-Val-Bit)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-Val-Bit :direct-slots new-slots))

;; method emit_go
(if (not (ignore-errors (find-method 'sv-emit_go () ())))
  (defgeneric sv-emit_go (sv-self)
      (:documentation "a method")))
(defmethod sv-emit_go ((sv-self mp-Val-Bit))
  (block mp6-function
    (progn (concatenate 'string (sv-string "toBit(") (sv-string (concatenate 'string (sv-string (sv-bit sv-self)) (sv-string ")")))))))

(defmethod sv-perl ((self mp-Val-Bit))
  (mp-Main::sv-lisp_dump_object "::Val::Bit" (list (let ((m (make-instance 'mp-Pair))) (setf (sv-key m) "bit") (setf (sv-value m) (sv-bit self)) m) )))




;; class Val::Num
(if (not (ignore-errors (find-class 'mp-Val-Num)))
  (defclass mp-Val-Num () ()))

(let (x) 
  (setq x (make-instance 'mp-Val-Num))
  (defun proto-mp-Val-Num () x))
;; has $.num
(let ((new-slots (list (list :name 'sv-num
  :readers '(sv-num)
  :writers '((setf sv-num))
  :initform '(sv-undef)
  :initfunction (constantly (sv-undef))))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-Val-Num)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-Val-Num :direct-slots new-slots))

;; method emit_go
(if (not (ignore-errors (find-method 'sv-emit_go () ())))
  (defgeneric sv-emit_go (sv-self)
      (:documentation "a method")))
(defmethod sv-emit_go ((sv-self mp-Val-Num))
  (block mp6-function
    (progn (concatenate 'string (sv-string "toNum(") (sv-string (concatenate 'string (sv-string (sv-num sv-self)) (sv-string ")")))))))

(defmethod sv-perl ((self mp-Val-Num))
  (mp-Main::sv-lisp_dump_object "::Val::Num" (list (let ((m (make-instance 'mp-Pair))) (setf (sv-key m) "num") (setf (sv-value m) (sv-num self)) m) )))




;; class Val::Buf
(if (not (ignore-errors (find-class 'mp-Val-Buf)))
  (defclass mp-Val-Buf () ()))

(let (x) 
  (setq x (make-instance 'mp-Val-Buf))
  (defun proto-mp-Val-Buf () x))
;; has $.buf
(let ((new-slots (list (list :name 'sv-buf
  :readers '(sv-buf)
  :writers '((setf sv-buf))
  :initform '(sv-undef)
  :initfunction (constantly (sv-undef))))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-Val-Buf)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-Val-Buf :direct-slots new-slots))

;; method emit_go
(if (not (ignore-errors (find-method 'sv-emit_go () ())))
  (defgeneric sv-emit_go (sv-self)
      (:documentation "a method")))
(defmethod sv-emit_go ((sv-self mp-Val-Buf))
  (block mp6-function
    (progn (concatenate 'string (sv-string "toStr(\"") (sv-string (concatenate 'string (sv-string (mp-Main::sv-javascript_escape_string (sv-buf sv-self))) (sv-string "\")")))))))

(defmethod sv-perl ((self mp-Val-Buf))
  (mp-Main::sv-lisp_dump_object "::Val::Buf" (list (let ((m (make-instance 'mp-Pair))) (setf (sv-key m) "buf") (setf (sv-value m) (sv-buf self)) m) )))




;; class Val::Undef
(if (not (ignore-errors (find-class 'mp-Val-Undef)))
  (defclass mp-Val-Undef () ()))

(let (x) 
  (setq x (make-instance 'mp-Val-Undef))
  (defun proto-mp-Val-Undef () x))
;; method emit_go
(if (not (ignore-errors (find-method 'sv-emit_go () ())))
  (defgeneric sv-emit_go (sv-self)
      (:documentation "a method")))
(defmethod sv-emit_go ((sv-self mp-Val-Undef))
  (block mp6-function
    (progn "u_undef()")))

(defmethod sv-perl ((self mp-Val-Undef))
  (mp-Main::sv-lisp_dump_object "::Val::Undef" (list )))




;; class Val::Object
(if (not (ignore-errors (find-class 'mp-Val-Object)))
  (defclass mp-Val-Object () ()))

(let (x) 
  (setq x (make-instance 'mp-Val-Object))
  (defun proto-mp-Val-Object () x))
;; has $.class
(let ((new-slots (list (list :name 'sv-class
  :readers '(sv-class)
  :writers '((setf sv-class))
  :initform '(sv-undef)
  :initfunction (constantly (sv-undef))))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-Val-Object)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-Val-Object :direct-slots new-slots))

;; has $.fields
(let ((new-slots (list (list :name 'sv-fields
  :readers '(sv-fields)
  :writers '((setf sv-fields))
  :initform '(sv-undef)
  :initfunction (constantly (sv-undef))))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-Val-Object)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-Val-Object :direct-slots new-slots))

;; method emit_go
(if (not (ignore-errors (find-method 'sv-emit_go () ())))
  (defgeneric sv-emit_go (sv-self)
      (:documentation "a method")))
(defmethod sv-emit_go ((sv-self mp-Val-Object))
  (block mp6-function
    (progn (progn (write-line (format nil "~{~a~}" (list "Val::Object - not used yet")) *error-output*) (sb-ext:quit)))))

(defmethod sv-perl ((self mp-Val-Object))
  (mp-Main::sv-lisp_dump_object "::Val::Object" (list (let ((m (make-instance 'mp-Pair))) (setf (sv-key m) "class") (setf (sv-value m) (sv-class self)) m) (let ((m (make-instance 'mp-Pair))) (setf (sv-key m) "fields") (setf (sv-value m) (sv-fields self)) m) )))




;; class Lit::Seq
(if (not (ignore-errors (find-class 'mp-Lit-Seq)))
  (defclass mp-Lit-Seq () ()))

(let (x) 
  (setq x (make-instance 'mp-Lit-Seq))
  (defun proto-mp-Lit-Seq () x))
;; has $.seq
(let ((new-slots (list (list :name 'sv-seq
  :readers '(sv-seq)
  :writers '((setf sv-seq))
  :initform '(sv-undef)
  :initfunction (constantly (sv-undef))))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-Lit-Seq)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-Lit-Seq :direct-slots new-slots))

;; method emit_go
(if (not (ignore-errors (find-method 'sv-emit_go () ())))
  (defgeneric sv-emit_go (sv-self)
      (:documentation "a method")))
(defmethod sv-emit_go ((sv-self mp-Lit-Seq))
  (block mp6-function
    (progn (concatenate 'string (sv-string "[]*Any{ ") (sv-string (concatenate 'string (sv-string (sv-join (map 'vector #'(lambda (c) (sv-emit_go  c)) (sv-seq sv-self)) ", ")) (sv-string " }")))))))

(defmethod sv-perl ((self mp-Lit-Seq))
  (mp-Main::sv-lisp_dump_object "::Lit::Seq" (list (let ((m (make-instance 'mp-Pair))) (setf (sv-key m) "seq") (setf (sv-value m) (sv-seq self)) m) )))




;; class Lit::Array
(if (not (ignore-errors (find-class 'mp-Lit-Array)))
  (defclass mp-Lit-Array () ()))

(let (x) 
  (setq x (make-instance 'mp-Lit-Array))
  (defun proto-mp-Lit-Array () x))
;; has $.array1
(let ((new-slots (list (list :name 'sv-array1
  :readers '(sv-array1)
  :writers '((setf sv-array1))
  :initform '(sv-undef)
  :initfunction (constantly (sv-undef))))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-Lit-Array)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-Lit-Array :direct-slots new-slots))

;; method emit_go
(if (not (ignore-errors (find-method 'sv-emit_go () ())))
  (defgeneric sv-emit_go (sv-self)
      (:documentation "a method")))
(defmethod sv-emit_go ((sv-self mp-Lit-Array))
  (block mp6-function
    (let ((sv-str (sv-undef))) (setf sv-str "")(loop for sv-item across (sv-array1 sv-self) do (progn (if (sv-bool (sv-or (sv-and (typep sv-item 'mp-Var) (sv-eq (sv-sigil sv-item ) "@")) (sv-and (typep sv-item 'mp-Apply) (sv-eq (sv-code sv-item ) "prefix:<@>")))) (progn (setf sv-str (concatenate 'string (sv-string sv-str) (sv-string (concatenate 'string (sv-string "func(a_ *Array) { ") (sv-string (concatenate 'string (sv-string "for i_ := 0; i_ <= a_.n; i_++ { (*a).(push_er).f_push( Capture{ p: []*Any{ a_.v[i_] } } ) } ") (sv-string (concatenate 'string (sv-string "}( (*") (sv-string (concatenate 'string (sv-string (mp-Call::sv-emit_go_call sv-item "array")) (sv-string ").(*Array) ); ")))))))))))) (progn (setf sv-str (concatenate 'string (sv-string sv-str) (sv-string (concatenate 'string (sv-string "(*a).(push_er).f_push( Capture{ p: []*Any{ ") (sv-string (concatenate 'string (sv-string (sv-emit_go sv-item )) (sv-string " } } ); ")))))))))))(concatenate 'string (sv-string "func () *Any { ") (sv-string (concatenate 'string (sv-string "a := a_array(); ") (sv-string (concatenate 'string (sv-string sv-str) (sv-string (concatenate 'string (sv-string "return a; ") (sv-string "}()")))))))))))

(defmethod sv-perl ((self mp-Lit-Array))
  (mp-Main::sv-lisp_dump_object "::Lit::Array" (list (let ((m (make-instance 'mp-Pair))) (setf (sv-key m) "array1") (setf (sv-value m) (sv-array1 self)) m) )))




;; class Lit::Hash
(if (not (ignore-errors (find-class 'mp-Lit-Hash)))
  (defclass mp-Lit-Hash () ()))

(let (x) 
  (setq x (make-instance 'mp-Lit-Hash))
  (defun proto-mp-Lit-Hash () x))
;; has $.hash1
(let ((new-slots (list (list :name 'sv-hash1
  :readers '(sv-hash1)
  :writers '((setf sv-hash1))
  :initform '(sv-undef)
  :initfunction (constantly (sv-undef))))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-Lit-Hash)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-Lit-Hash :direct-slots new-slots))

;; method emit_go
(if (not (ignore-errors (find-method 'sv-emit_go () ())))
  (defgeneric sv-emit_go (sv-self)
      (:documentation "a method")))
(defmethod sv-emit_go ((sv-self mp-Lit-Hash))
  (block mp6-function
    (let ((sv-fields (sv-undef))(sv-str (sv-undef))) (setf sv-fields (sv-hash1 sv-self))(setf sv-str "")(loop for sv-field across sv-fields do (progn (setf sv-str (concatenate 'string (sv-string sv-str) (sv-string (concatenate 'string (sv-string "*(*m).(lookup_er).f_lookup( Capture{ p : []*Any{ ") (sv-string (concatenate 'string (sv-string (sv-emit_go (mp-Main::sv-array-index sv-field 0) )) (sv-string (concatenate 'string (sv-string " }} ) = *(") (sv-string (concatenate 'string (sv-string (sv-emit_go (mp-Main::sv-array-index sv-field 1) )) (sv-string "); ")))))))))))))(concatenate 'string (sv-string "func() *Any { ") (sv-string (concatenate 'string (sv-string "m := h_hash(); ") (sv-string (concatenate 'string (sv-string sv-str) (sv-string (concatenate 'string (sv-string "return m; ") (sv-string "}()")))))))))))

(defmethod sv-perl ((self mp-Lit-Hash))
  (mp-Main::sv-lisp_dump_object "::Lit::Hash" (list (let ((m (make-instance 'mp-Pair))) (setf (sv-key m) "hash1") (setf (sv-value m) (sv-hash1 self)) m) )))




;; class Lit::Code
(if (not (ignore-errors (find-class 'mp-Lit-Code)))
  (defclass mp-Lit-Code () ()))

(let (x) 
  (setq x (make-instance 'mp-Lit-Code))
  (defun proto-mp-Lit-Code () x))
(defmethod sv-perl ((self mp-Lit-Code))
  (mp-Main::sv-lisp_dump_object "::Lit::Code" (list )))




;; class Lit::Object
(if (not (ignore-errors (find-class 'mp-Lit-Object)))
  (defclass mp-Lit-Object () ()))

(let (x) 
  (setq x (make-instance 'mp-Lit-Object))
  (defun proto-mp-Lit-Object () x))
;; has $.class
(let ((new-slots (list (list :name 'sv-class
  :readers '(sv-class)
  :writers '((setf sv-class))
  :initform '(sv-undef)
  :initfunction (constantly (sv-undef))))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-Lit-Object)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-Lit-Object :direct-slots new-slots))

;; has $.fields
(let ((new-slots (list (list :name 'sv-fields
  :readers '(sv-fields)
  :writers '((setf sv-fields))
  :initform '(sv-undef)
  :initfunction (constantly (sv-undef))))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-Lit-Object)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-Lit-Object :direct-slots new-slots))

;; method emit_go
(if (not (ignore-errors (find-method 'sv-emit_go () ())))
  (defgeneric sv-emit_go (sv-self)
      (:documentation "a method")))
(defmethod sv-emit_go ((sv-self mp-Lit-Object))
  (block mp6-function
    (let ((sv-fields (sv-undef))(sv-str (sv-undef))) (setf sv-fields (sv-fields sv-self))(setf sv-str "")(loop for sv-field across sv-fields do (progn (setf sv-str (concatenate 'string (sv-string sv-str) (sv-string (concatenate 'string (sv-string "if m.v_") (sv-string (concatenate 'string (sv-string (sv-buf (mp-Main::sv-array-index sv-field 0) )) (sv-string (concatenate 'string (sv-string " == nil {") (sv-string (concatenate 'string (sv-string "
") (sv-string (concatenate 'string (sv-string "var p Any; ") (sv-string (concatenate 'string (sv-string "
") (sv-string (concatenate 'string (sv-string "m.v_") (sv-string (concatenate 'string (sv-string (sv-buf (mp-Main::sv-array-index sv-field 0) )) (sv-string (concatenate 'string (sv-string " = &p; ") (sv-string (concatenate 'string (sv-string "
") (sv-string (concatenate 'string (sv-string "}") (sv-string (concatenate 'string (sv-string "
") (sv-string (concatenate 'string (sv-string "*m.v_") (sv-string (concatenate 'string (sv-string (sv-buf (mp-Main::sv-array-index sv-field 0) )) (sv-string (concatenate 'string (sv-string " = *") (sv-string (concatenate 'string (sv-string (sv-emit_go (mp-Main::sv-array-index sv-field 1) )) (sv-string (concatenate 'string (sv-string "; ") (sv-string "
")))))))))))))))))))))))))))))))))))))))(concatenate 'string (sv-string "func() *Any { ") (sv-string (concatenate 'string (sv-string "
") (sv-string (concatenate 'string (sv-string "  var m = new(") (sv-string (concatenate 'string (sv-string (mp-Main::sv-to_go_namespace (sv-class sv-self))) (sv-string (concatenate 'string (sv-string "); ") (sv-string (concatenate 'string (sv-string "
") (sv-string (concatenate 'string (sv-string "  ") (sv-string (concatenate 'string (sv-string sv-str) (sv-string (concatenate 'string (sv-string "
") (sv-string (concatenate 'string (sv-string "  var m1 Any = m; ") (sv-string (concatenate 'string (sv-string "
") (sv-string (concatenate 'string (sv-string "  return &m1; ") (sv-string (concatenate 'string (sv-string "
") (sv-string "}()")))))))))))))))))))))))))))))

(defmethod sv-perl ((self mp-Lit-Object))
  (mp-Main::sv-lisp_dump_object "::Lit::Object" (list (let ((m (make-instance 'mp-Pair))) (setf (sv-key m) "class") (setf (sv-value m) (sv-class self)) m) (let ((m (make-instance 'mp-Pair))) (setf (sv-key m) "fields") (setf (sv-value m) (sv-fields self)) m) )))




;; class Index
(if (not (ignore-errors (find-class 'mp-Index)))
  (defclass mp-Index () ()))

(let (x) 
  (setq x (make-instance 'mp-Index))
  (defun proto-mp-Index () x))
;; has $.obj
(let ((new-slots (list (list :name 'sv-obj
  :readers '(sv-obj)
  :writers '((setf sv-obj))
  :initform '(sv-undef)
  :initfunction (constantly (sv-undef))))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-Index)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-Index :direct-slots new-slots))

;; has $.index_exp
(let ((new-slots (list (list :name 'sv-index_exp
  :readers '(sv-index_exp)
  :writers '((setf sv-index_exp))
  :initform '(sv-undef)
  :initfunction (constantly (sv-undef))))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-Index)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-Index :direct-slots new-slots))

;; method emit_go
(if (not (ignore-errors (find-method 'sv-emit_go () ())))
  (defgeneric sv-emit_go (sv-self)
      (:documentation "a method")))
(defmethod sv-emit_go ((sv-self mp-Index))
  (block mp6-function
    (progn (concatenate 'string (sv-string "(*(*") (sv-string (concatenate 'string (sv-string (sv-emit_go (sv-obj sv-self) )) (sv-string (concatenate 'string (sv-string ").(array_er).f_array(Capture{}))") (sv-string (concatenate 'string (sv-string ".(index_er).f_index( Capture{ p : []*Any{ ") (sv-string (concatenate 'string (sv-string (sv-emit_go (sv-index_exp sv-self) )) (sv-string " }} )")))))))))))))

(defmethod sv-perl ((self mp-Index))
  (mp-Main::sv-lisp_dump_object "::Index" (list (let ((m (make-instance 'mp-Pair))) (setf (sv-key m) "obj") (setf (sv-value m) (sv-obj self)) m) (let ((m (make-instance 'mp-Pair))) (setf (sv-key m) "index_exp") (setf (sv-value m) (sv-index_exp self)) m) )))




;; class Lookup
(if (not (ignore-errors (find-class 'mp-Lookup)))
  (defclass mp-Lookup () ()))

(let (x) 
  (setq x (make-instance 'mp-Lookup))
  (defun proto-mp-Lookup () x))
;; has $.obj
(let ((new-slots (list (list :name 'sv-obj
  :readers '(sv-obj)
  :writers '((setf sv-obj))
  :initform '(sv-undef)
  :initfunction (constantly (sv-undef))))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-Lookup)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-Lookup :direct-slots new-slots))

;; has $.index_exp
(let ((new-slots (list (list :name 'sv-index_exp
  :readers '(sv-index_exp)
  :writers '((setf sv-index_exp))
  :initform '(sv-undef)
  :initfunction (constantly (sv-undef))))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-Lookup)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-Lookup :direct-slots new-slots))

;; method emit_go
(if (not (ignore-errors (find-method 'sv-emit_go () ())))
  (defgeneric sv-emit_go (sv-self)
      (:documentation "a method")))
(defmethod sv-emit_go ((sv-self mp-Lookup))
  (block mp6-function
    (progn (concatenate 'string (sv-string "(*(*") (sv-string (concatenate 'string (sv-string (sv-emit_go (sv-obj sv-self) )) (sv-string (concatenate 'string (sv-string ").(hash_er).f_hash(Capture{}))") (sv-string (concatenate 'string (sv-string ".(lookup_er).f_lookup( Capture{ p : []*Any{ ") (sv-string (concatenate 'string (sv-string (sv-emit_go (sv-index_exp sv-self) )) (sv-string " }} )")))))))))))))

(defmethod sv-perl ((self mp-Lookup))
  (mp-Main::sv-lisp_dump_object "::Lookup" (list (let ((m (make-instance 'mp-Pair))) (setf (sv-key m) "obj") (setf (sv-value m) (sv-obj self)) m) (let ((m (make-instance 'mp-Pair))) (setf (sv-key m) "index_exp") (setf (sv-value m) (sv-index_exp self)) m) )))




;; class Var
(if (not (ignore-errors (find-class 'mp-Var)))
  (defclass mp-Var () ()))

(let (x) 
  (setq x (make-instance 'mp-Var))
  (defun proto-mp-Var () x))
;; has $.sigil
(let ((new-slots (list (list :name 'sv-sigil
  :readers '(sv-sigil)
  :writers '((setf sv-sigil))
  :initform '(sv-undef)
  :initfunction (constantly (sv-undef))))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-Var)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-Var :direct-slots new-slots))

;; has $.twigil
(let ((new-slots (list (list :name 'sv-twigil
  :readers '(sv-twigil)
  :writers '((setf sv-twigil))
  :initform '(sv-undef)
  :initfunction (constantly (sv-undef))))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-Var)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-Var :direct-slots new-slots))

;; has $.namespace
(let ((new-slots (list (list :name 'sv-namespace
  :readers '(sv-namespace)
  :writers '((setf sv-namespace))
  :initform '(sv-undef)
  :initfunction (constantly (sv-undef))))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-Var)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-Var :direct-slots new-slots))

;; has $.name
(let ((new-slots (list (list :name 'sv-name
  :readers '(sv-name)
  :writers '((setf sv-name))
  :initform '(sv-undef)
  :initfunction (constantly (sv-undef))))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-Var)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-Var :direct-slots new-slots))

;; method emit_go
(if (not (ignore-errors (find-method 'sv-emit_go () ())))
  (defgeneric sv-emit_go (sv-self)
      (:documentation "a method")))
(defmethod sv-emit_go ((sv-self mp-Var))
  (block mp6-function
    (let ((sv-table (sv-undef))(sv-ns (sv-undef))) (setf sv-table (let ((h (make-hash-table :test 'equal))) (setf (mp-Main::sv-hash-lookup "$" h) "v_")(setf (mp-Main::sv-hash-lookup "@" h) "List_")(setf (mp-Main::sv-hash-lookup "%" h) "Hash_")(setf (mp-Main::sv-hash-lookup "&" h) "Code_") h))(setf sv-ns "")(if (sv-bool (sv-namespace sv-self)) (progn (setf sv-ns (concatenate 'string (sv-string (mp-Main::sv-to_go_namespace (sv-namespace sv-self))) (sv-string ".")))) nil)(if (sv-bool (sv-eq (sv-twigil sv-self) ".")) (concatenate 'string (sv-string "(*v_self).(") (sv-string (concatenate 'string (sv-string (sv-name sv-self)) (sv-string (concatenate 'string (sv-string "_er).f_") (sv-string (concatenate 'string (sv-string (sv-name sv-self)) (sv-string "(Capture{})")))))))) (if (sv-bool (sv-eq (sv-name sv-self) "/")) "v_MATCH" (concatenate 'string (sv-string (mp-Main::sv-hash-lookup (sv-sigil sv-self) sv-table)) (sv-string (concatenate 'string (sv-string sv-ns) (sv-string (sv-name sv-self))))))))))

;; method plain_name
(if (not (ignore-errors (find-method 'sv-plain_name () ())))
  (defgeneric sv-plain_name (sv-self)
      (:documentation "a method")))
(defmethod sv-plain_name ((sv-self mp-Var))
  (block mp6-function
    (progn (if (sv-bool (sv-namespace sv-self)) (progn (return-from mp6-function (concatenate 'string (sv-string (sv-namespace sv-self)) (sv-string (concatenate 'string (sv-string ".") (sv-string (sv-name sv-self))))))) nil)(return-from mp6-function (sv-name sv-self)))))

(defmethod sv-perl ((self mp-Var))
  (mp-Main::sv-lisp_dump_object "::Var" (list (let ((m (make-instance 'mp-Pair))) (setf (sv-key m) "sigil") (setf (sv-value m) (sv-sigil self)) m) (let ((m (make-instance 'mp-Pair))) (setf (sv-key m) "twigil") (setf (sv-value m) (sv-twigil self)) m) (let ((m (make-instance 'mp-Pair))) (setf (sv-key m) "namespace") (setf (sv-value m) (sv-namespace self)) m) (let ((m (make-instance 'mp-Pair))) (setf (sv-key m) "name") (setf (sv-value m) (sv-name self)) m) )))




;; class Bind
(if (not (ignore-errors (find-class 'mp-Bind)))
  (defclass mp-Bind () ()))

(let (x) 
  (setq x (make-instance 'mp-Bind))
  (defun proto-mp-Bind () x))
;; has $.parameters
(let ((new-slots (list (list :name 'sv-parameters
  :readers '(sv-parameters)
  :writers '((setf sv-parameters))
  :initform '(sv-undef)
  :initfunction (constantly (sv-undef))))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-Bind)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-Bind :direct-slots new-slots))

;; has $.arguments
(let ((new-slots (list (list :name 'sv-arguments
  :readers '(sv-arguments)
  :writers '((setf sv-arguments))
  :initform '(sv-undef)
  :initfunction (constantly (sv-undef))))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-Bind)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-Bind :direct-slots new-slots))

;; method emit_go
(if (not (ignore-errors (find-method 'sv-emit_go () ())))
  (defgeneric sv-emit_go (sv-self)
      (:documentation "a method")))
(defmethod sv-emit_go ((sv-self mp-Bind))
  (block mp6-function
    (progn (if (sv-bool (typep (sv-parameters sv-self) 'mp-Lit-Array)) (let ((sv-a (sv-undef))(sv-str (sv-undef))(sv-i (sv-undef))) (setf sv-a (sv-array1 (sv-parameters sv-self) ))(setf sv-str (concatenate 'string (sv-string "func () *Any { ") (sv-string (concatenate 'string (sv-string "List_tmp := ") (sv-string (concatenate 'string (sv-string (sv-emit_go (sv-arguments sv-self) )) (sv-string "; ")))))))(setf sv-i 0)(loop for sv-var across sv-a do (let ((sv-bind (sv-undef))) (setf sv-bind (let ((m (make-instance 'mp-Bind))) (setf (sv-parameters m) sv-var)(setf (sv-arguments m) (let ((m (make-instance 'mp-Index))) (setf (sv-obj m) (let ((m (make-instance 'mp-Var))) (setf (sv-sigil m) "@")(setf (sv-twigil m) "")(setf (sv-namespace m) "")(setf (sv-name m) "tmp") m))(setf (sv-index_exp m) (let ((m (make-instance 'mp-Val-Int))) (setf (sv-int m) sv-i) m)) m)) m))(setf sv-str (concatenate 'string (sv-string sv-str) (sv-string (concatenate 'string (sv-string " ") (sv-string (concatenate 'string (sv-string (sv-emit_go sv-bind )) (sv-string "; ")))))))(setf sv-i (sv-add sv-i 1))))(return-from mp6-function (concatenate 'string (sv-string sv-str) (sv-string " return List_tmp }()")))) nil)(if (sv-bool (typep (sv-parameters sv-self) 'mp-Lit-Hash)) (let ((sv-a (sv-undef))(sv-b (sv-undef))(sv-str (sv-undef))(sv-i (sv-undef))(sv-arg (sv-undef))) (setf sv-a (sv-hash1 (sv-parameters sv-self) ))(setf sv-b (sv-hash1 (sv-arguments sv-self) ))(setf sv-str "do { ")(setf sv-i 0)(loop for sv-var across sv-a do (let ((sv-bind (sv-undef))) (setf sv-arg (make-instance 'mp-Val-Undef))(loop for sv-var2 across sv-b do (progn (if (sv-bool (sv-eq (sv-buf (mp-Main::sv-array-index sv-var2 0) ) (sv-buf (mp-Main::sv-array-index sv-var 0) ))) (progn (setf sv-arg (mp-Main::sv-array-index sv-var2 1))) nil)))(setf sv-bind (let ((m (make-instance 'mp-Bind))) (setf (sv-parameters m) (mp-Main::sv-array-index sv-var 1))(setf (sv-arguments m) sv-arg) m))(setf sv-str (concatenate 'string (sv-string sv-str) (sv-string (concatenate 'string (sv-string " ") (sv-string (concatenate 'string (sv-string (sv-emit_go sv-bind )) (sv-string "; ")))))))(setf sv-i (sv-add sv-i 1))))(return-from mp6-function (concatenate 'string (sv-string sv-str) (sv-string (concatenate 'string (sv-string (sv-emit_go (sv-parameters sv-self) )) (sv-string " }")))))) nil)(if (sv-bool (typep (sv-parameters sv-self) 'mp-Lit-Object)) (let ((sv-class (sv-undef))(sv-a (sv-undef))(sv-b (sv-undef))(sv-str (sv-undef))(sv-i (sv-undef))(sv-arg (sv-undef))) (setf sv-class (sv-class (sv-parameters sv-self) ))(setf sv-a (sv-fields (sv-parameters sv-self) ))(setf sv-b (sv-arguments sv-self))(setf sv-str "do { ")(setf sv-i 0)(loop for sv-var across sv-a do (let ((sv-bind (sv-undef))) (setf sv-bind (let ((m (make-instance 'mp-Bind))) (setf (sv-parameters m) (mp-Main::sv-array-index sv-var 1))(setf (sv-arguments m) (let ((m (make-instance 'mp-Call))) (setf (sv-invocant m) sv-b)(setf (sv-method m) (sv-buf (mp-Main::sv-array-index sv-var 0) ))(setf (sv-arguments m) (make-array 0 :adjustable 1 :fill-pointer t))(setf (sv-hyper m) 0) m)) m))(setf sv-str (concatenate 'string (sv-string sv-str) (sv-string (concatenate 'string (sv-string " ") (sv-string (concatenate 'string (sv-string (sv-emit_go sv-bind )) (sv-string "; ")))))))(setf sv-i (sv-add sv-i 1))))(return-from mp6-function (concatenate 'string (sv-string sv-str) (sv-string (concatenate 'string (sv-string (sv-emit_go (sv-parameters sv-self) )) (sv-string " }")))))) nil)(if (sv-bool (typep (sv-parameters sv-self) 'mp-Call)) (progn (return-from mp6-function (concatenate 'string (sv-string "func () *Any { ") (sv-string (concatenate 'string (sv-string "var tmp = ") (sv-string (concatenate 'string (sv-string (mp-Call::sv-emit_go_call (sv-invocant (sv-parameters sv-self) ) (sv-method (sv-parameters sv-self) ))) (sv-string (concatenate 'string (sv-string "; ") (sv-string (concatenate 'string (sv-string "*tmp = *( ") (sv-string (concatenate 'string (sv-string (sv-emit_go (sv-arguments sv-self) )) (sv-string (concatenate 'string (sv-string " ); ") (sv-string (concatenate 'string (sv-string "return tmp; ") (sv-string "}()")))))))))))))))))) nil)(concatenate 'string (sv-string "*") (sv-string (concatenate 'string (sv-string (sv-emit_go (sv-parameters sv-self) )) (sv-string (concatenate 'string (sv-string " = *(") (sv-string (concatenate 'string (sv-string (sv-emit_go (sv-arguments sv-self) )) (sv-string ")")))))))))))

(defmethod sv-perl ((self mp-Bind))
  (mp-Main::sv-lisp_dump_object "::Bind" (list (let ((m (make-instance 'mp-Pair))) (setf (sv-key m) "parameters") (setf (sv-value m) (sv-parameters self)) m) (let ((m (make-instance 'mp-Pair))) (setf (sv-key m) "arguments") (setf (sv-value m) (sv-arguments self)) m) )))




;; class Proto
(if (not (ignore-errors (find-class 'mp-Proto)))
  (defclass mp-Proto () ()))

(let (x) 
  (setq x (make-instance 'mp-Proto))
  (defun proto-mp-Proto () x))
;; has $.name
(let ((new-slots (list (list :name 'sv-name
  :readers '(sv-name)
  :writers '((setf sv-name))
  :initform '(sv-undef)
  :initfunction (constantly (sv-undef))))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-Proto)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-Proto :direct-slots new-slots))

;; method emit_go
(if (not (ignore-errors (find-method 'sv-emit_go () ())))
  (defgeneric sv-emit_go (sv-self)
      (:documentation "a method")))
(defmethod sv-emit_go ((sv-self mp-Proto))
  (block mp6-function
    (progn (mp-Main::sv-to_go_namespace (sv-name sv-self)))))

(defmethod sv-perl ((self mp-Proto))
  (mp-Main::sv-lisp_dump_object "::Proto" (list (let ((m (make-instance 'mp-Pair))) (setf (sv-key m) "name") (setf (sv-value m) (sv-name self)) m) )))




;; class Call
(if (not (ignore-errors (find-class 'mp-Call)))
  (defclass mp-Call () ()))

(let (x) 
  (setq x (make-instance 'mp-Call))
  (defun proto-mp-Call () x))
;; has $.invocant
(let ((new-slots (list (list :name 'sv-invocant
  :readers '(sv-invocant)
  :writers '((setf sv-invocant))
  :initform '(sv-undef)
  :initfunction (constantly (sv-undef))))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-Call)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-Call :direct-slots new-slots))

;; has $.hyper
(let ((new-slots (list (list :name 'sv-hyper
  :readers '(sv-hyper)
  :writers '((setf sv-hyper))
  :initform '(sv-undef)
  :initfunction (constantly (sv-undef))))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-Call)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-Call :direct-slots new-slots))

;; has $.method
(let ((new-slots (list (list :name 'sv-method
  :readers '(sv-method)
  :writers '((setf sv-method))
  :initform '(sv-undef)
  :initfunction (constantly (sv-undef))))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-Call)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-Call :direct-slots new-slots))

;; has $.arguments
(let ((new-slots (list (list :name 'sv-arguments
  :readers '(sv-arguments)
  :writers '((setf sv-arguments))
  :initform '(sv-undef)
  :initfunction (constantly (sv-undef))))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-Call)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-Call :direct-slots new-slots))

;; method emit_go
(if (not (ignore-errors (find-method 'sv-emit_go () ())))
  (defgeneric sv-emit_go (sv-self)
      (:documentation "a method")))
(defmethod sv-emit_go ((sv-self mp-Call))
  (block mp6-function
    (let ((sv-invocant (sv-undef))(sv-meth (sv-undef))) (setf sv-invocant (sv-emit_go (sv-invocant sv-self) ))(if (sv-bool (typep (sv-invocant sv-self) 'mp-Proto)) (progn (if (sv-bool (sv-eq (sv-name (sv-invocant sv-self) ) "self")) (progn (setf sv-invocant "v_self")) (progn (setf sv-invocant (concatenate 'string (sv-string "Proto_") (sv-string sv-invocant)))))) nil)(setf sv-meth (sv-method sv-self))(if (sv-bool (sv-eq sv-meth "postcircumfix:<( )>")) (progn (if (sv-bool (sv-hyper sv-self)) (progn (setf sv-meth "")) (progn (return-from mp6-function (concatenate 'string (sv-string "((*") (sv-string (concatenate 'string (sv-string sv-invocant) (sv-string (concatenate 'string (sv-string ").(function_er).f_function( Capture{ p : []*Any{ ") (sv-string (concatenate 'string (sv-string (sv-join (map 'vector #'(lambda (c) (sv-emit_go  c)) (sv-arguments sv-self)) ", ")) (sv-string " } } ))")))))))))))) nil)(if (sv-bool (sv-hyper sv-self)) (progn (return-from mp6-function (concatenate 'string (sv-string "func (a_ *Any) *Any { ") (sv-string (concatenate 'string (sv-string "
") (sv-string (concatenate 'string (sv-string "  var out = a_array(); ") (sv-string (concatenate 'string (sv-string "
") (sv-string (concatenate 'string (sv-string "  var i = (*(*a_).(array_er).f_array(Capture{})).(*Array); ") (sv-string (concatenate 'string (sv-string "
") (sv-string (concatenate 'string (sv-string "  for pos := 0; pos <= i.n; pos++ { ") (sv-string (concatenate 'string (sv-string "
") (sv-string (concatenate 'string (sv-string "    (*out).(push_er).f_push( Capture{p: []*Any{ (*i.v[pos]).(") (sv-string (concatenate 'string (sv-string sv-meth) (sv-string (concatenate 'string (sv-string "_er).f_") (sv-string (concatenate 'string (sv-string sv-meth) (sv-string (concatenate 'string (sv-string "(Capture{ p : []*Any{}  }) }} )") (sv-string (concatenate 'string (sv-string "
") (sv-string (concatenate 'string (sv-string "  } ") (sv-string (concatenate 'string (sv-string "
") (sv-string (concatenate 'string (sv-string "  return out; ") (sv-string (concatenate 'string (sv-string "
") (sv-string (concatenate 'string (sv-string "}(") (sv-string (concatenate 'string (sv-string sv-invocant) (sv-string ")")))))))))))))))))))))))))))))))))))))))))) nil)(return-from mp6-function (concatenate 'string (sv-string "(*") (sv-string (concatenate 'string (sv-string sv-invocant) (sv-string (concatenate 'string (sv-string ").(") (sv-string (concatenate 'string (sv-string sv-meth) (sv-string (concatenate 'string (sv-string "_er).f_") (sv-string (concatenate 'string (sv-string sv-meth) (sv-string (concatenate 'string (sv-string "( Capture{ p : []*Any{ ") (sv-string (concatenate 'string (sv-string (sv-join (map 'vector #'(lambda (c) (sv-emit_go  c)) (sv-arguments sv-self)) ", ")) (sv-string " } } )"))))))))))))))))))))

(defun mp-Call-sv-emit_go_call (&optional sv-invocant sv-meth_name )
  (block mp6-function (let ((sv-invocant1 (sv-undef))(sv-meth (sv-undef))) (setf sv-invocant1 (sv-emit_go sv-invocant ))(if (sv-bool (typep sv-invocant 'mp-Proto)) (progn (setf sv-invocant1 (concatenate 'string (sv-string "Proto_") (sv-string sv-invocant1)))) nil)(setf sv-meth sv-meth_name)(return-from mp6-function (concatenate 'string (sv-string "(*") (sv-string (concatenate 'string (sv-string sv-invocant1) (sv-string (concatenate 'string (sv-string ").(") (sv-string (concatenate 'string (sv-string sv-meth) (sv-string (concatenate 'string (sv-string "_er).f_") (sv-string (concatenate 'string (sv-string sv-meth) (sv-string "(Capture{})"))))))))))))))))
(in-package mp-Call)
  (defun sv-emit_go_call (&optional sv-invocant sv-meth_name )
    (mp-Main::mp-Call-sv-emit_go_call sv-invocant sv-meth_name ))
(in-package mp-Main)
(defmethod sv-perl ((self mp-Call))
  (mp-Main::sv-lisp_dump_object "::Call" (list (let ((m (make-instance 'mp-Pair))) (setf (sv-key m) "invocant") (setf (sv-value m) (sv-invocant self)) m) (let ((m (make-instance 'mp-Pair))) (setf (sv-key m) "hyper") (setf (sv-value m) (sv-hyper self)) m) (let ((m (make-instance 'mp-Pair))) (setf (sv-key m) "method") (setf (sv-value m) (sv-method self)) m) (let ((m (make-instance 'mp-Pair))) (setf (sv-key m) "arguments") (setf (sv-value m) (sv-arguments self)) m) )))




;; class Apply
(if (not (ignore-errors (find-class 'mp-Apply)))
  (defclass mp-Apply () ()))

(let (x) 
  (setq x (make-instance 'mp-Apply))
  (defun proto-mp-Apply () x))
;; has $.code
(let ((new-slots (list (list :name 'sv-code
  :readers '(sv-code)
  :writers '((setf sv-code))
  :initform '(sv-undef)
  :initfunction (constantly (sv-undef))))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-Apply)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-Apply :direct-slots new-slots))

;; has $.arguments
(let ((new-slots (list (list :name 'sv-arguments
  :readers '(sv-arguments)
  :writers '((setf sv-arguments))
  :initform '(sv-undef)
  :initfunction (constantly (sv-undef))))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-Apply)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-Apply :direct-slots new-slots))

;; has $.namespace
(let ((new-slots (list (list :name 'sv-namespace
  :readers '(sv-namespace)
  :writers '((setf sv-namespace))
  :initform '(sv-undef)
  :initfunction (constantly (sv-undef))))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-Apply)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-Apply :direct-slots new-slots))

;; method emit_go
(if (not (ignore-errors (find-method 'sv-emit_go () ())))
  (defgeneric sv-emit_go (sv-self)
      (:documentation "a method")))
(defmethod sv-emit_go ((sv-self mp-Apply))
  (block mp6-function
    (let ((sv-code (sv-undef))) (setf sv-code (sv-code sv-self))(if (sv-bool (typep sv-code 'string)) nil (progn (return-from mp6-function (concatenate 'string (sv-string "(") (sv-string (concatenate 'string (sv-string (sv-emit_go (sv-code sv-self) )) (sv-string (concatenate 'string (sv-string ")->(") (sv-string (concatenate 'string (sv-string (sv-join (map 'vector #'(lambda (c) (sv-emit  c)) (sv-arguments sv-self)) ", ")) (sv-string ")")))))))))))(if (sv-bool (sv-eq sv-code "self")) (progn (return-from mp6-function "v_self")) nil)(if (sv-bool (sv-eq sv-code "false")) (progn (return-from mp6-function "b_false()")) nil)(if (sv-bool (sv-eq sv-code "make")) (progn (return-from mp6-function (concatenate 'string (sv-string "func () *Any { ") (sv-string (concatenate 'string (sv-string "tmp := ") (sv-string (concatenate 'string (sv-string (sv-join (map 'vector #'(lambda (c) (sv-emit_go  c)) (sv-arguments sv-self)) ", ")) (sv-string (concatenate 'string (sv-string "; ") (sv-string (concatenate 'string (sv-string "*(*v_MATCH).(capture_er).f_capture(Capture{}) = *tmp; ") (sv-string (concatenate 'string (sv-string "return tmp; ") (sv-string "}()")))))))))))))) nil)(if (sv-bool (sv-eq sv-code "say")) (progn (return-from mp6-function (concatenate 'string (sv-string "f_print( Capture{ p : []*Any{ ") (sv-string (concatenate 'string (sv-string (sv-join (map 'vector #'(lambda (c) (sv-emit_go  c)) (sv-arguments sv-self)) ", ")) (sv-string ", toStr(\"\\n\") } } )")))))) nil)(if (sv-bool (sv-eq sv-code "print")) (progn (return-from mp6-function (concatenate 'string (sv-string "f_print( Capture{ p : []*Any{ ") (sv-string (concatenate 'string (sv-string (sv-join (map 'vector #'(lambda (c) (sv-emit_go  c)) (sv-arguments sv-self)) ", ")) (sv-string " } } )")))))) nil)(if (sv-bool (sv-eq sv-code "warn")) (progn (return-from mp6-function (concatenate 'string (sv-string "f_print_stderr( Capture{ p : []*Any{ ") (sv-string (concatenate 'string (sv-string (sv-join (map 'vector #'(lambda (c) (sv-emit_go  c)) (sv-arguments sv-self)) ", ")) (sv-string ", toStr(\"\\n\") } } )")))))) nil)(if (sv-bool (sv-eq sv-code "die")) (progn (return-from mp6-function (concatenate 'string (sv-string "f_die( Capture{ p : []*Any{ ") (sv-string (concatenate 'string (sv-string (sv-join (map 'vector #'(lambda (c) (sv-emit_go  c)) (sv-arguments sv-self)) ", ")) (sv-string " } } )")))))) nil)(if (sv-bool (sv-eq sv-code "defined")) (progn (return-from mp6-function (concatenate 'string (sv-string "f_defined( Capture{ p : []*Any{ ") (sv-string (concatenate 'string (sv-string (sv-join (map 'vector #'(lambda (c) (sv-emit_go  c)) (sv-arguments sv-self)) ", ")) (sv-string " } } )")))))) nil)(if (sv-bool (sv-eq sv-code "pop")) (progn (return-from mp6-function (concatenate 'string (sv-string "f_pop( Capture{ p : []*Any{ ") (sv-string (concatenate 'string (sv-string (sv-join (map 'vector #'(lambda (c) (sv-emit_go  c)) (sv-arguments sv-self)) ", ")) (sv-string " } } )")))))) nil)(if (sv-bool (sv-eq sv-code "push")) (progn (return-from mp6-function (concatenate 'string (sv-string "f_push( Capture{ p : []*Any{ ") (sv-string (concatenate 'string (sv-string (sv-join (map 'vector #'(lambda (c) (sv-emit_go  c)) (sv-arguments sv-self)) ", ")) (sv-string " } } )")))))) nil)(if (sv-bool (sv-eq sv-code "shift")) (progn (return-from mp6-function (concatenate 'string (sv-string "f_shift( Capture{ p : []*Any{ ") (sv-string (concatenate 'string (sv-string (sv-join (map 'vector #'(lambda (c) (sv-emit_go  c)) (sv-arguments sv-self)) ", ")) (sv-string " } } )")))))) nil)(if (sv-bool (sv-eq sv-code "index")) (progn (return-from mp6-function (concatenate 'string (sv-string "f_index( Capture{ p : []*Any{ ") (sv-string (concatenate 'string (sv-string (sv-join (map 'vector #'(lambda (c) (sv-emit_go  c)) (sv-arguments sv-self)) ", ")) (sv-string " } } )")))))) nil)(if (sv-bool (sv-eq sv-code "substr")) (progn (return-from mp6-function (concatenate 'string (sv-string "f_substr( Capture{ p : []*Any{ ") (sv-string (concatenate 'string (sv-string (sv-join (map 'vector #'(lambda (c) (sv-emit_go  c)) (sv-arguments sv-self)) ", ")) (sv-string " } } )")))))) nil)(if (sv-bool (sv-eq sv-code "scalar")) (progn (return-from mp6-function (concatenate 'string (sv-string "f_scalar( Capture{ p : []*Any{ ") (sv-string (concatenate 'string (sv-string (sv-join (map 'vector #'(lambda (c) (sv-emit_go  c)) (sv-arguments sv-self)) ", ")) (sv-string " } } )")))))) nil)(if (sv-bool (sv-eq sv-code "Int")) (progn (return-from mp6-function (concatenate 'string (sv-string "toInt(") (sv-string (concatenate 'string (sv-string "toint(") (sv-string (concatenate 'string (sv-string (sv-emit_go (mp-Main::sv-array-index (sv-arguments sv-self) 0) )) (sv-string (concatenate 'string (sv-string ")") (sv-string ")")))))))))) nil)(if (sv-bool (sv-eq sv-code "Num")) (progn (return-from mp6-function (concatenate 'string (sv-string "toNum(") (sv-string (concatenate 'string (sv-string "tonum(") (sv-string (concatenate 'string (sv-string (sv-emit_go (mp-Main::sv-array-index (sv-arguments sv-self) 0) )) (sv-string (concatenate 'string (sv-string ")") (sv-string ")")))))))))) nil)(if (sv-bool (sv-eq sv-code "exists")) (let ((sv-arg (sv-undef))) (setf sv-arg (mp-Main::sv-array-index (sv-arguments sv-self) 0))(if (sv-bool (typep sv-arg 'mp-Lookup)) (progn (return-from mp6-function (concatenate 'string (sv-string "(*") (sv-string (concatenate 'string (sv-string (sv-emit_go (sv-obj sv-arg ) )) (sv-string (concatenate 'string (sv-string ")") (sv-string (concatenate 'string (sv-string ".(exists_er).f_exists(Capture{ p : []*Any{ ") (sv-string (concatenate 'string (sv-string (sv-emit_go (sv-index_exp sv-arg ) )) (sv-string " } } )")))))))))))) nil)) nil)(if (sv-bool (sv-eq sv-code "prefix:<~>")) (progn (return-from mp6-function (mp-Call::sv-emit_go_call (mp-Main::sv-array-index (sv-arguments sv-self) 0) "Str"))) nil)(if (sv-bool (sv-eq sv-code "prefix:<!>")) (progn (return-from mp6-function (concatenate 'string (sv-string "toBool(!tobool(") (sv-string (concatenate 'string (sv-string (sv-emit_go (mp-Main::sv-array-index (sv-arguments sv-self) 0) )) (sv-string "))")))))) nil)(if (sv-bool (sv-eq sv-code "prefix:<?>")) (progn (return-from mp6-function (mp-Call::sv-emit_go_call (mp-Main::sv-array-index (sv-arguments sv-self) 0) "Bool"))) nil)(if (sv-bool (sv-eq sv-code "prefix:<$>")) (progn (return-from mp6-function (concatenate 'string (sv-string "f_scalar( Capture{ p : []*Any{ ") (sv-string (concatenate 'string (sv-string (sv-join (map 'vector #'(lambda (c) (sv-emit_go  c)) (sv-arguments sv-self)) ", ")) (sv-string " } } )")))))) nil)(if (sv-bool (sv-eq sv-code "prefix:<@>")) (progn (return-from mp6-function (mp-Call::sv-emit_go_call (mp-Main::sv-array-index (sv-arguments sv-self) 0) "array"))) nil)(if (sv-bool (sv-eq sv-code "prefix:<%>")) (progn (return-from mp6-function (mp-Call::sv-emit_go_call (mp-Main::sv-array-index (sv-arguments sv-self) 0) "hash"))) nil)(if (sv-bool (sv-eq sv-code "infix:<~>")) (progn (return-from mp6-function (concatenate 'string (sv-string "toStr( ") (sv-string (concatenate 'string (sv-string "tostr(") (sv-string (concatenate 'string (sv-string (sv-emit_go (mp-Main::sv-array-index (sv-arguments sv-self) 0) )) (sv-string (concatenate 'string (sv-string ") + ") (sv-string (concatenate 'string (sv-string "tostr(") (sv-string (concatenate 'string (sv-string (sv-emit_go (mp-Main::sv-array-index (sv-arguments sv-self) 1) )) (sv-string (concatenate 'string (sv-string ") ") (sv-string ")")))))))))))))))) nil)(if (sv-bool (sv-eq sv-code "infix:<+>")) (progn (return-from mp6-function (concatenate 'string (sv-string "f_add( ") (sv-string (concatenate 'string (sv-string (sv-join (map 'vector #'(lambda (c) (sv-emit_go  c)) (sv-arguments sv-self)) ", ")) (sv-string ")")))))) nil)(if (sv-bool (sv-eq sv-code "infix:<->")) (progn (return-from mp6-function (concatenate 'string (sv-string "f_sub( ") (sv-string (concatenate 'string (sv-string (sv-join (map 'vector #'(lambda (c) (sv-emit_go  c)) (sv-arguments sv-self)) ", ")) (sv-string ")")))))) nil)(if (sv-bool (sv-eq sv-code "infix:<*>")) (progn (return-from mp6-function (concatenate 'string (sv-string "f_mul( ") (sv-string (concatenate 'string (sv-string (sv-join (map 'vector #'(lambda (c) (sv-emit_go  c)) (sv-arguments sv-self)) ", ")) (sv-string ")")))))) nil)(if (sv-bool (sv-eq sv-code "infix:</>")) (progn (return-from mp6-function (concatenate 'string (sv-string "f_div( ") (sv-string (concatenate 'string (sv-string (sv-join (map 'vector #'(lambda (c) (sv-emit_go  c)) (sv-arguments sv-self)) ", ")) (sv-string ")")))))) nil)(if (sv-bool (sv-eq sv-code "infix:<>>")) (progn (return-from mp6-function (concatenate 'string (sv-string "f_greater( ") (sv-string (concatenate 'string (sv-string (sv-join (map 'vector #'(lambda (c) (sv-emit_go  c)) (sv-arguments sv-self)) ", ")) (sv-string ")")))))) nil)(if (sv-bool (sv-eq sv-code "infix:<<>")) (progn (return-from mp6-function (concatenate 'string (sv-string "f_smaller( ") (sv-string (concatenate 'string (sv-string (sv-join (map 'vector #'(lambda (c) (sv-emit_go  c)) (sv-arguments sv-self)) ", ")) (sv-string ")")))))) nil)(if (sv-bool (sv-eq sv-code "infix:<>=>")) (progn (return-from mp6-function (concatenate 'string (sv-string "toBool( ") (sv-string (concatenate 'string (sv-string "toint(") (sv-string (concatenate 'string (sv-string (sv-emit_go (mp-Main::sv-array-index (sv-arguments sv-self) 0) )) (sv-string (concatenate 'string (sv-string ") >= ") (sv-string (concatenate 'string (sv-string "toint(") (sv-string (concatenate 'string (sv-string (sv-emit_go (mp-Main::sv-array-index (sv-arguments sv-self) 1) )) (sv-string (concatenate 'string (sv-string ") ") (sv-string ")")))))))))))))))) nil)(if (sv-bool (sv-eq sv-code "infix:<<=>")) (progn (return-from mp6-function (concatenate 'string (sv-string "toBool( ") (sv-string (concatenate 'string (sv-string "toint(") (sv-string (concatenate 'string (sv-string (sv-emit_go (mp-Main::sv-array-index (sv-arguments sv-self) 0) )) (sv-string (concatenate 'string (sv-string ") <= ") (sv-string (concatenate 'string (sv-string "toint(") (sv-string (concatenate 'string (sv-string (sv-emit_go (mp-Main::sv-array-index (sv-arguments sv-self) 1) )) (sv-string (concatenate 'string (sv-string ") ") (sv-string ")")))))))))))))))) nil)(if (sv-bool (sv-eq sv-code "infix:<&&>")) (progn (return-from mp6-function (concatenate 'string (sv-string "f_and( ") (sv-string (concatenate 'string (sv-string "func () *Any { return ") (sv-string (concatenate 'string (sv-string (sv-emit_go (mp-Main::sv-array-index (sv-arguments sv-self) 0) )) (sv-string (concatenate 'string (sv-string " }, ") (sv-string (concatenate 'string (sv-string "func () *Any { return ") (sv-string (concatenate 'string (sv-string (sv-emit_go (mp-Main::sv-array-index (sv-arguments sv-self) 1) )) (sv-string (concatenate 'string (sv-string " } ") (sv-string ")")))))))))))))))) nil)(if (sv-bool (sv-eq sv-code "infix:<||>")) (progn (return-from mp6-function (concatenate 'string (sv-string "f_or( ") (sv-string (concatenate 'string (sv-string "func () *Any { return ") (sv-string (concatenate 'string (sv-string (sv-emit_go (mp-Main::sv-array-index (sv-arguments sv-self) 0) )) (sv-string (concatenate 'string (sv-string " }, ") (sv-string (concatenate 'string (sv-string "func () *Any { return ") (sv-string (concatenate 'string (sv-string (sv-emit_go (mp-Main::sv-array-index (sv-arguments sv-self) 1) )) (sv-string (concatenate 'string (sv-string " } ") (sv-string ")")))))))))))))))) nil)(if (sv-bool (sv-eq sv-code "infix:<eq>")) (progn (return-from mp6-function (concatenate 'string (sv-string "toBool(") (sv-string (concatenate 'string (sv-string "tostr(") (sv-string (concatenate 'string (sv-string (sv-emit_go (mp-Main::sv-array-index (sv-arguments sv-self) 0) )) (sv-string (concatenate 'string (sv-string ") == ") (sv-string (concatenate 'string (sv-string "tostr(") (sv-string (concatenate 'string (sv-string (sv-emit_go (mp-Main::sv-array-index (sv-arguments sv-self) 1) )) (sv-string (concatenate 'string (sv-string ")") (sv-string ")")))))))))))))))) nil)(if (sv-bool (sv-eq sv-code "infix:<ne>")) (progn (return-from mp6-function (concatenate 'string (sv-string "toBool(") (sv-string (concatenate 'string (sv-string "tostr(") (sv-string (concatenate 'string (sv-string (sv-emit_go (mp-Main::sv-array-index (sv-arguments sv-self) 0) )) (sv-string (concatenate 'string (sv-string ") != ") (sv-string (concatenate 'string (sv-string "tostr(") (sv-string (concatenate 'string (sv-string (sv-emit_go (mp-Main::sv-array-index (sv-arguments sv-self) 1) )) (sv-string (concatenate 'string (sv-string ")") (sv-string ")")))))))))))))))) nil)(if (sv-bool (sv-eq sv-code "infix:<==>")) (progn (return-from mp6-function (concatenate 'string (sv-string "toBool(") (sv-string (concatenate 'string (sv-string "toint(") (sv-string (concatenate 'string (sv-string (sv-emit_go (mp-Main::sv-array-index (sv-arguments sv-self) 0) )) (sv-string (concatenate 'string (sv-string ") == ") (sv-string (concatenate 'string (sv-string "toint(") (sv-string (concatenate 'string (sv-string (sv-emit_go (mp-Main::sv-array-index (sv-arguments sv-self) 1) )) (sv-string (concatenate 'string (sv-string ") ") (sv-string ")")))))))))))))))) nil)(if (sv-bool (sv-eq sv-code "infix:<!=>")) (progn (return-from mp6-function (concatenate 'string (sv-string "toBool(") (sv-string (concatenate 'string (sv-string "toint(") (sv-string (concatenate 'string (sv-string (sv-emit_go (mp-Main::sv-array-index (sv-arguments sv-self) 0) )) (sv-string (concatenate 'string (sv-string ") != ") (sv-string (concatenate 'string (sv-string "toint(") (sv-string (concatenate 'string (sv-string (sv-emit_go (mp-Main::sv-array-index (sv-arguments sv-self) 1) )) (sv-string (concatenate 'string (sv-string ") ") (sv-string ")")))))))))))))))) nil)(if (sv-bool (sv-eq sv-code "ternary:<?? !!>")) (progn (return-from mp6-function (concatenate 'string (sv-string "func () *Any { ") (sv-string (concatenate 'string (sv-string "if tobool( ") (sv-string (concatenate 'string (sv-string (mp-Call::sv-emit_go_call (mp-Main::sv-array-index (sv-arguments sv-self) 0) "Bool")) (sv-string (concatenate 'string (sv-string " ) ") (sv-string (concatenate 'string (sv-string "{ return ") (sv-string (concatenate 'string (sv-string (sv-emit_go (mp-Main::sv-array-index (sv-arguments sv-self) 1) )) (sv-string (concatenate 'string (sv-string " }; ") (sv-string (concatenate 'string (sv-string "return ") (sv-string (concatenate 'string (sv-string (sv-emit_go (mp-Main::sv-array-index (sv-arguments sv-self) 2) )) (sv-string (concatenate 'string (sv-string " ") (sv-string "}()")))))))))))))))))))))) nil)(setf sv-code (concatenate 'string (sv-string "f_") (sv-string (sv-code sv-self))))(if (sv-bool (sv-namespace sv-self)) (progn (setf sv-code (concatenate 'string (sv-string "Namespace_") (sv-string (concatenate 'string (sv-string (mp-Main::sv-to_go_namespace (sv-namespace sv-self))) (sv-string (concatenate 'string (sv-string ".") (sv-string sv-code)))))))) (progn (setf sv-code (concatenate 'string (sv-string "this_namespace.") (sv-string sv-code)))))(concatenate 'string (sv-string sv-code) (sv-string (concatenate 'string (sv-string "( Capture{ p : []*Any{ ") (sv-string (concatenate 'string (sv-string (sv-join (map 'vector #'(lambda (c) (sv-emit_go  c)) (sv-arguments sv-self)) ", ")) (sv-string " } } )")))))))))

(defmethod sv-perl ((self mp-Apply))
  (mp-Main::sv-lisp_dump_object "::Apply" (list (let ((m (make-instance 'mp-Pair))) (setf (sv-key m) "code") (setf (sv-value m) (sv-code self)) m) (let ((m (make-instance 'mp-Pair))) (setf (sv-key m) "arguments") (setf (sv-value m) (sv-arguments self)) m) (let ((m (make-instance 'mp-Pair))) (setf (sv-key m) "namespace") (setf (sv-value m) (sv-namespace self)) m) )))




;; class Return
(if (not (ignore-errors (find-class 'mp-Return)))
  (defclass mp-Return () ()))

(let (x) 
  (setq x (make-instance 'mp-Return))
  (defun proto-mp-Return () x))
;; has $.result
(let ((new-slots (list (list :name 'sv-result
  :readers '(sv-result)
  :writers '((setf sv-result))
  :initform '(sv-undef)
  :initfunction (constantly (sv-undef))))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-Return)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-Return :direct-slots new-slots))

;; method emit_go
(if (not (ignore-errors (find-method 'sv-emit_go () ())))
  (defgeneric sv-emit_go (sv-self)
      (:documentation "a method")))
(defmethod sv-emit_go ((sv-self mp-Return))
  (block mp6-function
    (progn (if (sv-bool (typep (sv-result sv-self) 'mp-Bind)) (let ((sv-tmp (sv-undef))) (setf sv-tmp (sv-parameters (sv-result sv-self) ))(return-from mp6-function (concatenate 'string (sv-string "(func () { ") (sv-string (concatenate 'string (sv-string (sv-emit_go (sv-result sv-self) )) (sv-string (concatenate 'string (sv-string "; ") (sv-string (concatenate 'string (sv-string "p <- ") (sv-string (concatenate 'string (sv-string (sv-emit_go sv-tmp )) (sv-string (concatenate 'string (sv-string "; ") (sv-string (concatenate 'string (sv-string "runtime.Goexit(); ") (sv-string "}())")))))))))))))))) nil)(return-from mp6-function (concatenate 'string (sv-string "(func () { ") (sv-string (concatenate 'string (sv-string "var tmp *Any = ") (sv-string (concatenate 'string (sv-string (sv-emit_go (sv-result sv-self) )) (sv-string (concatenate 'string (sv-string "; ") (sv-string (concatenate 'string (sv-string "p <- tmp; ") (sv-string (concatenate 'string (sv-string "runtime.Goexit(); ") (sv-string "}())"))))))))))))))))

;; method emit_go_simple
(if (not (ignore-errors (find-method 'sv-emit_go_simple () ())))
  (defgeneric sv-emit_go_simple (sv-self)
      (:documentation "a method")))
(defmethod sv-emit_go_simple ((sv-self mp-Return))
  (block mp6-function
    (progn (if (sv-bool (typep (sv-result sv-self) 'mp-Bind)) (let ((sv-tmp (sv-undef))) (setf sv-tmp (sv-parameters (sv-result sv-self) ))(return-from mp6-function (concatenate 'string (sv-string "return (func () *Any { ") (sv-string (concatenate 'string (sv-string (sv-emit_go (sv-result sv-self) )) (sv-string (concatenate 'string (sv-string "; ") (sv-string (concatenate 'string (sv-string "return ") (sv-string (concatenate 'string (sv-string (sv-emit_go sv-tmp )) (sv-string (concatenate 'string (sv-string "; ") (sv-string "}())")))))))))))))) nil)(return-from mp6-function (concatenate 'string (sv-string "return( ") (sv-string (concatenate 'string (sv-string (sv-emit_go (sv-result sv-self) )) (sv-string ")"))))))))

(defmethod sv-perl ((self mp-Return))
  (mp-Main::sv-lisp_dump_object "::Return" (list (let ((m (make-instance 'mp-Pair))) (setf (sv-key m) "result") (setf (sv-value m) (sv-result self)) m) )))




;; class If
(if (not (ignore-errors (find-class 'mp-If)))
  (defclass mp-If () ()))

(let (x) 
  (setq x (make-instance 'mp-If))
  (defun proto-mp-If () x))
;; has $.cond
(let ((new-slots (list (list :name 'sv-cond
  :readers '(sv-cond)
  :writers '((setf sv-cond))
  :initform '(sv-undef)
  :initfunction (constantly (sv-undef))))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-If)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-If :direct-slots new-slots))

;; has $.body
(let ((new-slots (list (list :name 'sv-body
  :readers '(sv-body)
  :writers '((setf sv-body))
  :initform '(sv-undef)
  :initfunction (constantly (sv-undef))))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-If)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-If :direct-slots new-slots))

;; has $.otherwise
(let ((new-slots (list (list :name 'sv-otherwise
  :readers '(sv-otherwise)
  :writers '((setf sv-otherwise))
  :initform '(sv-undef)
  :initfunction (constantly (sv-undef))))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-If)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-If :direct-slots new-slots))

;; method emit_go
(if (not (ignore-errors (find-method 'sv-emit_go () ())))
  (defgeneric sv-emit_go (sv-self)
      (:documentation "a method")))
(defmethod sv-emit_go ((sv-self mp-If))
  (block mp6-function
    (let ((sv-cond (sv-undef))(sv-s (sv-undef))) (setf sv-cond (sv-cond sv-self))(if (sv-bool (sv-and (typep sv-cond 'mp-Apply) (sv-eq (sv-code sv-cond ) "prefix:<!>"))) (let ((sv-if (sv-undef))) (setf sv-if (let ((m (make-instance 'mp-If))) (setf (sv-cond m) (mp-Main::sv-array-index (sv-arguments sv-cond ) 0))(setf (sv-body m) (sv-otherwise sv-self))(setf (sv-otherwise m) (sv-body sv-self)) m))(return-from mp6-function (sv-emit_go sv-if ))) nil)(if (sv-bool (sv-and (typep sv-cond 'mp-Var) (sv-eq (sv-sigil sv-cond ) "@"))) (progn (setf sv-cond (let ((m (make-instance 'mp-Apply))) (setf (sv-code m) "prefix:<@>")(setf (sv-arguments m) (let ((_tmp_ (concatenate 'list  (list sv-cond)))) (make-array (length _tmp_) :adjustable 1 :fill-pointer t :initial-contents _tmp_))) m))) nil)(setf sv-s (concatenate 'string (sv-string "if tobool( ") (sv-string (concatenate 'string (sv-string (mp-Call::sv-emit_go_call sv-cond "Bool")) (sv-string (concatenate 'string (sv-string " ) { ") (sv-string (concatenate 'string (sv-string (sv-emit_go (let ((m (make-instance 'mp-MiniPerl6-Go-LexicalBlock))) (setf (sv-block m) (sv-body sv-self))(setf (sv-needs_return m) 0) m) )) (sv-string " }")))))))))(if (sv-bool (not (sv-bool (sv-otherwise sv-self)))) (progn (return-from mp6-function sv-s)) nil)(return-from mp6-function (concatenate 'string (sv-string sv-s) (sv-string (concatenate 'string (sv-string " else { ") (sv-string (concatenate 'string (sv-string (sv-emit_go (let ((m (make-instance 'mp-MiniPerl6-Go-LexicalBlock))) (setf (sv-block m) (sv-otherwise sv-self))(setf (sv-needs_return m) 0) m) )) (sv-string " }"))))))))))

(defmethod sv-perl ((self mp-If))
  (mp-Main::sv-lisp_dump_object "::If" (list (let ((m (make-instance 'mp-Pair))) (setf (sv-key m) "cond") (setf (sv-value m) (sv-cond self)) m) (let ((m (make-instance 'mp-Pair))) (setf (sv-key m) "body") (setf (sv-value m) (sv-body self)) m) (let ((m (make-instance 'mp-Pair))) (setf (sv-key m) "otherwise") (setf (sv-value m) (sv-otherwise self)) m) )))




;; class For
(if (not (ignore-errors (find-class 'mp-For)))
  (defclass mp-For () ()))

(let (x) 
  (setq x (make-instance 'mp-For))
  (defun proto-mp-For () x))
;; has $.cond
(let ((new-slots (list (list :name 'sv-cond
  :readers '(sv-cond)
  :writers '((setf sv-cond))
  :initform '(sv-undef)
  :initfunction (constantly (sv-undef))))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-For)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-For :direct-slots new-slots))

;; has $.body
(let ((new-slots (list (list :name 'sv-body
  :readers '(sv-body)
  :writers '((setf sv-body))
  :initform '(sv-undef)
  :initfunction (constantly (sv-undef))))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-For)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-For :direct-slots new-slots))

;; has $.topic
(let ((new-slots (list (list :name 'sv-topic
  :readers '(sv-topic)
  :writers '((setf sv-topic))
  :initform '(sv-undef)
  :initfunction (constantly (sv-undef))))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-For)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-For :direct-slots new-slots))

;; method emit_go
(if (not (ignore-errors (find-method 'sv-emit_go () ())))
  (defgeneric sv-emit_go (sv-self)
      (:documentation "a method")))
(defmethod sv-emit_go ((sv-self mp-For))
  (block mp6-function
    (progn (concatenate 'string (sv-string "func (a_ *Any) { ") (sv-string (concatenate 'string (sv-string "
") (sv-string (concatenate 'string (sv-string "  var i = (*(*a_).(array_er).f_array(Capture{})).(*Array); ") (sv-string (concatenate 'string (sv-string "
") (sv-string (concatenate 'string (sv-string "  for pos := 0; pos <= i.n; pos++ { ") (sv-string (concatenate 'string (sv-string "
") (sv-string (concatenate 'string (sv-string "    func (") (sv-string (concatenate 'string (sv-string (sv-emit_go (sv-topic sv-self) )) (sv-string (concatenate 'string (sv-string " *Any) { ") (sv-string (concatenate 'string (sv-string "
") (sv-string (concatenate 'string (sv-string "      ") (sv-string (concatenate 'string (sv-string (sv-emit_go (let ((m (make-instance 'mp-MiniPerl6-Go-LexicalBlock))) (setf (sv-block m) (sv-body sv-self))(setf (sv-needs_return m) 0) m) )) (sv-string (concatenate 'string (sv-string "
") (sv-string (concatenate 'string (sv-string "    }(i.v[pos]) ") (sv-string (concatenate 'string (sv-string "
") (sv-string (concatenate 'string (sv-string "  } ") (sv-string (concatenate 'string (sv-string "
") (sv-string (concatenate 'string (sv-string "}(") (sv-string (concatenate 'string (sv-string (sv-emit_go (sv-cond sv-self) )) (sv-string ")")))))))))))))))))))))))))))))))))))))))))

(defmethod sv-perl ((self mp-For))
  (mp-Main::sv-lisp_dump_object "::For" (list (let ((m (make-instance 'mp-Pair))) (setf (sv-key m) "cond") (setf (sv-value m) (sv-cond self)) m) (let ((m (make-instance 'mp-Pair))) (setf (sv-key m) "body") (setf (sv-value m) (sv-body self)) m) (let ((m (make-instance 'mp-Pair))) (setf (sv-key m) "topic") (setf (sv-value m) (sv-topic self)) m) )))




;; class When
(if (not (ignore-errors (find-class 'mp-When)))
  (defclass mp-When () ()))

(let (x) 
  (setq x (make-instance 'mp-When))
  (defun proto-mp-When () x))
;; has $.parameters
(let ((new-slots (list (list :name 'sv-parameters
  :readers '(sv-parameters)
  :writers '((setf sv-parameters))
  :initform '(sv-undef)
  :initfunction (constantly (sv-undef))))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-When)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-When :direct-slots new-slots))

;; has $.body
(let ((new-slots (list (list :name 'sv-body
  :readers '(sv-body)
  :writers '((setf sv-body))
  :initform '(sv-undef)
  :initfunction (constantly (sv-undef))))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-When)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-When :direct-slots new-slots))

;; method emit_go
(if (not (ignore-errors (find-method 'sv-emit_go () ())))
  (defgeneric sv-emit_go (sv-self)
      (:documentation "a method")))
(defmethod sv-emit_go ((sv-self mp-When))
  (block mp6-function
    (progn (progn (write-line (format nil "~{~a~}" (list "TODO - When")) *error-output*) (sb-ext:quit)))))

(defmethod sv-perl ((self mp-When))
  (mp-Main::sv-lisp_dump_object "::When" (list (let ((m (make-instance 'mp-Pair))) (setf (sv-key m) "parameters") (setf (sv-value m) (sv-parameters self)) m) (let ((m (make-instance 'mp-Pair))) (setf (sv-key m) "body") (setf (sv-value m) (sv-body self)) m) )))




;; class While
(if (not (ignore-errors (find-class 'mp-While)))
  (defclass mp-While () ()))

(let (x) 
  (setq x (make-instance 'mp-While))
  (defun proto-mp-While () x))
;; has $.cond
(let ((new-slots (list (list :name 'sv-cond
  :readers '(sv-cond)
  :writers '((setf sv-cond))
  :initform '(sv-undef)
  :initfunction (constantly (sv-undef))))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-While)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-While :direct-slots new-slots))

;; has $.body
(let ((new-slots (list (list :name 'sv-body
  :readers '(sv-body)
  :writers '((setf sv-body))
  :initform '(sv-undef)
  :initfunction (constantly (sv-undef))))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-While)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-While :direct-slots new-slots))

;; method emit_go
(if (not (ignore-errors (find-method 'sv-emit_go () ())))
  (defgeneric sv-emit_go (sv-self)
      (:documentation "a method")))
(defmethod sv-emit_go ((sv-self mp-While))
  (block mp6-function
    (let ((sv-cond (sv-undef))) (setf sv-cond (sv-cond sv-self))(if (sv-bool (sv-and (typep sv-cond 'mp-Var) (sv-eq (sv-sigil sv-cond ) "@"))) (progn (setf sv-cond (let ((m (make-instance 'mp-Apply))) (setf (sv-code m) "prefix:<@>")(setf (sv-arguments m) (let ((_tmp_ (concatenate 'list  (list sv-cond)))) (make-array (length _tmp_) :adjustable 1 :fill-pointer t :initial-contents _tmp_))) m))) nil)(return-from mp6-function (concatenate 'string (sv-string "for ;tobool( ") (sv-string (concatenate 'string (sv-string (mp-Call::sv-emit_go_call sv-cond "Bool")) (sv-string (concatenate 'string (sv-string " ); { ") (sv-string (concatenate 'string (sv-string (sv-emit_go (let ((m (make-instance 'mp-MiniPerl6-Go-LexicalBlock))) (setf (sv-block m) (sv-body sv-self))(setf (sv-needs_return m) 0) m) )) (sv-string " }"))))))))))))

(defmethod sv-perl ((self mp-While))
  (mp-Main::sv-lisp_dump_object "::While" (list (let ((m (make-instance 'mp-Pair))) (setf (sv-key m) "cond") (setf (sv-value m) (sv-cond self)) m) (let ((m (make-instance 'mp-Pair))) (setf (sv-key m) "body") (setf (sv-value m) (sv-body self)) m) )))




;; class Leave
(if (not (ignore-errors (find-class 'mp-Leave)))
  (defclass mp-Leave () ()))

(let (x) 
  (setq x (make-instance 'mp-Leave))
  (defun proto-mp-Leave () x))
;; method emit_go
(if (not (ignore-errors (find-method 'sv-emit_go () ())))
  (defgeneric sv-emit_go (sv-self)
      (:documentation "a method")))
(defmethod sv-emit_go ((sv-self mp-Leave))
  (block mp6-function
    (progn (progn (write-line (format nil "~{~a~}" (list "TODO - Leave")) *error-output*) (sb-ext:quit)))))

(defmethod sv-perl ((self mp-Leave))
  (mp-Main::sv-lisp_dump_object "::Leave" (list )))




;; class Decl
(if (not (ignore-errors (find-class 'mp-Decl)))
  (defclass mp-Decl () ()))

(let (x) 
  (setq x (make-instance 'mp-Decl))
  (defun proto-mp-Decl () x))
;; has $.decl
(let ((new-slots (list (list :name 'sv-decl
  :readers '(sv-decl)
  :writers '((setf sv-decl))
  :initform '(sv-undef)
  :initfunction (constantly (sv-undef))))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-Decl)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-Decl :direct-slots new-slots))

;; has $.type
(let ((new-slots (list (list :name 'sv-type
  :readers '(sv-type)
  :writers '((setf sv-type))
  :initform '(sv-undef)
  :initfunction (constantly (sv-undef))))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-Decl)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-Decl :direct-slots new-slots))

;; has $.var
(let ((new-slots (list (list :name 'sv-var
  :readers '(sv-var)
  :writers '((setf sv-var))
  :initform '(sv-undef)
  :initfunction (constantly (sv-undef))))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-Decl)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-Decl :direct-slots new-slots))

;; method emit_go
(if (not (ignore-errors (find-method 'sv-emit_go () ())))
  (defgeneric sv-emit_go (sv-self)
      (:documentation "a method")))
(defmethod sv-emit_go ((sv-self mp-Decl))
  (block mp6-function
    (progn (sv-emit_go (sv-var sv-self) ))))

;; method emit_go_init
(if (not (ignore-errors (find-method 'sv-emit_go_init () ())))
  (defgeneric sv-emit_go_init (sv-self)
      (:documentation "a method")))
(defmethod sv-emit_go_init ((sv-self mp-Decl))
  (block mp6-function
    (progn (if (sv-bool (sv-eq (sv-decl sv-self) "my")) (let ((sv-str (sv-undef))) (setf sv-str "")(setf sv-str (concatenate 'string (sv-string sv-str) (sv-string (concatenate 'string (sv-string "var ") (sv-string (concatenate 'string (sv-string (sv-emit_go (sv-var sv-self) )) (sv-string (concatenate 'string (sv-string " *Any;") (sv-string "
")))))))))(setf sv-str (concatenate 'string (sv-string sv-str) (sv-string (concatenate 'string (sv-string (sv-emit_go (sv-var sv-self) )) (sv-string (concatenate 'string (sv-string " = ") (sv-string (concatenate 'string (sv-string (sv-emit_go (sv-var sv-self) )) (sv-string (concatenate 'string (sv-string ";") (sv-string "
")))))))))))(if (sv-bool (sv-eq (sv-sigil (sv-var sv-self) ) "%")) (progn (setf sv-str (concatenate 'string (sv-string sv-str) (sv-string (concatenate 'string (sv-string (sv-emit_go (sv-var sv-self) )) (sv-string (concatenate 'string (sv-string " = h_hash();") (sv-string "
")))))))) (progn (if (sv-bool (sv-eq (sv-sigil (sv-var sv-self) ) "@")) (progn (setf sv-str (concatenate 'string (sv-string sv-str) (sv-string (concatenate 'string (sv-string (sv-emit_go (sv-var sv-self) )) (sv-string (concatenate 'string (sv-string " = a_array();") (sv-string "
")))))))) (progn (setf sv-str (concatenate 'string (sv-string sv-str) (sv-string (concatenate 'string (sv-string (sv-emit_go (sv-var sv-self) )) (sv-string (concatenate 'string (sv-string " = u_undef();") (sv-string "
")))))))))))(return-from mp6-function sv-str)) (progn (progn (write-line (format nil "~{~a~}" (list (concatenate 'string (sv-string "not implemented: Decl '") (sv-string (concatenate 'string (sv-string (sv-decl sv-self)) (sv-string "'")))))) *error-output*) (sb-ext:quit)))))))

(defmethod sv-perl ((self mp-Decl))
  (mp-Main::sv-lisp_dump_object "::Decl" (list (let ((m (make-instance 'mp-Pair))) (setf (sv-key m) "decl") (setf (sv-value m) (sv-decl self)) m) (let ((m (make-instance 'mp-Pair))) (setf (sv-key m) "type") (setf (sv-value m) (sv-type self)) m) (let ((m (make-instance 'mp-Pair))) (setf (sv-key m) "var") (setf (sv-value m) (sv-var self)) m) )))




;; class Sig
(if (not (ignore-errors (find-class 'mp-Sig)))
  (defclass mp-Sig () ()))

(let (x) 
  (setq x (make-instance 'mp-Sig))
  (defun proto-mp-Sig () x))
;; has $.invocant
(let ((new-slots (list (list :name 'sv-invocant
  :readers '(sv-invocant)
  :writers '((setf sv-invocant))
  :initform '(sv-undef)
  :initfunction (constantly (sv-undef))))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-Sig)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-Sig :direct-slots new-slots))

;; has $.positional
(let ((new-slots (list (list :name 'sv-positional
  :readers '(sv-positional)
  :writers '((setf sv-positional))
  :initform '(sv-undef)
  :initfunction (constantly (sv-undef))))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-Sig)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-Sig :direct-slots new-slots))

;; has $.named
(let ((new-slots (list (list :name 'sv-named
  :readers '(sv-named)
  :writers '((setf sv-named))
  :initform '(sv-undef)
  :initfunction (constantly (sv-undef))))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-Sig)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-Sig :direct-slots new-slots))

;; method emit_go
(if (not (ignore-errors (find-method 'sv-emit_go () ())))
  (defgeneric sv-emit_go (sv-self)
      (:documentation "a method")))
(defmethod sv-emit_go ((sv-self mp-Sig))
  (block mp6-function
    (progn " print 'Signature - TODO'; die 'Signature - TODO'; ")))

;; method emit_go_bind
(if (not (ignore-errors (find-method 'sv-emit_go_bind () ())))
  (defgeneric sv-emit_go_bind (sv-self)
      (:documentation "a method")))
(defmethod sv-emit_go_bind ((sv-self mp-Sig))
  (block mp6-function
    (let ((sv-str (sv-undef))(sv-i (sv-undef))) (setf sv-str "")(setf sv-i 0)(loop for sv-decl across (sv-positional sv-self) do (progn (setf sv-str (concatenate 'string (sv-string sv-str) (sv-string (concatenate 'string (sv-string "  var ") (sv-string (concatenate 'string (sv-string (sv-emit_go sv-decl )) (sv-string (concatenate 'string (sv-string " *Any;
") (sv-string (concatenate 'string (sv-string "  if len(v.p) > ") (sv-string (concatenate 'string (sv-string sv-i) (sv-string (concatenate 'string (sv-string " {
") (sv-string (concatenate 'string (sv-string "    ") (sv-string (concatenate 'string (sv-string (sv-emit_go sv-decl )) (sv-string (concatenate 'string (sv-string " = v.p[") (sv-string (concatenate 'string (sv-string sv-i) (sv-string (concatenate 'string (sv-string "];
") (sv-string "  }
")))))))))))))))))))))))))(setf sv-str (concatenate 'string (sv-string sv-str) (sv-string (concatenate 'string (sv-string (sv-emit_go sv-decl )) (sv-string (concatenate 'string (sv-string " = ") (sv-string (concatenate 'string (sv-string (sv-emit_go sv-decl )) (sv-string "; ")))))))))(setf sv-i (sv-add sv-i 1))))(return-from mp6-function sv-str))))

(defmethod sv-perl ((self mp-Sig))
  (mp-Main::sv-lisp_dump_object "::Sig" (list (let ((m (make-instance 'mp-Pair))) (setf (sv-key m) "invocant") (setf (sv-value m) (sv-invocant self)) m) (let ((m (make-instance 'mp-Pair))) (setf (sv-key m) "positional") (setf (sv-value m) (sv-positional self)) m) (let ((m (make-instance 'mp-Pair))) (setf (sv-key m) "named") (setf (sv-value m) (sv-named self)) m) )))




;; class Method
(if (not (ignore-errors (find-class 'mp-Method)))
  (defclass mp-Method () ()))

(let (x) 
  (setq x (make-instance 'mp-Method))
  (defun proto-mp-Method () x))
;; has $.name
(let ((new-slots (list (list :name 'sv-name
  :readers '(sv-name)
  :writers '((setf sv-name))
  :initform '(sv-undef)
  :initfunction (constantly (sv-undef))))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-Method)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-Method :direct-slots new-slots))

;; has $.sig
(let ((new-slots (list (list :name 'sv-sig
  :readers '(sv-sig)
  :writers '((setf sv-sig))
  :initform '(sv-undef)
  :initfunction (constantly (sv-undef))))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-Method)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-Method :direct-slots new-slots))

;; has $.block
(let ((new-slots (list (list :name 'sv-block
  :readers '(sv-block)
  :writers '((setf sv-block))
  :initform '(sv-undef)
  :initfunction (constantly (sv-undef))))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-Method)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-Method :direct-slots new-slots))

;; method emit_go
(if (not (ignore-errors (find-method 'sv-emit_go () ())))
  (defgeneric sv-emit_go (sv-self)
      (:documentation "a method")))
(defmethod sv-emit_go ((sv-self mp-Method))
  (block mp6-function
    (let ((sv-invocant (sv-undef))) (setf sv-invocant (sv-invocant (sv-sig sv-self) ))(concatenate 'string (sv-string "func ") (sv-string (concatenate 'string (sv-string (sv-name sv-self)) (sv-string (concatenate 'string (sv-string "(v Capture) *Any { ") (sv-string (concatenate 'string (sv-string "    ") (sv-string (concatenate 'string (sv-string (sv-emit_go_bind (sv-sig sv-self) )) (sv-string (concatenate 'string (sv-string "
") (sv-string (concatenate 'string (sv-string "    p := make(chan *Any); go func () { ") (sv-string (concatenate 'string (sv-string "
") (sv-string (concatenate 'string (sv-string "        ") (sv-string (concatenate 'string (sv-string (sv-emit_go (let ((m (make-instance 'mp-MiniPerl6-Go-LexicalBlock))) (setf (sv-block m) (sv-block sv-self))(setf (sv-needs_return m) 1)(setf (sv-top_level m) 1) m) )) (sv-string (concatenate 'string (sv-string "; p <- nil }(); ") (sv-string (concatenate 'string (sv-string "
") (sv-string (concatenate 'string (sv-string "    return <-p; ") (sv-string (concatenate 'string (sv-string "
") (sv-string " }")))))))))))))))))))))))))))))))

(defmethod sv-perl ((self mp-Method))
  (mp-Main::sv-lisp_dump_object "::Method" (list (let ((m (make-instance 'mp-Pair))) (setf (sv-key m) "name") (setf (sv-value m) (sv-name self)) m) (let ((m (make-instance 'mp-Pair))) (setf (sv-key m) "sig") (setf (sv-value m) (sv-sig self)) m) (let ((m (make-instance 'mp-Pair))) (setf (sv-key m) "block") (setf (sv-value m) (sv-block self)) m) )))




;; class Sub
(if (not (ignore-errors (find-class 'mp-Sub)))
  (defclass mp-Sub () ()))

(let (x) 
  (setq x (make-instance 'mp-Sub))
  (defun proto-mp-Sub () x))
;; has $.name
(let ((new-slots (list (list :name 'sv-name
  :readers '(sv-name)
  :writers '((setf sv-name))
  :initform '(sv-undef)
  :initfunction (constantly (sv-undef))))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-Sub)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-Sub :direct-slots new-slots))

;; has $.sig
(let ((new-slots (list (list :name 'sv-sig
  :readers '(sv-sig)
  :writers '((setf sv-sig))
  :initform '(sv-undef)
  :initfunction (constantly (sv-undef))))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-Sub)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-Sub :direct-slots new-slots))

;; has $.block
(let ((new-slots (list (list :name 'sv-block
  :readers '(sv-block)
  :writers '((setf sv-block))
  :initform '(sv-undef)
  :initfunction (constantly (sv-undef))))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-Sub)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-Sub :direct-slots new-slots))

;; method emit_go
(if (not (ignore-errors (find-method 'sv-emit_go () ())))
  (defgeneric sv-emit_go (sv-self)
      (:documentation "a method")))
(defmethod sv-emit_go ((sv-self mp-Sub))
  (block mp6-function
    (progn (if (sv-bool (sv-eq (sv-name sv-self) "")) (progn (return-from mp6-function (concatenate 'string (sv-string "toFunction( func(v Capture) *Any { ") (sv-string (concatenate 'string (sv-string "    ") (sv-string (concatenate 'string (sv-string (sv-emit_go_bind (sv-sig sv-self) )) (sv-string (concatenate 'string (sv-string "
") (sv-string (concatenate 'string (sv-string "    p := make(chan *Any); go func () { ") (sv-string (concatenate 'string (sv-string "
") (sv-string (concatenate 'string (sv-string "        ") (sv-string (concatenate 'string (sv-string (sv-emit_go (let ((m (make-instance 'mp-MiniPerl6-Go-LexicalBlock))) (setf (sv-block m) (sv-block sv-self))(setf (sv-needs_return m) 1)(setf (sv-top_level m) 1) m) )) (sv-string (concatenate 'string (sv-string "; p <- nil }(); ") (sv-string (concatenate 'string (sv-string "
") (sv-string (concatenate 'string (sv-string "    return <-p; ") (sv-string (concatenate 'string (sv-string "
") (sv-string (concatenate 'string (sv-string "} ") (sv-string ")")))))))))))))))))))))))))))) nil)(concatenate 'string (sv-string "func ") (sv-string (concatenate 'string (sv-string (sv-name sv-self)) (sv-string (concatenate 'string (sv-string "(v Capture) *Any { ") (sv-string (concatenate 'string (sv-string "    ") (sv-string (concatenate 'string (sv-string (sv-emit_go_bind (sv-sig sv-self) )) (sv-string (concatenate 'string (sv-string "
") (sv-string (concatenate 'string (sv-string "    p := make(chan *Any); go func () { ") (sv-string (concatenate 'string (sv-string "
") (sv-string (concatenate 'string (sv-string "        ") (sv-string (concatenate 'string (sv-string (sv-emit_go (let ((m (make-instance 'mp-MiniPerl6-Go-LexicalBlock))) (setf (sv-block m) (sv-block sv-self))(setf (sv-needs_return m) 1)(setf (sv-top_level m) 1) m) )) (sv-string (concatenate 'string (sv-string "; p <- nil }(); ") (sv-string (concatenate 'string (sv-string "
") (sv-string (concatenate 'string (sv-string "    return <-p; ") (sv-string (concatenate 'string (sv-string "
") (sv-string " }")))))))))))))))))))))))))))))))

(defmethod sv-perl ((self mp-Sub))
  (mp-Main::sv-lisp_dump_object "::Sub" (list (let ((m (make-instance 'mp-Pair))) (setf (sv-key m) "name") (setf (sv-value m) (sv-name self)) m) (let ((m (make-instance 'mp-Pair))) (setf (sv-key m) "sig") (setf (sv-value m) (sv-sig self)) m) (let ((m (make-instance 'mp-Pair))) (setf (sv-key m) "block") (setf (sv-value m) (sv-block self)) m) )))




;; class Do
(if (not (ignore-errors (find-class 'mp-Do)))
  (defclass mp-Do () ()))

(let (x) 
  (setq x (make-instance 'mp-Do))
  (defun proto-mp-Do () x))
;; has $.block
(let ((new-slots (list (list :name 'sv-block
  :readers '(sv-block)
  :writers '((setf sv-block))
  :initform '(sv-undef)
  :initfunction (constantly (sv-undef))))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-Do)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-Do :direct-slots new-slots))

;; method emit_go
(if (not (ignore-errors (find-method 'sv-emit_go () ())))
  (defgeneric sv-emit_go (sv-self)
      (:documentation "a method")))
(defmethod sv-emit_go ((sv-self mp-Do))
  (block mp6-function
    (progn (concatenate 'string (sv-string "(func () *Any { ") (sv-string (concatenate 'string (sv-string (sv-emit_go (let ((m (make-instance 'mp-MiniPerl6-Go-LexicalBlock))) (setf (sv-block m) (sv-block sv-self))(setf (sv-needs_return m) 1) m) )) (sv-string (concatenate 'string (sv-string "; return u_undef() ") (sv-string "})()")))))))))

(defmethod sv-perl ((self mp-Do))
  (mp-Main::sv-lisp_dump_object "::Do" (list (let ((m (make-instance 'mp-Pair))) (setf (sv-key m) "block") (setf (sv-value m) (sv-block self)) m) )))




;; class Use
(if (not (ignore-errors (find-class 'mp-Use)))
  (defclass mp-Use () ()))

(let (x) 
  (setq x (make-instance 'mp-Use))
  (defun proto-mp-Use () x))
;; has $.mod
(let ((new-slots (list (list :name 'sv-mod
  :readers '(sv-mod)
  :writers '((setf sv-mod))
  :initform '(sv-undef)
  :initfunction (constantly (sv-undef))))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-Use)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-Use :direct-slots new-slots))

;; method emit_go
(if (not (ignore-errors (find-method 'sv-emit_go () ())))
  (defgeneric sv-emit_go (sv-self)
      (:documentation "a method")))
(defmethod sv-emit_go ((sv-self mp-Use))
  (block mp6-function
    (progn (concatenate 'string (sv-string "// use ") (sv-string (concatenate 'string (sv-string (sv-mod sv-self)) (sv-string "
")))))))

(defmethod sv-perl ((self mp-Use))
  (mp-Main::sv-lisp_dump_object "::Use" (list (let ((m (make-instance 'mp-Pair))) (setf (sv-key m) "mod") (setf (sv-value m) (sv-mod self)) m) )))




