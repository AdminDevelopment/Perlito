;; Do not edit this file - Generated by MiniPerl6 3.0
;; class MiniPerl6::Go::LexicalBlock
(defpackage mp-MiniPerl6-Go-LexicalBlock
  (:use common-lisp mp-Main))
;; (in-package mp-MiniPerl6-Go-LexicalBlock)
(if (not (ignore-errors (find-class 'mp-MiniPerl6-Go-LexicalBlock)))
  (defclass mp-MiniPerl6-Go-LexicalBlock () ()))

(let (x) 
  (setq x (make-instance 'mp-MiniPerl6-Go-LexicalBlock))
  (defun proto-mp-MiniPerl6-Go-LexicalBlock () x))
;; has $.block
(let ((new-slots (list (list :name 'sv-block
  :readers '(sv-block)
  :writers '((setf sv-block))
  :initform '(sv-undef)
  :initfunction (constantly (sv-undef))))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-MiniPerl6-Go-LexicalBlock)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-MiniPerl6-Go-LexicalBlock :direct-slots new-slots))

;; has $.needs_return
(let ((new-slots (list (list :name 'sv-needs_return
  :readers '(sv-needs_return)
  :writers '((setf sv-needs_return))
  :initform '(sv-undef)
  :initfunction (constantly (sv-undef))))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-MiniPerl6-Go-LexicalBlock)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-MiniPerl6-Go-LexicalBlock :direct-slots new-slots))

;; has $.top_level
(let ((new-slots (list (list :name 'sv-top_level
  :readers '(sv-top_level)
  :writers '((setf sv-top_level))
  :initform '(sv-undef)
  :initfunction (constantly (sv-undef))))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-MiniPerl6-Go-LexicalBlock)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-MiniPerl6-Go-LexicalBlock :direct-slots new-slots))

;; method emit_go
(if (not (ignore-errors (find-method 'sv-emit_go () ())))
  (defgeneric sv-emit_go (sv-self)
      (:documentation "a method")))
(defmethod sv-emit_go ((sv-self mp-MiniPerl6-Go-LexicalBlock))
  (block mp6-function
    (let ((sv-str (sv-undef))(sv-decl_seen (sv-undef))(sv-last_statement (sv-undef))) (if (sv-bool (not (sv-bool (sv-block sv-self)))) (progn (return-from mp6-function "")) nil)(setf sv-str "")(dolist (sv-decl1 (sv-block sv-self)) (let ((sv-decl (sv-undef))) (setf sv-decl sv-decl1)(if (sv-bool (sv-and (typep sv-decl 'mp-Bind) (sv-and (typep (sv-parameters sv-decl ) 'mp-Decl) (sv-eq (sv-decl (sv-parameters sv-decl ) ) "my")))) (progn (setf sv-decl (sv-parameters sv-decl ))) nil)(if (sv-bool (sv-and (typep sv-decl 'mp-Decl) (sv-eq (sv-decl sv-decl ) "my"))) (let ((sv-var_name (sv-undef))) (setf sv-var_name (sv-emit_go (sv-var sv-decl ) ))(if (sv-bool (not (sv-bool (gethash sv-var_name sv-decl_seen)))) (progn (setf sv-str (concatenate 'string (sv-string sv-str) (sv-string (sv-emit_go_init sv-decl ))))(setf (gethash sv-var_name sv-decl_seen) 1)) nil)) nil)))(if (sv-bool (sv-needs_return sv-self)) (progn (setf sv-last_statement (sv-pop (sv-block sv-self)))) nil)(dolist (sv-decl (sv-block sv-self)) (progn (if (sv-bool (not (sv-bool (sv-and (typep sv-decl 'mp-Decl) (sv-eq (sv-decl sv-decl ) "my"))))) (progn (setf sv-str (concatenate 'string (sv-string sv-str) (sv-string (concatenate 'string (sv-string (sv-emit_go sv-decl )) (sv-string ";")))))) nil)))(if (sv-bool (sv-and (sv-needs_return sv-self) sv-last_statement)) (progn (if (sv-bool (typep sv-last_statement 'mp-If)) (let ((sv-cond (sv-undef))(sv-body (sv-undef))(sv-otherwise (sv-undef))) (setf sv-cond (sv-cond sv-last_statement ))(setf sv-body (sv-body sv-last_statement ))(setf sv-otherwise (sv-otherwise sv-last_statement ))(if (sv-bool (sv-and (typep sv-cond 'mp-Apply) (sv-eq (sv-code sv-cond ) "prefix:<!>"))) (progn (setf sv-cond (elt (sv-arguments sv-cond ) 0))(setf sv-body (sv-otherwise sv-last_statement ))(setf sv-otherwise (sv-body sv-last_statement ))) nil)(if (sv-bool (sv-and (typep sv-cond 'mp-Var) (sv-eq (sv-sigil sv-cond ) "@"))) (progn (setf sv-cond (let ((m (make-instance 'mp-Apply))) (setf (sv-code m) "prefix:<@>")(setf (sv-arguments m) (concatenate 'list  (list sv-cond))) m))) nil)(setf sv-body (let ((m (make-instance 'mp-MiniPerl6-Go-LexicalBlock))) (setf (sv-block m) sv-body)(setf (sv-needs_return m) 1)(setf (sv-top_level m) (sv-top_level sv-self)) m))(setf sv-otherwise (let ((m (make-instance 'mp-MiniPerl6-Go-LexicalBlock))) (setf (sv-block m) sv-otherwise)(setf (sv-needs_return m) 1)(setf (sv-top_level m) (sv-top_level sv-self)) m))(setf sv-str (concatenate 'string (sv-string sv-str) (sv-string (concatenate 'string (sv-string "if tobool( ") (sv-string (concatenate 'string (sv-string (mp-Call::sv-emit_go_call sv-cond "Bool")) (sv-string (concatenate 'string (sv-string " ) { ") (sv-string (concatenate 'string (sv-string (sv-emit_go sv-body )) (sv-string (concatenate 'string (sv-string " } else { ") (sv-string (concatenate 'string (sv-string (sv-emit_go sv-otherwise )) (sv-string " }")))))))))))))))) (progn (if (sv-bool (sv-or (typep sv-last_statement 'mp-Return) (typep sv-last_statement 'mp-For))) (progn (setf sv-str (concatenate 'string (sv-string sv-str) (sv-string (sv-emit_go sv-last_statement ))))) (progn (setf sv-last_statement (let ((m (make-instance 'mp-Return))) (setf (sv-result m) sv-last_statement) m))(if (sv-bool (sv-top_level sv-self)) (progn (setf sv-str (concatenate 'string (sv-string sv-str) (sv-string (sv-emit_go sv-last_statement ))))) (progn (setf sv-str (concatenate 'string (sv-string sv-str) (sv-string (sv-emit_go_simple sv-last_statement ))))))))))) nil)(return-from mp6-function sv-str))))

(defmethod sv-perl ((self mp-MiniPerl6-Go-LexicalBlock))
  (mp-Main::sv-lisp_dump_object "::MiniPerl6::Go::LexicalBlock" (list (let ((m (make-instance 'mp-Pair))) (setf (sv-key m) "block") (setf (sv-value m) (sv-block self)) m) (let ((m (make-instance 'mp-Pair))) (setf (sv-key m) "needs_return") (setf (sv-value m) (sv-needs_return self)) m) (let ((m (make-instance 'mp-Pair))) (setf (sv-key m) "top_level") (setf (sv-value m) (sv-top_level self)) m) )))




;; class CompUnit
(defpackage mp-CompUnit
  (:use common-lisp mp-Main))
;; (in-package mp-CompUnit)
(if (not (ignore-errors (find-class 'mp-CompUnit)))
  (defclass mp-CompUnit () ()))

(let (x) 
  (setq x (make-instance 'mp-CompUnit))
  (defun proto-mp-CompUnit () x))
;; has $.name
(let ((new-slots (list (list :name 'sv-name
  :readers '(sv-name)
  :writers '((setf sv-name))
  :initform '(sv-undef)
  :initfunction (constantly (sv-undef))))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-CompUnit)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-CompUnit :direct-slots new-slots))

;; has $.attributes
(let ((new-slots (list (list :name 'sv-attributes
  :readers '(sv-attributes)
  :writers '((setf sv-attributes))
  :initform '(sv-undef)
  :initfunction (constantly (sv-undef))))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-CompUnit)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-CompUnit :direct-slots new-slots))

;; has $.methods
(let ((new-slots (list (list :name 'sv-methods
  :readers '(sv-methods)
  :writers '((setf sv-methods))
  :initform '(sv-undef)
  :initfunction (constantly (sv-undef))))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-CompUnit)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-CompUnit :direct-slots new-slots))

;; has $.body
(let ((new-slots (list (list :name 'sv-body
  :readers '(sv-body)
  :writers '((setf sv-body))
  :initform '(sv-undef)
  :initfunction (constantly (sv-undef))))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-CompUnit)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-CompUnit :direct-slots new-slots))

;; method emit_go
(if (not (ignore-errors (find-method 'sv-emit_go () ())))
  (defgeneric sv-emit_go (sv-self)
      (:documentation "a method")))
(defmethod sv-emit_go ((sv-self mp-CompUnit))
  (block mp6-function
    (let ((sv-class_name (sv-undef))(sv-str (sv-undef))) (setf sv-class_name (mp-Main::sv-to_go_namespace (sv-name sv-self)))(setf sv-str (concatenate 'string (sv-string "// instances of class ") (sv-string (concatenate 'string (sv-string (sv-name sv-self)) (sv-string (concatenate 'string (sv-string "
") (sv-string (concatenate 'string (sv-string "type ") (sv-string (concatenate 'string (sv-string sv-class_name) (sv-string (concatenate 'string (sv-string " struct {") (sv-string "
")))))))))))))(dolist (sv-decl @{(sv-attributes sv-self)}) (progn (if (sv-bool (sv-and (typep sv-decl 'mp-Decl) (sv-eq (sv-decl sv-decl ) "has"))) (progn (setf sv-str (concatenate 'string (sv-string sv-str) (sv-string (concatenate 'string (sv-string "  ") (sv-string (concatenate 'string (sv-string "v_") (sv-string (concatenate 'string (sv-string (sv-name (sv-var sv-decl ) )) (sv-string (concatenate 'string (sv-string " *Any;") (sv-string "
")))))))))))) nil)))(setf sv-str (concatenate 'string (sv-string sv-str) (sv-string (concatenate 'string (sv-string "}") (sv-string "
")))))(setf sv-str (concatenate 'string (sv-string sv-str) (sv-string (concatenate 'string (sv-string "// methods in class ") (sv-string (concatenate 'string (sv-string (sv-name sv-self)) (sv-string (concatenate 'string (sv-string "
") (sv-string (concatenate 'string (sv-string "var Method_") (sv-string (concatenate 'string (sv-string sv-class_name) (sv-string (concatenate 'string (sv-string " struct {") (sv-string "
")))))))))))))))(dolist (sv-decl @{(sv-methods sv-self)}) (progn (if (sv-bool (typep sv-decl 'mp-Method)) (progn (setf sv-str (concatenate 'string (sv-string sv-str) (sv-string (concatenate 'string (sv-string "  ") (sv-string (concatenate 'string (sv-string "f_") (sv-string (concatenate 'string (sv-string (sv-name sv-decl )) (sv-string (concatenate 'string (sv-string " func (*") (sv-string (concatenate 'string (sv-string sv-class_name) (sv-string (concatenate 'string (sv-string ", Capture) *Any;") (sv-string "
")))))))))))))))) nil)))(dolist (sv-decl @{(sv-attributes sv-self)}) (progn (if (sv-bool (sv-and (typep sv-decl 'mp-Decl) (sv-eq (sv-decl sv-decl ) "has"))) (progn (setf sv-str (concatenate 'string (sv-string sv-str) (sv-string (concatenate 'string (sv-string "  ") (sv-string (concatenate 'string (sv-string "f_") (sv-string (concatenate 'string (sv-string (sv-name (sv-var sv-decl ) )) (sv-string (concatenate 'string (sv-string " func (*") (sv-string (concatenate 'string (sv-string sv-class_name) (sv-string (concatenate 'string (sv-string ", Capture) *Any;") (sv-string "
")))))))))))))))) nil)))(setf sv-str (concatenate 'string (sv-string sv-str) (sv-string (concatenate 'string (sv-string "}") (sv-string "
")))))(setf sv-str (concatenate 'string (sv-string sv-str) (sv-string (concatenate 'string (sv-string "// namespace ") (sv-string (concatenate 'string (sv-string (sv-name sv-self)) (sv-string (concatenate 'string (sv-string "
") (sv-string (concatenate 'string (sv-string "var Namespace_") (sv-string (concatenate 'string (sv-string sv-class_name) (sv-string (concatenate 'string (sv-string " struct {") (sv-string "
")))))))))))))))(dolist (sv-decl (sv-body sv-self)) (progn (if (sv-bool (typep sv-decl 'mp-Sub)) (progn (setf sv-str (concatenate 'string (sv-string sv-str) (sv-string (concatenate 'string (sv-string "  ") (sv-string (concatenate 'string (sv-string "f_") (sv-string (concatenate 'string (sv-string (sv-name sv-decl )) (sv-string (concatenate 'string (sv-string " Function;") (sv-string "
")))))))))))) nil)))(setf sv-str (concatenate 'string (sv-string sv-str) (sv-string (concatenate 'string (sv-string "}") (sv-string "
")))))(setf sv-str (concatenate 'string (sv-string sv-str) (sv-string (concatenate 'string (sv-string "var Run_") (sv-string (concatenate 'string (sv-string sv-class_name) (sv-string (concatenate 'string (sv-string " func ();") (sv-string "
")))))))))(setf sv-str (concatenate 'string (sv-string sv-str) (sv-string (concatenate 'string (sv-string "// method wrappers for ") (sv-string (concatenate 'string (sv-string (sv-name sv-self)) (sv-string "
")))))))(dolist (sv-decl @{(sv-methods sv-self)}) (progn (if (sv-bool (typep sv-decl 'mp-Method)) (progn (setf sv-str (concatenate 'string (sv-string sv-str) (sv-string (concatenate 'string (sv-string "func (v_self *") (sv-string (concatenate 'string (sv-string sv-class_name) (sv-string (concatenate 'string (sv-string ") f_") (sv-string (concatenate 'string (sv-string (sv-name sv-decl )) (sv-string (concatenate 'string (sv-string " (v Capture) *Any {") (sv-string (concatenate 'string (sv-string "
") (sv-string (concatenate 'string (sv-string "  return Method_") (sv-string (concatenate 'string (sv-string sv-class_name) (sv-string (concatenate 'string (sv-string ".f_") (sv-string (concatenate 'string (sv-string (sv-name sv-decl )) (sv-string (concatenate 'string (sv-string "(v_self, v);") (sv-string (concatenate 'string (sv-string "
") (sv-string (concatenate 'string (sv-string "}") (sv-string "
")))))))))))))))))))))))))))))) nil)))(dolist (sv-decl @{(sv-attributes sv-self)}) (progn (if (sv-bool (sv-and (typep sv-decl 'mp-Decl) (sv-eq (sv-decl sv-decl ) "has"))) (progn (setf sv-str (concatenate 'string (sv-string sv-str) (sv-string (concatenate 'string (sv-string "func (v_self *") (sv-string (concatenate 'string (sv-string sv-class_name) (sv-string (concatenate 'string (sv-string ") f_") (sv-string (concatenate 'string (sv-string (sv-name (sv-var sv-decl ) )) (sv-string (concatenate 'string (sv-string " (v Capture) *Any {") (sv-string (concatenate 'string (sv-string "
") (sv-string (concatenate 'string (sv-string "  return Method_") (sv-string (concatenate 'string (sv-string sv-class_name) (sv-string (concatenate 'string (sv-string ".f_") (sv-string (concatenate 'string (sv-string (sv-name (sv-var sv-decl ) )) (sv-string (concatenate 'string (sv-string "(v_self, v);") (sv-string (concatenate 'string (sv-string "
") (sv-string (concatenate 'string (sv-string "}") (sv-string "
")))))))))))))))))))))))))))))) nil)))(if (sv-bool (not (sv-bool (gethash "isa" (sv-methods sv-self))))) (progn (setf sv-str (concatenate 'string (sv-string sv-str) (sv-string (concatenate 'string (sv-string "func (v_self *") (sv-string (concatenate 'string (sv-string sv-class_name) (sv-string (concatenate 'string (sv-string ") f_isa (v Capture) *Any { ") (sv-string (concatenate 'string (sv-string "return toBool( \"") (sv-string (concatenate 'string (sv-string (sv-name sv-self)) (sv-string (concatenate 'string (sv-string "\" == tostr( v.p[0] ) ) ") (sv-string (concatenate 'string (sv-string "}") (sv-string "
")))))))))))))))))) nil)(if (sv-bool (not (sv-bool (gethash "perl" (sv-methods sv-self))))) (let ((sv-sep (sv-undef))) (setf sv-str (concatenate 'string (sv-string sv-str) (sv-string (concatenate 'string (sv-string "func (v_self *") (sv-string (concatenate 'string (sv-string sv-class_name) (sv-string (concatenate 'string (sv-string ") f_perl (v Capture) *Any { ") (sv-string (concatenate 'string (sv-string "return toStr( \"::") (sv-string (concatenate 'string (sv-string (sv-name sv-self)) (sv-string "(\" ")))))))))))))(setf sv-sep "")(dolist (sv-decl @{(sv-attributes sv-self)}) (progn (if (sv-bool (sv-and (typep sv-decl 'mp-Decl) (sv-eq (sv-decl sv-decl ) "has"))) (progn (setf sv-str (concatenate 'string (sv-string sv-str) (sv-string (concatenate 'string (sv-string sv-sep) (sv-string (concatenate 'string (sv-string "+ \"") (sv-string (concatenate 'string (sv-string (sv-name (sv-var sv-decl ) )) (sv-string (concatenate 'string (sv-string " => \"") (sv-string (concatenate 'string (sv-string "+ tostr((*(*v_self).f_") (sv-string (concatenate 'string (sv-string (sv-name (sv-var sv-decl ) )) (sv-string "(Capture{})).(perl_er).f_perl(Capture{})) ")))))))))))))))(setf sv-sep "+ \", \" ")) nil)))(setf sv-str (concatenate 'string (sv-string sv-str) (sv-string (concatenate 'string (sv-string "+ \")\" ) }") (sv-string "
")))))) nil)(if (sv-bool (sv-and (not (sv-bool (gethash "Bool" (sv-methods sv-self)))) (not (sv-bool (gethash "Bool" (sv-attributes sv-self)))))) (progn (setf sv-str (concatenate 'string (sv-string sv-str) (sv-string (concatenate 'string (sv-string "func (v_self *") (sv-string (concatenate 'string (sv-string sv-class_name) (sv-string (concatenate 'string (sv-string ") f_Bool (v Capture) *Any { ") (sv-string (concatenate 'string (sv-string "return b_true() ") (sv-string (concatenate 'string (sv-string "}") (sv-string "
")))))))))))))) nil)(setf sv-str (concatenate 'string (sv-string sv-str) (sv-string (concatenate 'string (sv-string "// prototype of ") (sv-string (concatenate 'string (sv-string (sv-name sv-self)) (sv-string (concatenate 'string (sv-string "
") (sv-string (concatenate 'string (sv-string "var Proto_") (sv-string (concatenate 'string (sv-string sv-class_name) (sv-string (concatenate 'string (sv-string " *Any;") (sv-string "
")))))))))))))))(setf sv-str (concatenate 'string (sv-string sv-str) (sv-string (concatenate 'string (sv-string "func Init_") (sv-string (concatenate 'string (sv-string sv-class_name) (sv-string (concatenate 'string (sv-string "() {") (sv-string "
")))))))))(setf sv-str (concatenate 'string (sv-string sv-str) (sv-string (concatenate 'string (sv-string "  this_namespace := &Namespace_") (sv-string (concatenate 'string (sv-string sv-class_name) (sv-string (concatenate 'string (sv-string ";") (sv-string (concatenate 'string (sv-string "
") (sv-string (concatenate 'string (sv-string "  this_namespace = this_namespace;") (sv-string "
")))))))))))))(setf sv-str (concatenate 'string (sv-string sv-str) (sv-string (concatenate 'string (sv-string "  Proto_") (sv-string (concatenate 'string (sv-string sv-class_name) (sv-string (concatenate 'string (sv-string " = ") (sv-string (concatenate 'string (sv-string "func() *Any { ") (sv-string (concatenate 'string (sv-string "var m = new(") (sv-string (concatenate 'string (sv-string sv-class_name) (sv-string (concatenate 'string (sv-string "); ") (sv-string (concatenate 'string (sv-string "var m1 Any = m; ") (sv-string (concatenate 'string (sv-string "return &m1; ") (sv-string (concatenate 'string (sv-string "}();") (sv-string "
")))))))))))))))))))))))(dolist (sv-decl1 (sv-body sv-self)) (let ((sv-decl (sv-undef))) (setf sv-decl sv-decl1)(if (sv-bool (sv-and (typep sv-decl 'mp-Bind) (sv-and (typep (sv-parameters sv-decl ) 'mp-Decl) (sv-eq (sv-decl (sv-parameters sv-decl ) ) "my")))) (progn (setf sv-decl (sv-parameters sv-decl ))) nil)(if (sv-bool (sv-and (typep sv-decl 'mp-Decl) (sv-eq (sv-decl sv-decl ) "my"))) (progn (setf sv-str (concatenate 'string (sv-string sv-str) (sv-string (sv-emit_go_init sv-decl ))))) nil)))(dolist (sv-decl (sv-body sv-self)) (progn (if (sv-bool (sv-and (typep sv-decl 'mp-Decl) (sv-eq (sv-decl sv-decl ) "has"))) (progn (setf sv-str (concatenate 'string (sv-string sv-str) (sv-string (concatenate 'string (sv-string "  // accessor ") (sv-string (concatenate 'string (sv-string (sv-name (sv-var sv-decl ) )) (sv-string (concatenate 'string (sv-string "
") (sv-string (concatenate 'string (sv-string "  Method_") (sv-string (concatenate 'string (sv-string sv-class_name) (sv-string (concatenate 'string (sv-string ".f_") (sv-string (concatenate 'string (sv-string (sv-name (sv-var sv-decl ) )) (sv-string (concatenate 'string (sv-string " = func (v_self *") (sv-string (concatenate 'string (sv-string sv-class_name) (sv-string (concatenate 'string (sv-string ", v Capture) *Any {") (sv-string "
")))))))))))))))))))))))(setf sv-str (concatenate 'string (sv-string sv-str) (sv-string (concatenate 'string (sv-string "    ") (sv-string (concatenate 'string (sv-string "if v_self.v_") (sv-string (concatenate 'string (sv-string (sv-name (sv-var sv-decl ) )) (sv-string (concatenate 'string (sv-string " == nil {") (sv-string (concatenate 'string (sv-string "
") (sv-string (concatenate 'string (sv-string "      ") (sv-string (concatenate 'string (sv-string (sv-emit_go_init (let ((m (make-instance 'mp-Decl))) (setf (sv-decl m) "my")(setf (sv-type m) (sv-undef))(setf (sv-var m) (let ((m (make-instance 'mp-Var))) (setf (sv-sigil m) (sv-sigil (sv-var sv-decl ) ))(setf (sv-twigil m) "")(setf (sv-namespace m) "")(setf (sv-name m) "tmp") m)) m) )) (sv-string (concatenate 'string (sv-string "      ") (sv-string (concatenate 'string (sv-string "v_self.v_") (sv-string (concatenate 'string (sv-string (sv-name (sv-var sv-decl ) )) (sv-string (concatenate 'string (sv-string " = ") (sv-string (concatenate 'string (sv-string (sv-emit_go (let ((m (make-instance 'mp-Var))) (setf (sv-sigil m) (sv-sigil (sv-var sv-decl ) ))(setf (sv-twigil m) "")(setf (sv-namespace m) "")(setf (sv-name m) "tmp") m) )) (sv-string (concatenate 'string (sv-string ";") (sv-string (concatenate 'string (sv-string "
") (sv-string (concatenate 'string (sv-string "    ") (sv-string (concatenate 'string (sv-string "}") (sv-string "
")))))))))))))))))))))))))))))))))))(setf sv-str (concatenate 'string (sv-string sv-str) (sv-string (concatenate 'string (sv-string "    ") (sv-string (concatenate 'string (sv-string "if *v_self.v_") (sv-string (concatenate 'string (sv-string (sv-name (sv-var sv-decl ) )) (sv-string (concatenate 'string (sv-string " == nil {") (sv-string (concatenate 'string (sv-string "
") (sv-string (concatenate 'string (sv-string "      ") (sv-string (concatenate 'string (sv-string (sv-emit_go_init (let ((m (make-instance 'mp-Decl))) (setf (sv-decl m) "my")(setf (sv-type m) (sv-undef))(setf (sv-var m) (let ((m (make-instance 'mp-Var))) (setf (sv-sigil m) (sv-sigil (sv-var sv-decl ) ))(setf (sv-twigil m) "")(setf (sv-namespace m) "")(setf (sv-name m) "tmp") m)) m) )) (sv-string (concatenate 'string (sv-string "      ") (sv-string (concatenate 'string (sv-string "v_self.v_") (sv-string (concatenate 'string (sv-string (sv-name (sv-var sv-decl ) )) (sv-string (concatenate 'string (sv-string " = ") (sv-string (concatenate 'string (sv-string (sv-emit_go (let ((m (make-instance 'mp-Var))) (setf (sv-sigil m) (sv-sigil (sv-var sv-decl ) ))(setf (sv-twigil m) "")(setf (sv-namespace m) "")(setf (sv-name m) "tmp") m) )) (sv-string (concatenate 'string (sv-string ";") (sv-string (concatenate 'string (sv-string "
") (sv-string (concatenate 'string (sv-string "    ") (sv-string (concatenate 'string (sv-string "}") (sv-string "
")))))))))))))))))))))))))))))))))))(setf sv-str (concatenate 'string (sv-string sv-str) (sv-string (concatenate 'string (sv-string "    ") (sv-string (concatenate 'string (sv-string "return v_self.v_") (sv-string (concatenate 'string (sv-string (sv-name (sv-var sv-decl ) )) (sv-string (concatenate 'string (sv-string "
") (sv-string (concatenate 'string (sv-string "  };") (sv-string "
")))))))))))))) nil)(if (sv-bool (typep sv-decl 'mp-Method)) (let ((sv-sig (sv-undef))(sv-block (sv-undef))) (setf sv-sig (sv-sig sv-decl ))(setf sv-block (let ((m (make-instance 'mp-MiniPerl6-Go-LexicalBlock))) (setf (sv-block m) (sv-block sv-decl ))(setf (sv-needs_return m) 1)(setf (sv-top_level m) 1) m))(setf sv-str (concatenate 'string (sv-string sv-str) (sv-string (concatenate 'string (sv-string "  // method ") (sv-string (concatenate 'string (sv-string (sv-name sv-decl )) (sv-string (concatenate 'string (sv-string "
") (sv-string (concatenate 'string (sv-string "  Method_") (sv-string (concatenate 'string (sv-string sv-class_name) (sv-string (concatenate 'string (sv-string ".f_") (sv-string (concatenate 'string (sv-string (sv-name sv-decl )) (sv-string (concatenate 'string (sv-string " = func (self *") (sv-string (concatenate 'string (sv-string sv-class_name) (sv-string (concatenate 'string (sv-string ", v Capture) *Any {") (sv-string "
")))))))))))))))))))))))(setf sv-str (concatenate 'string (sv-string sv-str) (sv-string (concatenate 'string (sv-string "    var self1 Any = self;") (sv-string (concatenate 'string (sv-string "
") (sv-string (concatenate 'string (sv-string "    var ") (sv-string (concatenate 'string (sv-string (sv-emit_go (sv-invocant sv-sig ) )) (sv-string (concatenate 'string (sv-string " *Any = &self1;") (sv-string (concatenate 'string (sv-string "
") (sv-string (concatenate 'string (sv-string "    ") (sv-string (concatenate 'string (sv-string (sv-emit_go (sv-invocant sv-sig ) )) (sv-string (concatenate 'string (sv-string " = ") (sv-string (concatenate 'string (sv-string (sv-emit_go (sv-invocant sv-sig ) )) (sv-string (concatenate 'string (sv-string ";") (sv-string (concatenate 'string (sv-string "
") (sv-string (concatenate 'string (sv-string "    ") (sv-string (concatenate 'string (sv-string (sv-emit_go_bind sv-sig )) (sv-string "
")))))))))))))))))))))))))))))))(setf sv-str (concatenate 'string (sv-string sv-str) (sv-string (concatenate 'string (sv-string "    p := make(chan *Any); go func () { ") (sv-string (concatenate 'string (sv-string "
") (sv-string (concatenate 'string (sv-string "        ") (sv-string (concatenate 'string (sv-string (sv-emit_go sv-block )) (sv-string (concatenate 'string (sv-string "; return }(); ") (sv-string (concatenate 'string (sv-string "
") (sv-string (concatenate 'string (sv-string "    return <-p; ") (sv-string (concatenate 'string (sv-string "
") (sv-string (concatenate 'string (sv-string "  };") (sv-string "
")))))))))))))))))))))) nil)(if (sv-bool (typep sv-decl 'mp-Sub)) (let ((sv-sig (sv-undef))(sv-block (sv-undef))) (setf sv-sig (sv-sig sv-decl ))(setf sv-block (let ((m (make-instance 'mp-MiniPerl6-Go-LexicalBlock))) (setf (sv-block m) (sv-block sv-decl ))(setf (sv-needs_return m) 1)(setf (sv-top_level m) 1) m))(setf sv-str (concatenate 'string (sv-string sv-str) (sv-string (concatenate 'string (sv-string "  // sub ") (sv-string (concatenate 'string (sv-string (sv-name sv-decl )) (sv-string (concatenate 'string (sv-string "
") (sv-string (concatenate 'string (sv-string "  Namespace_") (sv-string (concatenate 'string (sv-string sv-class_name) (sv-string (concatenate 'string (sv-string ".f_") (sv-string (concatenate 'string (sv-string (sv-name sv-decl )) (sv-string (concatenate 'string (sv-string " = Function( func (v Capture) *Any {") (sv-string "
")))))))))))))))))))(setf sv-str (concatenate 'string (sv-string sv-str) (sv-string (concatenate 'string (sv-string "    ") (sv-string (concatenate 'string (sv-string (sv-emit_go_bind sv-sig )) (sv-string (concatenate 'string (sv-string "
") (sv-string (concatenate 'string (sv-string "    p := make(chan *Any); go func () { ") (sv-string (concatenate 'string (sv-string "
") (sv-string (concatenate 'string (sv-string "        ") (sv-string (concatenate 'string (sv-string (sv-emit_go sv-block )) (sv-string (concatenate 'string (sv-string "; return }(); ") (sv-string "
")))))))))))))))))))(setf sv-str (concatenate 'string (sv-string sv-str) (sv-string (concatenate 'string (sv-string "    return <-p; ") (sv-string (concatenate 'string (sv-string "
") (sv-string (concatenate 'string (sv-string "  } );") (sv-string "
")))))))))) nil)))(setf sv-str (concatenate 'string (sv-string sv-str) (sv-string (concatenate 'string (sv-string "  // main runtime block of ") (sv-string (concatenate 'string (sv-string (sv-name sv-self)) (sv-string (concatenate 'string (sv-string "
") (sv-string (concatenate 'string (sv-string "  Run_") (sv-string (concatenate 'string (sv-string sv-class_name) (sv-string (concatenate 'string (sv-string " = func () {") (sv-string "
")))))))))))))))(dolist (sv-decl (sv-body sv-self)) (progn (if (sv-bool (sv-and (not (sv-bool (sv-and (typep sv-decl 'mp-Decl) (sv-or (sv-eq (sv-decl sv-decl ) "has") (sv-eq (sv-decl sv-decl ) "my"))))) (sv-and (not (sv-bool (typep sv-decl 'mp-Method))) (not (sv-bool (typep sv-decl 'mp-Sub)))))) (progn (setf sv-str (concatenate 'string (sv-string sv-str) (sv-string (concatenate 'string (sv-string "    ") (sv-string (concatenate 'string (sv-string (sv-emit_go sv-decl )) (sv-string (concatenate 'string (sv-string ";") (sv-string "
")))))))))) nil)))(setf sv-str (concatenate 'string (sv-string sv-str) (sv-string (concatenate 'string (sv-string "  }") (sv-string "
")))))(setf sv-str (concatenate 'string (sv-string sv-str) (sv-string (concatenate 'string (sv-string "}") (sv-string "
")))))(return-from mp6-function sv-str))))

(in-package mp-CompUnit)
  (defun sv-emit_go_program (&optional sv-comp_units )
  (block mp6-function (let ((sv-str (sv-undef))(sv-unit_seen (sv-undef))(sv-tmp_comp_unit nil)(sv-meth_seen (sv-undef))) (setf sv-str "")(dolist (sv-comp_unit sv-comp_units) (let ((sv-name (sv-undef))) (setf sv-name (sv-name sv-comp_unit ))(if (sv-bool (gethash sv-name sv-unit_seen)) (progn (dolist (sv-stmt (sv-body sv-comp_unit )) (progn (sv-push (sv-body (gethash sv-name sv-unit_seen) ) sv-stmt)))) (progn (setf (gethash sv-name sv-unit_seen) sv-comp_unit)(sv-push sv-tmp_comp_unit sv-comp_unit)))))(setf sv-comp_units sv-tmp_comp_unit)(dolist (sv-comp_unit sv-comp_units) (progn (dolist (sv-stmt (sv-body sv-comp_unit )) (progn (if (sv-bool (typep sv-stmt 'mp-Method)) (progn (setf (gethash (sv-name sv-stmt ) (sv-methods sv-comp_unit )) sv-stmt)) nil)(if (sv-bool (sv-and (typep sv-stmt 'mp-Decl) (sv-eq (sv-decl sv-stmt ) "has"))) (progn (setf (gethash (sv-name (sv-var sv-stmt ) ) (sv-attributes sv-comp_unit )) sv-stmt)) nil)))))(dolist (sv-comp_unit sv-comp_units) (progn (setf sv-str (concatenate 'string (sv-string sv-str) (sv-string (sv-emit_go sv-comp_unit ))))))(if (sv-bool (not (sv-bool (gethash "MiniPerl6::Grammar" sv-unit_seen)))) (progn (setf sv-str (concatenate 'string (sv-string sv-str) (sv-string "type MiniPerl6__Grammar struct{}
")))) nil)(setf sv-str (concatenate 'string (sv-string sv-str) (sv-string "// interfaces for all methods
")))(setf sv-meth_seen (let ((h (make-hash-table :test 'equal))) (setf (gethash "join" h) 1)(setf (gethash "perl" h) 1)(setf (gethash "scalar" h) 1)(setf (gethash "isa" h) 1)(setf (gethash "values" h) 1)(setf (gethash "keys" h) 1)(setf (gethash "bind" h) 1)(setf (gethash "int" h) 1)(setf (gethash "str" h) 1)(setf (gethash "Str" h) 1)(setf (gethash "bool" h) 1)(setf (gethash "Bool" h) 1)(setf (gethash "array" h) 1)(setf (gethash "hash" h) 1)(setf (gethash "push" h) 1)(setf (gethash "pop" h) 1)(setf (gethash "shift" h) 1)(setf (gethash "lookup" h) 1)(setf (gethash "index" h) 1) h))(dolist (sv-comp_unit sv-comp_units) (progn (dolist (sv-stmt (sv-body sv-comp_unit )) (progn (if (sv-bool (sv-and (typep sv-stmt 'mp-Method) (not (sv-bool (gethash (sv-name sv-stmt ) sv-meth_seen))))) (let ((sv-meth (sv-undef))) (setf sv-meth (sv-name sv-stmt ))(setf sv-str (concatenate 'string (sv-string sv-str) (sv-string (concatenate 'string (sv-string "type ") (sv-string (concatenate 'string (sv-string sv-meth) (sv-string (concatenate 'string (sv-string "_er interface { f_") (sv-string (concatenate 'string (sv-string sv-meth) (sv-string " (Capture) *Any }
")))))))))))(setf (gethash sv-meth sv-meth_seen) 1)) nil)(if (sv-bool (sv-and (typep sv-stmt 'mp-Decl) (sv-and (sv-eq (sv-decl sv-stmt ) "has") (not (sv-bool (gethash (sv-name (sv-var sv-stmt ) ) sv-meth_seen)))))) (let ((sv-meth (sv-undef))) (setf sv-meth (sv-name (sv-var sv-stmt ) ))(setf sv-str (concatenate 'string (sv-string sv-str) (sv-string (concatenate 'string (sv-string "type ") (sv-string (concatenate 'string (sv-string sv-meth) (sv-string (concatenate 'string (sv-string "_er interface { f_") (sv-string (concatenate 'string (sv-string sv-meth) (sv-string " (Capture) *Any }
")))))))))))(setf (gethash sv-meth sv-meth_seen) 1)) nil)))))(setf sv-str (concatenate 'string (sv-string sv-str) (sv-string (concatenate 'string (sv-string "
") (sv-string (concatenate 'string (sv-string "func main () {
") (sv-string "  Init_MiniPerl6__Match();
")))))))(dolist (sv-comp_unit sv-comp_units) (progn (setf sv-str (concatenate 'string (sv-string sv-str) (sv-string (concatenate 'string (sv-string "  Init_") (sv-string (concatenate 'string (sv-string (mp-Main::sv-to_go_namespace (sv-name sv-comp_unit ))) (sv-string "();
")))))))))(setf sv-str (concatenate 'string (sv-string sv-str) (sv-string "  Init_Prelude();
")))(dolist (sv-comp_unit sv-comp_units) (progn (setf sv-str (concatenate 'string (sv-string sv-str) (sv-string (concatenate 'string (sv-string "  Run_") (sv-string (concatenate 'string (sv-string (mp-Main::sv-to_go_namespace (sv-name sv-comp_unit ))) (sv-string "();
")))))))))(setf sv-str (concatenate 'string (sv-string sv-str) (sv-string (concatenate 'string (sv-string "}") (sv-string "
")))))(return-from mp6-function sv-str))))

(in-package mp-Main)
(defmethod sv-perl ((self mp-CompUnit))
  (mp-Main::sv-lisp_dump_object "::CompUnit" (list (let ((m (make-instance 'mp-Pair))) (setf (sv-key m) "name") (setf (sv-value m) (sv-name self)) m) (let ((m (make-instance 'mp-Pair))) (setf (sv-key m) "attributes") (setf (sv-value m) (sv-attributes self)) m) (let ((m (make-instance 'mp-Pair))) (setf (sv-key m) "methods") (setf (sv-value m) (sv-methods self)) m) (let ((m (make-instance 'mp-Pair))) (setf (sv-key m) "body") (setf (sv-value m) (sv-body self)) m) )))




;; class Val::Int
(defpackage mp-Val-Int
  (:use common-lisp mp-Main))
;; (in-package mp-Val-Int)
(if (not (ignore-errors (find-class 'mp-Val-Int)))
  (defclass mp-Val-Int () ()))

(let (x) 
  (setq x (make-instance 'mp-Val-Int))
  (defun proto-mp-Val-Int () x))
;; has $.int
(let ((new-slots (list (list :name 'sv-int
  :readers '(sv-int)
  :writers '((setf sv-int))
  :initform '(sv-undef)
  :initfunction (constantly (sv-undef))))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-Val-Int)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-Val-Int :direct-slots new-slots))

;; method emit_go
(if (not (ignore-errors (find-method 'sv-emit_go () ())))
  (defgeneric sv-emit_go (sv-self)
      (:documentation "a method")))
(defmethod sv-emit_go ((sv-self mp-Val-Int))
  (block mp6-function
    (progn (concatenate 'string (sv-string "toInt(") (sv-string (concatenate 'string (sv-string (sv-int sv-self)) (sv-string ")")))))))

(defmethod sv-perl ((self mp-Val-Int))
  (mp-Main::sv-lisp_dump_object "::Val::Int" (list (let ((m (make-instance 'mp-Pair))) (setf (sv-key m) "int") (setf (sv-value m) (sv-int self)) m) )))




;; class Val::Bit
(defpackage mp-Val-Bit
  (:use common-lisp mp-Main))
;; (in-package mp-Val-Bit)
(if (not (ignore-errors (find-class 'mp-Val-Bit)))
  (defclass mp-Val-Bit () ()))

(let (x) 
  (setq x (make-instance 'mp-Val-Bit))
  (defun proto-mp-Val-Bit () x))
;; has $.bit
(let ((new-slots (list (list :name 'sv-bit
  :readers '(sv-bit)
  :writers '((setf sv-bit))
  :initform '(sv-undef)
  :initfunction (constantly (sv-undef))))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-Val-Bit)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-Val-Bit :direct-slots new-slots))

;; method emit_go
(if (not (ignore-errors (find-method 'sv-emit_go () ())))
  (defgeneric sv-emit_go (sv-self)
      (:documentation "a method")))
(defmethod sv-emit_go ((sv-self mp-Val-Bit))
  (block mp6-function
    (progn (concatenate 'string (sv-string "toBit(") (sv-string (concatenate 'string (sv-string (sv-bit sv-self)) (sv-string ")")))))))

(defmethod sv-perl ((self mp-Val-Bit))
  (mp-Main::sv-lisp_dump_object "::Val::Bit" (list (let ((m (make-instance 'mp-Pair))) (setf (sv-key m) "bit") (setf (sv-value m) (sv-bit self)) m) )))




;; class Val::Num
(defpackage mp-Val-Num
  (:use common-lisp mp-Main))
;; (in-package mp-Val-Num)
(if (not (ignore-errors (find-class 'mp-Val-Num)))
  (defclass mp-Val-Num () ()))

(let (x) 
  (setq x (make-instance 'mp-Val-Num))
  (defun proto-mp-Val-Num () x))
;; has $.num
(let ((new-slots (list (list :name 'sv-num
  :readers '(sv-num)
  :writers '((setf sv-num))
  :initform '(sv-undef)
  :initfunction (constantly (sv-undef))))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-Val-Num)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-Val-Num :direct-slots new-slots))

;; method emit_go
(if (not (ignore-errors (find-method 'sv-emit_go () ())))
  (defgeneric sv-emit_go (sv-self)
      (:documentation "a method")))
(defmethod sv-emit_go ((sv-self mp-Val-Num))
  (block mp6-function
    (progn (concatenate 'string (sv-string "toNum(") (sv-string (concatenate 'string (sv-string (sv-num sv-self)) (sv-string ")")))))))

(defmethod sv-perl ((self mp-Val-Num))
  (mp-Main::sv-lisp_dump_object "::Val::Num" (list (let ((m (make-instance 'mp-Pair))) (setf (sv-key m) "num") (setf (sv-value m) (sv-num self)) m) )))




;; class Val::Buf
(defpackage mp-Val-Buf
  (:use common-lisp mp-Main))
;; (in-package mp-Val-Buf)
(if (not (ignore-errors (find-class 'mp-Val-Buf)))
  (defclass mp-Val-Buf () ()))

(let (x) 
  (setq x (make-instance 'mp-Val-Buf))
  (defun proto-mp-Val-Buf () x))
;; has $.buf
(let ((new-slots (list (list :name 'sv-buf
  :readers '(sv-buf)
  :writers '((setf sv-buf))
  :initform '(sv-undef)
  :initfunction (constantly (sv-undef))))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-Val-Buf)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-Val-Buf :direct-slots new-slots))

;; method emit_go
(if (not (ignore-errors (find-method 'sv-emit_go () ())))
  (defgeneric sv-emit_go (sv-self)
      (:documentation "a method")))
(defmethod sv-emit_go ((sv-self mp-Val-Buf))
  (block mp6-function
    (progn (concatenate 'string (sv-string "toStr(\"") (sv-string (concatenate 'string (sv-string (mp-Main::sv-javascript_escape_string (sv-buf sv-self))) (sv-string "\")")))))))

(defmethod sv-perl ((self mp-Val-Buf))
  (mp-Main::sv-lisp_dump_object "::Val::Buf" (list (let ((m (make-instance 'mp-Pair))) (setf (sv-key m) "buf") (setf (sv-value m) (sv-buf self)) m) )))




;; class Val::Undef
(defpackage mp-Val-Undef
  (:use common-lisp mp-Main))
;; (in-package mp-Val-Undef)
(if (not (ignore-errors (find-class 'mp-Val-Undef)))
  (defclass mp-Val-Undef () ()))

(let (x) 
  (setq x (make-instance 'mp-Val-Undef))
  (defun proto-mp-Val-Undef () x))
;; method emit_go
(if (not (ignore-errors (find-method 'sv-emit_go () ())))
  (defgeneric sv-emit_go (sv-self)
      (:documentation "a method")))
(defmethod sv-emit_go ((sv-self mp-Val-Undef))
  (block mp6-function
    (progn "u_undef()")))

(defmethod sv-perl ((self mp-Val-Undef))
  (mp-Main::sv-lisp_dump_object "::Val::Undef" (list )))




;; class Val::Object
(defpackage mp-Val-Object
  (:use common-lisp mp-Main))
;; (in-package mp-Val-Object)
(if (not (ignore-errors (find-class 'mp-Val-Object)))
  (defclass mp-Val-Object () ()))

(let (x) 
  (setq x (make-instance 'mp-Val-Object))
  (defun proto-mp-Val-Object () x))
;; has $.class
(let ((new-slots (list (list :name 'sv-class
  :readers '(sv-class)
  :writers '((setf sv-class))
  :initform '(sv-undef)
  :initfunction (constantly (sv-undef))))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-Val-Object)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-Val-Object :direct-slots new-slots))

;; has $.fields
(let ((new-slots (list (list :name 'sv-fields
  :readers '(sv-fields)
  :writers '((setf sv-fields))
  :initform '(sv-undef)
  :initfunction (constantly (sv-undef))))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-Val-Object)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-Val-Object :direct-slots new-slots))

;; method emit_go
(if (not (ignore-errors (find-method 'sv-emit_go () ())))
  (defgeneric sv-emit_go (sv-self)
      (:documentation "a method")))
(defmethod sv-emit_go ((sv-self mp-Val-Object))
  (block mp6-function
    (progn (progn (write-line (format nil "~{~a~}" (list "Val::Object - not used yet")) *error-output*) (sb-ext:quit)))))

(defmethod sv-perl ((self mp-Val-Object))
  (mp-Main::sv-lisp_dump_object "::Val::Object" (list (let ((m (make-instance 'mp-Pair))) (setf (sv-key m) "class") (setf (sv-value m) (sv-class self)) m) (let ((m (make-instance 'mp-Pair))) (setf (sv-key m) "fields") (setf (sv-value m) (sv-fields self)) m) )))




;; class Lit::Seq
(defpackage mp-Lit-Seq
  (:use common-lisp mp-Main))
;; (in-package mp-Lit-Seq)
(if (not (ignore-errors (find-class 'mp-Lit-Seq)))
  (defclass mp-Lit-Seq () ()))

(let (x) 
  (setq x (make-instance 'mp-Lit-Seq))
  (defun proto-mp-Lit-Seq () x))
;; has $.seq
(let ((new-slots (list (list :name 'sv-seq
  :readers '(sv-seq)
  :writers '((setf sv-seq))
  :initform '(sv-undef)
  :initfunction (constantly (sv-undef))))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-Lit-Seq)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-Lit-Seq :direct-slots new-slots))

;; method emit_go
(if (not (ignore-errors (find-method 'sv-emit_go () ())))
  (defgeneric sv-emit_go (sv-self)
      (:documentation "a method")))
(defmethod sv-emit_go ((sv-self mp-Lit-Seq))
  (block mp6-function
    (progn (concatenate 'string (sv-string "[]*Any{ ") (sv-string (concatenate 'string (sv-string (sv-join (mapcar #'sv-emit_go (sv-seq sv-self)) ", ")) (sv-string " }")))))))

(defmethod sv-perl ((self mp-Lit-Seq))
  (mp-Main::sv-lisp_dump_object "::Lit::Seq" (list (let ((m (make-instance 'mp-Pair))) (setf (sv-key m) "seq") (setf (sv-value m) (sv-seq self)) m) )))




;; class Lit::Array
(defpackage mp-Lit-Array
  (:use common-lisp mp-Main))
;; (in-package mp-Lit-Array)
(if (not (ignore-errors (find-class 'mp-Lit-Array)))
  (defclass mp-Lit-Array () ()))

(let (x) 
  (setq x (make-instance 'mp-Lit-Array))
  (defun proto-mp-Lit-Array () x))
;; has $.array1
(let ((new-slots (list (list :name 'sv-array1
  :readers '(sv-array1)
  :writers '((setf sv-array1))
  :initform '(sv-undef)
  :initfunction (constantly (sv-undef))))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-Lit-Array)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-Lit-Array :direct-slots new-slots))

;; method emit_go
(if (not (ignore-errors (find-method 'sv-emit_go () ())))
  (defgeneric sv-emit_go (sv-self)
      (:documentation "a method")))
(defmethod sv-emit_go ((sv-self mp-Lit-Array))
  (block mp6-function
    (let ((sv-str (sv-undef))) (setf sv-str "")(dolist (sv-item (sv-array1 sv-self)) (progn (if (sv-bool (sv-or (sv-and (typep sv-item 'mp-Var) (sv-eq (sv-sigil sv-item ) "@")) (sv-and (typep sv-item 'mp-Apply) (sv-eq (sv-code sv-item ) "prefix:<@>")))) (progn (setf sv-str (concatenate 'string (sv-string sv-str) (sv-string (concatenate 'string (sv-string "func(a_ *Array) { ") (sv-string (concatenate 'string (sv-string "for i_ := 0; i_ <= a_.n; i_++ { (*a).(push_er).f_push( Capture{ p: []*Any{ a_.v[i_] } } ) } ") (sv-string (concatenate 'string (sv-string "}( (*") (sv-string (concatenate 'string (sv-string (mp-Call::sv-emit_go_call sv-item "array")) (sv-string ").(*Array) ); ")))))))))))) (progn (setf sv-str (concatenate 'string (sv-string sv-str) (sv-string (concatenate 'string (sv-string "(*a).(push_er).f_push( Capture{ p: []*Any{ ") (sv-string (concatenate 'string (sv-string (sv-emit_go sv-item )) (sv-string " } } ); ")))))))))))(concatenate 'string (sv-string "func () *Any { ") (sv-string (concatenate 'string (sv-string "a := a_array(); ") (sv-string (concatenate 'string (sv-string sv-str) (sv-string (concatenate 'string (sv-string "return a; ") (sv-string "}()")))))))))))

(defmethod sv-perl ((self mp-Lit-Array))
  (mp-Main::sv-lisp_dump_object "::Lit::Array" (list (let ((m (make-instance 'mp-Pair))) (setf (sv-key m) "array1") (setf (sv-value m) (sv-array1 self)) m) )))




;; class Lit::Hash
(defpackage mp-Lit-Hash
  (:use common-lisp mp-Main))
;; (in-package mp-Lit-Hash)
(if (not (ignore-errors (find-class 'mp-Lit-Hash)))
  (defclass mp-Lit-Hash () ()))

(let (x) 
  (setq x (make-instance 'mp-Lit-Hash))
  (defun proto-mp-Lit-Hash () x))
;; has $.hash1
(let ((new-slots (list (list :name 'sv-hash1
  :readers '(sv-hash1)
  :writers '((setf sv-hash1))
  :initform '(sv-undef)
  :initfunction (constantly (sv-undef))))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-Lit-Hash)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-Lit-Hash :direct-slots new-slots))

;; method emit_go
(if (not (ignore-errors (find-method 'sv-emit_go () ())))
  (defgeneric sv-emit_go (sv-self)
      (:documentation "a method")))
(defmethod sv-emit_go ((sv-self mp-Lit-Hash))
  (block mp6-function
    (let ((sv-fields (sv-undef))(sv-str (sv-undef))) (setf sv-fields (sv-hash1 sv-self))(setf sv-str "")(dolist (sv-field sv-fields) (progn (setf sv-str (concatenate 'string (sv-string sv-str) (sv-string (concatenate 'string (sv-string "*(*m).(lookup_er).f_lookup( Capture{ p : []*Any{ ") (sv-string (concatenate 'string (sv-string (sv-emit_go (elt sv-field 0) )) (sv-string (concatenate 'string (sv-string " }} ) = *(") (sv-string (concatenate 'string (sv-string (sv-emit_go (elt sv-field 1) )) (sv-string "); ")))))))))))))(concatenate 'string (sv-string "func() *Any { ") (sv-string (concatenate 'string (sv-string "m := h_hash(); ") (sv-string (concatenate 'string (sv-string sv-str) (sv-string (concatenate 'string (sv-string "return m; ") (sv-string "}()")))))))))))

(defmethod sv-perl ((self mp-Lit-Hash))
  (mp-Main::sv-lisp_dump_object "::Lit::Hash" (list (let ((m (make-instance 'mp-Pair))) (setf (sv-key m) "hash1") (setf (sv-value m) (sv-hash1 self)) m) )))




;; class Lit::Code
(defpackage mp-Lit-Code
  (:use common-lisp mp-Main))
;; (in-package mp-Lit-Code)
(if (not (ignore-errors (find-class 'mp-Lit-Code)))
  (defclass mp-Lit-Code () ()))

(let (x) 
  (setq x (make-instance 'mp-Lit-Code))
  (defun proto-mp-Lit-Code () x))
(defmethod sv-perl ((self mp-Lit-Code))
  (mp-Main::sv-lisp_dump_object "::Lit::Code" (list )))




;; class Lit::Object
(defpackage mp-Lit-Object
  (:use common-lisp mp-Main))
;; (in-package mp-Lit-Object)
(if (not (ignore-errors (find-class 'mp-Lit-Object)))
  (defclass mp-Lit-Object () ()))

(let (x) 
  (setq x (make-instance 'mp-Lit-Object))
  (defun proto-mp-Lit-Object () x))
;; has $.class
(let ((new-slots (list (list :name 'sv-class
  :readers '(sv-class)
  :writers '((setf sv-class))
  :initform '(sv-undef)
  :initfunction (constantly (sv-undef))))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-Lit-Object)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-Lit-Object :direct-slots new-slots))

;; has $.fields
(let ((new-slots (list (list :name 'sv-fields
  :readers '(sv-fields)
  :writers '((setf sv-fields))
  :initform '(sv-undef)
  :initfunction (constantly (sv-undef))))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-Lit-Object)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-Lit-Object :direct-slots new-slots))

;; method emit_go
(if (not (ignore-errors (find-method 'sv-emit_go () ())))
  (defgeneric sv-emit_go (sv-self)
      (:documentation "a method")))
(defmethod sv-emit_go ((sv-self mp-Lit-Object))
  (block mp6-function
    (let ((sv-fields (sv-undef))(sv-str (sv-undef))) (setf sv-fields (sv-fields sv-self))(setf sv-str "")(dolist (sv-field sv-fields) (progn (setf sv-str (concatenate 'string (sv-string sv-str) (sv-string (concatenate 'string (sv-string "if m.v_") (sv-string (concatenate 'string (sv-string (sv-buf (elt sv-field 0) )) (sv-string (concatenate 'string (sv-string " == nil {") (sv-string (concatenate 'string (sv-string "
") (sv-string (concatenate 'string (sv-string "var p Any; ") (sv-string (concatenate 'string (sv-string "
") (sv-string (concatenate 'string (sv-string "m.v_") (sv-string (concatenate 'string (sv-string (sv-buf (elt sv-field 0) )) (sv-string (concatenate 'string (sv-string " = &p; ") (sv-string (concatenate 'string (sv-string "
") (sv-string (concatenate 'string (sv-string "}") (sv-string (concatenate 'string (sv-string "
") (sv-string (concatenate 'string (sv-string "*m.v_") (sv-string (concatenate 'string (sv-string (sv-buf (elt sv-field 0) )) (sv-string (concatenate 'string (sv-string " = *") (sv-string (concatenate 'string (sv-string (sv-emit_go (elt sv-field 1) )) (sv-string (concatenate 'string (sv-string "; ") (sv-string "
")))))))))))))))))))))))))))))))))))))))(concatenate 'string (sv-string "func() *Any { ") (sv-string (concatenate 'string (sv-string "
") (sv-string (concatenate 'string (sv-string "  var m = new(") (sv-string (concatenate 'string (sv-string (mp-Main::sv-to_go_namespace (sv-class sv-self))) (sv-string (concatenate 'string (sv-string "); ") (sv-string (concatenate 'string (sv-string "
") (sv-string (concatenate 'string (sv-string "  ") (sv-string (concatenate 'string (sv-string sv-str) (sv-string (concatenate 'string (sv-string "
") (sv-string (concatenate 'string (sv-string "  var m1 Any = m; ") (sv-string (concatenate 'string (sv-string "
") (sv-string (concatenate 'string (sv-string "  return &m1; ") (sv-string (concatenate 'string (sv-string "
") (sv-string "}()")))))))))))))))))))))))))))))

(defmethod sv-perl ((self mp-Lit-Object))
  (mp-Main::sv-lisp_dump_object "::Lit::Object" (list (let ((m (make-instance 'mp-Pair))) (setf (sv-key m) "class") (setf (sv-value m) (sv-class self)) m) (let ((m (make-instance 'mp-Pair))) (setf (sv-key m) "fields") (setf (sv-value m) (sv-fields self)) m) )))




;; class Index
(defpackage mp-Index
  (:use common-lisp mp-Main))
;; (in-package mp-Index)
(if (not (ignore-errors (find-class 'mp-Index)))
  (defclass mp-Index () ()))

(let (x) 
  (setq x (make-instance 'mp-Index))
  (defun proto-mp-Index () x))
;; has $.obj
(let ((new-slots (list (list :name 'sv-obj
  :readers '(sv-obj)
  :writers '((setf sv-obj))
  :initform '(sv-undef)
  :initfunction (constantly (sv-undef))))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-Index)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-Index :direct-slots new-slots))

;; has $.index_exp
(let ((new-slots (list (list :name 'sv-index_exp
  :readers '(sv-index_exp)
  :writers '((setf sv-index_exp))
  :initform '(sv-undef)
  :initfunction (constantly (sv-undef))))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-Index)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-Index :direct-slots new-slots))

;; method emit_go
(if (not (ignore-errors (find-method 'sv-emit_go () ())))
  (defgeneric sv-emit_go (sv-self)
      (:documentation "a method")))
(defmethod sv-emit_go ((sv-self mp-Index))
  (block mp6-function
    (progn (concatenate 'string (sv-string "(*(*") (sv-string (concatenate 'string (sv-string (sv-emit_go (sv-obj sv-self) )) (sv-string (concatenate 'string (sv-string ").(array_er).f_array(Capture{}))") (sv-string (concatenate 'string (sv-string ".(index_er).f_index( Capture{ p : []*Any{ ") (sv-string (concatenate 'string (sv-string (sv-emit_go (sv-index_exp sv-self) )) (sv-string " }} )")))))))))))))

(defmethod sv-perl ((self mp-Index))
  (mp-Main::sv-lisp_dump_object "::Index" (list (let ((m (make-instance 'mp-Pair))) (setf (sv-key m) "obj") (setf (sv-value m) (sv-obj self)) m) (let ((m (make-instance 'mp-Pair))) (setf (sv-key m) "index_exp") (setf (sv-value m) (sv-index_exp self)) m) )))




;; class Lookup
(defpackage mp-Lookup
  (:use common-lisp mp-Main))
;; (in-package mp-Lookup)
(if (not (ignore-errors (find-class 'mp-Lookup)))
  (defclass mp-Lookup () ()))

(let (x) 
  (setq x (make-instance 'mp-Lookup))
  (defun proto-mp-Lookup () x))
;; has $.obj
(let ((new-slots (list (list :name 'sv-obj
  :readers '(sv-obj)
  :writers '((setf sv-obj))
  :initform '(sv-undef)
  :initfunction (constantly (sv-undef))))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-Lookup)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-Lookup :direct-slots new-slots))

;; has $.index_exp
(let ((new-slots (list (list :name 'sv-index_exp
  :readers '(sv-index_exp)
  :writers '((setf sv-index_exp))
  :initform '(sv-undef)
  :initfunction (constantly (sv-undef))))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-Lookup)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-Lookup :direct-slots new-slots))

;; method emit_go
(if (not (ignore-errors (find-method 'sv-emit_go () ())))
  (defgeneric sv-emit_go (sv-self)
      (:documentation "a method")))
(defmethod sv-emit_go ((sv-self mp-Lookup))
  (block mp6-function
    (progn (concatenate 'string (sv-string "(*(*") (sv-string (concatenate 'string (sv-string (sv-emit_go (sv-obj sv-self) )) (sv-string (concatenate 'string (sv-string ").(hash_er).f_hash(Capture{}))") (sv-string (concatenate 'string (sv-string ".(lookup_er).f_lookup( Capture{ p : []*Any{ ") (sv-string (concatenate 'string (sv-string (sv-emit_go (sv-index_exp sv-self) )) (sv-string " }} )")))))))))))))

(defmethod sv-perl ((self mp-Lookup))
  (mp-Main::sv-lisp_dump_object "::Lookup" (list (let ((m (make-instance 'mp-Pair))) (setf (sv-key m) "obj") (setf (sv-value m) (sv-obj self)) m) (let ((m (make-instance 'mp-Pair))) (setf (sv-key m) "index_exp") (setf (sv-value m) (sv-index_exp self)) m) )))




;; class Var
(defpackage mp-Var
  (:use common-lisp mp-Main))
;; (in-package mp-Var)
(if (not (ignore-errors (find-class 'mp-Var)))
  (defclass mp-Var () ()))

(let (x) 
  (setq x (make-instance 'mp-Var))
  (defun proto-mp-Var () x))
;; has $.sigil
(let ((new-slots (list (list :name 'sv-sigil
  :readers '(sv-sigil)
  :writers '((setf sv-sigil))
  :initform '(sv-undef)
  :initfunction (constantly (sv-undef))))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-Var)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-Var :direct-slots new-slots))

;; has $.twigil
(let ((new-slots (list (list :name 'sv-twigil
  :readers '(sv-twigil)
  :writers '((setf sv-twigil))
  :initform '(sv-undef)
  :initfunction (constantly (sv-undef))))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-Var)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-Var :direct-slots new-slots))

;; has $.namespace
(let ((new-slots (list (list :name 'sv-namespace
  :readers '(sv-namespace)
  :writers '((setf sv-namespace))
  :initform '(sv-undef)
  :initfunction (constantly (sv-undef))))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-Var)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-Var :direct-slots new-slots))

;; has $.name
(let ((new-slots (list (list :name 'sv-name
  :readers '(sv-name)
  :writers '((setf sv-name))
  :initform '(sv-undef)
  :initfunction (constantly (sv-undef))))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-Var)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-Var :direct-slots new-slots))

;; method emit_go
(if (not (ignore-errors (find-method 'sv-emit_go () ())))
  (defgeneric sv-emit_go (sv-self)
      (:documentation "a method")))
(defmethod sv-emit_go ((sv-self mp-Var))
  (block mp6-function
    (let ((sv-table (sv-undef))(sv-ns (sv-undef))) (setf sv-table (let ((h (make-hash-table :test 'equal))) (setf (gethash "$" h) "v_")(setf (gethash "@" h) "List_")(setf (gethash "%" h) "Hash_")(setf (gethash "&" h) "Code_") h))(setf sv-ns "")(if (sv-bool (sv-namespace sv-self)) (progn (setf sv-ns (concatenate 'string (sv-string (mp-Main::sv-to_go_namespace (sv-namespace sv-self))) (sv-string ".")))) nil)(if (sv-bool (sv-eq (sv-twigil sv-self) ".")) (concatenate 'string (sv-string "(*v_self).(") (sv-string (concatenate 'string (sv-string (sv-name sv-self)) (sv-string (concatenate 'string (sv-string "_er).f_") (sv-string (concatenate 'string (sv-string (sv-name sv-self)) (sv-string "(Capture{})")))))))) (if (sv-bool (sv-eq (sv-name sv-self) "/")) "v_MATCH" (concatenate 'string (sv-string (gethash (sv-sigil sv-self) sv-table)) (sv-string (concatenate 'string (sv-string sv-ns) (sv-string (sv-name sv-self))))))))))

;; method plain_name
(if (not (ignore-errors (find-method 'sv-plain_name () ())))
  (defgeneric sv-plain_name (sv-self)
      (:documentation "a method")))
(defmethod sv-plain_name ((sv-self mp-Var))
  (block mp6-function
    (progn (if (sv-bool (sv-namespace sv-self)) (progn (return-from mp6-function (concatenate 'string (sv-string (sv-namespace sv-self)) (sv-string (concatenate 'string (sv-string ".") (sv-string (sv-name sv-self))))))) nil)(return-from mp6-function (sv-name sv-self)))))

(defmethod sv-perl ((self mp-Var))
  (mp-Main::sv-lisp_dump_object "::Var" (list (let ((m (make-instance 'mp-Pair))) (setf (sv-key m) "sigil") (setf (sv-value m) (sv-sigil self)) m) (let ((m (make-instance 'mp-Pair))) (setf (sv-key m) "twigil") (setf (sv-value m) (sv-twigil self)) m) (let ((m (make-instance 'mp-Pair))) (setf (sv-key m) "namespace") (setf (sv-value m) (sv-namespace self)) m) (let ((m (make-instance 'mp-Pair))) (setf (sv-key m) "name") (setf (sv-value m) (sv-name self)) m) )))




;; class Bind
(defpackage mp-Bind
  (:use common-lisp mp-Main))
;; (in-package mp-Bind)
(if (not (ignore-errors (find-class 'mp-Bind)))
  (defclass mp-Bind () ()))

(let (x) 
  (setq x (make-instance 'mp-Bind))
  (defun proto-mp-Bind () x))
;; has $.parameters
(let ((new-slots (list (list :name 'sv-parameters
  :readers '(sv-parameters)
  :writers '((setf sv-parameters))
  :initform '(sv-undef)
  :initfunction (constantly (sv-undef))))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-Bind)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-Bind :direct-slots new-slots))

;; has $.arguments
(let ((new-slots (list (list :name 'sv-arguments
  :readers '(sv-arguments)
  :writers '((setf sv-arguments))
  :initform '(sv-undef)
  :initfunction (constantly (sv-undef))))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-Bind)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-Bind :direct-slots new-slots))

;; method emit_go
(if (not (ignore-errors (find-method 'sv-emit_go () ())))
  (defgeneric sv-emit_go (sv-self)
      (:documentation "a method")))
(defmethod sv-emit_go ((sv-self mp-Bind))
  (block mp6-function
    (progn (if (sv-bool (typep (sv-parameters sv-self) 'mp-Lit-Array)) (let ((sv-a (sv-undef))(sv-str (sv-undef))(sv-i (sv-undef))) (setf sv-a (sv-array1 (sv-parameters sv-self) ))(setf sv-str (concatenate 'string (sv-string "func () *Any { ") (sv-string (concatenate 'string (sv-string "List_tmp := ") (sv-string (concatenate 'string (sv-string (sv-emit_go (sv-arguments sv-self) )) (sv-string "; ")))))))(setf sv-i 0)(dolist (sv-var sv-a) (let ((sv-bind (sv-undef))) (setf sv-bind (let ((m (make-instance 'mp-Bind))) (setf (sv-parameters m) sv-var)(setf (sv-arguments m) (let ((m (make-instance 'mp-Index))) (setf (sv-obj m) (let ((m (make-instance 'mp-Var))) (setf (sv-sigil m) "@")(setf (sv-twigil m) "")(setf (sv-namespace m) "")(setf (sv-name m) "tmp") m))(setf (sv-index_exp m) (let ((m (make-instance 'mp-Val-Int))) (setf (sv-int m) sv-i) m)) m)) m))(setf sv-str (concatenate 'string (sv-string sv-str) (sv-string (concatenate 'string (sv-string " ") (sv-string (concatenate 'string (sv-string (sv-emit_go sv-bind )) (sv-string "; ")))))))(setf sv-i (+ sv-i 1))))(return-from mp6-function (concatenate 'string (sv-string sv-str) (sv-string " return List_tmp }()")))) nil)(if (sv-bool (typep (sv-parameters sv-self) 'mp-Lit-Hash)) (let ((sv-a (sv-undef))(sv-b (sv-undef))(sv-str (sv-undef))(sv-i (sv-undef))(sv-arg (sv-undef))) (setf sv-a (sv-hash1 (sv-parameters sv-self) ))(setf sv-b (sv-hash1 (sv-arguments sv-self) ))(setf sv-str "do { ")(setf sv-i 0)(dolist (sv-var sv-a) (let ((sv-bind (sv-undef))) (setf sv-arg (make-instance 'mp-Val-Undef))(dolist (sv-var2 sv-b) (progn (if (sv-bool (sv-eq (sv-buf (elt sv-var2 0) ) (sv-buf (elt sv-var 0) ))) (progn (setf sv-arg (elt sv-var2 1))) nil)))(setf sv-bind (let ((m (make-instance 'mp-Bind))) (setf (sv-parameters m) (elt sv-var 1))(setf (sv-arguments m) sv-arg) m))(setf sv-str (concatenate 'string (sv-string sv-str) (sv-string (concatenate 'string (sv-string " ") (sv-string (concatenate 'string (sv-string (sv-emit_go sv-bind )) (sv-string "; ")))))))(setf sv-i (+ sv-i 1))))(return-from mp6-function (concatenate 'string (sv-string sv-str) (sv-string (concatenate 'string (sv-string (sv-emit_go (sv-parameters sv-self) )) (sv-string " }")))))) nil)(if (sv-bool (typep (sv-parameters sv-self) 'mp-Lit-Object)) (let ((sv-class (sv-undef))(sv-a (sv-undef))(sv-b (sv-undef))(sv-str (sv-undef))(sv-i (sv-undef))(sv-arg (sv-undef))) (setf sv-class (sv-class (sv-parameters sv-self) ))(setf sv-a (sv-fields (sv-parameters sv-self) ))(setf sv-b (sv-arguments sv-self))(setf sv-str "do { ")(setf sv-i 0)(dolist (sv-var sv-a) (let ((sv-bind (sv-undef))) (setf sv-bind (let ((m (make-instance 'mp-Bind))) (setf (sv-parameters m) (elt sv-var 1))(setf (sv-arguments m) (let ((m (make-instance 'mp-Call))) (setf (sv-invocant m) sv-b)(setf (sv-method m) (sv-buf (elt sv-var 0) ))(setf (sv-arguments m) nil)(setf (sv-hyper m) 0) m)) m))(setf sv-str (concatenate 'string (sv-string sv-str) (sv-string (concatenate 'string (sv-string " ") (sv-string (concatenate 'string (sv-string (sv-emit_go sv-bind )) (sv-string "; ")))))))(setf sv-i (+ sv-i 1))))(return-from mp6-function (concatenate 'string (sv-string sv-str) (sv-string (concatenate 'string (sv-string (sv-emit_go (sv-parameters sv-self) )) (sv-string " }")))))) nil)(if (sv-bool (typep (sv-parameters sv-self) 'mp-Call)) (progn (return-from mp6-function (concatenate 'string (sv-string "func () *Any { ") (sv-string (concatenate 'string (sv-string "var tmp = ") (sv-string (concatenate 'string (sv-string (mp-Call::sv-emit_go_call (sv-invocant (sv-parameters sv-self) ) (sv-method (sv-parameters sv-self) ))) (sv-string (concatenate 'string (sv-string "; ") (sv-string (concatenate 'string (sv-string "*tmp = *( ") (sv-string (concatenate 'string (sv-string (sv-emit_go (sv-arguments sv-self) )) (sv-string (concatenate 'string (sv-string " ); ") (sv-string (concatenate 'string (sv-string "return tmp; ") (sv-string "}()")))))))))))))))))) nil)(concatenate 'string (sv-string "*") (sv-string (concatenate 'string (sv-string (sv-emit_go (sv-parameters sv-self) )) (sv-string (concatenate 'string (sv-string " = *(") (sv-string (concatenate 'string (sv-string (sv-emit_go (sv-arguments sv-self) )) (sv-string ")")))))))))))

(defmethod sv-perl ((self mp-Bind))
  (mp-Main::sv-lisp_dump_object "::Bind" (list (let ((m (make-instance 'mp-Pair))) (setf (sv-key m) "parameters") (setf (sv-value m) (sv-parameters self)) m) (let ((m (make-instance 'mp-Pair))) (setf (sv-key m) "arguments") (setf (sv-value m) (sv-arguments self)) m) )))




;; class Proto
(defpackage mp-Proto
  (:use common-lisp mp-Main))
;; (in-package mp-Proto)
(if (not (ignore-errors (find-class 'mp-Proto)))
  (defclass mp-Proto () ()))

(let (x) 
  (setq x (make-instance 'mp-Proto))
  (defun proto-mp-Proto () x))
;; has $.name
(let ((new-slots (list (list :name 'sv-name
  :readers '(sv-name)
  :writers '((setf sv-name))
  :initform '(sv-undef)
  :initfunction (constantly (sv-undef))))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-Proto)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-Proto :direct-slots new-slots))

;; method emit_go
(if (not (ignore-errors (find-method 'sv-emit_go () ())))
  (defgeneric sv-emit_go (sv-self)
      (:documentation "a method")))
(defmethod sv-emit_go ((sv-self mp-Proto))
  (block mp6-function
    (progn (mp-Main::sv-to_go_namespace (sv-name sv-self)))))

(defmethod sv-perl ((self mp-Proto))
  (mp-Main::sv-lisp_dump_object "::Proto" (list (let ((m (make-instance 'mp-Pair))) (setf (sv-key m) "name") (setf (sv-value m) (sv-name self)) m) )))




;; class Call
(defpackage mp-Call
  (:use common-lisp mp-Main))
;; (in-package mp-Call)
(if (not (ignore-errors (find-class 'mp-Call)))
  (defclass mp-Call () ()))

(let (x) 
  (setq x (make-instance 'mp-Call))
  (defun proto-mp-Call () x))
;; has $.invocant
(let ((new-slots (list (list :name 'sv-invocant
  :readers '(sv-invocant)
  :writers '((setf sv-invocant))
  :initform '(sv-undef)
  :initfunction (constantly (sv-undef))))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-Call)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-Call :direct-slots new-slots))

;; has $.hyper
(let ((new-slots (list (list :name 'sv-hyper
  :readers '(sv-hyper)
  :writers '((setf sv-hyper))
  :initform '(sv-undef)
  :initfunction (constantly (sv-undef))))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-Call)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-Call :direct-slots new-slots))

;; has $.method
(let ((new-slots (list (list :name 'sv-method
  :readers '(sv-method)
  :writers '((setf sv-method))
  :initform '(sv-undef)
  :initfunction (constantly (sv-undef))))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-Call)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-Call :direct-slots new-slots))

;; has $.arguments
(let ((new-slots (list (list :name 'sv-arguments
  :readers '(sv-arguments)
  :writers '((setf sv-arguments))
  :initform '(sv-undef)
  :initfunction (constantly (sv-undef))))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-Call)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-Call :direct-slots new-slots))

;; method emit_go
(if (not (ignore-errors (find-method 'sv-emit_go () ())))
  (defgeneric sv-emit_go (sv-self)
      (:documentation "a method")))
(defmethod sv-emit_go ((sv-self mp-Call))
  (block mp6-function
    (let ((sv-invocant (sv-undef))(sv-meth (sv-undef))) (setf sv-invocant (sv-emit_go (sv-invocant sv-self) ))(if (sv-bool (typep (sv-invocant sv-self) 'mp-Proto)) (progn (if (sv-bool (sv-eq (sv-name (sv-invocant sv-self) ) "self")) (progn (setf sv-invocant "v_self")) (progn (setf sv-invocant (concatenate 'string (sv-string "Proto_") (sv-string sv-invocant)))))) nil)(setf sv-meth (sv-method sv-self))(if (sv-bool (sv-eq sv-meth "postcircumfix:<( )>")) (progn (if (sv-bool (sv-hyper sv-self)) (progn (setf sv-meth "")) (progn (return-from mp6-function (concatenate 'string (sv-string sv-invocant) (sv-string (concatenate 'string (sv-string "( Capture{ p : []*Any{ ") (sv-string (concatenate 'string (sv-string (sv-join (mapcar #'sv-emit_go (sv-arguments sv-self)) ", ")) (sv-string " } } )")))))))))) nil)(if (sv-bool (sv-hyper sv-self)) (progn (return-from mp6-function (concatenate 'string (sv-string "func (a_ *Any) *Any { ") (sv-string (concatenate 'string (sv-string "
") (sv-string (concatenate 'string (sv-string "  var out = a_array(); ") (sv-string (concatenate 'string (sv-string "
") (sv-string (concatenate 'string (sv-string "  var i = (*(*a_).(array_er).f_array(Capture{})).(*Array); ") (sv-string (concatenate 'string (sv-string "
") (sv-string (concatenate 'string (sv-string "  for pos := 0; pos <= i.n; pos++ { ") (sv-string (concatenate 'string (sv-string "
") (sv-string (concatenate 'string (sv-string "    (*out).(push_er).f_push( Capture{p: []*Any{ (*i.v[pos]).(") (sv-string (concatenate 'string (sv-string sv-meth) (sv-string (concatenate 'string (sv-string "_er).f_") (sv-string (concatenate 'string (sv-string sv-meth) (sv-string (concatenate 'string (sv-string "(Capture{ p : []*Any{}  }) }} )") (sv-string (concatenate 'string (sv-string "
") (sv-string (concatenate 'string (sv-string "  } ") (sv-string (concatenate 'string (sv-string "
") (sv-string (concatenate 'string (sv-string "  return out; ") (sv-string (concatenate 'string (sv-string "
") (sv-string (concatenate 'string (sv-string "}(") (sv-string (concatenate 'string (sv-string sv-invocant) (sv-string ")")))))))))))))))))))))))))))))))))))))))))) nil)(return-from mp6-function (concatenate 'string (sv-string "(*") (sv-string (concatenate 'string (sv-string sv-invocant) (sv-string (concatenate 'string (sv-string ").(") (sv-string (concatenate 'string (sv-string sv-meth) (sv-string (concatenate 'string (sv-string "_er).f_") (sv-string (concatenate 'string (sv-string sv-meth) (sv-string (concatenate 'string (sv-string "( Capture{ p : []*Any{ ") (sv-string (concatenate 'string (sv-string (sv-join (mapcar #'sv-emit_go (sv-arguments sv-self)) ", ")) (sv-string " } } )"))))))))))))))))))))

(in-package mp-Call)
  (defun sv-emit_go_call (&optional sv-invocant sv-meth_name )
  (block mp6-function (let ((sv-invocant1 (sv-undef))(sv-meth (sv-undef))) (setf sv-invocant1 (sv-emit_go sv-invocant ))(if (sv-bool (typep sv-invocant 'mp-Proto)) (progn (setf sv-invocant1 (concatenate 'string (sv-string "Proto_") (sv-string sv-invocant1)))) nil)(setf sv-meth sv-meth_name)(return-from mp6-function (concatenate 'string (sv-string "(*") (sv-string (concatenate 'string (sv-string sv-invocant1) (sv-string (concatenate 'string (sv-string ").(") (sv-string (concatenate 'string (sv-string sv-meth) (sv-string (concatenate 'string (sv-string "_er).f_") (sv-string (concatenate 'string (sv-string sv-meth) (sv-string "(Capture{})"))))))))))))))))

(in-package mp-Main)
(defmethod sv-perl ((self mp-Call))
  (mp-Main::sv-lisp_dump_object "::Call" (list (let ((m (make-instance 'mp-Pair))) (setf (sv-key m) "invocant") (setf (sv-value m) (sv-invocant self)) m) (let ((m (make-instance 'mp-Pair))) (setf (sv-key m) "hyper") (setf (sv-value m) (sv-hyper self)) m) (let ((m (make-instance 'mp-Pair))) (setf (sv-key m) "method") (setf (sv-value m) (sv-method self)) m) (let ((m (make-instance 'mp-Pair))) (setf (sv-key m) "arguments") (setf (sv-value m) (sv-arguments self)) m) )))




;; class Apply
(defpackage mp-Apply
  (:use common-lisp mp-Main))
;; (in-package mp-Apply)
(if (not (ignore-errors (find-class 'mp-Apply)))
  (defclass mp-Apply () ()))

(let (x) 
  (setq x (make-instance 'mp-Apply))
  (defun proto-mp-Apply () x))
;; has $.code
(let ((new-slots (list (list :name 'sv-code
  :readers '(sv-code)
  :writers '((setf sv-code))
  :initform '(sv-undef)
  :initfunction (constantly (sv-undef))))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-Apply)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-Apply :direct-slots new-slots))

;; has $.arguments
(let ((new-slots (list (list :name 'sv-arguments
  :readers '(sv-arguments)
  :writers '((setf sv-arguments))
  :initform '(sv-undef)
  :initfunction (constantly (sv-undef))))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-Apply)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-Apply :direct-slots new-slots))

;; has $.namespace
(let ((new-slots (list (list :name 'sv-namespace
  :readers '(sv-namespace)
  :writers '((setf sv-namespace))
  :initform '(sv-undef)
  :initfunction (constantly (sv-undef))))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-Apply)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-Apply :direct-slots new-slots))

;; method emit_go
(if (not (ignore-errors (find-method 'sv-emit_go () ())))
  (defgeneric sv-emit_go (sv-self)
      (:documentation "a method")))
(defmethod sv-emit_go ((sv-self mp-Apply))
  (block mp6-function
    (let ((sv-code (sv-undef))) (setf sv-code (sv-code sv-self))(if (sv-bool (typep sv-code 'string)) nil (progn (return-from mp6-function (concatenate 'string (sv-string "(") (sv-string (concatenate 'string (sv-string (sv-emit_go (sv-code sv-self) )) (sv-string (concatenate 'string (sv-string ")->(") (sv-string (concatenate 'string (sv-string (sv-join (mapcar #'sv-emit (sv-arguments sv-self)) ", ")) (sv-string ")")))))))))))(if (sv-bool (sv-eq sv-code "self")) (progn (return-from mp6-function "v_self")) nil)(if (sv-bool (sv-eq sv-code "false")) (progn (return-from mp6-function "b_false()")) nil)(if (sv-bool (sv-eq sv-code "make")) (progn (return-from mp6-function (concatenate 'string (sv-string "func () *Any { ") (sv-string (concatenate 'string (sv-string "tmp := ") (sv-string (concatenate 'string (sv-string (sv-join (mapcar #'sv-emit_go (sv-arguments sv-self)) ", ")) (sv-string (concatenate 'string (sv-string "; ") (sv-string (concatenate 'string (sv-string "*(*v_MATCH).(capture_er).f_capture(Capture{}) = *tmp; ") (sv-string (concatenate 'string (sv-string "return tmp; ") (sv-string "}()")))))))))))))) nil)(if (sv-bool (sv-eq sv-code "say")) (progn (return-from mp6-function (concatenate 'string (sv-string "f_print( Capture{ p : []*Any{ ") (sv-string (concatenate 'string (sv-string (sv-join (mapcar #'sv-emit_go (sv-arguments sv-self)) ", ")) (sv-string ", toStr(\"\\n\") } } )")))))) nil)(if (sv-bool (sv-eq sv-code "print")) (progn (return-from mp6-function (concatenate 'string (sv-string "f_print( Capture{ p : []*Any{ ") (sv-string (concatenate 'string (sv-string (sv-join (mapcar #'sv-emit_go (sv-arguments sv-self)) ", ")) (sv-string " } } )")))))) nil)(if (sv-bool (sv-eq sv-code "warn")) (progn (return-from mp6-function (concatenate 'string (sv-string "f_print_stderr( Capture{ p : []*Any{ ") (sv-string (concatenate 'string (sv-string (sv-join (mapcar #'sv-emit_go (sv-arguments sv-self)) ", ")) (sv-string ", toStr(\"\\n\") } } )")))))) nil)(if (sv-bool (sv-eq sv-code "die")) (progn (return-from mp6-function (concatenate 'string (sv-string "f_die( Capture{ p : []*Any{ ") (sv-string (concatenate 'string (sv-string (sv-join (mapcar #'sv-emit_go (sv-arguments sv-self)) ", ")) (sv-string " } } )")))))) nil)(if (sv-bool (sv-eq sv-code "defined")) (progn (return-from mp6-function (concatenate 'string (sv-string "f_defined( Capture{ p : []*Any{ ") (sv-string (concatenate 'string (sv-string (sv-join (mapcar #'sv-emit_go (sv-arguments sv-self)) ", ")) (sv-string " } } )")))))) nil)(if (sv-bool (sv-eq sv-code "pop")) (progn (return-from mp6-function (concatenate 'string (sv-string "f_pop( Capture{ p : []*Any{ ") (sv-string (concatenate 'string (sv-string (sv-join (mapcar #'sv-emit_go (sv-arguments sv-self)) ", ")) (sv-string " } } )")))))) nil)(if (sv-bool (sv-eq sv-code "push")) (progn (return-from mp6-function (concatenate 'string (sv-string "f_push( Capture{ p : []*Any{ ") (sv-string (concatenate 'string (sv-string (sv-join (mapcar #'sv-emit_go (sv-arguments sv-self)) ", ")) (sv-string " } } )")))))) nil)(if (sv-bool (sv-eq sv-code "shift")) (progn (return-from mp6-function (concatenate 'string (sv-string "f_shift( Capture{ p : []*Any{ ") (sv-string (concatenate 'string (sv-string (sv-join (mapcar #'sv-emit_go (sv-arguments sv-self)) ", ")) (sv-string " } } )")))))) nil)(if (sv-bool (sv-eq sv-code "index")) (progn (return-from mp6-function (concatenate 'string (sv-string "f_index( Capture{ p : []*Any{ ") (sv-string (concatenate 'string (sv-string (sv-join (mapcar #'sv-emit_go (sv-arguments sv-self)) ", ")) (sv-string " } } )")))))) nil)(if (sv-bool (sv-eq sv-code "substr")) (progn (return-from mp6-function (concatenate 'string (sv-string "f_substr( Capture{ p : []*Any{ ") (sv-string (concatenate 'string (sv-string (sv-join (mapcar #'sv-emit_go (sv-arguments sv-self)) ", ")) (sv-string " } } )")))))) nil)(if (sv-bool (sv-eq sv-code "scalar")) (progn (return-from mp6-function (concatenate 'string (sv-string "f_scalar( Capture{ p : []*Any{ ") (sv-string (concatenate 'string (sv-string (sv-join (mapcar #'sv-emit_go (sv-arguments sv-self)) ", ")) (sv-string " } } )")))))) nil)(if (sv-bool (sv-eq sv-code "prefix:<~>")) (progn (return-from mp6-function (mp-Call::sv-emit_go_call (elt (sv-arguments sv-self) 0) "Str"))) nil)(if (sv-bool (sv-eq sv-code "prefix:<!>")) (progn (return-from mp6-function (concatenate 'string (sv-string "toBool(!tobool(") (sv-string (concatenate 'string (sv-string (sv-emit_go (elt (sv-arguments sv-self) 0) )) (sv-string "))")))))) nil)(if (sv-bool (sv-eq sv-code "prefix:<?>")) (progn (return-from mp6-function (mp-Call::sv-emit_go_call (elt (sv-arguments sv-self) 0) "Bool"))) nil)(if (sv-bool (sv-eq sv-code "prefix:<$>")) (progn (return-from mp6-function (concatenate 'string (sv-string "f_scalar( Capture{ p : []*Any{ ") (sv-string (concatenate 'string (sv-string (sv-join (mapcar #'sv-emit_go (sv-arguments sv-self)) ", ")) (sv-string " } } )")))))) nil)(if (sv-bool (sv-eq sv-code "prefix:<@>")) (progn (return-from mp6-function (mp-Call::sv-emit_go_call (elt (sv-arguments sv-self) 0) "array"))) nil)(if (sv-bool (sv-eq sv-code "prefix:<%>")) (progn (return-from mp6-function (mp-Call::sv-emit_go_call (elt (sv-arguments sv-self) 0) "hash"))) nil)(if (sv-bool (sv-eq sv-code "infix:<~>")) (progn (return-from mp6-function (concatenate 'string (sv-string "toStr( ") (sv-string (concatenate 'string (sv-string "tostr(") (sv-string (concatenate 'string (sv-string (sv-emit_go (elt (sv-arguments sv-self) 0) )) (sv-string (concatenate 'string (sv-string ") + ") (sv-string (concatenate 'string (sv-string "tostr(") (sv-string (concatenate 'string (sv-string (sv-emit_go (elt (sv-arguments sv-self) 1) )) (sv-string (concatenate 'string (sv-string ") ") (sv-string ")")))))))))))))))) nil)(if (sv-bool (sv-eq sv-code "infix:<+>")) (progn (return-from mp6-function (concatenate 'string (sv-string "toInt( ") (sv-string (concatenate 'string (sv-string "toint(") (sv-string (concatenate 'string (sv-string (sv-emit_go (elt (sv-arguments sv-self) 0) )) (sv-string (concatenate 'string (sv-string ") + ") (sv-string (concatenate 'string (sv-string "toint(") (sv-string (concatenate 'string (sv-string (sv-emit_go (elt (sv-arguments sv-self) 1) )) (sv-string (concatenate 'string (sv-string ") ") (sv-string ")")))))))))))))))) nil)(if (sv-bool (sv-eq sv-code "infix:<->")) (progn (return-from mp6-function (concatenate 'string (sv-string "toInt( ") (sv-string (concatenate 'string (sv-string "toint(") (sv-string (concatenate 'string (sv-string (sv-emit_go (elt (sv-arguments sv-self) 0) )) (sv-string (concatenate 'string (sv-string ") - ") (sv-string (concatenate 'string (sv-string "toint(") (sv-string (concatenate 'string (sv-string (sv-emit_go (elt (sv-arguments sv-self) 1) )) (sv-string (concatenate 'string (sv-string ") ") (sv-string ")")))))))))))))))) nil)(if (sv-bool (sv-eq sv-code "infix:<>>")) (progn (return-from mp6-function (concatenate 'string (sv-string "toBool( ") (sv-string (concatenate 'string (sv-string "toint(") (sv-string (concatenate 'string (sv-string (sv-emit_go (elt (sv-arguments sv-self) 0) )) (sv-string (concatenate 'string (sv-string ") > ") (sv-string (concatenate 'string (sv-string "toint(") (sv-string (concatenate 'string (sv-string (sv-emit_go (elt (sv-arguments sv-self) 1) )) (sv-string (concatenate 'string (sv-string ") ") (sv-string ")")))))))))))))))) nil)(if (sv-bool (sv-eq sv-code "infix:<&&>")) (progn (return-from mp6-function (concatenate 'string (sv-string "f_and( ") (sv-string (concatenate 'string (sv-string "func () *Any { return ") (sv-string (concatenate 'string (sv-string (sv-emit_go (elt (sv-arguments sv-self) 0) )) (sv-string (concatenate 'string (sv-string " }, ") (sv-string (concatenate 'string (sv-string "func () *Any { return ") (sv-string (concatenate 'string (sv-string (sv-emit_go (elt (sv-arguments sv-self) 1) )) (sv-string (concatenate 'string (sv-string " } ") (sv-string ")")))))))))))))))) nil)(if (sv-bool (sv-eq sv-code "infix:<||>")) (progn (return-from mp6-function (concatenate 'string (sv-string "f_or( ") (sv-string (concatenate 'string (sv-string "func () *Any { return ") (sv-string (concatenate 'string (sv-string (sv-emit_go (elt (sv-arguments sv-self) 0) )) (sv-string (concatenate 'string (sv-string " }, ") (sv-string (concatenate 'string (sv-string "func () *Any { return ") (sv-string (concatenate 'string (sv-string (sv-emit_go (elt (sv-arguments sv-self) 1) )) (sv-string (concatenate 'string (sv-string " } ") (sv-string ")")))))))))))))))) nil)(if (sv-bool (sv-eq sv-code "infix:<eq>")) (progn (return-from mp6-function (concatenate 'string (sv-string "toBool(") (sv-string (concatenate 'string (sv-string "tostr(") (sv-string (concatenate 'string (sv-string (sv-emit_go (elt (sv-arguments sv-self) 0) )) (sv-string (concatenate 'string (sv-string ") == ") (sv-string (concatenate 'string (sv-string "tostr(") (sv-string (concatenate 'string (sv-string (sv-emit_go (elt (sv-arguments sv-self) 1) )) (sv-string (concatenate 'string (sv-string ")") (sv-string ")")))))))))))))))) nil)(if (sv-bool (sv-eq sv-code "infix:<ne>")) (progn (return-from mp6-function (concatenate 'string (sv-string "toBool(") (sv-string (concatenate 'string (sv-string "tostr(") (sv-string (concatenate 'string (sv-string (sv-emit_go (elt (sv-arguments sv-self) 0) )) (sv-string (concatenate 'string (sv-string ") != ") (sv-string (concatenate 'string (sv-string "tostr(") (sv-string (concatenate 'string (sv-string (sv-emit_go (elt (sv-arguments sv-self) 1) )) (sv-string (concatenate 'string (sv-string ")") (sv-string ")")))))))))))))))) nil)(if (sv-bool (sv-eq sv-code "infix:<==>")) (progn (return-from mp6-function (concatenate 'string (sv-string "toBool(") (sv-string (concatenate 'string (sv-string "toint(") (sv-string (concatenate 'string (sv-string (sv-emit_go (elt (sv-arguments sv-self) 0) )) (sv-string (concatenate 'string (sv-string ") == ") (sv-string (concatenate 'string (sv-string "toint(") (sv-string (concatenate 'string (sv-string (sv-emit_go (elt (sv-arguments sv-self) 1) )) (sv-string (concatenate 'string (sv-string ") ") (sv-string ")")))))))))))))))) nil)(if (sv-bool (sv-eq sv-code "infix:<!=>")) (progn (return-from mp6-function (concatenate 'string (sv-string "toBool(") (sv-string (concatenate 'string (sv-string "toint(") (sv-string (concatenate 'string (sv-string (sv-emit_go (elt (sv-arguments sv-self) 0) )) (sv-string (concatenate 'string (sv-string ") != ") (sv-string (concatenate 'string (sv-string "toint(") (sv-string (concatenate 'string (sv-string (sv-emit_go (elt (sv-arguments sv-self) 1) )) (sv-string (concatenate 'string (sv-string ") ") (sv-string ")")))))))))))))))) nil)(if (sv-bool (sv-eq sv-code "ternary:<?? !!>")) (progn (return-from mp6-function (concatenate 'string (sv-string "func () *Any { ") (sv-string (concatenate 'string (sv-string "if tobool( ") (sv-string (concatenate 'string (sv-string (mp-Call::sv-emit_go_call (elt (sv-arguments sv-self) 0) "Bool")) (sv-string (concatenate 'string (sv-string " ) ") (sv-string (concatenate 'string (sv-string "{ return ") (sv-string (concatenate 'string (sv-string (sv-emit_go (elt (sv-arguments sv-self) 1) )) (sv-string (concatenate 'string (sv-string " }; ") (sv-string (concatenate 'string (sv-string "return ") (sv-string (concatenate 'string (sv-string (sv-emit_go (elt (sv-arguments sv-self) 2) )) (sv-string (concatenate 'string (sv-string " ") (sv-string "}()")))))))))))))))))))))) nil)(setf sv-code (concatenate 'string (sv-string "f_") (sv-string (sv-code sv-self))))(if (sv-bool (sv-namespace sv-self)) (progn (setf sv-code (concatenate 'string (sv-string "Namespace_") (sv-string (concatenate 'string (sv-string (mp-Main::sv-to_go_namespace (sv-namespace sv-self))) (sv-string (concatenate 'string (sv-string ".") (sv-string sv-code)))))))) (progn (setf sv-code (concatenate 'string (sv-string "this_namespace.") (sv-string sv-code)))))(concatenate 'string (sv-string sv-code) (sv-string (concatenate 'string (sv-string "( Capture{ p : []*Any{ ") (sv-string (concatenate 'string (sv-string (sv-join (mapcar #'sv-emit_go (sv-arguments sv-self)) ", ")) (sv-string " } } )")))))))))

(defmethod sv-perl ((self mp-Apply))
  (mp-Main::sv-lisp_dump_object "::Apply" (list (let ((m (make-instance 'mp-Pair))) (setf (sv-key m) "code") (setf (sv-value m) (sv-code self)) m) (let ((m (make-instance 'mp-Pair))) (setf (sv-key m) "arguments") (setf (sv-value m) (sv-arguments self)) m) (let ((m (make-instance 'mp-Pair))) (setf (sv-key m) "namespace") (setf (sv-value m) (sv-namespace self)) m) )))




;; class Return
(defpackage mp-Return
  (:use common-lisp mp-Main))
;; (in-package mp-Return)
(if (not (ignore-errors (find-class 'mp-Return)))
  (defclass mp-Return () ()))

(let (x) 
  (setq x (make-instance 'mp-Return))
  (defun proto-mp-Return () x))
;; has $.result
(let ((new-slots (list (list :name 'sv-result
  :readers '(sv-result)
  :writers '((setf sv-result))
  :initform '(sv-undef)
  :initfunction (constantly (sv-undef))))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-Return)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-Return :direct-slots new-slots))

;; method emit_go
(if (not (ignore-errors (find-method 'sv-emit_go () ())))
  (defgeneric sv-emit_go (sv-self)
      (:documentation "a method")))
(defmethod sv-emit_go ((sv-self mp-Return))
  (block mp6-function
    (progn (if (sv-bool (typep (sv-result sv-self) 'mp-Bind)) (let ((sv-tmp (sv-undef))) (setf sv-tmp (sv-parameters (sv-result sv-self) ))(return-from mp6-function (concatenate 'string (sv-string "(func () *Any { ") (sv-string (concatenate 'string (sv-string (sv-emit_go (sv-result sv-self) )) (sv-string (concatenate 'string (sv-string "; ") (sv-string (concatenate 'string (sv-string "Go_return(p, ") (sv-string (concatenate 'string (sv-string (sv-emit_go sv-tmp )) (sv-string (concatenate 'string (sv-string "); ") (sv-string (concatenate 'string (sv-string "return u_undef(); ") (sv-string "}())")))))))))))))))) nil)(return-from mp6-function (concatenate 'string (sv-string "(func () *Any { ") (sv-string (concatenate 'string (sv-string "var tmp *Any = ") (sv-string (concatenate 'string (sv-string (sv-emit_go (sv-result sv-self) )) (sv-string (concatenate 'string (sv-string "; ") (sv-string (concatenate 'string (sv-string "Go_return(p, tmp); ") (sv-string (concatenate 'string (sv-string "return u_undef(); ") (sv-string "}())"))))))))))))))))

;; method emit_go_simple
(if (not (ignore-errors (find-method 'sv-emit_go_simple () ())))
  (defgeneric sv-emit_go_simple (sv-self)
      (:documentation "a method")))
(defmethod sv-emit_go_simple ((sv-self mp-Return))
  (block mp6-function
    (progn (if (sv-bool (typep (sv-result sv-self) 'mp-Bind)) (let ((sv-tmp (sv-undef))) (setf sv-tmp (sv-parameters (sv-result sv-self) ))(return-from mp6-function (concatenate 'string (sv-string "return (func () *Any { ") (sv-string (concatenate 'string (sv-string (sv-emit_go (sv-result sv-self) )) (sv-string (concatenate 'string (sv-string "; ") (sv-string (concatenate 'string (sv-string "return ") (sv-string (concatenate 'string (sv-string (sv-emit_go sv-tmp )) (sv-string (concatenate 'string (sv-string "; ") (sv-string "}())")))))))))))))) nil)(return-from mp6-function (concatenate 'string (sv-string "return( ") (sv-string (concatenate 'string (sv-string (sv-emit_go (sv-result sv-self) )) (sv-string ")"))))))))

(defmethod sv-perl ((self mp-Return))
  (mp-Main::sv-lisp_dump_object "::Return" (list (let ((m (make-instance 'mp-Pair))) (setf (sv-key m) "result") (setf (sv-value m) (sv-result self)) m) )))




;; class If
(defpackage mp-If
  (:use common-lisp mp-Main))
;; (in-package mp-If)
(if (not (ignore-errors (find-class 'mp-If)))
  (defclass mp-If () ()))

(let (x) 
  (setq x (make-instance 'mp-If))
  (defun proto-mp-If () x))
;; has $.cond
(let ((new-slots (list (list :name 'sv-cond
  :readers '(sv-cond)
  :writers '((setf sv-cond))
  :initform '(sv-undef)
  :initfunction (constantly (sv-undef))))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-If)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-If :direct-slots new-slots))

;; has $.body
(let ((new-slots (list (list :name 'sv-body
  :readers '(sv-body)
  :writers '((setf sv-body))
  :initform '(sv-undef)
  :initfunction (constantly (sv-undef))))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-If)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-If :direct-slots new-slots))

;; has $.otherwise
(let ((new-slots (list (list :name 'sv-otherwise
  :readers '(sv-otherwise)
  :writers '((setf sv-otherwise))
  :initform '(sv-undef)
  :initfunction (constantly (sv-undef))))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-If)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-If :direct-slots new-slots))

;; method emit_go
(if (not (ignore-errors (find-method 'sv-emit_go () ())))
  (defgeneric sv-emit_go (sv-self)
      (:documentation "a method")))
(defmethod sv-emit_go ((sv-self mp-If))
  (block mp6-function
    (let ((sv-cond (sv-undef))(sv-s (sv-undef))) (setf sv-cond (sv-cond sv-self))(if (sv-bool (sv-and (typep sv-cond 'mp-Apply) (sv-eq (sv-code sv-cond ) "prefix:<!>"))) (let ((sv-if (sv-undef))) (setf sv-if (let ((m (make-instance 'mp-If))) (setf (sv-cond m) (elt (sv-arguments sv-cond ) 0))(setf (sv-body m) (sv-otherwise sv-self))(setf (sv-otherwise m) (sv-body sv-self)) m))(return-from mp6-function (sv-emit_go sv-if ))) nil)(if (sv-bool (sv-and (typep sv-cond 'mp-Var) (sv-eq (sv-sigil sv-cond ) "@"))) (progn (setf sv-cond (let ((m (make-instance 'mp-Apply))) (setf (sv-code m) "prefix:<@>")(setf (sv-arguments m) (concatenate 'list  (list sv-cond))) m))) nil)(setf sv-s (concatenate 'string (sv-string "if tobool( ") (sv-string (concatenate 'string (sv-string (mp-Call::sv-emit_go_call sv-cond "Bool")) (sv-string (concatenate 'string (sv-string " ) { ") (sv-string (concatenate 'string (sv-string (sv-emit_go (let ((m (make-instance 'mp-MiniPerl6-Go-LexicalBlock))) (setf (sv-block m) (sv-body sv-self))(setf (sv-needs_return m) 0) m) )) (sv-string " }")))))))))(if (sv-bool (not (sv-bool (sv-otherwise sv-self)))) (progn (return-from mp6-function sv-s)) nil)(return-from mp6-function (concatenate 'string (sv-string sv-s) (sv-string (concatenate 'string (sv-string " else { ") (sv-string (concatenate 'string (sv-string (sv-emit_go (let ((m (make-instance 'mp-MiniPerl6-Go-LexicalBlock))) (setf (sv-block m) (sv-otherwise sv-self))(setf (sv-needs_return m) 0) m) )) (sv-string " }"))))))))))

(defmethod sv-perl ((self mp-If))
  (mp-Main::sv-lisp_dump_object "::If" (list (let ((m (make-instance 'mp-Pair))) (setf (sv-key m) "cond") (setf (sv-value m) (sv-cond self)) m) (let ((m (make-instance 'mp-Pair))) (setf (sv-key m) "body") (setf (sv-value m) (sv-body self)) m) (let ((m (make-instance 'mp-Pair))) (setf (sv-key m) "otherwise") (setf (sv-value m) (sv-otherwise self)) m) )))




;; class For
(defpackage mp-For
  (:use common-lisp mp-Main))
;; (in-package mp-For)
(if (not (ignore-errors (find-class 'mp-For)))
  (defclass mp-For () ()))

(let (x) 
  (setq x (make-instance 'mp-For))
  (defun proto-mp-For () x))
;; has $.cond
(let ((new-slots (list (list :name 'sv-cond
  :readers '(sv-cond)
  :writers '((setf sv-cond))
  :initform '(sv-undef)
  :initfunction (constantly (sv-undef))))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-For)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-For :direct-slots new-slots))

;; has $.body
(let ((new-slots (list (list :name 'sv-body
  :readers '(sv-body)
  :writers '((setf sv-body))
  :initform '(sv-undef)
  :initfunction (constantly (sv-undef))))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-For)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-For :direct-slots new-slots))

;; has $.topic
(let ((new-slots (list (list :name 'sv-topic
  :readers '(sv-topic)
  :writers '((setf sv-topic))
  :initform '(sv-undef)
  :initfunction (constantly (sv-undef))))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-For)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-For :direct-slots new-slots))

;; method emit_go
(if (not (ignore-errors (find-method 'sv-emit_go () ())))
  (defgeneric sv-emit_go (sv-self)
      (:documentation "a method")))
(defmethod sv-emit_go ((sv-self mp-For))
  (block mp6-function
    (progn (concatenate 'string (sv-string "func (a_ *Any) { ") (sv-string (concatenate 'string (sv-string "
") (sv-string (concatenate 'string (sv-string "  var i = (*(*a_).(array_er).f_array(Capture{})).(*Array); ") (sv-string (concatenate 'string (sv-string "
") (sv-string (concatenate 'string (sv-string "  for pos := 0; pos <= i.n; pos++ { ") (sv-string (concatenate 'string (sv-string "
") (sv-string (concatenate 'string (sv-string "    func (") (sv-string (concatenate 'string (sv-string (sv-emit_go (sv-topic sv-self) )) (sv-string (concatenate 'string (sv-string " *Any) { ") (sv-string (concatenate 'string (sv-string "
") (sv-string (concatenate 'string (sv-string "      ") (sv-string (concatenate 'string (sv-string (sv-emit_go (let ((m (make-instance 'mp-MiniPerl6-Go-LexicalBlock))) (setf (sv-block m) (sv-body sv-self))(setf (sv-needs_return m) 0) m) )) (sv-string (concatenate 'string (sv-string "
") (sv-string (concatenate 'string (sv-string "    }(i.v[pos]) ") (sv-string (concatenate 'string (sv-string "
") (sv-string (concatenate 'string (sv-string "  } ") (sv-string (concatenate 'string (sv-string "
") (sv-string (concatenate 'string (sv-string "}(") (sv-string (concatenate 'string (sv-string (sv-emit_go (sv-cond sv-self) )) (sv-string ")")))))))))))))))))))))))))))))))))))))))))

(defmethod sv-perl ((self mp-For))
  (mp-Main::sv-lisp_dump_object "::For" (list (let ((m (make-instance 'mp-Pair))) (setf (sv-key m) "cond") (setf (sv-value m) (sv-cond self)) m) (let ((m (make-instance 'mp-Pair))) (setf (sv-key m) "body") (setf (sv-value m) (sv-body self)) m) (let ((m (make-instance 'mp-Pair))) (setf (sv-key m) "topic") (setf (sv-value m) (sv-topic self)) m) )))




;; class When
(defpackage mp-When
  (:use common-lisp mp-Main))
;; (in-package mp-When)
(if (not (ignore-errors (find-class 'mp-When)))
  (defclass mp-When () ()))

(let (x) 
  (setq x (make-instance 'mp-When))
  (defun proto-mp-When () x))
;; has $.parameters
(let ((new-slots (list (list :name 'sv-parameters
  :readers '(sv-parameters)
  :writers '((setf sv-parameters))
  :initform '(sv-undef)
  :initfunction (constantly (sv-undef))))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-When)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-When :direct-slots new-slots))

;; has $.body
(let ((new-slots (list (list :name 'sv-body
  :readers '(sv-body)
  :writers '((setf sv-body))
  :initform '(sv-undef)
  :initfunction (constantly (sv-undef))))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-When)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-When :direct-slots new-slots))

;; method emit_go
(if (not (ignore-errors (find-method 'sv-emit_go () ())))
  (defgeneric sv-emit_go (sv-self)
      (:documentation "a method")))
(defmethod sv-emit_go ((sv-self mp-When))
  (block mp6-function
    (progn (progn (write-line (format nil "~{~a~}" (list "TODO - When")) *error-output*) (sb-ext:quit)))))

(defmethod sv-perl ((self mp-When))
  (mp-Main::sv-lisp_dump_object "::When" (list (let ((m (make-instance 'mp-Pair))) (setf (sv-key m) "parameters") (setf (sv-value m) (sv-parameters self)) m) (let ((m (make-instance 'mp-Pair))) (setf (sv-key m) "body") (setf (sv-value m) (sv-body self)) m) )))




;; class While
(defpackage mp-While
  (:use common-lisp mp-Main))
;; (in-package mp-While)
(if (not (ignore-errors (find-class 'mp-While)))
  (defclass mp-While () ()))

(let (x) 
  (setq x (make-instance 'mp-While))
  (defun proto-mp-While () x))
;; has $.cond
(let ((new-slots (list (list :name 'sv-cond
  :readers '(sv-cond)
  :writers '((setf sv-cond))
  :initform '(sv-undef)
  :initfunction (constantly (sv-undef))))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-While)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-While :direct-slots new-slots))

;; has $.body
(let ((new-slots (list (list :name 'sv-body
  :readers '(sv-body)
  :writers '((setf sv-body))
  :initform '(sv-undef)
  :initfunction (constantly (sv-undef))))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-While)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-While :direct-slots new-slots))

;; method emit_go
(if (not (ignore-errors (find-method 'sv-emit_go () ())))
  (defgeneric sv-emit_go (sv-self)
      (:documentation "a method")))
(defmethod sv-emit_go ((sv-self mp-While))
  (block mp6-function
    (progn (progn (write-line (format nil "~{~a~}" (list "TODO - While")) *error-output*) (sb-ext:quit)))))

(defmethod sv-perl ((self mp-While))
  (mp-Main::sv-lisp_dump_object "::While" (list (let ((m (make-instance 'mp-Pair))) (setf (sv-key m) "cond") (setf (sv-value m) (sv-cond self)) m) (let ((m (make-instance 'mp-Pair))) (setf (sv-key m) "body") (setf (sv-value m) (sv-body self)) m) )))




;; class Leave
(defpackage mp-Leave
  (:use common-lisp mp-Main))
;; (in-package mp-Leave)
(if (not (ignore-errors (find-class 'mp-Leave)))
  (defclass mp-Leave () ()))

(let (x) 
  (setq x (make-instance 'mp-Leave))
  (defun proto-mp-Leave () x))
;; method emit_go
(if (not (ignore-errors (find-method 'sv-emit_go () ())))
  (defgeneric sv-emit_go (sv-self)
      (:documentation "a method")))
(defmethod sv-emit_go ((sv-self mp-Leave))
  (block mp6-function
    (progn (progn (write-line (format nil "~{~a~}" (list "TODO - Leave")) *error-output*) (sb-ext:quit)))))

(defmethod sv-perl ((self mp-Leave))
  (mp-Main::sv-lisp_dump_object "::Leave" (list )))




;; class Decl
(defpackage mp-Decl
  (:use common-lisp mp-Main))
;; (in-package mp-Decl)
(if (not (ignore-errors (find-class 'mp-Decl)))
  (defclass mp-Decl () ()))

(let (x) 
  (setq x (make-instance 'mp-Decl))
  (defun proto-mp-Decl () x))
;; has $.decl
(let ((new-slots (list (list :name 'sv-decl
  :readers '(sv-decl)
  :writers '((setf sv-decl))
  :initform '(sv-undef)
  :initfunction (constantly (sv-undef))))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-Decl)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-Decl :direct-slots new-slots))

;; has $.type
(let ((new-slots (list (list :name 'sv-type
  :readers '(sv-type)
  :writers '((setf sv-type))
  :initform '(sv-undef)
  :initfunction (constantly (sv-undef))))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-Decl)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-Decl :direct-slots new-slots))

;; has $.var
(let ((new-slots (list (list :name 'sv-var
  :readers '(sv-var)
  :writers '((setf sv-var))
  :initform '(sv-undef)
  :initfunction (constantly (sv-undef))))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-Decl)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-Decl :direct-slots new-slots))

;; method emit_go
(if (not (ignore-errors (find-method 'sv-emit_go () ())))
  (defgeneric sv-emit_go (sv-self)
      (:documentation "a method")))
(defmethod sv-emit_go ((sv-self mp-Decl))
  (block mp6-function
    (progn (sv-emit_go (sv-var sv-self) ))))

;; method emit_go_init
(if (not (ignore-errors (find-method 'sv-emit_go_init () ())))
  (defgeneric sv-emit_go_init (sv-self)
      (:documentation "a method")))
(defmethod sv-emit_go_init ((sv-self mp-Decl))
  (block mp6-function
    (progn (if (sv-bool (sv-eq (sv-decl sv-self) "my")) (let ((sv-str (sv-undef))) (setf sv-str "")(setf sv-str (concatenate 'string (sv-string sv-str) (sv-string (concatenate 'string (sv-string "var ") (sv-string (concatenate 'string (sv-string (sv-emit_go (sv-var sv-self) )) (sv-string (concatenate 'string (sv-string " *Any;") (sv-string "
")))))))))(setf sv-str (concatenate 'string (sv-string sv-str) (sv-string (concatenate 'string (sv-string (sv-emit_go (sv-var sv-self) )) (sv-string (concatenate 'string (sv-string " = ") (sv-string (concatenate 'string (sv-string (sv-emit_go (sv-var sv-self) )) (sv-string (concatenate 'string (sv-string ";") (sv-string "
")))))))))))(if (sv-bool (sv-eq (sv-sigil (sv-var sv-self) ) "%")) (progn (setf sv-str (concatenate 'string (sv-string sv-str) (sv-string (concatenate 'string (sv-string (sv-emit_go (sv-var sv-self) )) (sv-string (concatenate 'string (sv-string " = h_hash();") (sv-string "
")))))))) (progn (if (sv-bool (sv-eq (sv-sigil (sv-var sv-self) ) "@")) (progn (setf sv-str (concatenate 'string (sv-string sv-str) (sv-string (concatenate 'string (sv-string (sv-emit_go (sv-var sv-self) )) (sv-string (concatenate 'string (sv-string " = a_array();") (sv-string "
")))))))) (progn (setf sv-str (concatenate 'string (sv-string sv-str) (sv-string (concatenate 'string (sv-string (sv-emit_go (sv-var sv-self) )) (sv-string (concatenate 'string (sv-string " = u_undef();") (sv-string "
")))))))))))(return-from mp6-function sv-str)) (progn (progn (write-line (format nil "~{~a~}" (list (concatenate 'string (sv-string "not implemented: Decl '") (sv-string (concatenate 'string (sv-string (sv-decl sv-self)) (sv-string "'")))))) *error-output*) (sb-ext:quit)))))))

(defmethod sv-perl ((self mp-Decl))
  (mp-Main::sv-lisp_dump_object "::Decl" (list (let ((m (make-instance 'mp-Pair))) (setf (sv-key m) "decl") (setf (sv-value m) (sv-decl self)) m) (let ((m (make-instance 'mp-Pair))) (setf (sv-key m) "type") (setf (sv-value m) (sv-type self)) m) (let ((m (make-instance 'mp-Pair))) (setf (sv-key m) "var") (setf (sv-value m) (sv-var self)) m) )))




;; class Sig
(defpackage mp-Sig
  (:use common-lisp mp-Main))
;; (in-package mp-Sig)
(if (not (ignore-errors (find-class 'mp-Sig)))
  (defclass mp-Sig () ()))

(let (x) 
  (setq x (make-instance 'mp-Sig))
  (defun proto-mp-Sig () x))
;; has $.invocant
(let ((new-slots (list (list :name 'sv-invocant
  :readers '(sv-invocant)
  :writers '((setf sv-invocant))
  :initform '(sv-undef)
  :initfunction (constantly (sv-undef))))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-Sig)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-Sig :direct-slots new-slots))

;; has $.positional
(let ((new-slots (list (list :name 'sv-positional
  :readers '(sv-positional)
  :writers '((setf sv-positional))
  :initform '(sv-undef)
  :initfunction (constantly (sv-undef))))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-Sig)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-Sig :direct-slots new-slots))

;; has $.named
(let ((new-slots (list (list :name 'sv-named
  :readers '(sv-named)
  :writers '((setf sv-named))
  :initform '(sv-undef)
  :initfunction (constantly (sv-undef))))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-Sig)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-Sig :direct-slots new-slots))

;; method emit_go
(if (not (ignore-errors (find-method 'sv-emit_go () ())))
  (defgeneric sv-emit_go (sv-self)
      (:documentation "a method")))
(defmethod sv-emit_go ((sv-self mp-Sig))
  (block mp6-function
    (progn " print 'Signature - TODO'; die 'Signature - TODO'; ")))

;; method emit_go_bind
(if (not (ignore-errors (find-method 'sv-emit_go_bind () ())))
  (defgeneric sv-emit_go_bind (sv-self)
      (:documentation "a method")))
(defmethod sv-emit_go_bind ((sv-self mp-Sig))
  (block mp6-function
    (let ((sv-str (sv-undef))(sv-i (sv-undef))) (setf sv-str "")(setf sv-i 0)(dolist (sv-decl (sv-positional sv-self)) (progn (setf sv-str (concatenate 'string (sv-string sv-str) (sv-string (concatenate 'string (sv-string (sv-emit_go sv-decl )) (sv-string (concatenate 'string (sv-string " := v.p[") (sv-string (concatenate 'string (sv-string sv-i) (sv-string "]; ")))))))))(setf sv-i (+ sv-i 1))))(return-from mp6-function sv-str))))

(defmethod sv-perl ((self mp-Sig))
  (mp-Main::sv-lisp_dump_object "::Sig" (list (let ((m (make-instance 'mp-Pair))) (setf (sv-key m) "invocant") (setf (sv-value m) (sv-invocant self)) m) (let ((m (make-instance 'mp-Pair))) (setf (sv-key m) "positional") (setf (sv-value m) (sv-positional self)) m) (let ((m (make-instance 'mp-Pair))) (setf (sv-key m) "named") (setf (sv-value m) (sv-named self)) m) )))




;; class Method
(defpackage mp-Method
  (:use common-lisp mp-Main))
;; (in-package mp-Method)
(if (not (ignore-errors (find-class 'mp-Method)))
  (defclass mp-Method () ()))

(let (x) 
  (setq x (make-instance 'mp-Method))
  (defun proto-mp-Method () x))
;; has $.name
(let ((new-slots (list (list :name 'sv-name
  :readers '(sv-name)
  :writers '((setf sv-name))
  :initform '(sv-undef)
  :initfunction (constantly (sv-undef))))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-Method)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-Method :direct-slots new-slots))

;; has $.sig
(let ((new-slots (list (list :name 'sv-sig
  :readers '(sv-sig)
  :writers '((setf sv-sig))
  :initform '(sv-undef)
  :initfunction (constantly (sv-undef))))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-Method)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-Method :direct-slots new-slots))

;; has $.block
(let ((new-slots (list (list :name 'sv-block
  :readers '(sv-block)
  :writers '((setf sv-block))
  :initform '(sv-undef)
  :initfunction (constantly (sv-undef))))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-Method)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-Method :direct-slots new-slots))

;; method emit_go
(if (not (ignore-errors (find-method 'sv-emit_go () ())))
  (defgeneric sv-emit_go (sv-self)
      (:documentation "a method")))
(defmethod sv-emit_go ((sv-self mp-Method))
  (block mp6-function
    (let ((sv-invocant (sv-undef))) (setf sv-invocant (sv-invocant (sv-sig sv-self) ))(concatenate 'string (sv-string "func ") (sv-string (concatenate 'string (sv-string (sv-name sv-self)) (sv-string (concatenate 'string (sv-string "(v Capture) *Any { ") (sv-string (concatenate 'string (sv-string "    ") (sv-string (concatenate 'string (sv-string (sv-emit_go_bind (sv-sig sv-self) )) (sv-string (concatenate 'string (sv-string "
") (sv-string (concatenate 'string (sv-string "    p := make(chan *Any); go func () { ") (sv-string (concatenate 'string (sv-string "
") (sv-string (concatenate 'string (sv-string "        ") (sv-string (concatenate 'string (sv-string (sv-emit_go (let ((m (make-instance 'mp-MiniPerl6-Go-LexicalBlock))) (setf (sv-block m) (sv-block sv-self))(setf (sv-needs_return m) 1)(setf (sv-top_level m) 1) m) )) (sv-string (concatenate 'string (sv-string "; return }(); ") (sv-string (concatenate 'string (sv-string "
") (sv-string (concatenate 'string (sv-string "    return <-p; ") (sv-string (concatenate 'string (sv-string "
") (sv-string " }")))))))))))))))))))))))))))))))

(defmethod sv-perl ((self mp-Method))
  (mp-Main::sv-lisp_dump_object "::Method" (list (let ((m (make-instance 'mp-Pair))) (setf (sv-key m) "name") (setf (sv-value m) (sv-name self)) m) (let ((m (make-instance 'mp-Pair))) (setf (sv-key m) "sig") (setf (sv-value m) (sv-sig self)) m) (let ((m (make-instance 'mp-Pair))) (setf (sv-key m) "block") (setf (sv-value m) (sv-block self)) m) )))




;; class Sub
(defpackage mp-Sub
  (:use common-lisp mp-Main))
;; (in-package mp-Sub)
(if (not (ignore-errors (find-class 'mp-Sub)))
  (defclass mp-Sub () ()))

(let (x) 
  (setq x (make-instance 'mp-Sub))
  (defun proto-mp-Sub () x))
;; has $.name
(let ((new-slots (list (list :name 'sv-name
  :readers '(sv-name)
  :writers '((setf sv-name))
  :initform '(sv-undef)
  :initfunction (constantly (sv-undef))))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-Sub)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-Sub :direct-slots new-slots))

;; has $.sig
(let ((new-slots (list (list :name 'sv-sig
  :readers '(sv-sig)
  :writers '((setf sv-sig))
  :initform '(sv-undef)
  :initfunction (constantly (sv-undef))))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-Sub)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-Sub :direct-slots new-slots))

;; has $.block
(let ((new-slots (list (list :name 'sv-block
  :readers '(sv-block)
  :writers '((setf sv-block))
  :initform '(sv-undef)
  :initfunction (constantly (sv-undef))))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-Sub)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-Sub :direct-slots new-slots))

;; method emit_go
(if (not (ignore-errors (find-method 'sv-emit_go () ())))
  (defgeneric sv-emit_go (sv-self)
      (:documentation "a method")))
(defmethod sv-emit_go ((sv-self mp-Sub))
  (block mp6-function
    (progn (if (sv-bool (sv-eq (sv-name sv-self) "")) (progn (return-from mp6-function (concatenate 'string (sv-string "Function( func(v Capture) *Any { ") (sv-string (concatenate 'string (sv-string "    ") (sv-string (concatenate 'string (sv-string (sv-emit_go_bind (sv-sig sv-self) )) (sv-string (concatenate 'string (sv-string "
") (sv-string (concatenate 'string (sv-string "    p := make(chan *Any); go func () { ") (sv-string (concatenate 'string (sv-string "
") (sv-string (concatenate 'string (sv-string "        ") (sv-string (concatenate 'string (sv-string (sv-emit_go (let ((m (make-instance 'mp-MiniPerl6-Go-LexicalBlock))) (setf (sv-block m) (sv-block sv-self))(setf (sv-needs_return m) 1)(setf (sv-top_level m) 1) m) )) (sv-string (concatenate 'string (sv-string "; return }(); ") (sv-string (concatenate 'string (sv-string "
") (sv-string (concatenate 'string (sv-string "    return <-p; ") (sv-string (concatenate 'string (sv-string "
") (sv-string (concatenate 'string (sv-string "} ") (sv-string ")")))))))))))))))))))))))))))) nil)(concatenate 'string (sv-string "func ") (sv-string (concatenate 'string (sv-string (sv-name sv-self)) (sv-string (concatenate 'string (sv-string "(v Capture) *Any { ") (sv-string (concatenate 'string (sv-string "    ") (sv-string (concatenate 'string (sv-string (sv-emit_go_bind (sv-sig sv-self) )) (sv-string (concatenate 'string (sv-string "
") (sv-string (concatenate 'string (sv-string "    p := make(chan *Any); go func () { ") (sv-string (concatenate 'string (sv-string "
") (sv-string (concatenate 'string (sv-string "        ") (sv-string (concatenate 'string (sv-string (sv-emit_go (let ((m (make-instance 'mp-MiniPerl6-Go-LexicalBlock))) (setf (sv-block m) (sv-block sv-self))(setf (sv-needs_return m) 1)(setf (sv-top_level m) 1) m) )) (sv-string (concatenate 'string (sv-string "; return }(); ") (sv-string (concatenate 'string (sv-string "
") (sv-string (concatenate 'string (sv-string "    return <-p; ") (sv-string (concatenate 'string (sv-string "
") (sv-string " }")))))))))))))))))))))))))))))))

(defmethod sv-perl ((self mp-Sub))
  (mp-Main::sv-lisp_dump_object "::Sub" (list (let ((m (make-instance 'mp-Pair))) (setf (sv-key m) "name") (setf (sv-value m) (sv-name self)) m) (let ((m (make-instance 'mp-Pair))) (setf (sv-key m) "sig") (setf (sv-value m) (sv-sig self)) m) (let ((m (make-instance 'mp-Pair))) (setf (sv-key m) "block") (setf (sv-value m) (sv-block self)) m) )))




;; class Do
(defpackage mp-Do
  (:use common-lisp mp-Main))
;; (in-package mp-Do)
(if (not (ignore-errors (find-class 'mp-Do)))
  (defclass mp-Do () ()))

(let (x) 
  (setq x (make-instance 'mp-Do))
  (defun proto-mp-Do () x))
;; has $.block
(let ((new-slots (list (list :name 'sv-block
  :readers '(sv-block)
  :writers '((setf sv-block))
  :initform '(sv-undef)
  :initfunction (constantly (sv-undef))))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-Do)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-Do :direct-slots new-slots))

;; method emit_go
(if (not (ignore-errors (find-method 'sv-emit_go () ())))
  (defgeneric sv-emit_go (sv-self)
      (:documentation "a method")))
(defmethod sv-emit_go ((sv-self mp-Do))
  (block mp6-function
    (progn (concatenate 'string (sv-string "(func () *Any { ") (sv-string (concatenate 'string (sv-string (sv-emit_go (let ((m (make-instance 'mp-MiniPerl6-Go-LexicalBlock))) (setf (sv-block m) (sv-block sv-self))(setf (sv-needs_return m) 1) m) )) (sv-string (concatenate 'string (sv-string "; return u_undef() ") (sv-string "})()")))))))))

(defmethod sv-perl ((self mp-Do))
  (mp-Main::sv-lisp_dump_object "::Do" (list (let ((m (make-instance 'mp-Pair))) (setf (sv-key m) "block") (setf (sv-value m) (sv-block self)) m) )))




;; class Use
(defpackage mp-Use
  (:use common-lisp mp-Main))
;; (in-package mp-Use)
(if (not (ignore-errors (find-class 'mp-Use)))
  (defclass mp-Use () ()))

(let (x) 
  (setq x (make-instance 'mp-Use))
  (defun proto-mp-Use () x))
;; has $.mod
(let ((new-slots (list (list :name 'sv-mod
  :readers '(sv-mod)
  :writers '((setf sv-mod))
  :initform '(sv-undef)
  :initfunction (constantly (sv-undef))))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-Use)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-Use :direct-slots new-slots))

;; method emit_go
(if (not (ignore-errors (find-method 'sv-emit_go () ())))
  (defgeneric sv-emit_go (sv-self)
      (:documentation "a method")))
(defmethod sv-emit_go ((sv-self mp-Use))
  (block mp6-function
    (progn (concatenate 'string (sv-string "// use ") (sv-string (concatenate 'string (sv-string (sv-mod sv-self)) (sv-string "
")))))))

(defmethod sv-perl ((self mp-Use))
  (mp-Main::sv-lisp_dump_object "::Use" (list (let ((m (make-instance 'mp-Pair))) (setf (sv-key m) "mod") (setf (sv-value m) (sv-mod self)) m) )))




