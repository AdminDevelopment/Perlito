# Do not edit this file - Generated by MiniPerl6 4.1
use v5;
use strict;
use MiniPerl6::Perl5::Runtime;
our $MATCH = MiniPerl6::Match->new();
{
package MiniPerl5::Grammar;
sub new { shift; bless { @_ }, "MiniPerl5::Grammar" }
use MiniPerl6::Grammar::Regex;
use MiniPerl6::Grammar::Mapping;
use MiniPerl6::Grammar::Control;
my  $Class_name;
sub get_class_name { $Class_name };
sub ident_digit { my $grammar = $_[0]; my $str = $_[1]; my $pos = $_[2]; my  $MATCH; ($MATCH = MiniPerl6::Match->new( 'str' => $str,'from' => $pos,'to' => $pos,'bool' => 1, )); (($MATCH)->{bool} = do { (my  $pos1 = $MATCH->to()); do { do { (my  $pos1 = $MATCH->to()); (do { (do { (my  $pos1 = $MATCH->to()); (do { do { (my  $m2 = $grammar->word($str, $MATCH->to())); if ($m2) { (($MATCH)->{to} = $m2->to());1 } else { 0 } } } || (do { (($MATCH)->{to} = $pos1); (('_' eq substr($str, $MATCH->to(), 1)) ? (1 + (($MATCH)->{to} = (1 + $MATCH->to()))) : 0) } || do { (($MATCH)->{to} = $pos1); do { (my  $m2 = $grammar->digit($str, $MATCH->to())); if ($m2) { (($MATCH)->{to} = $m2->to());1 } else { 0 } } })) } && do { (my  $m2 = $grammar->ident_digit($str, $MATCH->to())); if ($m2) { (($MATCH)->{to} = $m2->to());1 } else { 0 } }) } || do { (($MATCH)->{to} = $pos1); 1 }) } } }); $MATCH };
sub ident { my $grammar = $_[0]; my $str = $_[1]; my $pos = $_[2]; my  $MATCH; ($MATCH = MiniPerl6::Match->new( 'str' => $str,'from' => $pos,'to' => $pos,'bool' => 1, )); (($MATCH)->{bool} = do { (my  $pos1 = $MATCH->to()); do { (do { (my  $pos1 = $MATCH->to()); (do { do { (my  $m2 = $grammar->word($str, $MATCH->to())); if ($m2) { (($MATCH)->{to} = $m2->to());1 } else { 0 } } } || do { (($MATCH)->{to} = $pos1); (('_' eq substr($str, $MATCH->to(), 1)) ? (1 + (($MATCH)->{to} = (1 + $MATCH->to()))) : 0) }) } && do { (my  $m2 = $grammar->ident_digit($str, $MATCH->to())); if ($m2) { (($MATCH)->{to} = $m2->to());1 } else { 0 } }) } }); $MATCH };
sub full_ident { my $grammar = $_[0]; my $str = $_[1]; my $pos = $_[2]; my  $MATCH; ($MATCH = MiniPerl6::Match->new( 'str' => $str,'from' => $pos,'to' => $pos,'bool' => 1, )); (($MATCH)->{bool} = do { (my  $pos1 = $MATCH->to()); do { (do { (my  $m2 = $grammar->ident($str, $MATCH->to())); if ($m2) { (($MATCH)->{to} = $m2->to());1 } else { 0 } } && do { (my  $pos1 = $MATCH->to()); (do { ((('::' eq substr($str, $MATCH->to(), 2)) ? (1 + (($MATCH)->{to} = (2 + $MATCH->to()))) : 0) && do { (my  $m2 = $grammar->full_ident($str, $MATCH->to())); if ($m2) { (($MATCH)->{to} = $m2->to());1 } else { 0 } }) } || do { (($MATCH)->{to} = $pos1); 1 }) }) } }); $MATCH };
sub namespace_before_ident { my $grammar = $_[0]; my $str = $_[1]; my $pos = $_[2]; my  $MATCH; ($MATCH = MiniPerl6::Match->new( 'str' => $str,'from' => $pos,'to' => $pos,'bool' => 1, )); (($MATCH)->{bool} = do { (my  $pos1 = $MATCH->to()); do { (do { (my  $m2 = $grammar->ident($str, $MATCH->to())); if ($m2) { (($MATCH)->{to} = $m2->to());1 } else { 0 } } && (do { (my  $tmp = $MATCH); ($MATCH = MiniPerl6::Match->new( 'str' => $str,'from' => $tmp->to(),'to' => $tmp->to(),'bool' => 1, )); (($MATCH)->{bool} = do { (my  $pos1 = $MATCH->to()); do { (('::' eq substr($str, $MATCH->to(), 2)) ? (1 + (($MATCH)->{to} = (2 + $MATCH->to()))) : 0) } }); (($tmp)->{bool} = ($MATCH ? 1 : 0)); ($MATCH = $tmp); ($MATCH ? 1 : 0) } && do { (my  $pos1 = $MATCH->to()); (do { ((('::' eq substr($str, $MATCH->to(), 2)) ? (1 + (($MATCH)->{to} = (2 + $MATCH->to()))) : 0) && do { (my  $m2 = $grammar->namespace_before_ident($str, $MATCH->to())); if ($m2) { (($MATCH)->{to} = $m2->to());1 } else { 0 } }) } || do { (($MATCH)->{to} = $pos1); 1 }) })) } }); $MATCH };
sub optional_namespace_before_ident { my $grammar = $_[0]; my $str = $_[1]; my $pos = $_[2]; my  $MATCH; ($MATCH = MiniPerl6::Match->new( 'str' => $str,'from' => $pos,'to' => $pos,'bool' => 1, )); (($MATCH)->{bool} = do { (my  $pos1 = $MATCH->to()); (do { (do { (my  $m2 = $grammar->namespace_before_ident($str, $MATCH->to())); if ($m2) { (($MATCH)->{to} = $m2->to());($MATCH->{'namespace_before_ident'} = $m2);1 } else { 0 } } && ((('::' eq substr($str, $MATCH->to(), 2)) ? (1 + (($MATCH)->{to} = (2 + $MATCH->to()))) : 0) && (do { ($MATCH->{capture} = (("" . $MATCH->{'namespace_before_ident'}))) } || 1))) } || do { (($MATCH)->{to} = $pos1); (1 && (do { ($MATCH->{capture} = ('')) } || 1)) }) }); $MATCH };
sub to_line_end { my $grammar = $_[0]; my $str = $_[1]; my $pos = $_[2]; my  $MATCH; ($MATCH = MiniPerl6::Match->new( 'str' => $str,'from' => $pos,'to' => $pos,'bool' => 1, )); (($MATCH)->{bool} = do { (my  $pos1 = $MATCH->to()); (do { (do { (my  $m2 = $grammar->not_newline($str, $MATCH->to())); if ($m2) { (($MATCH)->{to} = $m2->to());1 } else { 0 } } && do { (my  $m2 = $grammar->to_line_end($str, $MATCH->to())); if ($m2) { (($MATCH)->{to} = $m2->to());1 } else { 0 } }) } || do { (($MATCH)->{to} = $pos1); 1 }) }); $MATCH };
sub pod_begin { my $grammar = $_[0]; my $str = $_[1]; my $pos = $_[2]; my  $MATCH; ($MATCH = MiniPerl6::Match->new( 'str' => $str,'from' => $pos,'to' => $pos,'bool' => 1, )); (($MATCH)->{bool} = do { (my  $pos1 = $MATCH->to()); (do { (do { (my  $m2 = $grammar->is_newline($str, $MATCH->to())); if ($m2) { (($MATCH)->{to} = $m2->to());1 } else { 0 } } && ((('=end' eq substr($str, $MATCH->to(), 4)) ? (1 + (($MATCH)->{to} = (4 + $MATCH->to()))) : 0) && do { (my  $m2 = $grammar->to_line_end($str, $MATCH->to())); if ($m2) { (($MATCH)->{to} = $m2->to());1 } else { 0 } })) } || do { (($MATCH)->{to} = $pos1); ((('' ne substr($str, $MATCH->to(), 1)) ? (1 + (($MATCH)->{to} = (1 + $MATCH->to()))) : 0) && (do { (my  $m2 = $grammar->to_line_end($str, $MATCH->to())); if ($m2) { (($MATCH)->{to} = $m2->to());1 } else { 0 } } && do { (my  $m2 = $grammar->pod_begin($str, $MATCH->to())); if ($m2) { (($MATCH)->{to} = $m2->to());1 } else { 0 } })) }) }); $MATCH };
sub pod_other { my $grammar = $_[0]; my $str = $_[1]; my $pos = $_[2]; my  $MATCH; ($MATCH = MiniPerl6::Match->new( 'str' => $str,'from' => $pos,'to' => $pos,'bool' => 1, )); (($MATCH)->{bool} = do { (my  $pos1 = $MATCH->to()); (do { (do { (my  $m2 = $grammar->is_newline($str, $MATCH->to())); if ($m2) { (($MATCH)->{to} = $m2->to());1 } else { 0 } } && ((('=cut' eq substr($str, $MATCH->to(), 4)) ? (1 + (($MATCH)->{to} = (4 + $MATCH->to()))) : 0) && do { (my  $m2 = $grammar->to_line_end($str, $MATCH->to())); if ($m2) { (($MATCH)->{to} = $m2->to());1 } else { 0 } })) } || do { (($MATCH)->{to} = $pos1); ((('' ne substr($str, $MATCH->to(), 1)) ? (1 + (($MATCH)->{to} = (1 + $MATCH->to()))) : 0) && (do { (my  $m2 = $grammar->to_line_end($str, $MATCH->to())); if ($m2) { (($MATCH)->{to} = $m2->to());1 } else { 0 } } && do { (my  $m2 = $grammar->pod_other($str, $MATCH->to())); if ($m2) { (($MATCH)->{to} = $m2->to());1 } else { 0 } })) }) }); $MATCH };
sub ws { my $grammar = $_[0]; my $str = $_[1]; my $pos = $_[2]; my  $MATCH; ($MATCH = MiniPerl6::Match->new( 'str' => $str,'from' => $pos,'to' => $pos,'bool' => 1, )); (($MATCH)->{bool} = do { (my  $pos1 = $MATCH->to()); do { (do { (my  $pos1 = $MATCH->to()); (do { ((('#' eq substr($str, $MATCH->to(), 1)) ? (1 + (($MATCH)->{to} = (1 + $MATCH->to()))) : 0) && do { (my  $m2 = $grammar->to_line_end($str, $MATCH->to())); if ($m2) { (($MATCH)->{to} = $m2->to());1 } else { 0 } }) } || (do { (($MATCH)->{to} = $pos1); (do { (my  $m2 = $grammar->is_newline($str, $MATCH->to())); if ($m2) { (($MATCH)->{to} = $m2->to());1 } else { 0 } } && do { (my  $pos1 = $MATCH->to()); (do { ((('=pod' eq substr($str, $MATCH->to(), 4)) ? (1 + (($MATCH)->{to} = (4 + $MATCH->to()))) : 0) && do { (my  $m2 = $grammar->pod_other($str, $MATCH->to())); if ($m2) { (($MATCH)->{to} = $m2->to());1 } else { 0 } }) } || (do { (($MATCH)->{to} = $pos1); ((('=for' eq substr($str, $MATCH->to(), 4)) ? (1 + (($MATCH)->{to} = (4 + $MATCH->to()))) : 0) && do { (my  $m2 = $grammar->pod_other($str, $MATCH->to())); if ($m2) { (($MATCH)->{to} = $m2->to());1 } else { 0 } }) } || (do { (($MATCH)->{to} = $pos1); ((('=head1' eq substr($str, $MATCH->to(), 6)) ? (1 + (($MATCH)->{to} = (6 + $MATCH->to()))) : 0) && do { (my  $m2 = $grammar->pod_other($str, $MATCH->to())); if ($m2) { (($MATCH)->{to} = $m2->to());1 } else { 0 } }) } || do { (($MATCH)->{to} = $pos1); 1 }))) }) } || do { (($MATCH)->{to} = $pos1); do { (my  $m2 = $grammar->space($str, $MATCH->to())); if ($m2) { (($MATCH)->{to} = $m2->to());1 } else { 0 } } })) } && do { (my  $pos1 = $MATCH->to()); (do { do { (my  $m2 = $grammar->ws($str, $MATCH->to())); if ($m2) { (($MATCH)->{to} = $m2->to());1 } else { 0 } } } || do { (($MATCH)->{to} = $pos1); 1 }) }) } }); $MATCH };
sub opt_ws { my $grammar = $_[0]; my $str = $_[1]; my $pos = $_[2]; my  $MATCH; ($MATCH = MiniPerl6::Match->new( 'str' => $str,'from' => $pos,'to' => $pos,'bool' => 1, )); (($MATCH)->{bool} = do { (my  $pos1 = $MATCH->to()); (do { do { (my  $m2 = $grammar->ws($str, $MATCH->to())); if ($m2) { (($MATCH)->{to} = $m2->to());1 } else { 0 } } } || do { (($MATCH)->{to} = $pos1); 1 }) }); $MATCH };
sub opt_ws2 { my $grammar = $_[0]; my $str = $_[1]; my $pos = $_[2]; my  $MATCH; ($MATCH = MiniPerl6::Match->new( 'str' => $str,'from' => $pos,'to' => $pos,'bool' => 1, )); (($MATCH)->{bool} = do { (my  $pos1 = $MATCH->to()); (do { do { (my  $m2 = $grammar->ws($str, $MATCH->to())); if ($m2) { (($MATCH)->{to} = $m2->to());1 } else { 0 } } } || do { (($MATCH)->{to} = $pos1); 1 }) }); $MATCH };
sub opt_ws3 { my $grammar = $_[0]; my $str = $_[1]; my $pos = $_[2]; my  $MATCH; ($MATCH = MiniPerl6::Match->new( 'str' => $str,'from' => $pos,'to' => $pos,'bool' => 1, )); (($MATCH)->{bool} = do { (my  $pos1 = $MATCH->to()); (do { do { (my  $m2 = $grammar->ws($str, $MATCH->to())); if ($m2) { (($MATCH)->{to} = $m2->to());1 } else { 0 } } } || do { (($MATCH)->{to} = $pos1); 1 }) }); $MATCH };
sub parse { my $grammar = $_[0]; my $str = $_[1]; my $pos = $_[2]; my  $MATCH; ($MATCH = MiniPerl6::Match->new( 'str' => $str,'from' => $pos,'to' => $pos,'bool' => 1, )); (($MATCH)->{bool} = do { (my  $pos1 = $MATCH->to()); (do { (do { (my  $m2 = $grammar->comp_unit($str, $MATCH->to())); if ($m2) { (($MATCH)->{to} = $m2->to());($MATCH->{'comp_unit'} = $m2);1 } else { 0 } } && do { (my  $pos1 = $MATCH->to()); (do { (do { (my  $m2 = $grammar->parse($str, $MATCH->to())); if ($m2) { (($MATCH)->{to} = $m2->to());($MATCH->{'parse'} = $m2);1 } else { 0 } } && (do { ($MATCH->{capture} = ([${$MATCH->{'comp_unit'}}, @{${$MATCH->{'parse'}}}])) } || 1)) } || do { (($MATCH)->{to} = $pos1); (do { ($MATCH->{capture} = ([${$MATCH->{'comp_unit'}}])) } || 1) }) }) } || do { (($MATCH)->{to} = $pos1); (do { ($MATCH->{capture} = ([])) } || 1) }) }); $MATCH };
sub comp_unit { my $grammar = $_[0]; my $str = $_[1]; my $pos = $_[2]; my  $MATCH; ($MATCH = MiniPerl6::Match->new( 'str' => $str,'from' => $pos,'to' => $pos,'bool' => 1, )); (($MATCH)->{bool} = do { (my  $pos1 = $MATCH->to()); do { (do { (my  $m2 = $grammar->opt_ws($str, $MATCH->to())); if ($m2) { (($MATCH)->{to} = $m2->to());1 } else { 0 } } && (do { (my  $pos1 = $MATCH->to()); (do { (((';' eq substr($str, $MATCH->to(), 1)) ? (1 + (($MATCH)->{to} = (1 + $MATCH->to()))) : 0) && do { (my  $m2 = $grammar->opt_ws($str, $MATCH->to())); if ($m2) { (($MATCH)->{to} = $m2->to());1 } else { 0 } }) } || do { (($MATCH)->{to} = $pos1); 1 }) } && ((('{' eq substr($str, $MATCH->to(), 1)) ? (1 + (($MATCH)->{to} = (1 + $MATCH->to()))) : 0) && (do { (my  $m2 = $grammar->opt_ws($str, $MATCH->to())); if ($m2) { (($MATCH)->{to} = $m2->to());1 } else { 0 } } && (do { (my  $pos1 = $MATCH->to()); (do { ((('use' eq substr($str, $MATCH->to(), 3)) ? (1 + (($MATCH)->{to} = (3 + $MATCH->to()))) : 0) && (do { (my  $m2 = $grammar->ws($str, $MATCH->to())); if ($m2) { (($MATCH)->{to} = $m2->to());1 } else { 0 } } && ((('v5' eq substr($str, $MATCH->to(), 2)) ? (1 + (($MATCH)->{to} = (2 + $MATCH->to()))) : 0) && (do { (my  $m2 = $grammar->opt_ws($str, $MATCH->to())); if ($m2) { (($MATCH)->{to} = $m2->to());1 } else { 0 } } && (((';' eq substr($str, $MATCH->to(), 1)) ? (1 + (($MATCH)->{to} = (1 + $MATCH->to()))) : 0) && do { (my  $m2 = $grammar->ws($str, $MATCH->to())); if ($m2) { (($MATCH)->{to} = $m2->to());1 } else { 0 } }))))) } || do { (($MATCH)->{to} = $pos1); 1 }) } && ((('package' eq substr($str, $MATCH->to(), 7)) ? (1 + (($MATCH)->{to} = (7 + $MATCH->to()))) : 0) && (do { (my  $m2 = $grammar->opt_ws($str, $MATCH->to())); if ($m2) { (($MATCH)->{to} = $m2->to());1 } else { 0 } } && (do { (my  $m2 = $grammar->full_ident($str, $MATCH->to())); if ($m2) { (($MATCH)->{to} = $m2->to());($MATCH->{'full_ident'} = $m2);1 } else { 0 } } && (do { (my  $m2 = $grammar->opt_ws($str, $MATCH->to())); if ($m2) { (($MATCH)->{to} = $m2->to());1 } else { 0 } } && ((do { ($Class_name = ("" . $MATCH->{'full_ident'})) } || 1) && (do { (my  $m2 = $grammar->opt_ws($str, $MATCH->to())); if ($m2) { (($MATCH)->{to} = $m2->to());1 } else { 0 } } && (do { (my  $m2 = $grammar->exp_stmts($str, $MATCH->to())); if ($m2) { (($MATCH)->{to} = $m2->to());($MATCH->{'exp_stmts'} = $m2);1 } else { 0 } } && (do { (my  $m2 = $grammar->opt_ws($str, $MATCH->to())); if ($m2) { (($MATCH)->{to} = $m2->to());1 } else { 0 } } && ((('}' eq substr($str, $MATCH->to(), 1)) ? (1 + (($MATCH)->{to} = (1 + $MATCH->to()))) : 0) && (do { (my  $m2 = $grammar->opt_ws($str, $MATCH->to())); if ($m2) { (($MATCH)->{to} = $m2->to());1 } else { 0 } } && (do { (my  $pos1 = $MATCH->to()); (do { (((';' eq substr($str, $MATCH->to(), 1)) ? (1 + (($MATCH)->{to} = (1 + $MATCH->to()))) : 0) && do { (my  $m2 = $grammar->opt_ws($str, $MATCH->to())); if ($m2) { (($MATCH)->{to} = $m2->to());1 } else { 0 } }) } || do { (($MATCH)->{to} = $pos1); 1 }) } && (do { ($MATCH->{capture} = (CompUnit->new( 'name' => ${$MATCH->{'full_ident'}},'attributes' => {  },'methods' => {  },'body' => ${$MATCH->{'exp_stmts'}}, ))) } || 1))))))))))))))))) } }); $MATCH };
sub infix_op { my $grammar = $_[0]; my $str = $_[1]; my $pos = $_[2]; my  $MATCH; ($MATCH = MiniPerl6::Match->new( 'str' => $str,'from' => $pos,'to' => $pos,'bool' => 1, )); (($MATCH)->{bool} = do { (my  $pos1 = $MATCH->to()); (do { (('+' eq substr($str, $MATCH->to(), 1)) ? (1 + (($MATCH)->{to} = (1 + $MATCH->to()))) : 0) } || (do { (($MATCH)->{to} = $pos1); (('-' eq substr($str, $MATCH->to(), 1)) ? (1 + (($MATCH)->{to} = (1 + $MATCH->to()))) : 0) } || (do { (($MATCH)->{to} = $pos1); (('*' eq substr($str, $MATCH->to(), 1)) ? (1 + (($MATCH)->{to} = (1 + $MATCH->to()))) : 0) } || (do { (($MATCH)->{to} = $pos1); (('/' eq substr($str, $MATCH->to(), 1)) ? (1 + (($MATCH)->{to} = (1 + $MATCH->to()))) : 0) } || (do { (($MATCH)->{to} = $pos1); ((('e' eq substr($str, $MATCH->to(), 1)) ? (1 + (($MATCH)->{to} = (1 + $MATCH->to()))) : 0) && (('q' eq substr($str, $MATCH->to(), 1)) ? (1 + (($MATCH)->{to} = (1 + $MATCH->to()))) : 0)) } || (do { (($MATCH)->{to} = $pos1); ((('n' eq substr($str, $MATCH->to(), 1)) ? (1 + (($MATCH)->{to} = (1 + $MATCH->to()))) : 0) && (('e' eq substr($str, $MATCH->to(), 1)) ? (1 + (($MATCH)->{to} = (1 + $MATCH->to()))) : 0)) } || (do { (($MATCH)->{to} = $pos1); (('==' eq substr($str, $MATCH->to(), 2)) ? (1 + (($MATCH)->{to} = (2 + $MATCH->to()))) : 0) } || (do { (($MATCH)->{to} = $pos1); (('!=' eq substr($str, $MATCH->to(), 2)) ? (1 + (($MATCH)->{to} = (2 + $MATCH->to()))) : 0) } || (do { (($MATCH)->{to} = $pos1); (('&&' eq substr($str, $MATCH->to(), 2)) ? (1 + (($MATCH)->{to} = (2 + $MATCH->to()))) : 0) } || (do { (($MATCH)->{to} = $pos1); (('||' eq substr($str, $MATCH->to(), 2)) ? (1 + (($MATCH)->{to} = (2 + $MATCH->to()))) : 0) } || (do { (($MATCH)->{to} = $pos1); (('~~' eq substr($str, $MATCH->to(), 2)) ? (1 + (($MATCH)->{to} = (2 + $MATCH->to()))) : 0) } || (do { (($MATCH)->{to} = $pos1); (('.' eq substr($str, $MATCH->to(), 1)) ? (1 + (($MATCH)->{to} = (1 + $MATCH->to()))) : 0) } || (do { (($MATCH)->{to} = $pos1); (('>' eq substr($str, $MATCH->to(), 1)) ? (1 + (($MATCH)->{to} = (1 + $MATCH->to()))) : 0) } || do { (($MATCH)->{to} = $pos1); (('x' eq substr($str, $MATCH->to(), 1)) ? (1 + (($MATCH)->{to} = (1 + $MATCH->to()))) : 0) }))))))))))))) }); $MATCH };
sub prefix_op { my $grammar = $_[0]; my $str = $_[1]; my $pos = $_[2]; my  $MATCH; ($MATCH = MiniPerl6::Match->new( 'str' => $str,'from' => $pos,'to' => $pos,'bool' => 1, )); (($MATCH)->{bool} = do { (my  $pos1 = $MATCH->to()); do { (do { (my  $pos1 = $MATCH->to()); (do { (('$' eq substr($str, $MATCH->to(), 1)) ? (1 + (($MATCH)->{to} = (1 + $MATCH->to()))) : 0) } || (do { (($MATCH)->{to} = $pos1); (('@' eq substr($str, $MATCH->to(), 1)) ? (1 + (($MATCH)->{to} = (1 + $MATCH->to()))) : 0) } || (do { (($MATCH)->{to} = $pos1); (('%' eq substr($str, $MATCH->to(), 1)) ? (1 + (($MATCH)->{to} = (1 + $MATCH->to()))) : 0) } || (do { (($MATCH)->{to} = $pos1); (('&' eq substr($str, $MATCH->to(), 1)) ? (1 + (($MATCH)->{to} = (1 + $MATCH->to()))) : 0) } || (do { (($MATCH)->{to} = $pos1); (('!' eq substr($str, $MATCH->to(), 1)) ? (1 + (($MATCH)->{to} = (1 + $MATCH->to()))) : 0) } || (do { (($MATCH)->{to} = $pos1); (('++' eq substr($str, $MATCH->to(), 2)) ? (1 + (($MATCH)->{to} = (2 + $MATCH->to()))) : 0) } || (do { (($MATCH)->{to} = $pos1); (('--' eq substr($str, $MATCH->to(), 2)) ? (1 + (($MATCH)->{to} = (2 + $MATCH->to()))) : 0) } || (do { (($MATCH)->{to} = $pos1); (('+' eq substr($str, $MATCH->to(), 1)) ? (1 + (($MATCH)->{to} = (1 + $MATCH->to()))) : 0) } || do { (($MATCH)->{to} = $pos1); (('-' eq substr($str, $MATCH->to(), 1)) ? (1 + (($MATCH)->{to} = (1 + $MATCH->to()))) : 0) })))))))) } && do { (my  $tmp = $MATCH); ($MATCH = MiniPerl6::Match->new( 'str' => $str,'from' => $tmp->to(),'to' => $tmp->to(),'bool' => 1, )); (($MATCH)->{bool} = do { (my  $pos1 = $MATCH->to()); (do { (('(' eq substr($str, $MATCH->to(), 1)) ? (1 + (($MATCH)->{to} = (1 + $MATCH->to()))) : 0) } || do { (($MATCH)->{to} = $pos1); (('$' eq substr($str, $MATCH->to(), 1)) ? (1 + (($MATCH)->{to} = (1 + $MATCH->to()))) : 0) }) }); (($tmp)->{bool} = ($MATCH ? 1 : 0)); ($MATCH = $tmp); ($MATCH ? 1 : 0) }) } }); $MATCH };
sub declarator { my $grammar = $_[0]; my $str = $_[1]; my $pos = $_[2]; my  $MATCH; ($MATCH = MiniPerl6::Match->new( 'str' => $str,'from' => $pos,'to' => $pos,'bool' => 1, )); (($MATCH)->{bool} = do { (my  $pos1 = $MATCH->to()); (do { (('my' eq substr($str, $MATCH->to(), 2)) ? (1 + (($MATCH)->{to} = (2 + $MATCH->to()))) : 0) } || do { (($MATCH)->{to} = $pos1); (('state' eq substr($str, $MATCH->to(), 5)) ? (1 + (($MATCH)->{to} = (5 + $MATCH->to()))) : 0) }) }); $MATCH };
sub exp2 { my $grammar = $_[0]; my $str = $_[1]; my $pos = $_[2]; my  $MATCH; ($MATCH = MiniPerl6::Match->new( 'str' => $str,'from' => $pos,'to' => $pos,'bool' => 1, )); (($MATCH)->{bool} = do { (my  $pos1 = $MATCH->to()); do { (do { (my  $m2 = $grammar->exp($str, $MATCH->to())); if ($m2) { (($MATCH)->{to} = $m2->to());($MATCH->{'exp'} = $m2);1 } else { 0 } } && (do { ($MATCH->{capture} = (${$MATCH->{'exp'}})) } || 1)) } }); $MATCH };
sub exp_stmts2 { my $grammar = $_[0]; my $str = $_[1]; my $pos = $_[2]; my  $MATCH; ($MATCH = MiniPerl6::Match->new( 'str' => $str,'from' => $pos,'to' => $pos,'bool' => 1, )); (($MATCH)->{bool} = do { (my  $pos1 = $MATCH->to()); do { (do { (my  $m2 = $grammar->exp_stmts($str, $MATCH->to())); if ($m2) { (($MATCH)->{to} = $m2->to());($MATCH->{'exp_stmts'} = $m2);1 } else { 0 } } && (do { ($MATCH->{capture} = (${$MATCH->{'exp_stmts'}})) } || 1)) } }); $MATCH };
sub exp { my $grammar = $_[0]; my $str = $_[1]; my $pos = $_[2]; my  $MATCH; ($MATCH = MiniPerl6::Match->new( 'str' => $str,'from' => $pos,'to' => $pos,'bool' => 1, )); (($MATCH)->{bool} = do { (my  $pos1 = $MATCH->to()); do { (do { (my  $m2 = $grammar->term_meth($str, $MATCH->to())); if ($m2) { (($MATCH)->{to} = $m2->to());($MATCH->{'term_meth'} = $m2);1 } else { 0 } } && do { (my  $pos1 = $MATCH->to()); (do { (do { (my  $m2 = $grammar->opt_ws($str, $MATCH->to())); if ($m2) { (($MATCH)->{to} = $m2->to());1 } else { 0 } } && ((('?' eq substr($str, $MATCH->to(), 1)) ? (1 + (($MATCH)->{to} = (1 + $MATCH->to()))) : 0) && do { (my  $pos1 = $MATCH->to()); (do { (do { (my  $m2 = $grammar->opt_ws($str, $MATCH->to())); if ($m2) { (($MATCH)->{to} = $m2->to());1 } else { 0 } } && (do { (my  $m2 = $grammar->exp($str, $MATCH->to())); if ($m2) { (($MATCH)->{to} = $m2->to());($MATCH->{'exp'} = $m2);1 } else { 0 } } && (do { (my  $m2 = $grammar->opt_ws($str, $MATCH->to())); if ($m2) { (($MATCH)->{to} = $m2->to());1 } else { 0 } } && (((':' eq substr($str, $MATCH->to(), 1)) ? (1 + (($MATCH)->{to} = (1 + $MATCH->to()))) : 0) && (do { (my  $m2 = $grammar->opt_ws($str, $MATCH->to())); if ($m2) { (($MATCH)->{to} = $m2->to());1 } else { 0 } } && (do { (my  $m2 = $grammar->exp2($str, $MATCH->to())); if ($m2) { (($MATCH)->{to} = $m2->to());($MATCH->{'exp2'} = $m2);1 } else { 0 } } && (do { ($MATCH->{capture} = (Apply->new( 'namespace' => '','code' => 'ternary:<?? !!>','arguments' => [${$MATCH->{'term_meth'}}, ${$MATCH->{'exp'}}, ${$MATCH->{'exp2'}}], ))) } || 1))))))) } || do { (($MATCH)->{to} = $pos1); (do { Main::say('*** Syntax error in ternary operation') } || 1) }) })) } || (do { (($MATCH)->{to} = $pos1); (do { (my  $m2 = $grammar->opt_ws($str, $MATCH->to())); if ($m2) { (($MATCH)->{to} = $m2->to());1 } else { 0 } } && (do { (my  $m2 = $grammar->infix_op($str, $MATCH->to())); if ($m2) { (($MATCH)->{to} = $m2->to());($MATCH->{'infix_op'} = $m2);1 } else { 0 } } && (do { (my  $m2 = $grammar->opt_ws($str, $MATCH->to())); if ($m2) { (($MATCH)->{to} = $m2->to());1 } else { 0 } } && (do { (my  $m2 = $grammar->exp($str, $MATCH->to())); if ($m2) { (($MATCH)->{to} = $m2->to());($MATCH->{'exp'} = $m2);1 } else { 0 } } && (do { ($MATCH->{capture} = (Apply->new( 'namespace' => '','code' => 'infix:<' . $MATCH->{'infix_op'} . '>','arguments' => [${$MATCH->{'term_meth'}}, ${$MATCH->{'exp'}}], ))) } || 1))))) } || (do { (($MATCH)->{to} = $pos1); (do { (my  $m2 = $grammar->opt_ws($str, $MATCH->to())); if ($m2) { (($MATCH)->{to} = $m2->to());1 } else { 0 } } && ((('=' eq substr($str, $MATCH->to(), 1)) ? (1 + (($MATCH)->{to} = (1 + $MATCH->to()))) : 0) && (do { (my  $m2 = $grammar->opt_ws($str, $MATCH->to())); if ($m2) { (($MATCH)->{to} = $m2->to());1 } else { 0 } } && (do { (my  $m2 = $grammar->exp($str, $MATCH->to())); if ($m2) { (($MATCH)->{to} = $m2->to());($MATCH->{'exp'} = $m2);1 } else { 0 } } && (do { ($MATCH->{capture} = (Bind->new( 'parameters' => ${$MATCH->{'term_meth'}},'arguments' => ${$MATCH->{'exp'}}, ))) } || 1))))) } || do { (($MATCH)->{to} = $pos1); (do { ($MATCH->{capture} = (${$MATCH->{'term_meth'}})) } || 1) }))) }) } }); $MATCH };
sub opt_ident { my $grammar = $_[0]; my $str = $_[1]; my $pos = $_[2]; my  $MATCH; ($MATCH = MiniPerl6::Match->new( 'str' => $str,'from' => $pos,'to' => $pos,'bool' => 1, )); (($MATCH)->{bool} = do { (my  $pos1 = $MATCH->to()); (do { (do { (my  $m2 = $grammar->ident($str, $MATCH->to())); if ($m2) { (($MATCH)->{to} = $m2->to());($MATCH->{'ident'} = $m2);1 } else { 0 } } && (do { ($MATCH->{capture} = (${$MATCH->{'ident'}})) } || 1)) } || do { (($MATCH)->{to} = $pos1); (1 && (do { ($MATCH->{capture} = ('postcircumfix:<( )>')) } || 1)) }) }); $MATCH };
sub term_meth { my $grammar = $_[0]; my $str = $_[1]; my $pos = $_[2]; my  $MATCH; ($MATCH = MiniPerl6::Match->new( 'str' => $str,'from' => $pos,'to' => $pos,'bool' => 1, )); (($MATCH)->{bool} = do { (my  $pos1 = $MATCH->to()); (do { (do { (my  $m2 = $grammar->full_ident($str, $MATCH->to())); if ($m2) { (($MATCH)->{to} = $m2->to());($MATCH->{'full_ident'} = $m2);1 } else { 0 } } && do { (my  $pos1 = $MATCH->to()); (do { do { (my  $pos1 = $MATCH->to()); do { ((('->new(' eq substr($str, $MATCH->to(), 6)) ? (1 + (($MATCH)->{to} = (6 + $MATCH->to()))) : 0) && do { (my  $pos1 = $MATCH->to()); (do { (do { (my  $m2 = $grammar->opt_ws($str, $MATCH->to())); if ($m2) { (($MATCH)->{to} = $m2->to());1 } else { 0 } } && (do { (my  $m2 = $grammar->exp_mapping($str, $MATCH->to())); if ($m2) { (($MATCH)->{to} = $m2->to());($MATCH->{'exp_mapping'} = $m2);1 } else { 0 } } && (do { (my  $m2 = $grammar->opt_ws($str, $MATCH->to())); if ($m2) { (($MATCH)->{to} = $m2->to());1 } else { 0 } } && (((')' eq substr($str, $MATCH->to(), 1)) ? (1 + (($MATCH)->{to} = (1 + $MATCH->to()))) : 0) && (do { ($MATCH->{capture} = (Lit::Object->new( 'class' => ${$MATCH->{'full_ident'}},'fields' => ${$MATCH->{'exp_mapping'}}, ))) } || 1))))) } || do { (($MATCH)->{to} = $pos1); (do { Main::say('*** Syntax Error parsing Constructor'); die() } || 1) }) }) } } } || do { (($MATCH)->{to} = $pos1); do { (my  $pos1 = $MATCH->to()); do { ((('->' eq substr($str, $MATCH->to(), 2)) ? (1 + (($MATCH)->{to} = (2 + $MATCH->to()))) : 0) && (do { (my  $m2 = $grammar->ident($str, $MATCH->to())); if ($m2) { (($MATCH)->{to} = $m2->to());($MATCH->{'ident'} = $m2);1 } else { 0 } } && do { (my  $pos1 = $MATCH->to()); (do { ((('(' eq substr($str, $MATCH->to(), 1)) ? (1 + (($MATCH)->{to} = (1 + $MATCH->to()))) : 0) && (do { (my  $m2 = $grammar->opt_ws($str, $MATCH->to())); if ($m2) { (($MATCH)->{to} = $m2->to());1 } else { 0 } } && (do { (my  $m2 = $grammar->exp_seq($str, $MATCH->to())); if ($m2) { (($MATCH)->{to} = $m2->to());($MATCH->{'exp_seq'} = $m2);1 } else { 0 } } && (do { (my  $m2 = $grammar->opt_ws($str, $MATCH->to())); if ($m2) { (($MATCH)->{to} = $m2->to());1 } else { 0 } } && (((')' eq substr($str, $MATCH->to(), 1)) ? (1 + (($MATCH)->{to} = (1 + $MATCH->to()))) : 0) && (do { ($MATCH->{capture} = (Call->new( 'invocant' => Proto->new( 'name' => ("" . $MATCH->{'full_ident'}), ),'method' => ${$MATCH->{'ident'}},'arguments' => ${$MATCH->{'exp_seq'}},'hyper' => '', ))) } || 1)))))) } || do { (($MATCH)->{to} = $pos1); (do { ($MATCH->{capture} = (Call->new( 'invocant' => Proto->new( 'name' => ("" . $MATCH->{'full_ident'}), ),'method' => ${$MATCH->{'ident'}},'arguments' => [],'hyper' => '', ))) } || 1) }) })) } } }) }) } || do { (($MATCH)->{to} = $pos1); (do { (my  $m2 = $grammar->exp_term($str, $MATCH->to())); if ($m2) { (($MATCH)->{to} = $m2->to());($MATCH->{'exp_term'} = $m2);1 } else { 0 } } && do { (my  $pos1 = $MATCH->to()); (do { ((('->' eq substr($str, $MATCH->to(), 2)) ? (1 + (($MATCH)->{to} = (2 + $MATCH->to()))) : 0) && (do { (my  $m2 = $grammar->opt_ident($str, $MATCH->to())); if ($m2) { (($MATCH)->{to} = $m2->to());($MATCH->{'opt_ident'} = $m2);1 } else { 0 } } && (do { (my  $pos1 = $MATCH->to()); (do { ((('(' eq substr($str, $MATCH->to(), 1)) ? (1 + (($MATCH)->{to} = (1 + $MATCH->to()))) : 0) && (do { (my  $m2 = $grammar->opt_ws($str, $MATCH->to())); if ($m2) { (($MATCH)->{to} = $m2->to());1 } else { 0 } } && (do { (my  $m2 = $grammar->exp_seq($str, $MATCH->to())); if ($m2) { (($MATCH)->{to} = $m2->to());($MATCH->{'exp_seq'} = $m2);1 } else { 0 } } && (do { (my  $m2 = $grammar->opt_ws($str, $MATCH->to())); if ($m2) { (($MATCH)->{to} = $m2->to());1 } else { 0 } } && ((')' eq substr($str, $MATCH->to(), 1)) ? (1 + (($MATCH)->{to} = (1 + $MATCH->to()))) : 0))))) } || do { (($MATCH)->{to} = $pos1); (do { ($MATCH->{capture} = (Call->new( 'invocant' => ${$MATCH->{'exp_term'}},'method' => ${$MATCH->{'opt_ident'}},'arguments' => [],'hyper' => '', ))) } || 1) }) } && (do { ($MATCH->{capture} = (Call->new( 'invocant' => ${$MATCH->{'exp_term'}},'method' => ${$MATCH->{'opt_ident'}},'arguments' => ${$MATCH->{'exp_seq'}},'hyper' => '', ))) } || 1)))) } || (do { (($MATCH)->{to} = $pos1); ((('[' eq substr($str, $MATCH->to(), 1)) ? (1 + (($MATCH)->{to} = (1 + $MATCH->to()))) : 0) && (do { (my  $m2 = $grammar->opt_ws($str, $MATCH->to())); if ($m2) { (($MATCH)->{to} = $m2->to());1 } else { 0 } } && (do { (my  $m2 = $grammar->exp($str, $MATCH->to())); if ($m2) { (($MATCH)->{to} = $m2->to());($MATCH->{'exp'} = $m2);1 } else { 0 } } && (do { (my  $m2 = $grammar->opt_ws($str, $MATCH->to())); if ($m2) { (($MATCH)->{to} = $m2->to());1 } else { 0 } } && (((']' eq substr($str, $MATCH->to(), 1)) ? (1 + (($MATCH)->{to} = (1 + $MATCH->to()))) : 0) && (do { ($MATCH->{capture} = (Index->new( 'obj' => ${$MATCH->{'exp_term'}},'index_exp' => ${$MATCH->{'exp'}}, ))) } || 1)))))) } || (do { (($MATCH)->{to} = $pos1); ((('{' eq substr($str, $MATCH->to(), 1)) ? (1 + (($MATCH)->{to} = (1 + $MATCH->to()))) : 0) && (do { (my  $m2 = $grammar->opt_ws($str, $MATCH->to())); if ($m2) { (($MATCH)->{to} = $m2->to());1 } else { 0 } } && (do { (my  $m2 = $grammar->exp($str, $MATCH->to())); if ($m2) { (($MATCH)->{to} = $m2->to());($MATCH->{'exp'} = $m2);1 } else { 0 } } && (do { (my  $m2 = $grammar->opt_ws($str, $MATCH->to())); if ($m2) { (($MATCH)->{to} = $m2->to());1 } else { 0 } } && ((('}' eq substr($str, $MATCH->to(), 1)) ? (1 + (($MATCH)->{to} = (1 + $MATCH->to()))) : 0) && (do { ($MATCH->{capture} = (Lookup->new( 'obj' => ${$MATCH->{'exp_term'}},'index_exp' => ${$MATCH->{'exp'}}, ))) } || 1)))))) } || do { (($MATCH)->{to} = $pos1); (do { ($MATCH->{capture} = (${$MATCH->{'exp_term'}})) } || 1) }))) }) }) }); $MATCH };
sub sub_or_method_name { my $grammar = $_[0]; my $str = $_[1]; my $pos = $_[2]; my  $MATCH; ($MATCH = MiniPerl6::Match->new( 'str' => $str,'from' => $pos,'to' => $pos,'bool' => 1, )); (($MATCH)->{bool} = do { (my  $pos1 = $MATCH->to()); do { (do { (my  $m2 = $grammar->full_ident($str, $MATCH->to())); if ($m2) { (($MATCH)->{to} = $m2->to());($MATCH->{'full_ident'} = $m2);1 } else { 0 } } && do { (my  $pos1 = $MATCH->to()); (do { ((('->' eq substr($str, $MATCH->to(), 2)) ? (1 + (($MATCH)->{to} = (2 + $MATCH->to()))) : 0) && do { (my  $m2 = $grammar->ident($str, $MATCH->to())); if ($m2) { (($MATCH)->{to} = $m2->to());($MATCH->{'ident'} = $m2);1 } else { 0 } }) } || do { (($MATCH)->{to} = $pos1); 1 }) }) } }); $MATCH };
sub opt_type { my $grammar = $_[0]; my $str = $_[1]; my $pos = $_[2]; my  $MATCH; ($MATCH = MiniPerl6::Match->new( 'str' => $str,'from' => $pos,'to' => $pos,'bool' => 1, )); (($MATCH)->{bool} = do { (my  $pos1 = $MATCH->to()); (do { (do { (my  $pos1 = $MATCH->to()); (do { (('::' eq substr($str, $MATCH->to(), 2)) ? (1 + (($MATCH)->{to} = (2 + $MATCH->to()))) : 0) } || do { (($MATCH)->{to} = $pos1); 1 }) } && (do { (my  $m2 = $grammar->full_ident($str, $MATCH->to())); if ($m2) { (($MATCH)->{to} = $m2->to());($MATCH->{'full_ident'} = $m2);1 } else { 0 } } && (do { ($MATCH->{capture} = (${$MATCH->{'full_ident'}})) } || 1))) } || do { (($MATCH)->{to} = $pos1); (1 && (do { ($MATCH->{capture} = ('')) } || 1)) }) }); $MATCH };
sub exp_term { my $grammar = $_[0]; my $str = $_[1]; my $pos = $_[2]; my  $MATCH; ($MATCH = MiniPerl6::Match->new( 'str' => $str,'from' => $pos,'to' => $pos,'bool' => 1, )); (($MATCH)->{bool} = do { (my  $pos1 = $MATCH->to()); (do { (do { (my  $m2 = $grammar->var_ident($str, $MATCH->to())); if ($m2) { (($MATCH)->{to} = $m2->to());($MATCH->{'var_ident'} = $m2);1 } else { 0 } } && (do { ($MATCH->{capture} = (${$MATCH->{'var_ident'}})) } || 1)) } || (do { (($MATCH)->{to} = $pos1); (do { (my  $m2 = $grammar->prefix_op($str, $MATCH->to())); if ($m2) { (($MATCH)->{to} = $m2->to());($MATCH->{'prefix_op'} = $m2);1 } else { 0 } } && (do { (my  $m2 = $grammar->exp($str, $MATCH->to())); if ($m2) { (($MATCH)->{to} = $m2->to());($MATCH->{'exp'} = $m2);1 } else { 0 } } && (do { ($MATCH->{capture} = (Apply->new( 'namespace' => '','code' => 'prefix:<' . $MATCH->{'prefix_op'} . '>','arguments' => [${$MATCH->{'exp'}}], ))) } || 1))) } || (do { (($MATCH)->{to} = $pos1); ((('(' eq substr($str, $MATCH->to(), 1)) ? (1 + (($MATCH)->{to} = (1 + $MATCH->to()))) : 0) && (do { (my  $m2 = $grammar->opt_ws($str, $MATCH->to())); if ($m2) { (($MATCH)->{to} = $m2->to());1 } else { 0 } } && (do { (my  $m2 = $grammar->exp($str, $MATCH->to())); if ($m2) { (($MATCH)->{to} = $m2->to());($MATCH->{'exp'} = $m2);1 } else { 0 } } && (do { (my  $m2 = $grammar->opt_ws($str, $MATCH->to())); if ($m2) { (($MATCH)->{to} = $m2->to());1 } else { 0 } } && (((')' eq substr($str, $MATCH->to(), 1)) ? (1 + (($MATCH)->{to} = (1 + $MATCH->to()))) : 0) && (do { ($MATCH->{capture} = (${$MATCH->{'exp'}})) } || 1)))))) } || (do { (($MATCH)->{to} = $pos1); ((('{' eq substr($str, $MATCH->to(), 1)) ? (1 + (($MATCH)->{to} = (1 + $MATCH->to()))) : 0) && (do { (my  $m2 = $grammar->opt_ws($str, $MATCH->to())); if ($m2) { (($MATCH)->{to} = $m2->to());1 } else { 0 } } && (do { (my  $m2 = $grammar->exp_mapping($str, $MATCH->to())); if ($m2) { (($MATCH)->{to} = $m2->to());($MATCH->{'exp_mapping'} = $m2);1 } else { 0 } } && (do { (my  $m2 = $grammar->opt_ws($str, $MATCH->to())); if ($m2) { (($MATCH)->{to} = $m2->to());1 } else { 0 } } && ((('}' eq substr($str, $MATCH->to(), 1)) ? (1 + (($MATCH)->{to} = (1 + $MATCH->to()))) : 0) && (do { ($MATCH->{capture} = (Lit::Hash->new( 'hash1' => ${$MATCH->{'exp_mapping'}}, ))) } || 1)))))) } || (do { (($MATCH)->{to} = $pos1); ((('[' eq substr($str, $MATCH->to(), 1)) ? (1 + (($MATCH)->{to} = (1 + $MATCH->to()))) : 0) && (do { (my  $m2 = $grammar->opt_ws($str, $MATCH->to())); if ($m2) { (($MATCH)->{to} = $m2->to());1 } else { 0 } } && (do { (my  $m2 = $grammar->exp_seq($str, $MATCH->to())); if ($m2) { (($MATCH)->{to} = $m2->to());($MATCH->{'exp_seq'} = $m2);1 } else { 0 } } && (do { (my  $m2 = $grammar->opt_ws($str, $MATCH->to())); if ($m2) { (($MATCH)->{to} = $m2->to());1 } else { 0 } } && (((']' eq substr($str, $MATCH->to(), 1)) ? (1 + (($MATCH)->{to} = (1 + $MATCH->to()))) : 0) && (do { ($MATCH->{capture} = (Lit::Array->new( 'array1' => ${$MATCH->{'exp_seq'}}, ))) } || 1)))))) } || (do { (($MATCH)->{to} = $pos1); ((('$' eq substr($str, $MATCH->to(), 1)) ? (1 + (($MATCH)->{to} = (1 + $MATCH->to()))) : 0) && ((('<' eq substr($str, $MATCH->to(), 1)) ? (1 + (($MATCH)->{to} = (1 + $MATCH->to()))) : 0) && (do { (my  $m2 = $grammar->sub_or_method_name($str, $MATCH->to())); if ($m2) { (($MATCH)->{to} = $m2->to());($MATCH->{'sub_or_method_name'} = $m2);1 } else { 0 } } && ((('>' eq substr($str, $MATCH->to(), 1)) ? (1 + (($MATCH)->{to} = (1 + $MATCH->to()))) : 0) && (do { ($MATCH->{capture} = (Lookup->new( 'obj' => Var->new( 'sigil' => '$','twigil' => '','name' => '/', ),'index_exp' => Val::Buf->new( 'buf' => ${$MATCH->{'sub_or_method_name'}}, ), ))) } || 1))))) } || (do { (($MATCH)->{to} = $pos1); ((('d' eq substr($str, $MATCH->to(), 1)) ? (1 + (($MATCH)->{to} = (1 + $MATCH->to()))) : 0) && ((('o' eq substr($str, $MATCH->to(), 1)) ? (1 + (($MATCH)->{to} = (1 + $MATCH->to()))) : 0) && (do { (my  $m2 = $grammar->opt_ws($str, $MATCH->to())); if ($m2) { (($MATCH)->{to} = $m2->to());1 } else { 0 } } && ((('{' eq substr($str, $MATCH->to(), 1)) ? (1 + (($MATCH)->{to} = (1 + $MATCH->to()))) : 0) && (do { (my  $m2 = $grammar->opt_ws($str, $MATCH->to())); if ($m2) { (($MATCH)->{to} = $m2->to());1 } else { 0 } } && (do { (my  $m2 = $grammar->exp_stmts($str, $MATCH->to())); if ($m2) { (($MATCH)->{to} = $m2->to());($MATCH->{'exp_stmts'} = $m2);1 } else { 0 } } && (do { (my  $m2 = $grammar->opt_ws($str, $MATCH->to())); if ($m2) { (($MATCH)->{to} = $m2->to());1 } else { 0 } } && ((('}' eq substr($str, $MATCH->to(), 1)) ? (1 + (($MATCH)->{to} = (1 + $MATCH->to()))) : 0) && (do { ($MATCH->{capture} = (Do->new( 'block' => ${$MATCH->{'exp_stmts'}}, ))) } || 1))))))))) } || (do { (($MATCH)->{to} = $pos1); (do { (my  $m2 = $grammar->declarator($str, $MATCH->to())); if ($m2) { (($MATCH)->{to} = $m2->to());($MATCH->{'declarator'} = $m2);1 } else { 0 } } && (do { (my  $m2 = $grammar->ws($str, $MATCH->to())); if ($m2) { (($MATCH)->{to} = $m2->to());1 } else { 0 } } && (do { (my  $m2 = $grammar->opt_type($str, $MATCH->to())); if ($m2) { (($MATCH)->{to} = $m2->to());($MATCH->{'opt_type'} = $m2);1 } else { 0 } } && (do { (my  $m2 = $grammar->opt_ws($str, $MATCH->to())); if ($m2) { (($MATCH)->{to} = $m2->to());1 } else { 0 } } && (do { (my  $m2 = $grammar->var_ident($str, $MATCH->to())); if ($m2) { (($MATCH)->{to} = $m2->to());($MATCH->{'var_ident'} = $m2);1 } else { 0 } } && (do { ($MATCH->{capture} = (Decl->new( 'decl' => ${$MATCH->{'declarator'}},'type' => ${$MATCH->{'opt_type'}},'var' => ${$MATCH->{'var_ident'}}, ))) } || 1)))))) } || (do { (($MATCH)->{to} = $pos1); ((('u' eq substr($str, $MATCH->to(), 1)) ? (1 + (($MATCH)->{to} = (1 + $MATCH->to()))) : 0) && ((('s' eq substr($str, $MATCH->to(), 1)) ? (1 + (($MATCH)->{to} = (1 + $MATCH->to()))) : 0) && ((('e' eq substr($str, $MATCH->to(), 1)) ? (1 + (($MATCH)->{to} = (1 + $MATCH->to()))) : 0) && (do { (my  $m2 = $grammar->ws($str, $MATCH->to())); if ($m2) { (($MATCH)->{to} = $m2->to());1 } else { 0 } } && (do { (my  $m2 = $grammar->full_ident($str, $MATCH->to())); if ($m2) { (($MATCH)->{to} = $m2->to());($MATCH->{'full_ident'} = $m2);1 } else { 0 } } && (do { (my  $pos1 = $MATCH->to()); (do { ((('-' eq substr($str, $MATCH->to(), 1)) ? (1 + (($MATCH)->{to} = (1 + $MATCH->to()))) : 0) && do { (my  $m2 = $grammar->ident($str, $MATCH->to())); if ($m2) { (($MATCH)->{to} = $m2->to());($MATCH->{'ident'} = $m2);1 } else { 0 } }) } || do { (($MATCH)->{to} = $pos1); 1 }) } && (do { ($MATCH->{capture} = (Use->new( 'mod' => ${$MATCH->{'full_ident'}}, ))) } || 1))))))) } || (do { (($MATCH)->{to} = $pos1); (do { (my  $m2 = $grammar->val($str, $MATCH->to())); if ($m2) { (($MATCH)->{to} = $m2->to());($MATCH->{'val'} = $m2);1 } else { 0 } } && (do { ($MATCH->{capture} = (${$MATCH->{'val'}})) } || 1)) } || (do { (($MATCH)->{to} = $pos1); (do { (my  $m2 = $grammar->lit($str, $MATCH->to())); if ($m2) { (($MATCH)->{to} = $m2->to());($MATCH->{'lit'} = $m2);1 } else { 0 } } && (do { ($MATCH->{capture} = (${$MATCH->{'lit'}})) } || 1)) } || (do { (($MATCH)->{to} = $pos1); (do { (my  $m2 = $grammar->token($str, $MATCH->to())); if ($m2) { (($MATCH)->{to} = $m2->to());($MATCH->{'token'} = $m2);1 } else { 0 } } && (do { ($MATCH->{capture} = (${$MATCH->{'token'}})) } || 1)) } || (do { (($MATCH)->{to} = $pos1); (do { (my  $m2 = $grammar->method_def($str, $MATCH->to())); if ($m2) { (($MATCH)->{to} = $m2->to());($MATCH->{'method_def'} = $m2);1 } else { 0 } } && (do { ($MATCH->{capture} = (${$MATCH->{'method_def'}})) } || 1)) } || (do { (($MATCH)->{to} = $pos1); (do { (my  $m2 = $grammar->sub_def($str, $MATCH->to())); if ($m2) { (($MATCH)->{to} = $m2->to());($MATCH->{'sub_def'} = $m2);1 } else { 0 } } && (do { ($MATCH->{capture} = (${$MATCH->{'sub_def'}})) } || 1)) } || (do { (($MATCH)->{to} = $pos1); (do { (my  $m2 = $grammar->control($str, $MATCH->to())); if ($m2) { (($MATCH)->{to} = $m2->to());($MATCH->{'control'} = $m2);1 } else { 0 } } && (do { ($MATCH->{capture} = (${$MATCH->{'control'}})) } || 1)) } || do { (($MATCH)->{to} = $pos1); (do { (my  $m2 = $grammar->apply($str, $MATCH->to())); if ($m2) { (($MATCH)->{to} = $m2->to());($MATCH->{'apply'} = $m2);1 } else { 0 } } && (do { ($MATCH->{capture} = (${$MATCH->{'apply'}})) } || 1)) }))))))))))))))) }); $MATCH };
sub var_sigil { my $grammar = $_[0]; my $str = $_[1]; my $pos = $_[2]; my  $MATCH; ($MATCH = MiniPerl6::Match->new( 'str' => $str,'from' => $pos,'to' => $pos,'bool' => 1, )); (($MATCH)->{bool} = do { (my  $pos1 = $MATCH->to()); (do { (('$' eq substr($str, $MATCH->to(), 1)) ? (1 + (($MATCH)->{to} = (1 + $MATCH->to()))) : 0) } || (do { (($MATCH)->{to} = $pos1); (('%' eq substr($str, $MATCH->to(), 1)) ? (1 + (($MATCH)->{to} = (1 + $MATCH->to()))) : 0) } || (do { (($MATCH)->{to} = $pos1); (('@' eq substr($str, $MATCH->to(), 1)) ? (1 + (($MATCH)->{to} = (1 + $MATCH->to()))) : 0) } || do { (($MATCH)->{to} = $pos1); (('&' eq substr($str, $MATCH->to(), 1)) ? (1 + (($MATCH)->{to} = (1 + $MATCH->to()))) : 0) }))) }); $MATCH };
sub var_name { my $grammar = $_[0]; my $str = $_[1]; my $pos = $_[2]; my  $MATCH; ($MATCH = MiniPerl6::Match->new( 'str' => $str,'from' => $pos,'to' => $pos,'bool' => 1, )); (($MATCH)->{bool} = do { (my  $pos1 = $MATCH->to()); (do { do { (my  $m2 = $grammar->full_ident($str, $MATCH->to())); if ($m2) { (($MATCH)->{to} = $m2->to());($MATCH->{'full_ident'} = $m2);1 } else { 0 } } } || (do { (($MATCH)->{to} = $pos1); (('/' eq substr($str, $MATCH->to(), 1)) ? (1 + (($MATCH)->{to} = (1 + $MATCH->to()))) : 0) } || do { (($MATCH)->{to} = $pos1); do { (my  $m2 = $grammar->digit($str, $MATCH->to())); if ($m2) { (($MATCH)->{to} = $m2->to());($MATCH->{'digit'} = $m2);1 } else { 0 } } })) }); $MATCH };
sub var_ident { my $grammar = $_[0]; my $str = $_[1]; my $pos = $_[2]; my  $MATCH; ($MATCH = MiniPerl6::Match->new( 'str' => $str,'from' => $pos,'to' => $pos,'bool' => 1, )); (($MATCH)->{bool} = do { (my  $pos1 = $MATCH->to()); do { (do { (my  $m2 = $grammar->var_sigil($str, $MATCH->to())); if ($m2) { (($MATCH)->{to} = $m2->to());($MATCH->{'var_sigil'} = $m2);1 } else { 0 } } && (do { (my  $m2 = $grammar->optional_namespace_before_ident($str, $MATCH->to())); if ($m2) { (($MATCH)->{to} = $m2->to());($MATCH->{'optional_namespace_before_ident'} = $m2);1 } else { 0 } } && (do { (my  $m2 = $grammar->var_name($str, $MATCH->to())); if ($m2) { (($MATCH)->{to} = $m2->to());($MATCH->{'var_name'} = $m2);1 } else { 0 } } && (do { ($MATCH->{capture} = (Var->new( 'sigil' => ("" . $MATCH->{'var_sigil'}),'twigil' => '','namespace' => ${$MATCH->{'optional_namespace_before_ident'}},'name' => ("" . $MATCH->{'var_name'}), ))) } || 1)))) } }); $MATCH };
sub val { my $grammar = $_[0]; my $str = $_[1]; my $pos = $_[2]; my  $MATCH; ($MATCH = MiniPerl6::Match->new( 'str' => $str,'from' => $pos,'to' => $pos,'bool' => 1, )); (($MATCH)->{bool} = do { (my  $pos1 = $MATCH->to()); (do { (do { (my  $m2 = $grammar->val_undef($str, $MATCH->to())); if ($m2) { (($MATCH)->{to} = $m2->to());($MATCH->{'val_undef'} = $m2);1 } else { 0 } } && (do { ($MATCH->{capture} = (${$MATCH->{'val_undef'}})) } || 1)) } || (do { (($MATCH)->{to} = $pos1); (do { (my  $m2 = $grammar->val_int($str, $MATCH->to())); if ($m2) { (($MATCH)->{to} = $m2->to());($MATCH->{'val_int'} = $m2);1 } else { 0 } } && (do { ($MATCH->{capture} = (${$MATCH->{'val_int'}})) } || 1)) } || (do { (($MATCH)->{to} = $pos1); (do { (my  $m2 = $grammar->val_num($str, $MATCH->to())); if ($m2) { (($MATCH)->{to} = $m2->to());($MATCH->{'val_num'} = $m2);1 } else { 0 } } && (do { ($MATCH->{capture} = (${$MATCH->{'val_num'}})) } || 1)) } || do { (($MATCH)->{to} = $pos1); (do { (my  $m2 = $grammar->val_buf($str, $MATCH->to())); if ($m2) { (($MATCH)->{to} = $m2->to());($MATCH->{'val_buf'} = $m2);1 } else { 0 } } && (do { ($MATCH->{capture} = (${$MATCH->{'val_buf'}})) } || 1)) }))) }); $MATCH };
sub val_undef { my $grammar = $_[0]; my $str = $_[1]; my $pos = $_[2]; my  $MATCH; ($MATCH = MiniPerl6::Match->new( 'str' => $str,'from' => $pos,'to' => $pos,'bool' => 1, )); (($MATCH)->{bool} = do { (my  $pos1 = $MATCH->to()); do { ((('u' eq substr($str, $MATCH->to(), 1)) ? (1 + (($MATCH)->{to} = (1 + $MATCH->to()))) : 0) && ((('n' eq substr($str, $MATCH->to(), 1)) ? (1 + (($MATCH)->{to} = (1 + $MATCH->to()))) : 0) && ((('d' eq substr($str, $MATCH->to(), 1)) ? (1 + (($MATCH)->{to} = (1 + $MATCH->to()))) : 0) && ((('e' eq substr($str, $MATCH->to(), 1)) ? (1 + (($MATCH)->{to} = (1 + $MATCH->to()))) : 0) && ((('f' eq substr($str, $MATCH->to(), 1)) ? (1 + (($MATCH)->{to} = (1 + $MATCH->to()))) : 0) && (do { (my  $tmp = $MATCH); ($MATCH = MiniPerl6::Match->new( 'str' => $str,'from' => $tmp->to(),'to' => $tmp->to(),'bool' => 1, )); (($MATCH)->{bool} = do { (my  $pos1 = $MATCH->to()); do { (('w' eq substr($str, $MATCH->to(), 1)) ? (1 + (($MATCH)->{to} = (1 + $MATCH->to()))) : 0) } }); (($tmp)->{bool} = ($MATCH ? 0 : 1)); ($MATCH = $tmp); ($MATCH ? 1 : 0) } && (do { ($MATCH->{capture} = (Val::Undef->new(  ))) } || 1))))))) } }); $MATCH };
sub val_num { my $grammar = $_[0]; my $str = $_[1]; my $pos = $_[2]; my  $MATCH; ($MATCH = MiniPerl6::Match->new( 'str' => $str,'from' => $pos,'to' => $pos,'bool' => 1, )); (($MATCH)->{bool} = do { (my  $pos1 = $MATCH->to()); do { ((('X' eq substr($str, $MATCH->to(), 1)) ? (1 + (($MATCH)->{to} = (1 + $MATCH->to()))) : 0) && ((('X' eq substr($str, $MATCH->to(), 1)) ? (1 + (($MATCH)->{to} = (1 + $MATCH->to()))) : 0) && ((('X' eq substr($str, $MATCH->to(), 1)) ? (1 + (($MATCH)->{to} = (1 + $MATCH->to()))) : 0) && (do { ($MATCH->{capture} = ('TODO: val_num')) } || 1)))) } }); $MATCH };
sub char_any { my $grammar = $_[0]; my $str = $_[1]; my $pos = $_[2]; my  $MATCH; ($MATCH = MiniPerl6::Match->new( 'str' => $str,'from' => $pos,'to' => $pos,'bool' => 1, )); (($MATCH)->{bool} = do { (my  $pos1 = $MATCH->to()); do { (('' ne substr($str, $MATCH->to(), 1)) ? (1 + (($MATCH)->{to} = (1 + $MATCH->to()))) : 0) } }); $MATCH };
sub single_quoted_unescape { my $grammar = $_[0]; my $str = $_[1]; my $pos = $_[2]; my  $MATCH; ($MATCH = MiniPerl6::Match->new( 'str' => $str,'from' => $pos,'to' => $pos,'bool' => 1, )); (($MATCH)->{bool} = do { (my  $pos1 = $MATCH->to()); (do { ((('\\' eq substr($str, $MATCH->to(), 1)) ? (1 + (($MATCH)->{to} = (1 + $MATCH->to()))) : 0) && ((('\'' eq substr($str, $MATCH->to(), 1)) ? (1 + (($MATCH)->{to} = (1 + $MATCH->to()))) : 0) && (do { (my  $m2 = $grammar->single_quoted_unescape($str, $MATCH->to())); if ($m2) { (($MATCH)->{to} = $m2->to());($MATCH->{'single_quoted_unescape'} = $m2);1 } else { 0 } } && (do { ($MATCH->{capture} = ('\'' . $MATCH->{'single_quoted_unescape'})) } || 1)))) } || (do { (($MATCH)->{to} = $pos1); ((('\\' eq substr($str, $MATCH->to(), 1)) ? (1 + (($MATCH)->{to} = (1 + $MATCH->to()))) : 0) && ((('"' eq substr($str, $MATCH->to(), 1)) ? (1 + (($MATCH)->{to} = (1 + $MATCH->to()))) : 0) && (do { (my  $m2 = $grammar->single_quoted_unescape($str, $MATCH->to())); if ($m2) { (($MATCH)->{to} = $m2->to());($MATCH->{'single_quoted_unescape'} = $m2);1 } else { 0 } } && (do { ($MATCH->{capture} = ('"' . $MATCH->{'single_quoted_unescape'})) } || 1)))) } || (do { (($MATCH)->{to} = $pos1); ((('\\' eq substr($str, $MATCH->to(), 1)) ? (1 + (($MATCH)->{to} = (1 + $MATCH->to()))) : 0) && ((('\\' eq substr($str, $MATCH->to(), 1)) ? (1 + (($MATCH)->{to} = (1 + $MATCH->to()))) : 0) && (do { (my  $m2 = $grammar->single_quoted_unescape($str, $MATCH->to())); if ($m2) { (($MATCH)->{to} = $m2->to());($MATCH->{'single_quoted_unescape'} = $m2);1 } else { 0 } } && (do { ($MATCH->{capture} = ('\\' . $MATCH->{'single_quoted_unescape'})) } || 1)))) } || (do { (($MATCH)->{to} = $pos1); (do { (my  $tmp = $MATCH); ($MATCH = MiniPerl6::Match->new( 'str' => $str,'from' => $tmp->to(),'to' => $tmp->to(),'bool' => 1, )); (($MATCH)->{bool} = do { (my  $pos1 = $MATCH->to()); do { (('\'' eq substr($str, $MATCH->to(), 1)) ? (1 + (($MATCH)->{to} = (1 + $MATCH->to()))) : 0) } }); (($tmp)->{bool} = ($MATCH ? 0 : 1)); ($MATCH = $tmp); ($MATCH ? 1 : 0) } && (do { (my  $m2 = $grammar->char_any($str, $MATCH->to())); if ($m2) { (($MATCH)->{to} = $m2->to());($MATCH->{'char_any'} = $m2);1 } else { 0 } } && (do { (my  $m2 = $grammar->single_quoted_unescape($str, $MATCH->to())); if ($m2) { (($MATCH)->{to} = $m2->to());($MATCH->{'single_quoted_unescape'} = $m2);1 } else { 0 } } && (do { ($MATCH->{capture} = ($MATCH->{'char_any'} . $MATCH->{'single_quoted_unescape'})) } || 1)))) } || do { (($MATCH)->{to} = $pos1); 1 })))) }); $MATCH };
sub double_quoted_unescape { my $grammar = $_[0]; my $str = $_[1]; my $pos = $_[2]; my  $MATCH; ($MATCH = MiniPerl6::Match->new( 'str' => $str,'from' => $pos,'to' => $pos,'bool' => 1, )); (($MATCH)->{bool} = do { (my  $pos1 = $MATCH->to()); (do { ((('\\' eq substr($str, $MATCH->to(), 1)) ? (1 + (($MATCH)->{to} = (1 + $MATCH->to()))) : 0) && ((('\'' eq substr($str, $MATCH->to(), 1)) ? (1 + (($MATCH)->{to} = (1 + $MATCH->to()))) : 0) && (do { (my  $m2 = $grammar->double_quoted_unescape($str, $MATCH->to())); if ($m2) { (($MATCH)->{to} = $m2->to());($MATCH->{'double_quoted_unescape'} = $m2);1 } else { 0 } } && (do { ($MATCH->{capture} = ('\'' . $MATCH->{'double_quoted_unescape'})) } || 1)))) } || (do { (($MATCH)->{to} = $pos1); ((('\\' eq substr($str, $MATCH->to(), 1)) ? (1 + (($MATCH)->{to} = (1 + $MATCH->to()))) : 0) && ((('"' eq substr($str, $MATCH->to(), 1)) ? (1 + (($MATCH)->{to} = (1 + $MATCH->to()))) : 0) && (do { (my  $m2 = $grammar->double_quoted_unescape($str, $MATCH->to())); if ($m2) { (($MATCH)->{to} = $m2->to());($MATCH->{'double_quoted_unescape'} = $m2);1 } else { 0 } } && (do { ($MATCH->{capture} = ('"' . $MATCH->{'double_quoted_unescape'})) } || 1)))) } || (do { (($MATCH)->{to} = $pos1); ((('\\' eq substr($str, $MATCH->to(), 1)) ? (1 + (($MATCH)->{to} = (1 + $MATCH->to()))) : 0) && ((('\\' eq substr($str, $MATCH->to(), 1)) ? (1 + (($MATCH)->{to} = (1 + $MATCH->to()))) : 0) && (do { (my  $m2 = $grammar->double_quoted_unescape($str, $MATCH->to())); if ($m2) { (($MATCH)->{to} = $m2->to());($MATCH->{'double_quoted_unescape'} = $m2);1 } else { 0 } } && (do { ($MATCH->{capture} = ('\\' . $MATCH->{'double_quoted_unescape'})) } || 1)))) } || (do { (($MATCH)->{to} = $pos1); ((('\\' eq substr($str, $MATCH->to(), 1)) ? (1 + (($MATCH)->{to} = (1 + $MATCH->to()))) : 0) && ((('n' eq substr($str, $MATCH->to(), 1)) ? (1 + (($MATCH)->{to} = (1 + $MATCH->to()))) : 0) && (do { (my  $m2 = $grammar->double_quoted_unescape($str, $MATCH->to())); if ($m2) { (($MATCH)->{to} = $m2->to());($MATCH->{'double_quoted_unescape'} = $m2);1 } else { 0 } } && (do { ($MATCH->{capture} = (Main->newline() . $MATCH->{'double_quoted_unescape'})) } || 1)))) } || (do { (($MATCH)->{to} = $pos1); (do { (my  $tmp = $MATCH); ($MATCH = MiniPerl6::Match->new( 'str' => $str,'from' => $tmp->to(),'to' => $tmp->to(),'bool' => 1, )); (($MATCH)->{bool} = do { (my  $pos1 = $MATCH->to()); do { (('"' eq substr($str, $MATCH->to(), 1)) ? (1 + (($MATCH)->{to} = (1 + $MATCH->to()))) : 0) } }); (($tmp)->{bool} = ($MATCH ? 0 : 1)); ($MATCH = $tmp); ($MATCH ? 1 : 0) } && (do { (my  $m2 = $grammar->char_any($str, $MATCH->to())); if ($m2) { (($MATCH)->{to} = $m2->to());($MATCH->{'char_any'} = $m2);1 } else { 0 } } && (do { (my  $m2 = $grammar->double_quoted_unescape($str, $MATCH->to())); if ($m2) { (($MATCH)->{to} = $m2->to());($MATCH->{'double_quoted_unescape'} = $m2);1 } else { 0 } } && (do { ($MATCH->{capture} = ($MATCH->{'char_any'} . $MATCH->{'double_quoted_unescape'})) } || 1)))) } || do { (($MATCH)->{to} = $pos1); 1 }))))) }); $MATCH };
sub val_buf { my $grammar = $_[0]; my $str = $_[1]; my $pos = $_[2]; my  $MATCH; ($MATCH = MiniPerl6::Match->new( 'str' => $str,'from' => $pos,'to' => $pos,'bool' => 1, )); (($MATCH)->{bool} = do { (my  $pos1 = $MATCH->to()); (do { ((('"' eq substr($str, $MATCH->to(), 1)) ? (1 + (($MATCH)->{to} = (1 + $MATCH->to()))) : 0) && (do { (my  $m2 = $grammar->double_quoted_unescape($str, $MATCH->to())); if ($m2) { (($MATCH)->{to} = $m2->to());($MATCH->{'double_quoted_unescape'} = $m2);1 } else { 0 } } && ((('"' eq substr($str, $MATCH->to(), 1)) ? (1 + (($MATCH)->{to} = (1 + $MATCH->to()))) : 0) && (do { ($MATCH->{capture} = (Val::Buf->new( 'buf' => ${$MATCH->{'double_quoted_unescape'}}, ))) } || 1)))) } || do { (($MATCH)->{to} = $pos1); ((('\'' eq substr($str, $MATCH->to(), 1)) ? (1 + (($MATCH)->{to} = (1 + $MATCH->to()))) : 0) && (do { (my  $m2 = $grammar->single_quoted_unescape($str, $MATCH->to())); if ($m2) { (($MATCH)->{to} = $m2->to());($MATCH->{'single_quoted_unescape'} = $m2);1 } else { 0 } } && ((('\'' eq substr($str, $MATCH->to(), 1)) ? (1 + (($MATCH)->{to} = (1 + $MATCH->to()))) : 0) && (do { ($MATCH->{capture} = (Val::Buf->new( 'buf' => ${$MATCH->{'single_quoted_unescape'}}, ))) } || 1)))) }) }); $MATCH };
sub digits { my $grammar = $_[0]; my $str = $_[1]; my $pos = $_[2]; my  $MATCH; ($MATCH = MiniPerl6::Match->new( 'str' => $str,'from' => $pos,'to' => $pos,'bool' => 1, )); (($MATCH)->{bool} = do { (my  $pos1 = $MATCH->to()); do { (do { (my  $m2 = $grammar->digit($str, $MATCH->to())); if ($m2) { (($MATCH)->{to} = $m2->to());1 } else { 0 } } && do { (my  $pos1 = $MATCH->to()); (do { do { (my  $m2 = $grammar->digits($str, $MATCH->to())); if ($m2) { (($MATCH)->{to} = $m2->to());($MATCH->{'digits'} = $m2);1 } else { 0 } } } || do { (($MATCH)->{to} = $pos1); 1 }) }) } }); $MATCH };
sub val_int { my $grammar = $_[0]; my $str = $_[1]; my $pos = $_[2]; my  $MATCH; ($MATCH = MiniPerl6::Match->new( 'str' => $str,'from' => $pos,'to' => $pos,'bool' => 1, )); (($MATCH)->{bool} = do { (my  $pos1 = $MATCH->to()); do { (do { (my  $m2 = $grammar->digits($str, $MATCH->to())); if ($m2) { (($MATCH)->{to} = $m2->to());($MATCH->{'digits'} = $m2);1 } else { 0 } } && (do { ($MATCH->{capture} = (Val::Int->new( 'int' => ("" . $MATCH), ))) } || 1)) } }); $MATCH };
sub exp_stmts { my $grammar = $_[0]; my $str = $_[1]; my $pos = $_[2]; my  $MATCH; ($MATCH = MiniPerl6::Match->new( 'str' => $str,'from' => $pos,'to' => $pos,'bool' => 1, )); (($MATCH)->{bool} = do { (my  $pos1 = $MATCH->to()); (do { (do { (my  $m2 = $grammar->exp($str, $MATCH->to())); if ($m2) { (($MATCH)->{to} = $m2->to());($MATCH->{'exp'} = $m2);1 } else { 0 } } && do { (my  $pos1 = $MATCH->to()); (do { (do { (my  $m2 = $grammar->opt_ws($str, $MATCH->to())); if ($m2) { (($MATCH)->{to} = $m2->to());1 } else { 0 } } && (do { (my  $pos1 = $MATCH->to()); (do { ((';' eq substr($str, $MATCH->to(), 1)) ? (1 + (($MATCH)->{to} = (1 + $MATCH->to()))) : 0) } || do { (($MATCH)->{to} = $pos1); 1 }) } && (do { (my  $m2 = $grammar->opt_ws($str, $MATCH->to())); if ($m2) { (($MATCH)->{to} = $m2->to());1 } else { 0 } } && (do { (my  $m2 = $grammar->exp_stmts($str, $MATCH->to())); if ($m2) { (($MATCH)->{to} = $m2->to());($MATCH->{'exp_stmts'} = $m2);1 } else { 0 } } && (do { (my  $m2 = $grammar->opt_ws($str, $MATCH->to())); if ($m2) { (($MATCH)->{to} = $m2->to());1 } else { 0 } } && (do { (my  $pos1 = $MATCH->to()); (do { (((';' eq substr($str, $MATCH->to(), 1)) ? (1 + (($MATCH)->{to} = (1 + $MATCH->to()))) : 0) && do { (my  $m2 = $grammar->opt_ws($str, $MATCH->to())); if ($m2) { (($MATCH)->{to} = $m2->to());1 } else { 0 } }) } || do { (($MATCH)->{to} = $pos1); 1 }) } && (do { ($MATCH->{capture} = ([${$MATCH->{'exp'}}, @{${$MATCH->{'exp_stmts'}}}])) } || 1))))))) } || do { (($MATCH)->{to} = $pos1); (do { (my  $m2 = $grammar->opt_ws($str, $MATCH->to())); if ($m2) { (($MATCH)->{to} = $m2->to());1 } else { 0 } } && (do { (my  $pos1 = $MATCH->to()); (do { (((';' eq substr($str, $MATCH->to(), 1)) ? (1 + (($MATCH)->{to} = (1 + $MATCH->to()))) : 0) && do { (my  $m2 = $grammar->opt_ws($str, $MATCH->to())); if ($m2) { (($MATCH)->{to} = $m2->to());1 } else { 0 } }) } || do { (($MATCH)->{to} = $pos1); 1 }) } && (do { ($MATCH->{capture} = ([${$MATCH->{'exp'}}])) } || 1))) }) }) } || do { (($MATCH)->{to} = $pos1); (do { ($MATCH->{capture} = ([])) } || 1) }) }); $MATCH };
sub exp_seq { my $grammar = $_[0]; my $str = $_[1]; my $pos = $_[2]; my  $MATCH; ($MATCH = MiniPerl6::Match->new( 'str' => $str,'from' => $pos,'to' => $pos,'bool' => 1, )); (($MATCH)->{bool} = do { (my  $pos1 = $MATCH->to()); (do { (do { (my  $m2 = $grammar->exp($str, $MATCH->to())); if ($m2) { (($MATCH)->{to} = $m2->to());($MATCH->{'exp'} = $m2);1 } else { 0 } } && do { (my  $pos1 = $MATCH->to()); (do { (do { (my  $m2 = $grammar->opt_ws($str, $MATCH->to())); if ($m2) { (($MATCH)->{to} = $m2->to());1 } else { 0 } } && (((',' eq substr($str, $MATCH->to(), 1)) ? (1 + (($MATCH)->{to} = (1 + $MATCH->to()))) : 0) && (do { (my  $m2 = $grammar->opt_ws($str, $MATCH->to())); if ($m2) { (($MATCH)->{to} = $m2->to());1 } else { 0 } } && (do { (my  $m2 = $grammar->exp_seq($str, $MATCH->to())); if ($m2) { (($MATCH)->{to} = $m2->to());($MATCH->{'exp_seq'} = $m2);1 } else { 0 } } && (do { (my  $m2 = $grammar->opt_ws($str, $MATCH->to())); if ($m2) { (($MATCH)->{to} = $m2->to());1 } else { 0 } } && (do { (my  $pos1 = $MATCH->to()); (do { (((',' eq substr($str, $MATCH->to(), 1)) ? (1 + (($MATCH)->{to} = (1 + $MATCH->to()))) : 0) && do { (my  $m2 = $grammar->opt_ws($str, $MATCH->to())); if ($m2) { (($MATCH)->{to} = $m2->to());1 } else { 0 } }) } || do { (($MATCH)->{to} = $pos1); 1 }) } && (do { ($MATCH->{capture} = ([${$MATCH->{'exp'}}, @{${$MATCH->{'exp_seq'}}}])) } || 1))))))) } || do { (($MATCH)->{to} = $pos1); (do { (my  $m2 = $grammar->opt_ws($str, $MATCH->to())); if ($m2) { (($MATCH)->{to} = $m2->to());1 } else { 0 } } && (do { (my  $pos1 = $MATCH->to()); (do { (((',' eq substr($str, $MATCH->to(), 1)) ? (1 + (($MATCH)->{to} = (1 + $MATCH->to()))) : 0) && do { (my  $m2 = $grammar->opt_ws($str, $MATCH->to())); if ($m2) { (($MATCH)->{to} = $m2->to());1 } else { 0 } }) } || do { (($MATCH)->{to} = $pos1); 1 }) } && (do { ($MATCH->{capture} = ([${$MATCH->{'exp'}}])) } || 1))) }) }) } || do { (($MATCH)->{to} = $pos1); (do { ($MATCH->{capture} = ([])) } || 1) }) }); $MATCH };
sub lit { my $grammar = $_[0]; my $str = $_[1]; my $pos = $_[2]; my  $MATCH; ($MATCH = MiniPerl6::Match->new( 'str' => $str,'from' => $pos,'to' => $pos,'bool' => 1, )); (($MATCH)->{bool} = do { (my  $pos1 = $MATCH->to()); do { (do { (my  $m2 = $grammar->lit_object($str, $MATCH->to())); if ($m2) { (($MATCH)->{to} = $m2->to());($MATCH->{'lit_object'} = $m2);1 } else { 0 } } && (do { ($MATCH->{capture} = (${$MATCH->{'lit_object'}})) } || 1)) } }); $MATCH };
sub lit_object { my $grammar = $_[0]; my $str = $_[1]; my $pos = $_[2]; my  $MATCH; ($MATCH = MiniPerl6::Match->new( 'str' => $str,'from' => $pos,'to' => $pos,'bool' => 1, )); (($MATCH)->{bool} = do { (my  $pos1 = $MATCH->to()); do { ((('::' eq substr($str, $MATCH->to(), 2)) ? (1 + (($MATCH)->{to} = (2 + $MATCH->to()))) : 0) && (do { (my  $m2 = $grammar->full_ident($str, $MATCH->to())); if ($m2) { (($MATCH)->{to} = $m2->to());($MATCH->{'full_ident'} = $m2);1 } else { 0 } } && ((('(' eq substr($str, $MATCH->to(), 1)) ? (1 + (($MATCH)->{to} = (1 + $MATCH->to()))) : 0) && do { (my  $pos1 = $MATCH->to()); (do { (do { (my  $m2 = $grammar->opt_ws($str, $MATCH->to())); if ($m2) { (($MATCH)->{to} = $m2->to());1 } else { 0 } } && (do { (my  $m2 = $grammar->exp_mapping($str, $MATCH->to())); if ($m2) { (($MATCH)->{to} = $m2->to());($MATCH->{'exp_mapping'} = $m2);1 } else { 0 } } && (do { (my  $m2 = $grammar->opt_ws($str, $MATCH->to())); if ($m2) { (($MATCH)->{to} = $m2->to());1 } else { 0 } } && (((')' eq substr($str, $MATCH->to(), 1)) ? (1 + (($MATCH)->{to} = (1 + $MATCH->to()))) : 0) && (do { ($MATCH->{capture} = (Lit::Object->new( 'class' => ${$MATCH->{'full_ident'}},'fields' => ${$MATCH->{'exp_mapping'}}, ))) } || 1))))) } || do { (($MATCH)->{to} = $pos1); (do { Main::say('*** Syntax Error parsing Constructor'); die() } || 1) }) }))) } }); $MATCH };
sub bind { my $grammar = $_[0]; my $str = $_[1]; my $pos = $_[2]; my  $MATCH; ($MATCH = MiniPerl6::Match->new( 'str' => $str,'from' => $pos,'to' => $pos,'bool' => 1, )); (($MATCH)->{bool} = do { (my  $pos1 = $MATCH->to()); do { (do { (my  $m2 = $grammar->exp($str, $MATCH->to())); if ($m2) { (($MATCH)->{to} = $m2->to());($MATCH->{'exp'} = $m2);1 } else { 0 } } && (do { (my  $m2 = $grammar->opt_ws($str, $MATCH->to())); if ($m2) { (($MATCH)->{to} = $m2->to());1 } else { 0 } } && ((('=' eq substr($str, $MATCH->to(), 1)) ? (1 + (($MATCH)->{to} = (1 + $MATCH->to()))) : 0) && (do { (my  $m2 = $grammar->opt_ws($str, $MATCH->to())); if ($m2) { (($MATCH)->{to} = $m2->to());1 } else { 0 } } && (do { (my  $m2 = $grammar->exp2($str, $MATCH->to())); if ($m2) { (($MATCH)->{to} = $m2->to());($MATCH->{'exp2'} = $m2);1 } else { 0 } } && (do { ($MATCH->{capture} = (Bind->new( 'parameters' => ${$MATCH->{'exp'}},'arguments' => ${$MATCH->{'exp2'}}, ))) } || 1)))))) } }); $MATCH };
sub call { my $grammar = $_[0]; my $str = $_[1]; my $pos = $_[2]; my  $MATCH; ($MATCH = MiniPerl6::Match->new( 'str' => $str,'from' => $pos,'to' => $pos,'bool' => 1, )); (($MATCH)->{bool} = do { (my  $pos1 = $MATCH->to()); do { (do { (my  $m2 = $grammar->exp($str, $MATCH->to())); if ($m2) { (($MATCH)->{to} = $m2->to());($MATCH->{'exp'} = $m2);1 } else { 0 } } && ((('->' eq substr($str, $MATCH->to(), 2)) ? (1 + (($MATCH)->{to} = (2 + $MATCH->to()))) : 0) && (do { (my  $m2 = $grammar->ident($str, $MATCH->to())); if ($m2) { (($MATCH)->{to} = $m2->to());($MATCH->{'ident'} = $m2);1 } else { 0 } } && ((('(' eq substr($str, $MATCH->to(), 1)) ? (1 + (($MATCH)->{to} = (1 + $MATCH->to()))) : 0) && (do { (my  $m2 = $grammar->opt_ws($str, $MATCH->to())); if ($m2) { (($MATCH)->{to} = $m2->to());1 } else { 0 } } && (do { (my  $m2 = $grammar->exp_seq($str, $MATCH->to())); if ($m2) { (($MATCH)->{to} = $m2->to());($MATCH->{'exp_seq'} = $m2);1 } else { 0 } } && (do { (my  $m2 = $grammar->opt_ws($str, $MATCH->to())); if ($m2) { (($MATCH)->{to} = $m2->to());1 } else { 0 } } && (((')' eq substr($str, $MATCH->to(), 1)) ? (1 + (($MATCH)->{to} = (1 + $MATCH->to()))) : 0) && (do { ($MATCH->{capture} = (Call->new( 'invocant' => ${$MATCH->{'exp'}},'method' => ${$MATCH->{'ident'}},'arguments' => ${$MATCH->{'exp_seq'}},'hyper' => '', ))) } || 1))))))))) } }); $MATCH };
sub apply { my $grammar = $_[0]; my $str = $_[1]; my $pos = $_[2]; my  $MATCH; ($MATCH = MiniPerl6::Match->new( 'str' => $str,'from' => $pos,'to' => $pos,'bool' => 1, )); (($MATCH)->{bool} = do { (my  $pos1 = $MATCH->to()); do { (do { (my  $m2 = $grammar->optional_namespace_before_ident($str, $MATCH->to())); if ($m2) { (($MATCH)->{to} = $m2->to());($MATCH->{'optional_namespace_before_ident'} = $m2);1 } else { 0 } } && (do { (my  $m2 = $grammar->full_ident($str, $MATCH->to())); if ($m2) { (($MATCH)->{to} = $m2->to());($MATCH->{'full_ident'} = $m2);1 } else { 0 } } && do { (my  $pos1 = $MATCH->to()); (do { (do { (my  $pos1 = $MATCH->to()); (do { ((('(' eq substr($str, $MATCH->to(), 1)) ? (1 + (($MATCH)->{to} = (1 + $MATCH->to()))) : 0) && (do { (my  $m2 = $grammar->opt_ws($str, $MATCH->to())); if ($m2) { (($MATCH)->{to} = $m2->to());1 } else { 0 } } && (do { (my  $m2 = $grammar->exp_seq($str, $MATCH->to())); if ($m2) { (($MATCH)->{to} = $m2->to());($MATCH->{'exp_seq'} = $m2);1 } else { 0 } } && (do { (my  $m2 = $grammar->opt_ws($str, $MATCH->to())); if ($m2) { (($MATCH)->{to} = $m2->to());1 } else { 0 } } && ((')' eq substr($str, $MATCH->to(), 1)) ? (1 + (($MATCH)->{to} = (1 + $MATCH->to()))) : 0))))) } || do { (($MATCH)->{to} = $pos1); (do { (my  $m2 = $grammar->ws($str, $MATCH->to())); if ($m2) { (($MATCH)->{to} = $m2->to());1 } else { 0 } } && (do { (my  $m2 = $grammar->exp_seq($str, $MATCH->to())); if ($m2) { (($MATCH)->{to} = $m2->to());($MATCH->{'exp_seq'} = $m2);1 } else { 0 } } && do { (my  $m2 = $grammar->opt_ws($str, $MATCH->to())); if ($m2) { (($MATCH)->{to} = $m2->to());1 } else { 0 } })) }) } && (do { ($MATCH->{capture} = (Apply->new( 'namespace' => ${$MATCH->{'optional_namespace_before_ident'}},'code' => ${$MATCH->{'full_ident'}},'arguments' => ${$MATCH->{'exp_seq'}}, ))) } || 1)) } || do { (($MATCH)->{to} = $pos1); (do { ($MATCH->{capture} = (Apply->new( 'namespace' => ${$MATCH->{'optional_namespace_before_ident'}},'code' => ${$MATCH->{'full_ident'}},'arguments' => [], ))) } || 1) }) })) } }); $MATCH };
sub opt_name { my $grammar = $_[0]; my $str = $_[1]; my $pos = $_[2]; my  $MATCH; ($MATCH = MiniPerl6::Match->new( 'str' => $str,'from' => $pos,'to' => $pos,'bool' => 1, )); (($MATCH)->{bool} = do { (my  $pos1 = $MATCH->to()); (do { do { (my  $m2 = $grammar->ident($str, $MATCH->to())); if ($m2) { (($MATCH)->{to} = $m2->to());($MATCH->{'ident'} = $m2);1 } else { 0 } } } || do { (($MATCH)->{to} = $pos1); 1 }) }); $MATCH };
sub var_invocant { my $grammar = $_[0]; my $str = $_[1]; my $pos = $_[2]; my  $MATCH; ($MATCH = MiniPerl6::Match->new( 'str' => $str,'from' => $pos,'to' => $pos,'bool' => 1, )); (($MATCH)->{bool} = do { (my  $pos1 = $MATCH->to()); (do { (do { (my  $m2 = $grammar->var_ident($str, $MATCH->to())); if ($m2) { (($MATCH)->{to} = $m2->to());($MATCH->{'var_ident'} = $m2);1 } else { 0 } } && (((':' eq substr($str, $MATCH->to(), 1)) ? (1 + (($MATCH)->{to} = (1 + $MATCH->to()))) : 0) && (do { ($MATCH->{capture} = (${$MATCH->{'var_ident'}})) } || 1))) } || do { (($MATCH)->{to} = $pos1); (do { ($MATCH->{capture} = (Var->new( 'sigil' => '$','twigil' => '','name' => 'self', ))) } || 1) }) }); $MATCH };
sub args_sig { my $grammar = $_[0]; my $str = $_[1]; my $pos = $_[2]; my  $MATCH; ($MATCH = MiniPerl6::Match->new( 'str' => $str,'from' => $pos,'to' => $pos,'bool' => 1, )); (($MATCH)->{bool} = do { (my  $pos1 = $MATCH->to()); do { (do { (my  $m2 = $grammar->var_invocant($str, $MATCH->to())); if ($m2) { (($MATCH)->{to} = $m2->to());($MATCH->{'var_invocant'} = $m2);1 } else { 0 } } && (do { (my  $m2 = $grammar->opt_ws($str, $MATCH->to())); if ($m2) { (($MATCH)->{to} = $m2->to());1 } else { 0 } } && (do { (my  $m2 = $grammar->exp_seq($str, $MATCH->to())); if ($m2) { (($MATCH)->{to} = $m2->to());($MATCH->{'exp_seq'} = $m2);1 } else { 0 } } && (do { ($MATCH->{capture} = (Sig->new( 'invocant' => ${$MATCH->{'var_invocant'}},'positional' => ${$MATCH->{'exp_seq'}},'named' => {  }, ))) } || 1)))) } }); $MATCH };
sub method_sig { my $grammar = $_[0]; my $str = $_[1]; my $pos = $_[2]; my  $MATCH; ($MATCH = MiniPerl6::Match->new( 'str' => $str,'from' => $pos,'to' => $pos,'bool' => 1, )); (($MATCH)->{bool} = do { (my  $pos1 = $MATCH->to()); (do { (do { (my  $m2 = $grammar->opt_ws($str, $MATCH->to())); if ($m2) { (($MATCH)->{to} = $m2->to());1 } else { 0 } } && ((('(' eq substr($str, $MATCH->to(), 1)) ? (1 + (($MATCH)->{to} = (1 + $MATCH->to()))) : 0) && (do { (my  $m2 = $grammar->opt_ws($str, $MATCH->to())); if ($m2) { (($MATCH)->{to} = $m2->to());1 } else { 0 } } && (do { (my  $m2 = $grammar->args_sig($str, $MATCH->to())); if ($m2) { (($MATCH)->{to} = $m2->to());($MATCH->{'args_sig'} = $m2);1 } else { 0 } } && (do { (my  $m2 = $grammar->opt_ws($str, $MATCH->to())); if ($m2) { (($MATCH)->{to} = $m2->to());1 } else { 0 } } && (((')' eq substr($str, $MATCH->to(), 1)) ? (1 + (($MATCH)->{to} = (1 + $MATCH->to()))) : 0) && (do { ($MATCH->{capture} = (${$MATCH->{'args_sig'}})) } || 1))))))) } || do { (($MATCH)->{to} = $pos1); (do { ($MATCH->{capture} = (Sig->new( 'invocant' => Var->new( 'sigil' => '$','twigil' => '','name' => 'self', ),'positional' => [],'named' => {  }, ))) } || 1) }) }); $MATCH };
sub method_def { my $grammar = $_[0]; my $str = $_[1]; my $pos = $_[2]; my  $MATCH; ($MATCH = MiniPerl6::Match->new( 'str' => $str,'from' => $pos,'to' => $pos,'bool' => 1, )); (($MATCH)->{bool} = do { (my  $pos1 = $MATCH->to()); do { ((('m' eq substr($str, $MATCH->to(), 1)) ? (1 + (($MATCH)->{to} = (1 + $MATCH->to()))) : 0) && ((('e' eq substr($str, $MATCH->to(), 1)) ? (1 + (($MATCH)->{to} = (1 + $MATCH->to()))) : 0) && ((('t' eq substr($str, $MATCH->to(), 1)) ? (1 + (($MATCH)->{to} = (1 + $MATCH->to()))) : 0) && ((('h' eq substr($str, $MATCH->to(), 1)) ? (1 + (($MATCH)->{to} = (1 + $MATCH->to()))) : 0) && ((('o' eq substr($str, $MATCH->to(), 1)) ? (1 + (($MATCH)->{to} = (1 + $MATCH->to()))) : 0) && ((('d' eq substr($str, $MATCH->to(), 1)) ? (1 + (($MATCH)->{to} = (1 + $MATCH->to()))) : 0) && (do { (my  $m2 = $grammar->ws($str, $MATCH->to())); if ($m2) { (($MATCH)->{to} = $m2->to());1 } else { 0 } } && (do { (my  $m2 = $grammar->opt_name($str, $MATCH->to())); if ($m2) { (($MATCH)->{to} = $m2->to());($MATCH->{'opt_name'} = $m2);1 } else { 0 } } && (do { (my  $m2 = $grammar->opt_ws($str, $MATCH->to())); if ($m2) { (($MATCH)->{to} = $m2->to());1 } else { 0 } } && (do { (my  $m2 = $grammar->method_sig($str, $MATCH->to())); if ($m2) { (($MATCH)->{to} = $m2->to());($MATCH->{'method_sig'} = $m2);1 } else { 0 } } && (do { (my  $m2 = $grammar->opt_ws($str, $MATCH->to())); if ($m2) { (($MATCH)->{to} = $m2->to());1 } else { 0 } } && ((('{' eq substr($str, $MATCH->to(), 1)) ? (1 + (($MATCH)->{to} = (1 + $MATCH->to()))) : 0) && (do { (my  $m2 = $grammar->opt_ws($str, $MATCH->to())); if ($m2) { (($MATCH)->{to} = $m2->to());1 } else { 0 } } && (do { (my  $m2 = $grammar->exp_stmts($str, $MATCH->to())); if ($m2) { (($MATCH)->{to} = $m2->to());($MATCH->{'exp_stmts'} = $m2);1 } else { 0 } } && (do { (my  $m2 = $grammar->opt_ws($str, $MATCH->to())); if ($m2) { (($MATCH)->{to} = $m2->to());1 } else { 0 } } && (do { (my  $pos1 = $MATCH->to()); (do { (('}' eq substr($str, $MATCH->to(), 1)) ? (1 + (($MATCH)->{to} = (1 + $MATCH->to()))) : 0) } || do { (($MATCH)->{to} = $pos1); (do { Main::say('*** Syntax Error in method \'', get_class_name(), '.', ${$MATCH->{'name'}}, '\' near pos=', $MATCH->to()); die('error in Block') } || 1) }) } && (do { ($MATCH->{capture} = (Method->new( 'name' => ${$MATCH->{'opt_name'}},'sig' => ${$MATCH->{'method_sig'}},'block' => ${$MATCH->{'exp_stmts'}}, ))) } || 1))))))))))))))))) } }); $MATCH };
sub sub_def { my $grammar = $_[0]; my $str = $_[1]; my $pos = $_[2]; my  $MATCH; ($MATCH = MiniPerl6::Match->new( 'str' => $str,'from' => $pos,'to' => $pos,'bool' => 1, )); (($MATCH)->{bool} = do { (my  $pos1 = $MATCH->to()); do { ((('s' eq substr($str, $MATCH->to(), 1)) ? (1 + (($MATCH)->{to} = (1 + $MATCH->to()))) : 0) && ((('u' eq substr($str, $MATCH->to(), 1)) ? (1 + (($MATCH)->{to} = (1 + $MATCH->to()))) : 0) && ((('b' eq substr($str, $MATCH->to(), 1)) ? (1 + (($MATCH)->{to} = (1 + $MATCH->to()))) : 0) && (do { (my  $m2 = $grammar->ws($str, $MATCH->to())); if ($m2) { (($MATCH)->{to} = $m2->to());1 } else { 0 } } && (do { (my  $m2 = $grammar->opt_name($str, $MATCH->to())); if ($m2) { (($MATCH)->{to} = $m2->to());($MATCH->{'opt_name'} = $m2);1 } else { 0 } } && (do { (my  $m2 = $grammar->opt_ws($str, $MATCH->to())); if ($m2) { (($MATCH)->{to} = $m2->to());1 } else { 0 } } && (do { (my  $m2 = $grammar->method_sig($str, $MATCH->to())); if ($m2) { (($MATCH)->{to} = $m2->to());($MATCH->{'method_sig'} = $m2);1 } else { 0 } } && (do { (my  $m2 = $grammar->opt_ws($str, $MATCH->to())); if ($m2) { (($MATCH)->{to} = $m2->to());1 } else { 0 } } && ((('{' eq substr($str, $MATCH->to(), 1)) ? (1 + (($MATCH)->{to} = (1 + $MATCH->to()))) : 0) && (do { (my  $m2 = $grammar->opt_ws($str, $MATCH->to())); if ($m2) { (($MATCH)->{to} = $m2->to());1 } else { 0 } } && (do { (my  $m2 = $grammar->exp_stmts($str, $MATCH->to())); if ($m2) { (($MATCH)->{to} = $m2->to());($MATCH->{'exp_stmts'} = $m2);1 } else { 0 } } && (do { (my  $m2 = $grammar->opt_ws($str, $MATCH->to())); if ($m2) { (($MATCH)->{to} = $m2->to());1 } else { 0 } } && (do { (my  $pos1 = $MATCH->to()); (do { (('}' eq substr($str, $MATCH->to(), 1)) ? (1 + (($MATCH)->{to} = (1 + $MATCH->to()))) : 0) } || do { (($MATCH)->{to} = $pos1); (do { Main::say('*** Syntax Error in sub \'', ${$MATCH->{'name'}}, '\''); die('error in Block') } || 1) }) } && (do { ($MATCH->{capture} = (Sub->new( 'name' => ${$MATCH->{'opt_name'}},'sig' => ${$MATCH->{'method_sig'}},'block' => ${$MATCH->{'exp_stmts'}}, ))) } || 1)))))))))))))) } }); $MATCH };
sub token { my $grammar = $_[0]; my $str = $_[1]; my $pos = $_[2]; my  $MATCH; ($MATCH = MiniPerl6::Match->new( 'str' => $str,'from' => $pos,'to' => $pos,'bool' => 1, )); (($MATCH)->{bool} = do { (my  $pos1 = $MATCH->to()); do { ((('t' eq substr($str, $MATCH->to(), 1)) ? (1 + (($MATCH)->{to} = (1 + $MATCH->to()))) : 0) && ((('o' eq substr($str, $MATCH->to(), 1)) ? (1 + (($MATCH)->{to} = (1 + $MATCH->to()))) : 0) && ((('k' eq substr($str, $MATCH->to(), 1)) ? (1 + (($MATCH)->{to} = (1 + $MATCH->to()))) : 0) && ((('e' eq substr($str, $MATCH->to(), 1)) ? (1 + (($MATCH)->{to} = (1 + $MATCH->to()))) : 0) && ((('n' eq substr($str, $MATCH->to(), 1)) ? (1 + (($MATCH)->{to} = (1 + $MATCH->to()))) : 0) && (do { (my  $m2 = $grammar->ws($str, $MATCH->to())); if ($m2) { (($MATCH)->{to} = $m2->to());1 } else { 0 } } && (do { (my  $m2 = $grammar->opt_name($str, $MATCH->to())); if ($m2) { (($MATCH)->{to} = $m2->to());($MATCH->{'opt_name'} = $m2);1 } else { 0 } } && (do { (my  $m2 = $grammar->opt_ws($str, $MATCH->to())); if ($m2) { (($MATCH)->{to} = $m2->to());1 } else { 0 } } && ((('{' eq substr($str, $MATCH->to(), 1)) ? (1 + (($MATCH)->{to} = (1 + $MATCH->to()))) : 0) && (do { (my  $m2 = MiniPerl6::Grammar::Regex->rule($str, $MATCH->to())); if ($m2) { (($MATCH)->{to} = $m2->to());($MATCH->{'MiniPerl6::Grammar::Regex.rule'} = $m2);1 } else { 0 } } && ((('}' eq substr($str, $MATCH->to(), 1)) ? (1 + (($MATCH)->{to} = (1 + $MATCH->to()))) : 0) && (do { (my  $source = 'method ' . $MATCH->{'opt_name'} . ' ( $grammar: $str, $pos ) { ' . 'my $MATCH; $MATCH := MiniPerl6::Match.new( \'str\' => $str, \'from\' => $pos, \'to\' => $pos, \'bool\' => 1 ); ' . '$MATCH.bool := ( ' . ${$MATCH->{'MiniPerl6::Grammar::Regex.rule'}}->emit() . '); ' . '$MATCH }'); (my  $ast = MiniPerl6::Grammar->exp_term($source, 0)); ($MATCH->{capture} = (${$ast})) } || 1)))))))))))) } }); $MATCH }
}

1;
