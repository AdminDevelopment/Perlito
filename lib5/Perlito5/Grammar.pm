# Do not edit this file - Generated by Perlito5 8.0
use v5;
use utf8;
use strict;
use warnings;
no warnings ('redefine', 'once', 'void', 'uninitialized', 'misc', 'recursion');
use Perlito5::Perl5::Runtime;
our $MATCH = Perlito5::Match->new();
package main;
package Perlito5::Grammar;
use Perlito5::Expression;
use Perlito5::Grammar::Control;
use Perlito5::Grammar::String;
sub Perlito5::Grammar::is_newline {
    ((my  $grammar) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    ((my  $MATCH) = Perlito5::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1)));
    ($MATCH->{'bool'} = (((do {
    ((my  $pos1) = $MATCH->{'to'});
    (((do {
    ((chr(10) eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'}))))
})) || ((do {
    ($MATCH->{'to'} = $pos1);
    ((((chr(13) eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'}))))))
})))
}))));
    $MATCH
};
sub Perlito5::Grammar::not_newline {
    ((my  $grammar) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    ((my  $MATCH) = Perlito5::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1)));
    ($MATCH->{'bool'} = (((do {
    ((my  $pos1) = $MATCH->{'to'});
    ((do {
    (((do {
    ((my  $tmp) = $MATCH);
    ($MATCH = Perlito5::Match->new(('str' => $str), ('from' => $tmp->{'to'}), ('to' => $tmp->{'to'}), ('bool' => 1)));
    ($MATCH->{'bool'} = ((do {
    ((my  $pos1) = $MATCH->{'to'});
    ((do {
    ((my  $m2) = $grammar->is_newline($str, $MATCH->{'to'}));
    if (($m2->{'bool'})) {
        ($MATCH->{'to'} = $m2->{'to'});
        1
    }
    else {
        0
    }
}))
})));
    ($tmp->{'bool'} = !($MATCH->{'bool'}));
    ($MATCH = $tmp);
    ($MATCH->{'bool'} ? 1 : 0)
})) && ((('' ne substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'}))))))
}))
}))));
    $MATCH
};
sub Perlito5::Grammar::ident {
    ((my  $grammar) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    ((my  $MATCH) = Perlito5::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1)));
    ($MATCH->{'bool'} = (((do {
    ((my  $pos1) = $MATCH->{'to'});
    ((do {
    (((do {
    ((my  $tmp) = $MATCH);
    ($MATCH = Perlito5::Match->new(('str' => $str), ('from' => $tmp->{'to'}), ('to' => $tmp->{'to'}), ('bool' => 1)));
    ($MATCH->{'bool'} = ((do {
    ((my  $pos1) = $MATCH->{'to'});
    ((do {
    ((my  $m2) = $grammar->digit($str, $MATCH->{'to'}));
    if (($m2->{'bool'})) {
        ($MATCH->{'to'} = $m2->{'to'});
        1
    }
    else {
        0
    }
}))
})));
    ($tmp->{'bool'} = !($MATCH->{'bool'}));
    ($MATCH = $tmp);
    ($MATCH->{'bool'} ? 1 : 0)
})) && ((do {
    ((my  $last_match_null) = 0);
    ((my  $last_pos) = $MATCH->{'to'});
    ((my  $count) = 0);
    for ( ; ((((do {
    ((my  $m2) = $grammar->word($str, $MATCH->{'to'}));
    if (($m2->{'bool'})) {
        ($MATCH->{'to'} = $m2->{'to'});
        1
    }
    else {
        0
    }
})) && (($last_match_null < 2))));  ) {
        if ((($last_pos == $MATCH->{'to'}))) {
            ($last_match_null = ($last_match_null + 1))
        }
        else {
            ($last_match_null = 0)
        };
        ($last_pos = $MATCH->{'to'});
        ($count = ($count + 1))
    };
    ($MATCH->{'to'} = $last_pos);
    ($count > 0)
})))
}))
}))));
    $MATCH
};
sub Perlito5::Grammar::full_ident {
    ((my  $grammar) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    ((my  $MATCH) = Perlito5::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1)));
    ($MATCH->{'bool'} = (((do {
    ((my  $pos1) = $MATCH->{'to'});
    ((do {
    (((do {
    ((my  $m2) = $grammar->ident($str, $MATCH->{'to'}));
    if (($m2->{'bool'})) {
        ($MATCH->{'to'} = $m2->{'to'});
        1
    }
    else {
        0
    }
})) && ((do {
    ((my  $last_match_null) = 0);
    ((my  $last_pos) = $MATCH->{'to'});
    for ( ; ((((do {
    ((my  $pos1) = $MATCH->{'to'});
    ((do {
    (((('::' eq substr($str, $MATCH->{'to'}, 2)) && (($MATCH->{'to'} = (2 + $MATCH->{'to'}))))) && ((do {
    ((my  $m2) = $grammar->ident($str, $MATCH->{'to'}));
    if (($m2->{'bool'})) {
        ($MATCH->{'to'} = $m2->{'to'});
        1
    }
    else {
        0
    }
})))
}))
})) && (($last_match_null < 2))));  ) {
        if ((($last_pos == $MATCH->{'to'}))) {
            ($last_match_null = ($last_match_null + 1))
        }
        else {
            ($last_match_null = 0)
        };
        ($last_pos = $MATCH->{'to'})
    };
    ($MATCH->{'to'} = $last_pos);
    1
})))
}))
}))));
    $MATCH
};
sub Perlito5::Grammar::namespace_before_ident {
    ((my  $grammar) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    ((my  $MATCH) = Perlito5::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1)));
    ($MATCH->{'bool'} = (((do {
    ((my  $pos1) = $MATCH->{'to'});
    ((do {
    ((((do {
    ((my  $m2) = $grammar->ident($str, $MATCH->{'to'}));
    if (($m2->{'bool'})) {
        ($MATCH->{'to'} = $m2->{'to'});
        1
    }
    else {
        0
    }
})) && ((do {
    ((my  $tmp) = $MATCH);
    ($MATCH = Perlito5::Match->new(('str' => $str), ('from' => $tmp->{'to'}), ('to' => $tmp->{'to'}), ('bool' => 1)));
    ($MATCH->{'bool'} = ((do {
    ((my  $pos1) = $MATCH->{'to'});
    ((do {
    (('::' eq substr($str, $MATCH->{'to'}, 2)) && (($MATCH->{'to'} = (2 + $MATCH->{'to'}))))
}))
})));
    ($tmp->{'bool'} = ($MATCH->{'bool'} ? 1 : 0));
    ($MATCH = $tmp);
    ($MATCH->{'bool'} ? 1 : 0)
}))) && ((do {
    ((my  $last_match_null) = 0);
    ((my  $last_pos) = $MATCH->{'to'});
    for ( ; ((((do {
    ((my  $pos1) = $MATCH->{'to'});
    ((do {
    ((((('::' eq substr($str, $MATCH->{'to'}, 2)) && (($MATCH->{'to'} = (2 + $MATCH->{'to'}))))) && ((do {
    ((my  $m2) = $grammar->ident($str, $MATCH->{'to'}));
    if (($m2->{'bool'})) {
        ($MATCH->{'to'} = $m2->{'to'});
        1
    }
    else {
        0
    }
}))) && ((do {
    ((my  $tmp) = $MATCH);
    ($MATCH = Perlito5::Match->new(('str' => $str), ('from' => $tmp->{'to'}), ('to' => $tmp->{'to'}), ('bool' => 1)));
    ($MATCH->{'bool'} = ((do {
    ((my  $pos1) = $MATCH->{'to'});
    ((do {
    (('::' eq substr($str, $MATCH->{'to'}, 2)) && (($MATCH->{'to'} = (2 + $MATCH->{'to'}))))
}))
})));
    ($tmp->{'bool'} = ($MATCH->{'bool'} ? 1 : 0));
    ($MATCH = $tmp);
    ($MATCH->{'bool'} ? 1 : 0)
})))
}))
})) && (($last_match_null < 2))));  ) {
        if ((($last_pos == $MATCH->{'to'}))) {
            ($last_match_null = ($last_match_null + 1))
        }
        else {
            ($last_match_null = 0)
        };
        ($last_pos = $MATCH->{'to'})
    };
    ($MATCH->{'to'} = $last_pos);
    1
})))
}))
}))));
    $MATCH
};
sub Perlito5::Grammar::optional_namespace_before_ident {
    ((my  $grammar) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    ((my  $MATCH) = Perlito5::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1)));
    ($MATCH->{'bool'} = (((do {
    ((my  $pos1) = $MATCH->{'to'});
    ((((do {
    ((((do {
    ((my  $m2) = $grammar->namespace_before_ident($str, $MATCH->{'to'}));
    if (($m2->{'bool'})) {
        ($MATCH->{'to'} = $m2->{'to'});
        ($MATCH->{'namespace_before_ident'} = $m2);
        1
    }
    else {
        0
    }
})) && ((('::' eq substr($str, $MATCH->{'to'}, 2)) && (($MATCH->{'to'} = (2 + $MATCH->{'to'})))))) && ((do {
    ($MATCH->{'capture'} = $MATCH->{'namespace_before_ident'}->flat());
    1
})))
})) || ((do {
    ($MATCH->{'to'} = $pos1);
    ((((('::' eq substr($str, $MATCH->{'to'}, 2)) && (($MATCH->{'to'} = (2 + $MATCH->{'to'}))))) && ((do {
    ($MATCH->{'capture'} = 'main');
    1
}))))
}))) || ((do {
    ($MATCH->{'to'} = $pos1);
    ((1 && ((do {
    ($MATCH->{'capture'} = '');
    1
}))))
})))
}))));
    $MATCH
};
sub Perlito5::Grammar::pod_pod_begin {
    ((my  $grammar) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    ((my  $MATCH) = Perlito5::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1)));
    ($MATCH->{'bool'} = (((do {
    ((my  $pos1) = $MATCH->{'to'});
    (((do {
    ((((do {
    ((my  $m2) = $grammar->is_newline($str, $MATCH->{'to'}));
    if (($m2->{'bool'})) {
        ($MATCH->{'to'} = $m2->{'to'});
        1
    }
    else {
        0
    }
})) && ((('=cut' eq substr($str, $MATCH->{'to'}, 4)) && (($MATCH->{'to'} = (4 + $MATCH->{'to'})))))) && ((do {
    ((my  $last_match_null) = 0);
    ((my  $last_pos) = $MATCH->{'to'});
    for ( ; ((((do {
    ((my  $m2) = $grammar->not_newline($str, $MATCH->{'to'}));
    if (($m2->{'bool'})) {
        ($MATCH->{'to'} = $m2->{'to'});
        1
    }
    else {
        0
    }
})) && (($last_match_null < 2))));  ) {
        if ((($last_pos == $MATCH->{'to'}))) {
            ($last_match_null = ($last_match_null + 1))
        }
        else {
            ($last_match_null = 0)
        };
        ($last_pos = $MATCH->{'to'})
    };
    ($MATCH->{'to'} = $last_pos);
    1
})))
})) || ((do {
    ($MATCH->{'to'} = $pos1);
    (((((('' ne substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'}))))) && ((do {
    ((my  $last_match_null) = 0);
    ((my  $last_pos) = $MATCH->{'to'});
    for ( ; ((((do {
    ((my  $m2) = $grammar->not_newline($str, $MATCH->{'to'}));
    if (($m2->{'bool'})) {
        ($MATCH->{'to'} = $m2->{'to'});
        1
    }
    else {
        0
    }
})) && (($last_match_null < 2))));  ) {
        if ((($last_pos == $MATCH->{'to'}))) {
            ($last_match_null = ($last_match_null + 1))
        }
        else {
            ($last_match_null = 0)
        };
        ($last_pos = $MATCH->{'to'})
    };
    ($MATCH->{'to'} = $last_pos);
    1
}))) && ((do {
    ((my  $m2) = $grammar->pod_pod_begin($str, $MATCH->{'to'}));
    if (($m2->{'bool'})) {
        ($MATCH->{'to'} = $m2->{'to'});
        1
    }
    else {
        0
    }
}))))
})))
}))));
    $MATCH
};
sub Perlito5::Grammar::pod_begin {
    ((my  $grammar) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    ((my  $MATCH) = Perlito5::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1)));
    ($MATCH->{'bool'} = (((do {
    ((my  $pos1) = $MATCH->{'to'});
    (((do {
    ((((do {
    ((my  $m2) = $grammar->is_newline($str, $MATCH->{'to'}));
    if (($m2->{'bool'})) {
        ($MATCH->{'to'} = $m2->{'to'});
        1
    }
    else {
        0
    }
})) && ((('=end' eq substr($str, $MATCH->{'to'}, 4)) && (($MATCH->{'to'} = (4 + $MATCH->{'to'})))))) && ((do {
    ((my  $last_match_null) = 0);
    ((my  $last_pos) = $MATCH->{'to'});
    for ( ; ((((do {
    ((my  $m2) = $grammar->not_newline($str, $MATCH->{'to'}));
    if (($m2->{'bool'})) {
        ($MATCH->{'to'} = $m2->{'to'});
        1
    }
    else {
        0
    }
})) && (($last_match_null < 2))));  ) {
        if ((($last_pos == $MATCH->{'to'}))) {
            ($last_match_null = ($last_match_null + 1))
        }
        else {
            ($last_match_null = 0)
        };
        ($last_pos = $MATCH->{'to'})
    };
    ($MATCH->{'to'} = $last_pos);
    1
})))
})) || ((do {
    ($MATCH->{'to'} = $pos1);
    (((((('' ne substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'}))))) && ((do {
    ((my  $last_match_null) = 0);
    ((my  $last_pos) = $MATCH->{'to'});
    for ( ; ((((do {
    ((my  $m2) = $grammar->not_newline($str, $MATCH->{'to'}));
    if (($m2->{'bool'})) {
        ($MATCH->{'to'} = $m2->{'to'});
        1
    }
    else {
        0
    }
})) && (($last_match_null < 2))));  ) {
        if ((($last_pos == $MATCH->{'to'}))) {
            ($last_match_null = ($last_match_null + 1))
        }
        else {
            ($last_match_null = 0)
        };
        ($last_pos = $MATCH->{'to'})
    };
    ($MATCH->{'to'} = $last_pos);
    1
}))) && ((do {
    ((my  $m2) = $grammar->pod_begin($str, $MATCH->{'to'}));
    if (($m2->{'bool'})) {
        ($MATCH->{'to'} = $m2->{'to'});
        1
    }
    else {
        0
    }
}))))
})))
}))));
    $MATCH
};
sub Perlito5::Grammar::ws {
    ((my  $grammar) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    ((my  $MATCH) = Perlito5::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1)));
    ($MATCH->{'bool'} = (((do {
    ((my  $pos1) = $MATCH->{'to'});
    ((do {
    ((my  $last_match_null) = 0);
    ((my  $last_pos) = $MATCH->{'to'});
    ((my  $count) = 0);
    for ( ; ((((do {
    ((my  $pos1) = $MATCH->{'to'});
    ((((do {
    (((('#' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'}))))) && ((do {
    ((my  $last_match_null) = 0);
    ((my  $last_pos) = $MATCH->{'to'});
    for ( ; ((((do {
    ((my  $m2) = $grammar->not_newline($str, $MATCH->{'to'}));
    if (($m2->{'bool'})) {
        ($MATCH->{'to'} = $m2->{'to'});
        1
    }
    else {
        0
    }
})) && (($last_match_null < 2))));  ) {
        if ((($last_pos == $MATCH->{'to'}))) {
            ($last_match_null = ($last_match_null + 1))
        }
        else {
            ($last_match_null = 0)
        };
        ($last_pos = $MATCH->{'to'})
    };
    ($MATCH->{'to'} = $last_pos);
    1
})))
})) || ((do {
    ($MATCH->{'to'} = $pos1);
    (((((do {
    ((my  $pos1) = $MATCH->{'to'});
    (((do {
    ((((chr(10) eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'}))))) && ((do {
    ((my  $last_pos) = $MATCH->{'to'});
    if ((!(((do {
    ((chr(13) eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'}))))
}))))) {
        ($MATCH->{'to'} = $last_pos)
    };
    1
})))
})) || ((do {
    ($MATCH->{'to'} = $pos1);
    (((((chr(13) eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'}))))) && ((do {
    ((my  $last_pos) = $MATCH->{'to'});
    if ((!(((do {
    ((chr(10) eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'}))))
}))))) {
        ($MATCH->{'to'} = $last_pos)
    };
    1
}))))
})))
})) && ((do {
    ((my  $m2) = Perlito5::Grammar::String->here_doc($str, $MATCH->{'to'}));
    if (($m2->{'bool'})) {
        ($MATCH->{'to'} = $m2->{'to'});
        1
    }
    else {
        0
    }
}))) && ((do {
    ((my  $pos1) = $MATCH->{'to'});
    (((do {
    (((('=' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'}))))) && ((do {
    ((my  $pos1) = $MATCH->{'to'});
    (((((do {
    (((('pod' eq substr($str, $MATCH->{'to'}, 3)) && (($MATCH->{'to'} = (3 + $MATCH->{'to'}))))) && ((do {
    ((my  $m2) = $grammar->pod_pod_begin($str, $MATCH->{'to'}));
    if (($m2->{'bool'})) {
        ($MATCH->{'to'} = $m2->{'to'});
        1
    }
    else {
        0
    }
})))
})) || ((do {
    ($MATCH->{'to'} = $pos1);
    ((((('head1' eq substr($str, $MATCH->{'to'}, 5)) && (($MATCH->{'to'} = (5 + $MATCH->{'to'}))))) && ((do {
    ((my  $m2) = $grammar->pod_pod_begin($str, $MATCH->{'to'}));
    if (($m2->{'bool'})) {
        ($MATCH->{'to'} = $m2->{'to'});
        1
    }
    else {
        0
    }
}))))
}))) || ((do {
    ($MATCH->{'to'} = $pos1);
    ((((('begin' eq substr($str, $MATCH->{'to'}, 5)) && (($MATCH->{'to'} = (5 + $MATCH->{'to'}))))) && ((do {
    ((my  $m2) = $grammar->pod_begin($str, $MATCH->{'to'}));
    if (($m2->{'bool'})) {
        ($MATCH->{'to'} = $m2->{'to'});
        1
    }
    else {
        0
    }
}))))
}))) || ((do {
    ($MATCH->{'to'} = $pos1);
    ((((('for' eq substr($str, $MATCH->{'to'}, 3)) && (($MATCH->{'to'} = (3 + $MATCH->{'to'}))))) && ((do {
    ((my  $m2) = $grammar->pod_begin($str, $MATCH->{'to'}));
    if (($m2->{'bool'})) {
        ($MATCH->{'to'} = $m2->{'to'});
        1
    }
    else {
        0
    }
}))))
})))
})))
})) || ((do {
    ($MATCH->{'to'} = $pos1);
    (1)
})))
}))))
}))) || ((do {
    ($MATCH->{'to'} = $pos1);
    (((do {
    ((my  $m2) = $grammar->space($str, $MATCH->{'to'}));
    if (($m2->{'bool'})) {
        ($MATCH->{'to'} = $m2->{'to'});
        1
    }
    else {
        0
    }
})))
})))
})) && (($last_match_null < 2))));  ) {
        if ((($last_pos == $MATCH->{'to'}))) {
            ($last_match_null = ($last_match_null + 1))
        }
        else {
            ($last_match_null = 0)
        };
        ($last_pos = $MATCH->{'to'});
        ($count = ($count + 1))
    };
    ($MATCH->{'to'} = $last_pos);
    ($count > 0)
}))
}))));
    $MATCH
};
sub Perlito5::Grammar::opt_ws {
    ((my  $grammar) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    ((my  $MATCH) = Perlito5::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1)));
    ($MATCH->{'bool'} = (((do {
    ((my  $pos1) = $MATCH->{'to'});
    ((do {
    ((my  $last_pos) = $MATCH->{'to'});
    if ((!(((do {
    ((my  $m2) = $grammar->ws($str, $MATCH->{'to'}));
    if (($m2->{'bool'})) {
        ($MATCH->{'to'} = $m2->{'to'});
        1
    }
    else {
        0
    }
}))))) {
        ($MATCH->{'to'} = $last_pos)
    };
    1
}))
}))));
    $MATCH
};
sub Perlito5::Grammar::opt_ws2 {
    ((my  $grammar) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    ((my  $MATCH) = Perlito5::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1)));
    ($MATCH->{'bool'} = (((do {
    ((my  $pos1) = $MATCH->{'to'});
    ((do {
    ((my  $last_pos) = $MATCH->{'to'});
    if ((!(((do {
    ((my  $m2) = $grammar->ws($str, $MATCH->{'to'}));
    if (($m2->{'bool'})) {
        ($MATCH->{'to'} = $m2->{'to'});
        1
    }
    else {
        0
    }
}))))) {
        ($MATCH->{'to'} = $last_pos)
    };
    1
}))
}))));
    $MATCH
};
sub Perlito5::Grammar::opt_ws3 {
    ((my  $grammar) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    ((my  $MATCH) = Perlito5::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1)));
    ($MATCH->{'bool'} = (((do {
    ((my  $pos1) = $MATCH->{'to'});
    ((do {
    ((my  $last_pos) = $MATCH->{'to'});
    if ((!(((do {
    ((my  $m2) = $grammar->ws($str, $MATCH->{'to'}));
    if (($m2->{'bool'})) {
        ($MATCH->{'to'} = $m2->{'to'});
        1
    }
    else {
        0
    }
}))))) {
        ($MATCH->{'to'} = $last_pos)
    };
    1
}))
}))));
    $MATCH
};
sub Perlito5::Grammar::declarator {
    ((my  $grammar) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    ((my  $MATCH) = Perlito5::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1)));
    ($MATCH->{'bool'} = (((do {
    ((my  $pos1) = $MATCH->{'to'});
    (((((do {
    (('my' eq substr($str, $MATCH->{'to'}, 2)) && (($MATCH->{'to'} = (2 + $MATCH->{'to'}))))
})) || ((do {
    ($MATCH->{'to'} = $pos1);
    (((('state' eq substr($str, $MATCH->{'to'}, 5)) && (($MATCH->{'to'} = (5 + $MATCH->{'to'}))))))
}))) || ((do {
    ($MATCH->{'to'} = $pos1);
    (((('our' eq substr($str, $MATCH->{'to'}, 3)) && (($MATCH->{'to'} = (3 + $MATCH->{'to'}))))))
}))) || ((do {
    ($MATCH->{'to'} = $pos1);
    (((('local' eq substr($str, $MATCH->{'to'}, 5)) && (($MATCH->{'to'} = (5 + $MATCH->{'to'}))))))
})))
}))));
    $MATCH
};
sub Perlito5::Grammar::exp_stmts2 {
    ((my  $grammar) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    ((my  $MATCH) = Perlito5::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1)));
    ($MATCH->{'bool'} = (((do {
    ((my  $pos1) = $MATCH->{'to'});
    ((do {
    (((do {
    ((my  $m2) = $grammar->exp_stmts($str, $MATCH->{'to'}));
    if (($m2->{'bool'})) {
        ($MATCH->{'to'} = $m2->{'to'});
        ($MATCH->{'exp_stmts'} = $m2);
        1
    }
    else {
        0
    }
})) && ((do {
    ($MATCH->{'capture'} = $MATCH->{'exp_stmts'}->flat());
    1
})))
}))
}))));
    $MATCH
};
sub Perlito5::Grammar::exp {
    ((my  $grammar) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    ((my  $MATCH) = Perlito5::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1)));
    ($MATCH->{'bool'} = (((do {
    ((my  $pos1) = $MATCH->{'to'});
    ((do {
    (((do {
    ((my  $m2) = Perlito5::Expression->exp_parse($str, $MATCH->{'to'}));
    if (($m2->{'bool'})) {
        ($MATCH->{'to'} = $m2->{'to'});
        ($MATCH->{'Perlito5::Expression.exp_parse'} = $m2);
        1
    }
    else {
        0
    }
})) && ((do {
    ($MATCH->{'capture'} = $MATCH->{'Perlito5::Expression.exp_parse'}->flat());
    1
})))
}))
}))));
    $MATCH
};
sub Perlito5::Grammar::exp2 {
    ((my  $grammar) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    ((my  $MATCH) = Perlito5::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1)));
    ($MATCH->{'bool'} = (((do {
    ((my  $pos1) = $MATCH->{'to'});
    ((do {
    (((do {
    ((my  $m2) = Perlito5::Expression->exp_parse($str, $MATCH->{'to'}));
    if (($m2->{'bool'})) {
        ($MATCH->{'to'} = $m2->{'to'});
        ($MATCH->{'Perlito5::Expression.exp_parse'} = $m2);
        1
    }
    else {
        0
    }
})) && ((do {
    ($MATCH->{'capture'} = $MATCH->{'Perlito5::Expression.exp_parse'}->flat());
    1
})))
}))
}))));
    $MATCH
};
sub Perlito5::Grammar::opt_ident {
    ((my  $grammar) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    ((my  $MATCH) = Perlito5::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1)));
    ($MATCH->{'bool'} = (((do {
    ((my  $pos1) = $MATCH->{'to'});
    (((do {
    (((do {
    ((my  $m2) = $grammar->ident($str, $MATCH->{'to'}));
    if (($m2->{'bool'})) {
        ($MATCH->{'to'} = $m2->{'to'});
        ($MATCH->{'ident'} = $m2);
        1
    }
    else {
        0
    }
})) && ((do {
    ($MATCH->{'capture'} = $MATCH->{'ident'}->flat());
    1
})))
})) || ((do {
    ($MATCH->{'to'} = $pos1);
    ((1 && ((do {
    ($MATCH->{'capture'} = 'postcircumfix:<( )>');
    1
}))))
})))
}))));
    $MATCH
};
sub Perlito5::Grammar::opt_type {
    ((my  $grammar) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    ((my  $MATCH) = Perlito5::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1)));
    ($MATCH->{'bool'} = (((do {
    ((my  $pos1) = $MATCH->{'to'});
    (((do {
    ((((do {
    ((my  $last_pos) = $MATCH->{'to'});
    if ((!(((do {
    (('::' eq substr($str, $MATCH->{'to'}, 2)) && (($MATCH->{'to'} = (2 + $MATCH->{'to'}))))
}))))) {
        ($MATCH->{'to'} = $last_pos)
    };
    1
})) && ((do {
    ((my  $m2) = $grammar->full_ident($str, $MATCH->{'to'}));
    if (($m2->{'bool'})) {
        ($MATCH->{'to'} = $m2->{'to'});
        ($MATCH->{'full_ident'} = $m2);
        1
    }
    else {
        0
    }
}))) && ((do {
    ($MATCH->{'capture'} = $MATCH->{'full_ident'}->flat());
    1
})))
})) || ((do {
    ($MATCH->{'to'} = $pos1);
    ((1 && ((do {
    ($MATCH->{'capture'} = '');
    1
}))))
})))
}))));
    $MATCH
};
sub Perlito5::Grammar::var_sigil {
    ((my  $grammar) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    ((my  $MATCH) = Perlito5::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1)));
    ($MATCH->{'bool'} = (((do {
    ((my  $pos1) = $MATCH->{'to'});
    ((((((do {
    (('$' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'}))))
})) || ((do {
    ($MATCH->{'to'} = $pos1);
    (((('%' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'}))))))
}))) || ((do {
    ($MATCH->{'to'} = $pos1);
    (((('@' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'}))))))
}))) || ((do {
    ($MATCH->{'to'} = $pos1);
    (((('&' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'}))))))
}))) || ((do {
    ($MATCH->{'to'} = $pos1);
    (((('*' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'}))))))
})))
}))));
    $MATCH
};
sub Perlito5::Grammar::var_name {
    ((my  $grammar) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    ((my  $MATCH) = Perlito5::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1)));
    ($MATCH->{'bool'} = (((do {
    ((my  $pos1) = $MATCH->{'to'});
    (((do {
    ((my  $m2) = $grammar->full_ident($str, $MATCH->{'to'}));
    if (($m2->{'bool'})) {
        ($MATCH->{'to'} = $m2->{'to'});
        ($MATCH->{'full_ident'} = $m2);
        1
    }
    else {
        0
    }
})) || ((do {
    ($MATCH->{'to'} = $pos1);
    (((do {
    ((my  $m2) = $grammar->digit($str, $MATCH->{'to'}));
    if (($m2->{'bool'})) {
        ($MATCH->{'to'} = $m2->{'to'});
        ($MATCH->{'digit'} = $m2);
        1
    }
    else {
        0
    }
})))
})))
}))));
    $MATCH
};
sub Perlito5::Grammar::var_ident {
    ((my  $grammar) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    ((my  $MATCH) = Perlito5::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1)));
    ($MATCH->{'bool'} = (((do {
    ((my  $pos1) = $MATCH->{'to'});
    ((do {
    (((((do {
    ((my  $m2) = $grammar->var_sigil($str, $MATCH->{'to'}));
    if (($m2->{'bool'})) {
        ($MATCH->{'to'} = $m2->{'to'});
        ($MATCH->{'var_sigil'} = $m2);
        1
    }
    else {
        0
    }
})) && ((do {
    ((my  $m2) = $grammar->optional_namespace_before_ident($str, $MATCH->{'to'}));
    if (($m2->{'bool'})) {
        ($MATCH->{'to'} = $m2->{'to'});
        ($MATCH->{'optional_namespace_before_ident'} = $m2);
        1
    }
    else {
        0
    }
}))) && ((do {
    ((my  $m2) = $grammar->var_name($str, $MATCH->{'to'}));
    if (($m2->{'bool'})) {
        ($MATCH->{'to'} = $m2->{'to'});
        ($MATCH->{'var_name'} = $m2);
        1
    }
    else {
        0
    }
}))) && ((do {
    ($MATCH->{'capture'} = Perlito5::AST::Var->new(('sigil' => $MATCH->{'var_sigil'}->flat()), ('namespace' => $MATCH->{'optional_namespace_before_ident'}->flat()), ('name' => $MATCH->{'var_name'}->flat())));
    1
})))
}))
}))));
    $MATCH
};
sub Perlito5::Grammar::exponent {
    ((my  $grammar) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    ((my  $MATCH) = Perlito5::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1)));
    ($MATCH->{'bool'} = (((do {
    ((my  $pos1) = $MATCH->{'to'});
    ((do {
    ((((do {
    ((my  $pos1) = $MATCH->{'to'});
    (((do {
    (('e' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'}))))
})) || ((do {
    ($MATCH->{'to'} = $pos1);
    (((('E' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'}))))))
})))
})) && ((do {
    ((my  $pos1) = $MATCH->{'to'});
    ((((do {
    (('+' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'}))))
})) || ((do {
    ($MATCH->{'to'} = $pos1);
    (((('-' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'}))))))
}))) || ((do {
    ($MATCH->{'to'} = $pos1);
    (1)
})))
}))) && ((do {
    ((my  $last_match_null) = 0);
    ((my  $last_pos) = $MATCH->{'to'});
    ((my  $count) = 0);
    for ( ; ((((do {
    ((my  $m2) = $grammar->digit($str, $MATCH->{'to'}));
    if (($m2->{'bool'})) {
        ($MATCH->{'to'} = $m2->{'to'});
        1
    }
    else {
        0
    }
})) && (($last_match_null < 2))));  ) {
        if ((($last_pos == $MATCH->{'to'}))) {
            ($last_match_null = ($last_match_null + 1))
        }
        else {
            ($last_match_null = 0)
        };
        ($last_pos = $MATCH->{'to'});
        ($count = ($count + 1))
    };
    ($MATCH->{'to'} = $last_pos);
    ($count > 0)
})))
}))
}))));
    $MATCH
};
sub Perlito5::Grammar::val_num {
    ((my  $grammar) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    ((my  $MATCH) = Perlito5::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1)));
    ($MATCH->{'bool'} = (((do {
    ((my  $pos1) = $MATCH->{'to'});
    ((do {
    (((do {
    ((my  $pos1) = $MATCH->{'to'});
    (((do {
    ((((('.' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'}))))) && ((do {
    ((my  $last_match_null) = 0);
    ((my  $last_pos) = $MATCH->{'to'});
    ((my  $count) = 0);
    for ( ; ((((do {
    ((my  $m2) = $grammar->digit($str, $MATCH->{'to'}));
    if (($m2->{'bool'})) {
        ($MATCH->{'to'} = $m2->{'to'});
        1
    }
    else {
        0
    }
})) && (($last_match_null < 2))));  ) {
        if ((($last_pos == $MATCH->{'to'}))) {
            ($last_match_null = ($last_match_null + 1))
        }
        else {
            ($last_match_null = 0)
        };
        ($last_pos = $MATCH->{'to'});
        ($count = ($count + 1))
    };
    ($MATCH->{'to'} = $last_pos);
    ($count > 0)
}))) && ((do {
    ((my  $last_pos) = $MATCH->{'to'});
    if ((!(((do {
    ((my  $m2) = $grammar->exponent($str, $MATCH->{'to'}));
    if (($m2->{'bool'})) {
        ($MATCH->{'to'} = $m2->{'to'});
        1
    }
    else {
        0
    }
}))))) {
        ($MATCH->{'to'} = $last_pos)
    };
    1
})))
})) || ((do {
    ($MATCH->{'to'} = $pos1);
    ((((do {
    ((my  $last_match_null) = 0);
    ((my  $last_pos) = $MATCH->{'to'});
    ((my  $count) = 0);
    for ( ; ((((do {
    ((my  $m2) = $grammar->digit($str, $MATCH->{'to'}));
    if (($m2->{'bool'})) {
        ($MATCH->{'to'} = $m2->{'to'});
        1
    }
    else {
        0
    }
})) && (($last_match_null < 2))));  ) {
        if ((($last_pos == $MATCH->{'to'}))) {
            ($last_match_null = ($last_match_null + 1))
        }
        else {
            ($last_match_null = 0)
        };
        ($last_pos = $MATCH->{'to'});
        ($count = ($count + 1))
    };
    ($MATCH->{'to'} = $last_pos);
    ($count > 0)
})) && ((do {
    ((my  $pos1) = $MATCH->{'to'});
    (((do {
    ((my  $m2) = $grammar->exponent($str, $MATCH->{'to'}));
    if (($m2->{'bool'})) {
        ($MATCH->{'to'} = $m2->{'to'});
        1
    }
    else {
        0
    }
})) || ((do {
    ($MATCH->{'to'} = $pos1);
    (((((('.' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'}))))) && ((do {
    ((my  $last_match_null) = 0);
    ((my  $last_pos) = $MATCH->{'to'});
    ((my  $count) = 0);
    for ( ; ((((do {
    ((my  $m2) = $grammar->digit($str, $MATCH->{'to'}));
    if (($m2->{'bool'})) {
        ($MATCH->{'to'} = $m2->{'to'});
        1
    }
    else {
        0
    }
})) && (($last_match_null < 2))));  ) {
        if ((($last_pos == $MATCH->{'to'}))) {
            ($last_match_null = ($last_match_null + 1))
        }
        else {
            ($last_match_null = 0)
        };
        ($last_pos = $MATCH->{'to'});
        ($count = ($count + 1))
    };
    ($MATCH->{'to'} = $last_pos);
    ($count > 0)
}))) && ((do {
    ((my  $last_pos) = $MATCH->{'to'});
    if ((!(((do {
    ((my  $m2) = $grammar->exponent($str, $MATCH->{'to'}));
    if (($m2->{'bool'})) {
        ($MATCH->{'to'} = $m2->{'to'});
        1
    }
    else {
        0
    }
}))))) {
        ($MATCH->{'to'} = $last_pos)
    };
    1
}))))
})))
}))))
})))
})) && ((do {
    ($MATCH->{'capture'} = Perlito5::AST::Val::Num->new(('num' => $MATCH->flat())));
    1
})))
}))
}))));
    $MATCH
};
sub Perlito5::Grammar::digits {
    ((my  $grammar) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    ((my  $MATCH) = Perlito5::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1)));
    ($MATCH->{'bool'} = (((do {
    ((my  $pos1) = $MATCH->{'to'});
    ((do {
    ((my  $last_match_null) = 0);
    ((my  $last_pos) = $MATCH->{'to'});
    ((my  $count) = 0);
    for ( ; ((((do {
    ((my  $m2) = $grammar->digit($str, $MATCH->{'to'}));
    if (($m2->{'bool'})) {
        ($MATCH->{'to'} = $m2->{'to'});
        1
    }
    else {
        0
    }
})) && (($last_match_null < 2))));  ) {
        if ((($last_pos == $MATCH->{'to'}))) {
            ($last_match_null = ($last_match_null + 1))
        }
        else {
            ($last_match_null = 0)
        };
        ($last_pos = $MATCH->{'to'});
        ($count = ($count + 1))
    };
    ($MATCH->{'to'} = $last_pos);
    ($count > 0)
}))
}))));
    $MATCH
};
sub Perlito5::Grammar::val_int {
    ((my  $grammar) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    ((my  $MATCH) = Perlito5::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1)));
    ($MATCH->{'bool'} = (((do {
    ((my  $pos1) = $MATCH->{'to'});
    ((do {
    (((do {
    ((my  $last_match_null) = 0);
    ((my  $last_pos) = $MATCH->{'to'});
    ((my  $count) = 0);
    for ( ; ((((do {
    ((my  $m2) = $grammar->digit($str, $MATCH->{'to'}));
    if (($m2->{'bool'})) {
        ($MATCH->{'to'} = $m2->{'to'});
        1
    }
    else {
        0
    }
})) && (($last_match_null < 2))));  ) {
        if ((($last_pos == $MATCH->{'to'}))) {
            ($last_match_null = ($last_match_null + 1))
        }
        else {
            ($last_match_null = 0)
        };
        ($last_pos = $MATCH->{'to'});
        ($count = ($count + 1))
    };
    ($MATCH->{'to'} = $last_pos);
    ($count > 0)
})) && ((do {
    ($MATCH->{'capture'} = Perlito5::AST::Val::Int->new(('int' => $MATCH->flat())));
    1
})))
}))
}))));
    $MATCH
};
(my  @PKG);
sub Perlito5::Grammar::exp_stmts {
    ((my  $grammar) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    ((my  $MATCH) = Perlito5::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1)));
    ($MATCH->{'bool'} = (((do {
    ((my  $pos1) = $MATCH->{'to'});
    ((do {
    ((((do {
    push(@PKG, $Perlito5::PKG_NAME );
    1
})) && ((do {
    ((my  $last_match_null) = 0);
    ((my  $last_pos) = $MATCH->{'to'});
    for ( ; ((((do {
    ((my  $m2) = Perlito5::Expression->delimited_statement($str, $MATCH->{'to'}));
    if (($m2->{'bool'})) {
        ($MATCH->{'to'} = $m2->{'to'});
        if ((exists($MATCH->{'Perlito5::Expression.delimited_statement'}))) {
            push(@{$MATCH->{'Perlito5::Expression.delimited_statement'}}, $m2 )
        }
        else {
            ($MATCH->{'Perlito5::Expression.delimited_statement'} = [$m2])
        };
        1
    }
    else {
        0
    }
})) && (($last_match_null < 2))));  ) {
        if ((($last_pos == $MATCH->{'to'}))) {
            ($last_match_null = ($last_match_null + 1))
        }
        else {
            ($last_match_null = 0)
        };
        ($last_pos = $MATCH->{'to'})
    };
    ($MATCH->{'to'} = $last_pos);
    1
}))) && ((do {
    ($Perlito5::PKG_NAME = pop(@PKG));
    ($MATCH->{'capture'} = [map($_->capture(), @{$MATCH->{'Perlito5::Expression.delimited_statement'}})]);
    1
})))
}))
}))));
    $MATCH
};
sub Perlito5::Grammar::opt_name {
    ((my  $grammar) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    ((my  $MATCH) = Perlito5::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1)));
    ($MATCH->{'bool'} = (((do {
    ((my  $pos1) = $MATCH->{'to'});
    ((do {
    ((my  $last_pos) = $MATCH->{'to'});
    if ((!(((do {
    ((my  $m2) = $grammar->ident($str, $MATCH->{'to'}));
    if (($m2->{'bool'})) {
        ($MATCH->{'to'} = $m2->{'to'});
        if ((exists($MATCH->{'ident'}))) {
            push(@{$MATCH->{'ident'}}, $m2 )
        }
        else {
            ($MATCH->{'ident'} = [$m2])
        };
        1
    }
    else {
        0
    }
}))))) {
        ($MATCH->{'to'} = $last_pos)
    };
    1
}))
}))));
    $MATCH
};
sub Perlito5::Grammar::args_sig {
    ((my  $grammar) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    ((my  $MATCH) = Perlito5::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1)));
    ($MATCH->{'bool'} = (((do {
    ((my  $pos1) = $MATCH->{'to'});
    ((do {
    ((my  $last_match_null) = 0);
    ((my  $last_pos) = $MATCH->{'to'});
    for ( ; ((((do {
    ((my  $pos1) = $MATCH->{'to'});
    (((((((((((do {
    ((';' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'}))))
})) || ((do {
    ($MATCH->{'to'} = $pos1);
    ((((chr(92) eq substr($str, $MATCH->{'to'}, 2)) && (($MATCH->{'to'} = (2 + $MATCH->{'to'}))))))
}))) || ((do {
    ($MATCH->{'to'} = $pos1);
    (((('[' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'}))))))
}))) || ((do {
    ($MATCH->{'to'} = $pos1);
    ((((']' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'}))))))
}))) || ((do {
    ($MATCH->{'to'} = $pos1);
    (((('*' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'}))))))
}))) || ((do {
    ($MATCH->{'to'} = $pos1);
    (((('+' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'}))))))
}))) || ((do {
    ($MATCH->{'to'} = $pos1);
    (((('@' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'}))))))
}))) || ((do {
    ($MATCH->{'to'} = $pos1);
    (((('%' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'}))))))
}))) || ((do {
    ($MATCH->{'to'} = $pos1);
    (((('$' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'}))))))
}))) || ((do {
    ($MATCH->{'to'} = $pos1);
    (((('&' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'}))))))
})))
})) && (($last_match_null < 2))));  ) {
        if ((($last_pos == $MATCH->{'to'}))) {
            ($last_match_null = ($last_match_null + 1))
        }
        else {
            ($last_match_null = 0)
        };
        ($last_pos = $MATCH->{'to'})
    };
    ($MATCH->{'to'} = $last_pos);
    1
}))
}))));
    $MATCH
};
sub Perlito5::Grammar::prototype {
    ((my  $grammar) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    ((my  $MATCH) = Perlito5::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1)));
    ($MATCH->{'bool'} = (((do {
    ((my  $pos1) = $MATCH->{'to'});
    (((do {
    ((((((((do {
    ((my  $m2) = $grammar->opt_ws($str, $MATCH->{'to'}));
    if (($m2->{'bool'})) {
        ($MATCH->{'to'} = $m2->{'to'});
        1
    }
    else {
        0
    }
})) && ((('(' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'})))))) && ((do {
    ((my  $m2) = $grammar->opt_ws($str, $MATCH->{'to'}));
    if (($m2->{'bool'})) {
        ($MATCH->{'to'} = $m2->{'to'});
        1
    }
    else {
        0
    }
}))) && ((do {
    ((my  $m2) = $grammar->args_sig($str, $MATCH->{'to'}));
    if (($m2->{'bool'})) {
        ($MATCH->{'to'} = $m2->{'to'});
        ($MATCH->{'args_sig'} = $m2);
        1
    }
    else {
        0
    }
}))) && ((do {
    ((my  $m2) = $grammar->opt_ws($str, $MATCH->{'to'}));
    if (($m2->{'bool'})) {
        ($MATCH->{'to'} = $m2->{'to'});
        1
    }
    else {
        0
    }
}))) && (((')' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'})))))) && ((do {
    ($MATCH->{'capture'} = ('' . $MATCH->{'args_sig'}->flat()));
    1
})))
})) || ((do {
    ($MATCH->{'to'} = $pos1);
    (((do {
    ($MATCH->{'capture'} = '*undef*');
    1
})))
})))
}))));
    $MATCH
};
sub Perlito5::Grammar::sub_def {
    ((my  $grammar) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    ((my  $MATCH) = Perlito5::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1)));
    ($MATCH->{'bool'} = (((do {
    ((my  $pos1) = $MATCH->{'to'});
    ((do {
    ((((((((((do {
    ((my  $m2) = $grammar->opt_name($str, $MATCH->{'to'}));
    if (($m2->{'bool'})) {
        ($MATCH->{'to'} = $m2->{'to'});
        ($MATCH->{'opt_name'} = $m2);
        1
    }
    else {
        0
    }
})) && ((do {
    ((my  $m2) = $grammar->prototype($str, $MATCH->{'to'}));
    if (($m2->{'bool'})) {
        ($MATCH->{'to'} = $m2->{'to'});
        ($MATCH->{'prototype'} = $m2);
        1
    }
    else {
        0
    }
}))) && ((do {
    ((my  $m2) = $grammar->opt_ws($str, $MATCH->{'to'}));
    if (($m2->{'bool'})) {
        ($MATCH->{'to'} = $m2->{'to'});
        1
    }
    else {
        0
    }
}))) && ((('{' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'})))))) && ((do {
    ((my  $m2) = $grammar->opt_ws($str, $MATCH->{'to'}));
    if (($m2->{'bool'})) {
        ($MATCH->{'to'} = $m2->{'to'});
        1
    }
    else {
        0
    }
}))) && ((do {
    ((my  $m2) = $grammar->exp_stmts($str, $MATCH->{'to'}));
    if (($m2->{'bool'})) {
        ($MATCH->{'to'} = $m2->{'to'});
        ($MATCH->{'exp_stmts'} = $m2);
        1
    }
    else {
        0
    }
}))) && ((do {
    ((my  $m2) = $grammar->opt_ws($str, $MATCH->{'to'}));
    if (($m2->{'bool'})) {
        ($MATCH->{'to'} = $m2->{'to'});
        1
    }
    else {
        0
    }
}))) && ((do {
    ((my  $pos1) = $MATCH->{'to'});
    (((do {
    (('}' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'}))))
})) || ((do {
    ($MATCH->{'to'} = $pos1);
    (((do {
    die('Syntax Error in sub ' . chr(39), $MATCH->{'opt_name'}->flat(), chr(39));
    1
})))
})))
}))) && ((do {
    ((my  $name) = $MATCH->{'opt_name'}->flat());
    ((my  $sig) = $MATCH->{'prototype'}->flat());
    if (($sig eq '*undef*')) {
        ($sig = undef())
    };
    (my  $namespace);
    if (($name)) {
        if ($namespace) {

        }
        else {
            ($namespace = $Perlito5::PKG_NAME)
        };
        ((my  $full_name) = ($namespace . '::' . $name));
        if (exists($Perlito5::PROTO->{$full_name})) {
            warn(('Subroutine ' . $full_name . ' redefined'))
        };
        ($Perlito5::PROTO->{$full_name} = $sig)
    };
    ($MATCH->{'capture'} = Perlito5::AST::Sub->new(('name' => $name), ('namespace' => $namespace), ('sig' => $sig), ('block' => $MATCH->{'exp_stmts'}->flat())));
    1
})))
}))
}))));
    $MATCH
};

1;
