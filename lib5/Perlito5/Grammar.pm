# Do not edit this file - Generated by Perlito5 8.0
use v5;
use utf8;
use strict;
use warnings;
no warnings ('redefine', 'once', 'void', 'uninitialized', 'misc', 'recursion');
use Perlito5::Perl5::Runtime;
use Perlito5::Perl5::Prelude;
our $MATCH = Perlito5::Match->new();
{
package main;
    sub new { shift; bless { @_ }, "main" }
    package Perlito5::Grammar;
    use Perlito5::Expression;
    use Perlito5::Grammar::Regex;
    use Perlito5::Grammar::Control;
    sub is_newline {
        my $List__ = bless \@_, "ARRAY";
        ((my  $grammar) = $List__->[0]);
        ((my  $str) = $List__->[1]);
        ((my  $pos) = $List__->[2]);
        ((my  $MATCH) = Perlito5::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1)));
        (($MATCH)->{bool} = (((do {
    ((my  $pos1) = $MATCH->to());
    (((do {
    ((((chr(10) eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to()))))) && ((do {
    ((my  $last_pos) = $MATCH->to());
    if ((!(((do {
    ((chr(13) eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to()))))
}))))) {
        (($MATCH)->{to} = $last_pos)
    };
    1
})))
})) || ((do {
    (($MATCH)->{to} = $pos1);
    (((((chr(13) eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to()))))) && ((do {
    ((my  $last_pos) = $MATCH->to());
    if ((!(((do {
    ((chr(10) eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to()))))
}))))) {
        (($MATCH)->{to} = $last_pos)
    };
    1
}))))
})))
}))));
        $MATCH
    };
    sub not_newline {
        my $List__ = bless \@_, "ARRAY";
        ((my  $grammar) = $List__->[0]);
        ((my  $str) = $List__->[1]);
        ((my  $pos) = $List__->[2]);
        ((my  $MATCH) = Perlito5::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1)));
        (($MATCH)->{bool} = (((do {
    ((my  $pos1) = $MATCH->to());
    ((do {
    (((do {
    ((my  $tmp) = $MATCH);
    ($MATCH = Perlito5::Match->new(('str' => $str), ('from' => $tmp->to()), ('to' => $tmp->to()), ('bool' => 1)));
    (($MATCH)->{bool} = ((do {
    ((my  $pos1) = $MATCH->to());
    ((do {
    ((my  $m2) = $grammar->is_newline($str, $MATCH->to()));
    if (($m2->bool())) {
        (($MATCH)->{to} = $m2->to());
        1
    }
    else {
        0
    }
}))
})));
    (($tmp)->{bool} = !($MATCH->bool()));
    ($MATCH = $tmp);
    ($MATCH->bool() ? 1 : 0)
})) && ((('' ne substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to()))))))
}))
}))));
        $MATCH
    };
    sub ident {
        my $List__ = bless \@_, "ARRAY";
        ((my  $grammar) = $List__->[0]);
        ((my  $str) = $List__->[1]);
        ((my  $pos) = $List__->[2]);
        ((my  $MATCH) = Perlito5::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1)));
        (($MATCH)->{bool} = (((do {
    ((my  $pos1) = $MATCH->to());
    ((do {
    (((do {
    ((my  $tmp) = $MATCH);
    ($MATCH = Perlito5::Match->new(('str' => $str), ('from' => $tmp->to()), ('to' => $tmp->to()), ('bool' => 1)));
    (($MATCH)->{bool} = ((do {
    ((my  $pos1) = $MATCH->to());
    ((do {
    ((my  $m2) = $grammar->digit($str, $MATCH->to()));
    if (($m2->bool())) {
        (($MATCH)->{to} = $m2->to());
        1
    }
    else {
        0
    }
}))
})));
    (($tmp)->{bool} = !($MATCH->bool()));
    ($MATCH = $tmp);
    ($MATCH->bool() ? 1 : 0)
})) && ((do {
    ((my  $last_match_null) = 0);
    ((my  $last_pos) = $MATCH->to());
    ((my  $count) = 0);
    for ( ; ((((do {
    ((my  $m2) = $grammar->word($str, $MATCH->to()));
    if (($m2->bool())) {
        (($MATCH)->{to} = $m2->to());
        1
    }
    else {
        0
    }
})) && (($last_match_null < 2))));  ) {
        if ((($last_pos == $MATCH->to()))) {
            ($last_match_null = ($last_match_null + 1))
        }
        else {
            ($last_match_null = 0)
        };
        ($last_pos = $MATCH->to());
        ($count = ($count + 1))
    };
    (($MATCH)->{to} = $last_pos);
    ($count > 0)
})))
}))
}))));
        $MATCH
    };
    sub full_ident {
        my $List__ = bless \@_, "ARRAY";
        ((my  $grammar) = $List__->[0]);
        ((my  $str) = $List__->[1]);
        ((my  $pos) = $List__->[2]);
        ((my  $MATCH) = Perlito5::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1)));
        (($MATCH)->{bool} = (((do {
    ((my  $pos1) = $MATCH->to());
    ((do {
    (((do {
    ((my  $m2) = $grammar->ident($str, $MATCH->to()));
    if (($m2->bool())) {
        (($MATCH)->{to} = $m2->to());
        1
    }
    else {
        0
    }
})) && ((do {
    ((my  $last_match_null) = 0);
    ((my  $last_pos) = $MATCH->to());
    for ( ; ((((do {
    ((my  $pos1) = $MATCH->to());
    ((do {
    (((('::' eq substr($str, $MATCH->to(), 2)) && ((($MATCH)->{to} = (2 + $MATCH->to()))))) && ((do {
    ((my  $m2) = $grammar->ident($str, $MATCH->to()));
    if (($m2->bool())) {
        (($MATCH)->{to} = $m2->to());
        1
    }
    else {
        0
    }
})))
}))
})) && (($last_match_null < 2))));  ) {
        if ((($last_pos == $MATCH->to()))) {
            ($last_match_null = ($last_match_null + 1))
        }
        else {
            ($last_match_null = 0)
        };
        ($last_pos = $MATCH->to())
    };
    (($MATCH)->{to} = $last_pos);
    1
})))
}))
}))));
        $MATCH
    };
    sub namespace_before_ident {
        my $List__ = bless \@_, "ARRAY";
        ((my  $grammar) = $List__->[0]);
        ((my  $str) = $List__->[1]);
        ((my  $pos) = $List__->[2]);
        ((my  $MATCH) = Perlito5::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1)));
        (($MATCH)->{bool} = (((do {
    ((my  $pos1) = $MATCH->to());
    ((do {
    ((((do {
    ((my  $m2) = $grammar->ident($str, $MATCH->to()));
    if (($m2->bool())) {
        (($MATCH)->{to} = $m2->to());
        1
    }
    else {
        0
    }
})) && ((do {
    ((my  $tmp) = $MATCH);
    ($MATCH = Perlito5::Match->new(('str' => $str), ('from' => $tmp->to()), ('to' => $tmp->to()), ('bool' => 1)));
    (($MATCH)->{bool} = ((do {
    ((my  $pos1) = $MATCH->to());
    ((do {
    (('::' eq substr($str, $MATCH->to(), 2)) && ((($MATCH)->{to} = (2 + $MATCH->to()))))
}))
})));
    (($tmp)->{bool} = ($MATCH->bool() ? 1 : 0));
    ($MATCH = $tmp);
    ($MATCH->bool() ? 1 : 0)
}))) && ((do {
    ((my  $last_match_null) = 0);
    ((my  $last_pos) = $MATCH->to());
    for ( ; ((((do {
    ((my  $pos1) = $MATCH->to());
    ((do {
    ((((('::' eq substr($str, $MATCH->to(), 2)) && ((($MATCH)->{to} = (2 + $MATCH->to()))))) && ((do {
    ((my  $m2) = $grammar->ident($str, $MATCH->to()));
    if (($m2->bool())) {
        (($MATCH)->{to} = $m2->to());
        1
    }
    else {
        0
    }
}))) && ((do {
    ((my  $tmp) = $MATCH);
    ($MATCH = Perlito5::Match->new(('str' => $str), ('from' => $tmp->to()), ('to' => $tmp->to()), ('bool' => 1)));
    (($MATCH)->{bool} = ((do {
    ((my  $pos1) = $MATCH->to());
    ((do {
    (('::' eq substr($str, $MATCH->to(), 2)) && ((($MATCH)->{to} = (2 + $MATCH->to()))))
}))
})));
    (($tmp)->{bool} = ($MATCH->bool() ? 1 : 0));
    ($MATCH = $tmp);
    ($MATCH->bool() ? 1 : 0)
})))
}))
})) && (($last_match_null < 2))));  ) {
        if ((($last_pos == $MATCH->to()))) {
            ($last_match_null = ($last_match_null + 1))
        }
        else {
            ($last_match_null = 0)
        };
        ($last_pos = $MATCH->to())
    };
    (($MATCH)->{to} = $last_pos);
    1
})))
}))
}))));
        $MATCH
    };
    sub optional_namespace_before_ident {
        my $List__ = bless \@_, "ARRAY";
        ((my  $grammar) = $List__->[0]);
        ((my  $str) = $List__->[1]);
        ((my  $pos) = $List__->[2]);
        ((my  $MATCH) = Perlito5::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1)));
        (($MATCH)->{bool} = (((do {
    ((my  $pos1) = $MATCH->to());
    (((do {
    ((((do {
    ((my  $m2) = $grammar->namespace_before_ident($str, $MATCH->to()));
    if (($m2->bool())) {
        (($MATCH)->{to} = $m2->to());
        ($MATCH->{'namespace_before_ident'} = $m2);
        1
    }
    else {
        0
    }
})) && ((('::' eq substr($str, $MATCH->to(), 2)) && ((($MATCH)->{to} = (2 + $MATCH->to())))))) && ((do {
    (($MATCH)->{capture} = $MATCH->{('namespace_before_ident')}->flat());
    1
})))
})) || ((do {
    (($MATCH)->{to} = $pos1);
    ((1 && ((do {
    (($MATCH)->{capture} = '');
    1
}))))
})))
}))));
        $MATCH
    };
    sub pod_begin {
        my $List__ = bless \@_, "ARRAY";
        ((my  $grammar) = $List__->[0]);
        ((my  $str) = $List__->[1]);
        ((my  $pos) = $List__->[2]);
        ((my  $MATCH) = Perlito5::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1)));
        (($MATCH)->{bool} = (((do {
    ((my  $pos1) = $MATCH->to());
    (((do {
    ((((do {
    ((my  $m2) = $grammar->is_newline($str, $MATCH->to()));
    if (($m2->bool())) {
        (($MATCH)->{to} = $m2->to());
        1
    }
    else {
        0
    }
})) && (((chr(61) . 'end' eq substr($str, $MATCH->to(), 4)) && ((($MATCH)->{to} = (4 + $MATCH->to())))))) && ((do {
    ((my  $last_match_null) = 0);
    ((my  $last_pos) = $MATCH->to());
    for ( ; ((((do {
    ((my  $m2) = $grammar->not_newline($str, $MATCH->to()));
    if (($m2->bool())) {
        (($MATCH)->{to} = $m2->to());
        1
    }
    else {
        0
    }
})) && (($last_match_null < 2))));  ) {
        if ((($last_pos == $MATCH->to()))) {
            ($last_match_null = ($last_match_null + 1))
        }
        else {
            ($last_match_null = 0)
        };
        ($last_pos = $MATCH->to())
    };
    (($MATCH)->{to} = $last_pos);
    1
})))
})) || ((do {
    (($MATCH)->{to} = $pos1);
    (((((('' ne substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to()))))) && ((do {
    ((my  $last_match_null) = 0);
    ((my  $last_pos) = $MATCH->to());
    for ( ; ((((do {
    ((my  $m2) = $grammar->not_newline($str, $MATCH->to()));
    if (($m2->bool())) {
        (($MATCH)->{to} = $m2->to());
        1
    }
    else {
        0
    }
})) && (($last_match_null < 2))));  ) {
        if ((($last_pos == $MATCH->to()))) {
            ($last_match_null = ($last_match_null + 1))
        }
        else {
            ($last_match_null = 0)
        };
        ($last_pos = $MATCH->to())
    };
    (($MATCH)->{to} = $last_pos);
    1
}))) && ((do {
    ((my  $m2) = $grammar->pod_begin($str, $MATCH->to()));
    if (($m2->bool())) {
        (($MATCH)->{to} = $m2->to());
        1
    }
    else {
        0
    }
}))))
})))
}))));
        $MATCH
    };
    sub ws {
        my $List__ = bless \@_, "ARRAY";
        ((my  $grammar) = $List__->[0]);
        ((my  $str) = $List__->[1]);
        ((my  $pos) = $List__->[2]);
        ((my  $MATCH) = Perlito5::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1)));
        (($MATCH)->{bool} = (((do {
    ((my  $pos1) = $MATCH->to());
    ((do {
    ((my  $last_match_null) = 0);
    ((my  $last_pos) = $MATCH->to());
    ((my  $count) = 0);
    for ( ; ((((do {
    ((my  $pos1) = $MATCH->to());
    ((((do {
    ((((chr(35) eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to()))))) && ((do {
    ((my  $last_match_null) = 0);
    ((my  $last_pos) = $MATCH->to());
    for ( ; ((((do {
    ((my  $m2) = $grammar->not_newline($str, $MATCH->to()));
    if (($m2->bool())) {
        (($MATCH)->{to} = $m2->to());
        1
    }
    else {
        0
    }
})) && (($last_match_null < 2))));  ) {
        if ((($last_pos == $MATCH->to()))) {
            ($last_match_null = ($last_match_null + 1))
        }
        else {
            ($last_match_null = 0)
        };
        ($last_pos = $MATCH->to())
    };
    (($MATCH)->{to} = $last_pos);
    1
})))
})) || ((do {
    (($MATCH)->{to} = $pos1);
    ((((do {
    ((my  $pos1) = $MATCH->to());
    (((do {
    ((((chr(10) eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to()))))) && ((do {
    ((my  $last_pos) = $MATCH->to());
    if ((!(((do {
    ((chr(13) eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to()))))
}))))) {
        (($MATCH)->{to} = $last_pos)
    };
    1
})))
})) || ((do {
    (($MATCH)->{to} = $pos1);
    (((((chr(13) eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to()))))) && ((do {
    ((my  $last_pos) = $MATCH->to());
    if ((!(((do {
    ((chr(10) eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to()))))
}))))) {
        (($MATCH)->{to} = $last_pos)
    };
    1
}))))
})))
})) && ((do {
    ((my  $pos1) = $MATCH->to());
    ((((do {
    ((((chr(61) . 'begin' eq substr($str, $MATCH->to(), 6)) && ((($MATCH)->{to} = (6 + $MATCH->to()))))) && ((do {
    ((my  $m2) = $grammar->pod_begin($str, $MATCH->to()));
    if (($m2->bool())) {
        (($MATCH)->{to} = $m2->to());
        1
    }
    else {
        0
    }
})))
})) || ((do {
    (($MATCH)->{to} = $pos1);
    (((((chr(61) . 'for' eq substr($str, $MATCH->to(), 4)) && ((($MATCH)->{to} = (4 + $MATCH->to()))))) && ((do {
    ((my  $m2) = $grammar->pod_begin($str, $MATCH->to()));
    if (($m2->bool())) {
        (($MATCH)->{to} = $m2->to());
        1
    }
    else {
        0
    }
}))))
}))) || ((do {
    (($MATCH)->{to} = $pos1);
    (1)
})))
}))))
}))) || ((do {
    (($MATCH)->{to} = $pos1);
    (((do {
    ((my  $m2) = $grammar->space($str, $MATCH->to()));
    if (($m2->bool())) {
        (($MATCH)->{to} = $m2->to());
        1
    }
    else {
        0
    }
})))
})))
})) && (($last_match_null < 2))));  ) {
        if ((($last_pos == $MATCH->to()))) {
            ($last_match_null = ($last_match_null + 1))
        }
        else {
            ($last_match_null = 0)
        };
        ($last_pos = $MATCH->to());
        ($count = ($count + 1))
    };
    (($MATCH)->{to} = $last_pos);
    ($count > 0)
}))
}))));
        $MATCH
    };
    sub opt_ws {
        my $List__ = bless \@_, "ARRAY";
        ((my  $grammar) = $List__->[0]);
        ((my  $str) = $List__->[1]);
        ((my  $pos) = $List__->[2]);
        ((my  $MATCH) = Perlito5::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1)));
        (($MATCH)->{bool} = (((do {
    ((my  $pos1) = $MATCH->to());
    ((do {
    ((my  $last_pos) = $MATCH->to());
    if ((!(((do {
    ((my  $m2) = $grammar->ws($str, $MATCH->to()));
    if (($m2->bool())) {
        (($MATCH)->{to} = $m2->to());
        1
    }
    else {
        0
    }
}))))) {
        (($MATCH)->{to} = $last_pos)
    };
    1
}))
}))));
        $MATCH
    };
    sub opt_ws2 {
        my $List__ = bless \@_, "ARRAY";
        ((my  $grammar) = $List__->[0]);
        ((my  $str) = $List__->[1]);
        ((my  $pos) = $List__->[2]);
        ((my  $MATCH) = Perlito5::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1)));
        (($MATCH)->{bool} = (((do {
    ((my  $pos1) = $MATCH->to());
    ((do {
    ((my  $last_pos) = $MATCH->to());
    if ((!(((do {
    ((my  $m2) = $grammar->ws($str, $MATCH->to()));
    if (($m2->bool())) {
        (($MATCH)->{to} = $m2->to());
        1
    }
    else {
        0
    }
}))))) {
        (($MATCH)->{to} = $last_pos)
    };
    1
}))
}))));
        $MATCH
    };
    sub opt_ws3 {
        my $List__ = bless \@_, "ARRAY";
        ((my  $grammar) = $List__->[0]);
        ((my  $str) = $List__->[1]);
        ((my  $pos) = $List__->[2]);
        ((my  $MATCH) = Perlito5::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1)));
        (($MATCH)->{bool} = (((do {
    ((my  $pos1) = $MATCH->to());
    ((do {
    ((my  $last_pos) = $MATCH->to());
    if ((!(((do {
    ((my  $m2) = $grammar->ws($str, $MATCH->to()));
    if (($m2->bool())) {
        (($MATCH)->{to} = $m2->to());
        1
    }
    else {
        0
    }
}))))) {
        (($MATCH)->{to} = $last_pos)
    };
    1
}))
}))));
        $MATCH
    };
    sub grammar {
        my $List__ = bless \@_, "ARRAY";
        ((my  $grammar) = $List__->[0]);
        ((my  $str) = $List__->[1]);
        ((my  $pos) = $List__->[2]);
        ((my  $MATCH) = Perlito5::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1)));
        (($MATCH)->{bool} = (((do {
    ((my  $pos1) = $MATCH->to());
    ((do {
    (((((((((do {
    ((my  $m2) = $grammar->full_ident($str, $MATCH->to()));
    if (($m2->bool())) {
        (($MATCH)->{to} = $m2->to());
        ($MATCH->{'full_ident'} = $m2);
        1
    }
    else {
        0
    }
})) && ((do {
    ((my  $last_pos) = $MATCH->to());
    if ((!(((do {
    ((my  $m2) = $grammar->ws($str, $MATCH->to()));
    if (($m2->bool())) {
        (($MATCH)->{to} = $m2->to());
        1
    }
    else {
        0
    }
}))))) {
        (($MATCH)->{to} = $last_pos)
    };
    1
}))) && (((chr(123) eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to())))))) && ((do {
    ((my  $last_pos) = $MATCH->to());
    if ((!(((do {
    ((my  $m2) = $grammar->ws($str, $MATCH->to()));
    if (($m2->bool())) {
        (($MATCH)->{to} = $m2->to());
        1
    }
    else {
        0
    }
}))))) {
        (($MATCH)->{to} = $last_pos)
    };
    1
}))) && ((do {
    ((my  $m2) = $grammar->exp_stmts($str, $MATCH->to()));
    if (($m2->bool())) {
        (($MATCH)->{to} = $m2->to());
        ($MATCH->{'exp_stmts'} = $m2);
        1
    }
    else {
        0
    }
}))) && ((do {
    ((my  $last_pos) = $MATCH->to());
    if ((!(((do {
    ((my  $m2) = $grammar->ws($str, $MATCH->to()));
    if (($m2->bool())) {
        (($MATCH)->{to} = $m2->to());
        1
    }
    else {
        0
    }
}))))) {
        (($MATCH)->{to} = $last_pos)
    };
    1
}))) && (((chr(125) eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to())))))) && ((do {
    (($MATCH)->{capture} = CompUnit->new(('name' => $MATCH->{('full_ident')}->flat()), ('body' => $MATCH->{('exp_stmts')}->flat())));
    1
})))
}))
}))));
        $MATCH
    };
    sub declarator {
        my $List__ = bless \@_, "ARRAY";
        ((my  $grammar) = $List__->[0]);
        ((my  $str) = $List__->[1]);
        ((my  $pos) = $List__->[2]);
        ((my  $MATCH) = Perlito5::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1)));
        (($MATCH)->{bool} = (((do {
    ((my  $pos1) = $MATCH->to());
    ((((do {
    (('my' eq substr($str, $MATCH->to(), 2)) && ((($MATCH)->{to} = (2 + $MATCH->to()))))
})) || ((do {
    (($MATCH)->{to} = $pos1);
    (((('state' eq substr($str, $MATCH->to(), 5)) && ((($MATCH)->{to} = (5 + $MATCH->to()))))))
}))) || ((do {
    (($MATCH)->{to} = $pos1);
    (((('has' eq substr($str, $MATCH->to(), 3)) && ((($MATCH)->{to} = (3 + $MATCH->to()))))))
})))
}))));
        $MATCH
    };
    sub exp_stmts2 {
        my $List__ = bless \@_, "ARRAY";
        ((my  $grammar) = $List__->[0]);
        ((my  $str) = $List__->[1]);
        ((my  $pos) = $List__->[2]);
        ((my  $MATCH) = Perlito5::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1)));
        (($MATCH)->{bool} = (((do {
    ((my  $pos1) = $MATCH->to());
    ((do {
    (((do {
    ((my  $m2) = $grammar->exp_stmts($str, $MATCH->to()));
    if (($m2->bool())) {
        (($MATCH)->{to} = $m2->to());
        ($MATCH->{'exp_stmts'} = $m2);
        1
    }
    else {
        0
    }
})) && ((do {
    (($MATCH)->{capture} = $MATCH->{('exp_stmts')}->flat());
    1
})))
}))
}))));
        $MATCH
    };
    sub exp {
        my $List__ = bless \@_, "ARRAY";
        ((my  $grammar) = $List__->[0]);
        ((my  $str) = $List__->[1]);
        ((my  $pos) = $List__->[2]);
        ((my  $MATCH) = Perlito5::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1)));
        (($MATCH)->{bool} = (((do {
    ((my  $pos1) = $MATCH->to());
    ((do {
    (((do {
    ((my  $m2) = Perlito5::Expression->exp_parse($str, $MATCH->to()));
    if (($m2->bool())) {
        (($MATCH)->{to} = $m2->to());
        ($MATCH->{'Perlito5::Expression.exp_parse'} = $m2);
        1
    }
    else {
        0
    }
})) && ((do {
    (($MATCH)->{capture} = $MATCH->{('Perlito5::Expression.exp_parse')}->flat());
    1
})))
}))
}))));
        $MATCH
    };
    sub exp2 {
        my $List__ = bless \@_, "ARRAY";
        ((my  $grammar) = $List__->[0]);
        ((my  $str) = $List__->[1]);
        ((my  $pos) = $List__->[2]);
        ((my  $MATCH) = Perlito5::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1)));
        (($MATCH)->{bool} = (((do {
    ((my  $pos1) = $MATCH->to());
    ((do {
    (((do {
    ((my  $m2) = Perlito5::Expression->exp_parse($str, $MATCH->to()));
    if (($m2->bool())) {
        (($MATCH)->{to} = $m2->to());
        ($MATCH->{'Perlito5::Expression.exp_parse'} = $m2);
        1
    }
    else {
        0
    }
})) && ((do {
    (($MATCH)->{capture} = $MATCH->{('Perlito5::Expression.exp_parse')}->flat());
    1
})))
}))
}))));
        $MATCH
    };
    sub opt_ident {
        my $List__ = bless \@_, "ARRAY";
        ((my  $grammar) = $List__->[0]);
        ((my  $str) = $List__->[1]);
        ((my  $pos) = $List__->[2]);
        ((my  $MATCH) = Perlito5::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1)));
        (($MATCH)->{bool} = (((do {
    ((my  $pos1) = $MATCH->to());
    (((do {
    (((do {
    ((my  $m2) = $grammar->ident($str, $MATCH->to()));
    if (($m2->bool())) {
        (($MATCH)->{to} = $m2->to());
        ($MATCH->{'ident'} = $m2);
        1
    }
    else {
        0
    }
})) && ((do {
    (($MATCH)->{capture} = $MATCH->{('ident')}->flat());
    1
})))
})) || ((do {
    (($MATCH)->{to} = $pos1);
    ((1 && ((do {
    (($MATCH)->{capture} = 'postcircumfix:<( )>');
    1
}))))
})))
}))));
        $MATCH
    };
    sub opt_type {
        my $List__ = bless \@_, "ARRAY";
        ((my  $grammar) = $List__->[0]);
        ((my  $str) = $List__->[1]);
        ((my  $pos) = $List__->[2]);
        ((my  $MATCH) = Perlito5::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1)));
        (($MATCH)->{bool} = (((do {
    ((my  $pos1) = $MATCH->to());
    (((do {
    ((((do {
    ((my  $last_pos) = $MATCH->to());
    if ((!(((do {
    (('::' eq substr($str, $MATCH->to(), 2)) && ((($MATCH)->{to} = (2 + $MATCH->to()))))
}))))) {
        (($MATCH)->{to} = $last_pos)
    };
    1
})) && ((do {
    ((my  $m2) = $grammar->full_ident($str, $MATCH->to()));
    if (($m2->bool())) {
        (($MATCH)->{to} = $m2->to());
        ($MATCH->{'full_ident'} = $m2);
        1
    }
    else {
        0
    }
}))) && ((do {
    (($MATCH)->{capture} = $MATCH->{('full_ident')}->flat());
    1
})))
})) || ((do {
    (($MATCH)->{to} = $pos1);
    ((1 && ((do {
    (($MATCH)->{capture} = '');
    1
}))))
})))
}))));
        $MATCH
    };
    sub var_sigil {
        my $List__ = bless \@_, "ARRAY";
        ((my  $grammar) = $List__->[0]);
        ((my  $str) = $List__->[1]);
        ((my  $pos) = $List__->[2]);
        ((my  $MATCH) = Perlito5::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1)));
        (($MATCH)->{bool} = (((do {
    ((my  $pos1) = $MATCH->to());
    (((((do {
    ((chr(36) eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to()))))
})) || ((do {
    (($MATCH)->{to} = $pos1);
    ((((chr(37) eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to()))))))
}))) || ((do {
    (($MATCH)->{to} = $pos1);
    ((((chr(64) eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to()))))))
}))) || ((do {
    (($MATCH)->{to} = $pos1);
    ((((chr(38) eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to()))))))
})))
}))));
        $MATCH
    };
    sub var_twigil {
        my $List__ = bless \@_, "ARRAY";
        ((my  $grammar) = $List__->[0]);
        ((my  $str) = $List__->[1]);
        ((my  $pos) = $List__->[2]);
        ((my  $MATCH) = Perlito5::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1)));
        (($MATCH)->{bool} = (((do {
    ((my  $pos1) = $MATCH->to());
    ((do {
    ((my  $last_pos) = $MATCH->to());
    if ((!(((do {
    ((my  $pos1) = $MATCH->to());
    (((((do {
    (('.' eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to()))))
})) || ((do {
    (($MATCH)->{to} = $pos1);
    ((((chr(33) eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to()))))))
}))) || ((do {
    (($MATCH)->{to} = $pos1);
    ((((chr(94) eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to()))))))
}))) || ((do {
    (($MATCH)->{to} = $pos1);
    (((('*' eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to()))))))
})))
}))))) {
        (($MATCH)->{to} = $last_pos)
    };
    1
}))
}))));
        $MATCH
    };
    sub var_name {
        my $List__ = bless \@_, "ARRAY";
        ((my  $grammar) = $List__->[0]);
        ((my  $str) = $List__->[1]);
        ((my  $pos) = $List__->[2]);
        ((my  $MATCH) = Perlito5::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1)));
        (($MATCH)->{bool} = (((do {
    ((my  $pos1) = $MATCH->to());
    (((do {
    ((my  $m2) = $grammar->full_ident($str, $MATCH->to()));
    if (($m2->bool())) {
        (($MATCH)->{to} = $m2->to());
        ($MATCH->{'full_ident'} = $m2);
        1
    }
    else {
        0
    }
})) || ((do {
    (($MATCH)->{to} = $pos1);
    (((do {
    ((my  $m2) = $grammar->digit($str, $MATCH->to()));
    if (($m2->bool())) {
        (($MATCH)->{to} = $m2->to());
        ($MATCH->{'digit'} = $m2);
        1
    }
    else {
        0
    }
})))
})))
}))));
        $MATCH
    };
    sub var_ident {
        my $List__ = bless \@_, "ARRAY";
        ((my  $grammar) = $List__->[0]);
        ((my  $str) = $List__->[1]);
        ((my  $pos) = $List__->[2]);
        ((my  $MATCH) = Perlito5::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1)));
        (($MATCH)->{bool} = (((do {
    ((my  $pos1) = $MATCH->to());
    ((do {
    ((((((do {
    ((my  $m2) = $grammar->var_sigil($str, $MATCH->to()));
    if (($m2->bool())) {
        (($MATCH)->{to} = $m2->to());
        ($MATCH->{'var_sigil'} = $m2);
        1
    }
    else {
        0
    }
})) && ((do {
    ((my  $m2) = $grammar->var_twigil($str, $MATCH->to()));
    if (($m2->bool())) {
        (($MATCH)->{to} = $m2->to());
        ($MATCH->{'var_twigil'} = $m2);
        1
    }
    else {
        0
    }
}))) && ((do {
    ((my  $m2) = $grammar->optional_namespace_before_ident($str, $MATCH->to()));
    if (($m2->bool())) {
        (($MATCH)->{to} = $m2->to());
        ($MATCH->{'optional_namespace_before_ident'} = $m2);
        1
    }
    else {
        0
    }
}))) && ((do {
    ((my  $m2) = $grammar->var_name($str, $MATCH->to()));
    if (($m2->bool())) {
        (($MATCH)->{to} = $m2->to());
        ($MATCH->{'var_name'} = $m2);
        1
    }
    else {
        0
    }
}))) && ((do {
    (($MATCH)->{capture} = Var->new(('sigil' => $MATCH->{('var_sigil')}->flat()), ('twigil' => $MATCH->{('var_twigil')}->flat()), ('namespace' => $MATCH->{('optional_namespace_before_ident')}->flat()), ('name' => $MATCH->{('var_name')}->flat())));
    1
})))
}))
}))));
        $MATCH
    };
    sub exponent {
        my $List__ = bless \@_, "ARRAY";
        ((my  $grammar) = $List__->[0]);
        ((my  $str) = $List__->[1]);
        ((my  $pos) = $List__->[2]);
        ((my  $MATCH) = Perlito5::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1)));
        (($MATCH)->{bool} = (((do {
    ((my  $pos1) = $MATCH->to());
    ((do {
    ((((do {
    ((my  $pos1) = $MATCH->to());
    (((do {
    (('e' eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to()))))
})) || ((do {
    (($MATCH)->{to} = $pos1);
    (((('E' eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to()))))))
})))
})) && ((do {
    ((my  $pos1) = $MATCH->to());
    ((((do {
    (('+' eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to()))))
})) || ((do {
    (($MATCH)->{to} = $pos1);
    (((('-' eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to()))))))
}))) || ((do {
    (($MATCH)->{to} = $pos1);
    (1)
})))
}))) && ((do {
    ((my  $last_match_null) = 0);
    ((my  $last_pos) = $MATCH->to());
    ((my  $count) = 0);
    for ( ; ((((do {
    ((my  $m2) = $grammar->digit($str, $MATCH->to()));
    if (($m2->bool())) {
        (($MATCH)->{to} = $m2->to());
        1
    }
    else {
        0
    }
})) && (($last_match_null < 2))));  ) {
        if ((($last_pos == $MATCH->to()))) {
            ($last_match_null = ($last_match_null + 1))
        }
        else {
            ($last_match_null = 0)
        };
        ($last_pos = $MATCH->to());
        ($count = ($count + 1))
    };
    (($MATCH)->{to} = $last_pos);
    ($count > 0)
})))
}))
}))));
        $MATCH
    };
    sub val_num {
        my $List__ = bless \@_, "ARRAY";
        ((my  $grammar) = $List__->[0]);
        ((my  $str) = $List__->[1]);
        ((my  $pos) = $List__->[2]);
        ((my  $MATCH) = Perlito5::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1)));
        (($MATCH)->{bool} = (((do {
    ((my  $pos1) = $MATCH->to());
    ((do {
    (((do {
    ((my  $pos1) = $MATCH->to());
    (((do {
    ((((('.' eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to()))))) && ((do {
    ((my  $last_match_null) = 0);
    ((my  $last_pos) = $MATCH->to());
    ((my  $count) = 0);
    for ( ; ((((do {
    ((my  $m2) = $grammar->digit($str, $MATCH->to()));
    if (($m2->bool())) {
        (($MATCH)->{to} = $m2->to());
        1
    }
    else {
        0
    }
})) && (($last_match_null < 2))));  ) {
        if ((($last_pos == $MATCH->to()))) {
            ($last_match_null = ($last_match_null + 1))
        }
        else {
            ($last_match_null = 0)
        };
        ($last_pos = $MATCH->to());
        ($count = ($count + 1))
    };
    (($MATCH)->{to} = $last_pos);
    ($count > 0)
}))) && ((do {
    ((my  $last_pos) = $MATCH->to());
    if ((!(((do {
    ((my  $m2) = $grammar->exponent($str, $MATCH->to()));
    if (($m2->bool())) {
        (($MATCH)->{to} = $m2->to());
        1
    }
    else {
        0
    }
}))))) {
        (($MATCH)->{to} = $last_pos)
    };
    1
})))
})) || ((do {
    (($MATCH)->{to} = $pos1);
    ((((do {
    ((my  $last_match_null) = 0);
    ((my  $last_pos) = $MATCH->to());
    ((my  $count) = 0);
    for ( ; ((((do {
    ((my  $m2) = $grammar->digit($str, $MATCH->to()));
    if (($m2->bool())) {
        (($MATCH)->{to} = $m2->to());
        1
    }
    else {
        0
    }
})) && (($last_match_null < 2))));  ) {
        if ((($last_pos == $MATCH->to()))) {
            ($last_match_null = ($last_match_null + 1))
        }
        else {
            ($last_match_null = 0)
        };
        ($last_pos = $MATCH->to());
        ($count = ($count + 1))
    };
    (($MATCH)->{to} = $last_pos);
    ($count > 0)
})) && ((do {
    ((my  $pos1) = $MATCH->to());
    (((do {
    ((my  $m2) = $grammar->exponent($str, $MATCH->to()));
    if (($m2->bool())) {
        (($MATCH)->{to} = $m2->to());
        1
    }
    else {
        0
    }
})) || ((do {
    (($MATCH)->{to} = $pos1);
    (((((('.' eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to()))))) && ((do {
    ((my  $last_match_null) = 0);
    ((my  $last_pos) = $MATCH->to());
    ((my  $count) = 0);
    for ( ; ((((do {
    ((my  $m2) = $grammar->digit($str, $MATCH->to()));
    if (($m2->bool())) {
        (($MATCH)->{to} = $m2->to());
        1
    }
    else {
        0
    }
})) && (($last_match_null < 2))));  ) {
        if ((($last_pos == $MATCH->to()))) {
            ($last_match_null = ($last_match_null + 1))
        }
        else {
            ($last_match_null = 0)
        };
        ($last_pos = $MATCH->to());
        ($count = ($count + 1))
    };
    (($MATCH)->{to} = $last_pos);
    ($count > 0)
}))) && ((do {
    ((my  $last_pos) = $MATCH->to());
    if ((!(((do {
    ((my  $m2) = $grammar->exponent($str, $MATCH->to()));
    if (($m2->bool())) {
        (($MATCH)->{to} = $m2->to());
        1
    }
    else {
        0
    }
}))))) {
        (($MATCH)->{to} = $last_pos)
    };
    1
}))))
})))
}))))
})))
})) && ((do {
    (($MATCH)->{capture} = Val::Num->new(('num' => $MATCH->flat())));
    1
})))
}))
}))));
        $MATCH
    };
    sub char_any {
        my $List__ = bless \@_, "ARRAY";
        ((my  $grammar) = $List__->[0]);
        ((my  $str) = $List__->[1]);
        ((my  $pos) = $List__->[2]);
        ((my  $MATCH) = Perlito5::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1)));
        (($MATCH)->{bool} = (((do {
    ((my  $pos1) = $MATCH->to());
    ((do {
    (('' ne substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to()))))
}))
}))));
        $MATCH
    };
    sub char_any_single_quote {
        my $List__ = bless \@_, "ARRAY";
        ((my  $grammar) = $List__->[0]);
        ((my  $str) = $List__->[1]);
        ((my  $pos) = $List__->[2]);
        ((my  $MATCH) = Perlito5::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1)));
        (($MATCH)->{bool} = (((do {
    ((my  $pos1) = $MATCH->to());
    ((do {
    ((((do {
    ((my  $tmp) = $MATCH);
    ($MATCH = Perlito5::Match->new(('str' => $str), ('from' => $tmp->to()), ('to' => $tmp->to()), ('bool' => 1)));
    (($MATCH)->{bool} = ((do {
    ((my  $pos1) = $MATCH->to());
    ((do {
    ((chr(39) eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to()))))
}))
})));
    (($tmp)->{bool} = !($MATCH->bool()));
    ($MATCH = $tmp);
    ($MATCH->bool() ? 1 : 0)
})) && ((('' ne substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to())))))) && ((do {
    ((my  $last_match_null) = 0);
    ((my  $last_pos) = $MATCH->to());
    for ( ; ((((do {
    ((my  $pos1) = $MATCH->to());
    ((do {
    (((do {
    ((my  $tmp) = $MATCH);
    ($MATCH = Perlito5::Match->new(('str' => $str), ('from' => $tmp->to()), ('to' => $tmp->to()), ('bool' => 1)));
    (($MATCH)->{bool} = ((do {
    ((my  $pos1) = $MATCH->to());
    ((do {
    ((my  $pos1) = $MATCH->to());
    (((do {
    ((chr(39) eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to()))))
})) || ((do {
    (($MATCH)->{to} = $pos1);
    ((((chr(92) eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to()))))))
})))
}))
})));
    (($tmp)->{bool} = !($MATCH->bool()));
    ($MATCH = $tmp);
    ($MATCH->bool() ? 1 : 0)
})) && ((('' ne substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to()))))))
}))
})) && (($last_match_null < 2))));  ) {
        if ((($last_pos == $MATCH->to()))) {
            ($last_match_null = ($last_match_null + 1))
        }
        else {
            ($last_match_null = 0)
        };
        ($last_pos = $MATCH->to())
    };
    (($MATCH)->{to} = $last_pos);
    1
})))
}))
}))));
        $MATCH
    };
    sub single_quoted_unescape {
        my $List__ = bless \@_, "ARRAY";
        ((my  $grammar) = $List__->[0]);
        ((my  $str) = $List__->[1]);
        ((my  $pos) = $List__->[2]);
        ((my  $MATCH) = Perlito5::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1)));
        (($MATCH)->{bool} = (((do {
    ((my  $pos1) = $MATCH->to());
    ((((((do {
    ((((((chr(92) eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to()))))) && (((chr(92) eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to())))))) && ((do {
    ((my  $m2) = $grammar->single_quoted_unescape($str, $MATCH->to()));
    if (($m2->bool())) {
        (($MATCH)->{to} = $m2->to());
        ($MATCH->{'single_quoted_unescape'} = $m2);
        1
    }
    else {
        0
    }
}))) && ((do {
    (($MATCH)->{capture} = (chr(92) . $MATCH->{('single_quoted_unescape')}->flat()));
    1
})))
})) || ((do {
    (($MATCH)->{to} = $pos1);
    (((((((chr(92) eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to()))))) && (((chr(39) eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to())))))) && ((do {
    ((my  $m2) = $grammar->single_quoted_unescape($str, $MATCH->to()));
    if (($m2->bool())) {
        (($MATCH)->{to} = $m2->to());
        ($MATCH->{'single_quoted_unescape'} = $m2);
        1
    }
    else {
        0
    }
}))) && ((do {
    (($MATCH)->{capture} = (chr(39) . $MATCH->{('single_quoted_unescape')}->flat()));
    1
}))))
}))) || ((do {
    (($MATCH)->{to} = $pos1);
    ((((((chr(92) eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to()))))) && ((do {
    ((my  $m2) = $grammar->single_quoted_unescape($str, $MATCH->to()));
    if (($m2->bool())) {
        (($MATCH)->{to} = $m2->to());
        ($MATCH->{'single_quoted_unescape'} = $m2);
        1
    }
    else {
        0
    }
}))) && ((do {
    (($MATCH)->{capture} = (chr(92) . $MATCH->{('single_quoted_unescape')}));
    1
}))))
}))) || ((do {
    (($MATCH)->{to} = $pos1);
    (((((do {
    ((my  $m2) = $grammar->char_any_single_quote($str, $MATCH->to()));
    if (($m2->bool())) {
        (($MATCH)->{to} = $m2->to());
        ($MATCH->{'char_any_single_quote'} = $m2);
        1
    }
    else {
        0
    }
})) && ((do {
    ((my  $m2) = $grammar->single_quoted_unescape($str, $MATCH->to()));
    if (($m2->bool())) {
        (($MATCH)->{to} = $m2->to());
        ($MATCH->{'single_quoted_unescape'} = $m2);
        1
    }
    else {
        0
    }
}))) && ((do {
    (($MATCH)->{capture} = ($MATCH->{('char_any_single_quote')} . $MATCH->{('single_quoted_unescape')}));
    1
}))))
}))) || ((do {
    (($MATCH)->{to} = $pos1);
    (1)
})))
}))));
        $MATCH
    };
    sub char_any_double_quote {
        my $List__ = bless \@_, "ARRAY";
        ((my  $grammar) = $List__->[0]);
        ((my  $str) = $List__->[1]);
        ((my  $pos) = $List__->[2]);
        ((my  $MATCH) = Perlito5::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1)));
        (($MATCH)->{bool} = (((do {
    ((my  $pos1) = $MATCH->to());
    ((do {
    ((((do {
    ((my  $tmp) = $MATCH);
    ($MATCH = Perlito5::Match->new(('str' => $str), ('from' => $tmp->to()), ('to' => $tmp->to()), ('bool' => 1)));
    (($MATCH)->{bool} = ((do {
    ((my  $pos1) = $MATCH->to());
    ((do {
    ((my  $pos1) = $MATCH->to());
    ((((do {
    ((chr(34) eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to()))))
})) || ((do {
    (($MATCH)->{to} = $pos1);
    ((((chr(36) eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to()))))))
}))) || ((do {
    (($MATCH)->{to} = $pos1);
    ((((chr(64) eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to()))))))
})))
}))
})));
    (($tmp)->{bool} = !($MATCH->bool()));
    ($MATCH = $tmp);
    ($MATCH->bool() ? 1 : 0)
})) && ((('' ne substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to())))))) && ((do {
    ((my  $last_match_null) = 0);
    ((my  $last_pos) = $MATCH->to());
    for ( ; ((((do {
    ((my  $pos1) = $MATCH->to());
    ((do {
    (((do {
    ((my  $tmp) = $MATCH);
    ($MATCH = Perlito5::Match->new(('str' => $str), ('from' => $tmp->to()), ('to' => $tmp->to()), ('bool' => 1)));
    (($MATCH)->{bool} = ((do {
    ((my  $pos1) = $MATCH->to());
    ((do {
    ((my  $pos1) = $MATCH->to());
    (((((do {
    ((chr(34) eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to()))))
})) || ((do {
    (($MATCH)->{to} = $pos1);
    ((((chr(36) eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to()))))))
}))) || ((do {
    (($MATCH)->{to} = $pos1);
    ((((chr(64) eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to()))))))
}))) || ((do {
    (($MATCH)->{to} = $pos1);
    ((((chr(92) eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to()))))))
})))
}))
})));
    (($tmp)->{bool} = !($MATCH->bool()));
    ($MATCH = $tmp);
    ($MATCH->bool() ? 1 : 0)
})) && ((('' ne substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to()))))))
}))
})) && (($last_match_null < 2))));  ) {
        if ((($last_pos == $MATCH->to()))) {
            ($last_match_null = ($last_match_null + 1))
        }
        else {
            ($last_match_null = 0)
        };
        ($last_pos = $MATCH->to())
    };
    (($MATCH)->{to} = $last_pos);
    1
})))
}))
}))));
        $MATCH
    };
    sub double_quoted_unescape {
        my $List__ = bless \@_, "ARRAY";
        ((my  $grammar) = $List__->[0]);
        ((my  $str) = $List__->[1]);
        ((my  $pos) = $List__->[2]);
        ((my  $MATCH) = Perlito5::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1)));
        (($MATCH)->{bool} = (((do {
    ((my  $pos1) = $MATCH->to());
    (((do {
    ((((chr(92) eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to()))))) && ((do {
    ((my  $pos1) = $MATCH->to());
    ((((((do {
    (((('c' eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to()))))) && ((do {
    ((my  $pos1) = $MATCH->to());
    (((do {
    (((((('[' eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to()))))) && ((do {
    ((my  $m2) = $grammar->digits($str, $MATCH->to()));
    if (($m2->bool())) {
        (($MATCH)->{to} = $m2->to());
        ($MATCH->{'digits'} = $m2);
        1
    }
    else {
        0
    }
}))) && (((']' eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to())))))) && ((do {
    (($MATCH)->{capture} = chr($MATCH->{('digits')}));
    1
})))
})) || ((do {
    (($MATCH)->{to} = $pos1);
    ((((do {
    ((my  $m2) = $grammar->digits($str, $MATCH->to()));
    if (($m2->bool())) {
        (($MATCH)->{to} = $m2->to());
        ($MATCH->{'digits'} = $m2);
        1
    }
    else {
        0
    }
})) && ((do {
    (($MATCH)->{capture} = chr($MATCH->{('digits')}));
    1
}))))
})))
})))
})) || ((do {
    (($MATCH)->{to} = $pos1);
    ((((('e' eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to()))))) && ((do {
    (($MATCH)->{capture} = chr(27));
    1
}))))
}))) || ((do {
    (($MATCH)->{to} = $pos1);
    ((((('n' eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to()))))) && ((do {
    (($MATCH)->{capture} = (chr(10)));
    1
}))))
}))) || ((do {
    (($MATCH)->{to} = $pos1);
    ((((('t' eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to()))))) && ((do {
    (($MATCH)->{capture} = chr(9));
    1
}))))
}))) || ((do {
    (($MATCH)->{to} = $pos1);
    ((((do {
    ((my  $m2) = $grammar->char_any($str, $MATCH->to()));
    if (($m2->bool())) {
        (($MATCH)->{to} = $m2->to());
        ($MATCH->{'char_any'} = $m2);
        1
    }
    else {
        0
    }
})) && ((do {
    (($MATCH)->{capture} = $MATCH->{('char_any')}->flat());
    1
}))))
})))
})))
})) || ((do {
    (($MATCH)->{to} = $pos1);
    ((((do {
    ((my  $m2) = $grammar->char_any_double_quote($str, $MATCH->to()));
    if (($m2->bool())) {
        (($MATCH)->{to} = $m2->to());
        ($MATCH->{'char_any_double_quote'} = $m2);
        1
    }
    else {
        0
    }
})) && ((do {
    (($MATCH)->{capture} = $MATCH->{('char_any_double_quote')}->flat());
    1
}))))
})))
}))));
        $MATCH
    };
    sub double_quoted_buf {
        my $List__ = bless \@_, "ARRAY";
        ((my  $grammar) = $List__->[0]);
        ((my  $str) = $List__->[1]);
        ((my  $pos) = $List__->[2]);
        ((my  $MATCH) = Perlito5::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1)));
        (($MATCH)->{bool} = (((do {
    ((my  $pos1) = $MATCH->to());
    ((((do {
    (((do {
    ((my  $tmp) = $MATCH);
    ($MATCH = Perlito5::Match->new(('str' => $str), ('from' => $tmp->to()), ('to' => $tmp->to()), ('bool' => 1)));
    (($MATCH)->{bool} = ((do {
    ((my  $pos1) = $MATCH->to());
    ((do {
    ((chr(36) eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to()))))
}))
})));
    (($tmp)->{bool} = ($MATCH->bool() ? 1 : 0));
    ($MATCH = $tmp);
    ($MATCH->bool() ? 1 : 0)
})) && ((do {
    ((my  $pos1) = $MATCH->to());
    ((((do {
    ((((do {
    ((my  $tmp) = $MATCH);
    ($MATCH = Perlito5::Match->new(('str' => $str), ('from' => $tmp->to()), ('to' => $tmp->to()), ('bool' => 1)));
    (($MATCH)->{bool} = ((do {
    ((my  $pos1) = $MATCH->to());
    ((do {
    ((((chr(36) eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to()))))) && ((do {
    ((my  $m2) = $grammar->ident($str, $MATCH->to()));
    if (($m2->bool())) {
        (($MATCH)->{to} = $m2->to());
        1
    }
    else {
        0
    }
})))
}))
})));
    (($tmp)->{bool} = ($MATCH->bool() ? 1 : 0));
    ($MATCH = $tmp);
    ($MATCH->bool() ? 1 : 0)
})) && ((do {
    ((my  $m2) = Perlito5::Expression->operator($str, $MATCH->to()));
    if (($m2->bool())) {
        (($MATCH)->{to} = $m2->to());
        ($MATCH->{'Perlito5::Expression.operator'} = $m2);
        1
    }
    else {
        0
    }
}))) && ((do {
    (($MATCH)->{capture} = ($MATCH->{('Perlito5::Expression.operator')}->flat())->[1]);
    1
})))
})) || ((do {
    (($MATCH)->{to} = $pos1);
    ((((((((chr(36) eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to()))))) && (((chr(123) eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to())))))) && ((do {
    ((my  $m2) = $grammar->ident($str, $MATCH->to()));
    if (($m2->bool())) {
        (($MATCH)->{to} = $m2->to());
        ($MATCH->{'ident'} = $m2);
        1
    }
    else {
        0
    }
}))) && (((chr(125) eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to())))))) && ((do {
    (($MATCH)->{capture} = Var->new(('sigil' => chr(36)), ('twigil' => ''), ('name' => $MATCH->{('ident')}->flat())));
    1
}))))
}))) || ((do {
    (($MATCH)->{to} = $pos1);
    ((((do {
    ((my  $m2) = $grammar->char_any($str, $MATCH->to()));
    if (($m2->bool())) {
        (($MATCH)->{to} = $m2->to());
        ($MATCH->{'char_any'} = $m2);
        1
    }
    else {
        0
    }
})) && ((do {
    (($MATCH)->{capture} = Val::Buf->new(('buf' => $MATCH->{('char_any')}->flat())));
    1
}))))
})))
})))
})) || ((do {
    (($MATCH)->{to} = $pos1);
    ((((do {
    ((my  $tmp) = $MATCH);
    ($MATCH = Perlito5::Match->new(('str' => $str), ('from' => $tmp->to()), ('to' => $tmp->to()), ('bool' => 1)));
    (($MATCH)->{bool} = ((do {
    ((my  $pos1) = $MATCH->to());
    ((do {
    ((chr(64) eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to()))))
}))
})));
    (($tmp)->{bool} = ($MATCH->bool() ? 1 : 0));
    ($MATCH = $tmp);
    ($MATCH->bool() ? 1 : 0)
})) && ((do {
    ((my  $pos1) = $MATCH->to());
    ((((do {
    ((((do {
    ((my  $tmp) = $MATCH);
    ($MATCH = Perlito5::Match->new(('str' => $str), ('from' => $tmp->to()), ('to' => $tmp->to()), ('bool' => 1)));
    (($MATCH)->{bool} = ((do {
    ((my  $pos1) = $MATCH->to());
    ((do {
    ((((chr(64) eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to()))))) && ((do {
    ((my  $m2) = $grammar->ident($str, $MATCH->to()));
    if (($m2->bool())) {
        (($MATCH)->{to} = $m2->to());
        1
    }
    else {
        0
    }
})))
}))
})));
    (($tmp)->{bool} = ($MATCH->bool() ? 1 : 0));
    ($MATCH = $tmp);
    ($MATCH->bool() ? 1 : 0)
})) && ((do {
    ((my  $m2) = Perlito5::Expression->operator($str, $MATCH->to()));
    if (($m2->bool())) {
        (($MATCH)->{to} = $m2->to());
        ($MATCH->{'Perlito5::Expression.operator'} = $m2);
        1
    }
    else {
        0
    }
}))) && ((do {
    (($MATCH)->{capture} = Apply->new(('namespace' => ''), ('code' => 'join'), ('arguments' => (do {
    (my  $List_a = bless [], 'ARRAY');
    (my  $List_v = bless [], 'ARRAY');
    push( @{$List_a}, Val::Buf->new(('buf' => ' ')) );
    push( @{$List_a}, ($MATCH->{('Perlito5::Expression.operator')}->flat())->[1] );
    $List_a
}))));
    1
})))
})) || ((do {
    (($MATCH)->{to} = $pos1);
    ((((((((chr(64) eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to()))))) && (((chr(123) eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to())))))) && ((do {
    ((my  $m2) = $grammar->exp_stmts($str, $MATCH->to()));
    if (($m2->bool())) {
        (($MATCH)->{to} = $m2->to());
        ($MATCH->{'exp_stmts'} = $m2);
        1
    }
    else {
        0
    }
}))) && (((chr(125) eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to())))))) && ((do {
    (($MATCH)->{capture} = Apply->new(('namespace' => ''), ('code' => 'join'), ('arguments' => (do {
    (my  $List_a = bless [], 'ARRAY');
    (my  $List_v = bless [], 'ARRAY');
    push( @{$List_a}, Val::Buf->new(('buf' => ' ')) );
    push( @{$List_a}, ($MATCH->{('exp_stmts')}->flat())->[0] );
    $List_a
}))));
    1
}))))
}))) || ((do {
    (($MATCH)->{to} = $pos1);
    ((((do {
    ((my  $m2) = $grammar->char_any($str, $MATCH->to()));
    if (($m2->bool())) {
        (($MATCH)->{to} = $m2->to());
        ($MATCH->{'char_any'} = $m2);
        1
    }
    else {
        0
    }
})) && ((do {
    (($MATCH)->{capture} = Val::Buf->new(('buf' => $MATCH->{('char_any')}->flat())));
    1
}))))
})))
}))))
}))) || ((do {
    (($MATCH)->{to} = $pos1);
    ((((do {
    ((my  $m2) = $grammar->double_quoted_unescape($str, $MATCH->to()));
    if (($m2->bool())) {
        (($MATCH)->{to} = $m2->to());
        ($MATCH->{'double_quoted_unescape'} = $m2);
        1
    }
    else {
        0
    }
})) && ((do {
    (($MATCH)->{capture} = Val::Buf->new(('buf' => $MATCH->{('double_quoted_unescape')}->flat())));
    1
}))))
})))
}))));
        $MATCH
    };
    sub val_buf {
        my $List__ = bless \@_, "ARRAY";
        ((my  $grammar) = $List__->[0]);
        ((my  $str) = $List__->[1]);
        ((my  $pos) = $List__->[2]);
        ((my  $MATCH) = Perlito5::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1)));
        (($MATCH)->{bool} = (((do {
    ((my  $pos1) = $MATCH->to());
    (((do {
    ((((((chr(34) eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to()))))) && ((do {
    ((my  $last_match_null) = 0);
    ((my  $last_pos) = $MATCH->to());
    for ( ; ((((do {
    ((my  $m2) = $grammar->double_quoted_buf($str, $MATCH->to()));
    if (($m2->bool())) {
        (($MATCH)->{to} = $m2->to());
        if ((exists($MATCH->{'double_quoted_buf'}))) {
            push( @{($MATCH->{'double_quoted_buf'})}, $m2 )
        }
        else {
            ($MATCH->{'double_quoted_buf'} = (do {
    (my  $List_a = bless [], 'ARRAY');
    (my  $List_v = bless [], 'ARRAY');
    push( @{$List_a}, $m2 );
    $List_a
}))
        };
        1
    }
    else {
        0
    }
})) && (($last_match_null < 2))));  ) {
        if ((($last_pos == $MATCH->to()))) {
            ($last_match_null = ($last_match_null + 1))
        }
        else {
            ($last_match_null = 0)
        };
        ($last_pos = $MATCH->to())
    };
    (($MATCH)->{to} = $last_pos);
    1
}))) && (((chr(34) eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to())))))) && ((do {
    ((my  $args) = $MATCH->{('double_quoted_buf')});
    if ((!($args))) {
        (($MATCH)->{capture} = Val::Buf->new(('buf' => '')))
    }
    else {
        (($MATCH)->{capture} = Apply->new(('namespace' => ''), ('code' => 'list:<.>'), ('arguments' => [map($_->capture(), @{($MATCH->{('double_quoted_buf')})})])))
    };
;
    1
})))
})) || ((do {
    (($MATCH)->{to} = $pos1);
    (((((((chr(39) eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to()))))) && ((do {
    ((my  $m2) = $grammar->single_quoted_unescape($str, $MATCH->to()));
    if (($m2->bool())) {
        (($MATCH)->{to} = $m2->to());
        ($MATCH->{'single_quoted_unescape'} = $m2);
        1
    }
    else {
        0
    }
}))) && (((chr(39) eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to())))))) && ((do {
    (($MATCH)->{capture} = Val::Buf->new(('buf' => $MATCH->{('single_quoted_unescape')}->flat())));
    1
}))))
})))
}))));
        $MATCH
    };
    sub digits {
        my $List__ = bless \@_, "ARRAY";
        ((my  $grammar) = $List__->[0]);
        ((my  $str) = $List__->[1]);
        ((my  $pos) = $List__->[2]);
        ((my  $MATCH) = Perlito5::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1)));
        (($MATCH)->{bool} = (((do {
    ((my  $pos1) = $MATCH->to());
    ((do {
    ((my  $last_match_null) = 0);
    ((my  $last_pos) = $MATCH->to());
    ((my  $count) = 0);
    for ( ; ((((do {
    ((my  $m2) = $grammar->digit($str, $MATCH->to()));
    if (($m2->bool())) {
        (($MATCH)->{to} = $m2->to());
        1
    }
    else {
        0
    }
})) && (($last_match_null < 2))));  ) {
        if ((($last_pos == $MATCH->to()))) {
            ($last_match_null = ($last_match_null + 1))
        }
        else {
            ($last_match_null = 0)
        };
        ($last_pos = $MATCH->to());
        ($count = ($count + 1))
    };
    (($MATCH)->{to} = $last_pos);
    ($count > 0)
}))
}))));
        $MATCH
    };
    sub val_int {
        my $List__ = bless \@_, "ARRAY";
        ((my  $grammar) = $List__->[0]);
        ((my  $str) = $List__->[1]);
        ((my  $pos) = $List__->[2]);
        ((my  $MATCH) = Perlito5::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1)));
        (($MATCH)->{bool} = (((do {
    ((my  $pos1) = $MATCH->to());
    ((do {
    (((do {
    ((my  $last_match_null) = 0);
    ((my  $last_pos) = $MATCH->to());
    ((my  $count) = 0);
    for ( ; ((((do {
    ((my  $m2) = $grammar->digit($str, $MATCH->to()));
    if (($m2->bool())) {
        (($MATCH)->{to} = $m2->to());
        1
    }
    else {
        0
    }
})) && (($last_match_null < 2))));  ) {
        if ((($last_pos == $MATCH->to()))) {
            ($last_match_null = ($last_match_null + 1))
        }
        else {
            ($last_match_null = 0)
        };
        ($last_pos = $MATCH->to());
        ($count = ($count + 1))
    };
    (($MATCH)->{to} = $last_pos);
    ($count > 0)
})) && ((do {
    (($MATCH)->{capture} = Val::Int->new(('int' => $MATCH->flat())));
    1
})))
}))
}))));
        $MATCH
    };
    sub exp_stmts {
        my $List__ = bless \@_, "ARRAY";
        ((my  $grammar) = $List__->[0]);
        ((my  $str) = $List__->[1]);
        ((my  $pos) = $List__->[2]);
        ((my  $MATCH) = Perlito5::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1)));
        (($MATCH)->{bool} = (((do {
    ((my  $pos1) = $MATCH->to());
    ((do {
    (((do {
    ((my  $last_match_null) = 0);
    ((my  $last_pos) = $MATCH->to());
    for ( ; ((((do {
    ((my  $m2) = Perlito5::Expression->delimited_statement($str, $MATCH->to()));
    if (($m2->bool())) {
        (($MATCH)->{to} = $m2->to());
        if ((exists($MATCH->{'Perlito5::Expression.delimited_statement'}))) {
            push( @{($MATCH->{'Perlito5::Expression.delimited_statement'})}, $m2 )
        }
        else {
            ($MATCH->{'Perlito5::Expression.delimited_statement'} = (do {
    (my  $List_a = bless [], 'ARRAY');
    (my  $List_v = bless [], 'ARRAY');
    push( @{$List_a}, $m2 );
    $List_a
}))
        };
        1
    }
    else {
        0
    }
})) && (($last_match_null < 2))));  ) {
        if ((($last_pos == $MATCH->to()))) {
            ($last_match_null = ($last_match_null + 1))
        }
        else {
            ($last_match_null = 0)
        };
        ($last_pos = $MATCH->to())
    };
    (($MATCH)->{to} = $last_pos);
    1
})) && ((do {
    (($MATCH)->{capture} = [map($_->capture(), @{($MATCH->{('Perlito5::Expression.delimited_statement')})})]);
    1
})))
}))
}))));
        $MATCH
    };
    sub opt_name {
        my $List__ = bless \@_, "ARRAY";
        ((my  $grammar) = $List__->[0]);
        ((my  $str) = $List__->[1]);
        ((my  $pos) = $List__->[2]);
        ((my  $MATCH) = Perlito5::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1)));
        (($MATCH)->{bool} = (((do {
    ((my  $pos1) = $MATCH->to());
    ((do {
    ((my  $last_pos) = $MATCH->to());
    if ((!(((do {
    ((my  $m2) = $grammar->ident($str, $MATCH->to()));
    if (($m2->bool())) {
        (($MATCH)->{to} = $m2->to());
        if ((exists($MATCH->{'ident'}))) {
            push( @{($MATCH->{'ident'})}, $m2 )
        }
        else {
            ($MATCH->{'ident'} = (do {
    (my  $List_a = bless [], 'ARRAY');
    (my  $List_v = bless [], 'ARRAY');
    push( @{$List_a}, $m2 );
    $List_a
}))
        };
        1
    }
    else {
        0
    }
}))))) {
        (($MATCH)->{to} = $last_pos)
    };
    1
}))
}))));
        $MATCH
    };
    sub var_invocant {
        my $List__ = bless \@_, "ARRAY";
        ((my  $grammar) = $List__->[0]);
        ((my  $str) = $List__->[1]);
        ((my  $pos) = $List__->[2]);
        ((my  $MATCH) = Perlito5::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1)));
        (($MATCH)->{bool} = (((do {
    ((my  $pos1) = $MATCH->to());
    (((do {
    ((((do {
    ((my  $m2) = $grammar->var_ident($str, $MATCH->to()));
    if (($m2->bool())) {
        (($MATCH)->{to} = $m2->to());
        ($MATCH->{'var_ident'} = $m2);
        1
    }
    else {
        0
    }
})) && (((':' eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to())))))) && ((do {
    (($MATCH)->{capture} = $MATCH->{('var_ident')}->flat());
    1
})))
})) || ((do {
    (($MATCH)->{to} = $pos1);
    (((do {
    (($MATCH)->{capture} = Var->new(('sigil' => chr(36)), ('twigil' => ''), ('name' => 'self')));
    1
})))
})))
}))));
        $MATCH
    };
    sub args_sig {
        my $List__ = bless \@_, "ARRAY";
        ((my  $grammar) = $List__->[0]);
        ((my  $str) = $List__->[1]);
        ((my  $pos) = $List__->[2]);
        ((my  $MATCH) = Perlito5::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1)));
        (($MATCH)->{bool} = (((do {
    ((my  $pos1) = $MATCH->to());
    ((do {
    (((((do {
    ((my  $m2) = $grammar->var_invocant($str, $MATCH->to()));
    if (($m2->bool())) {
        (($MATCH)->{to} = $m2->to());
        ($MATCH->{'var_invocant'} = $m2);
        1
    }
    else {
        0
    }
})) && ((do {
    ((my  $m2) = $grammar->opt_ws($str, $MATCH->to()));
    if (($m2->bool())) {
        (($MATCH)->{to} = $m2->to());
        1
    }
    else {
        0
    }
}))) && ((do {
    ((my  $m2) = Perlito5::Expression->list_parse($str, $MATCH->to()));
    if (($m2->bool())) {
        (($MATCH)->{to} = $m2->to());
        ($MATCH->{'Perlito5::Expression.list_parse'} = $m2);
        1
    }
    else {
        0
    }
}))) && ((do {
    (($MATCH)->{capture} = Sig->new(('invocant' => $MATCH->{('var_invocant')}->flat()), ('positional' => Perlito5::Expression::expand_list(($MATCH->{('Perlito5::Expression.list_parse')}->flat())->{'exp'})), ('named' => (do {
    (my  $Hash_a = bless {}, 'HASH');
    $Hash_a
}))));
;
    1
})))
}))
}))));
        $MATCH
    };
    sub method_sig {
        my $List__ = bless \@_, "ARRAY";
        ((my  $grammar) = $List__->[0]);
        ((my  $str) = $List__->[1]);
        ((my  $pos) = $List__->[2]);
        ((my  $MATCH) = Perlito5::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1)));
        (($MATCH)->{bool} = (((do {
    ((my  $pos1) = $MATCH->to());
    (((do {
    ((((((((do {
    ((my  $m2) = $grammar->opt_ws($str, $MATCH->to()));
    if (($m2->bool())) {
        (($MATCH)->{to} = $m2->to());
        1
    }
    else {
        0
    }
})) && ((('(' eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to())))))) && ((do {
    ((my  $m2) = $grammar->opt_ws($str, $MATCH->to()));
    if (($m2->bool())) {
        (($MATCH)->{to} = $m2->to());
        1
    }
    else {
        0
    }
}))) && ((do {
    ((my  $m2) = $grammar->args_sig($str, $MATCH->to()));
    if (($m2->bool())) {
        (($MATCH)->{to} = $m2->to());
        ($MATCH->{'args_sig'} = $m2);
        1
    }
    else {
        0
    }
}))) && ((do {
    ((my  $m2) = $grammar->opt_ws($str, $MATCH->to()));
    if (($m2->bool())) {
        (($MATCH)->{to} = $m2->to());
        1
    }
    else {
        0
    }
}))) && (((')' eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to())))))) && ((do {
    (($MATCH)->{capture} = $MATCH->{('args_sig')}->flat());
    1
})))
})) || ((do {
    (($MATCH)->{to} = $pos1);
    (((do {
    (($MATCH)->{capture} = Sig->new(('invocant' => Var->new(('sigil' => chr(36)), ('twigil' => ''), ('name' => 'self'))), ('positional' => (do {
    (my  $List_a = bless [], 'ARRAY');
    (my  $List_v = bless [], 'ARRAY');
    $List_a
})), ('named' => (do {
    (my  $Hash_a = bless {}, 'HASH');
    $Hash_a
}))));
    1
})))
})))
}))));
        $MATCH
    };
    sub sub_def {
        my $List__ = bless \@_, "ARRAY";
        ((my  $grammar) = $List__->[0]);
        ((my  $str) = $List__->[1]);
        ((my  $pos) = $List__->[2]);
        ((my  $MATCH) = Perlito5::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1)));
        (($MATCH)->{bool} = (((do {
    ((my  $pos1) = $MATCH->to());
    ((do {
    (((((((((((do {
    ((my  $m2) = $grammar->opt_name($str, $MATCH->to()));
    if (($m2->bool())) {
        (($MATCH)->{to} = $m2->to());
        ($MATCH->{'opt_name'} = $m2);
        1
    }
    else {
        0
    }
})) && ((do {
    ((my  $m2) = $grammar->opt_ws($str, $MATCH->to()));
    if (($m2->bool())) {
        (($MATCH)->{to} = $m2->to());
        1
    }
    else {
        0
    }
}))) && ((do {
    ((my  $m2) = $grammar->method_sig($str, $MATCH->to()));
    if (($m2->bool())) {
        (($MATCH)->{to} = $m2->to());
        ($MATCH->{'method_sig'} = $m2);
        1
    }
    else {
        0
    }
}))) && ((do {
    ((my  $m2) = $grammar->opt_ws($str, $MATCH->to()));
    if (($m2->bool())) {
        (($MATCH)->{to} = $m2->to());
        1
    }
    else {
        0
    }
}))) && (((chr(123) eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to())))))) && ((do {
    ((my  $m2) = $grammar->opt_ws($str, $MATCH->to()));
    if (($m2->bool())) {
        (($MATCH)->{to} = $m2->to());
        1
    }
    else {
        0
    }
}))) && ((do {
    ((my  $m2) = $grammar->exp_stmts($str, $MATCH->to()));
    if (($m2->bool())) {
        (($MATCH)->{to} = $m2->to());
        ($MATCH->{'exp_stmts'} = $m2);
        1
    }
    else {
        0
    }
}))) && ((do {
    ((my  $m2) = $grammar->opt_ws($str, $MATCH->to()));
    if (($m2->bool())) {
        (($MATCH)->{to} = $m2->to());
        1
    }
    else {
        0
    }
}))) && ((do {
    ((my  $pos1) = $MATCH->to());
    (((do {
    ((chr(125) eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to()))))
})) || ((do {
    (($MATCH)->{to} = $pos1);
    (((do {
    die('Syntax Error in sub ' . chr(39), $MATCH->{('opt_name')}->flat(), chr(39));
;
    1
})))
})))
}))) && ((do {
    (($MATCH)->{capture} = Sub->new(('name' => $MATCH->{('opt_name')}->flat()), ('sig' => $MATCH->{('method_sig')}->flat()), ('block' => $MATCH->{('exp_stmts')}->flat())));
    1
})))
}))
}))));
        $MATCH
    };
    sub token {
        my $List__ = bless \@_, "ARRAY";
        ((my  $grammar) = $List__->[0]);
        ((my  $str) = $List__->[1]);
        ((my  $pos) = $List__->[2]);
        ((my  $MATCH) = Perlito5::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1)));
        (($MATCH)->{bool} = (((do {
    ((my  $pos1) = $MATCH->to());
    ((do {
    (((((((do {
    ((my  $m2) = $grammar->opt_name($str, $MATCH->to()));
    if (($m2->bool())) {
        (($MATCH)->{to} = $m2->to());
        ($MATCH->{'opt_name'} = $m2);
        1
    }
    else {
        0
    }
})) && ((do {
    ((my  $m2) = $grammar->opt_ws($str, $MATCH->to()));
    if (($m2->bool())) {
        (($MATCH)->{to} = $m2->to());
        1
    }
    else {
        0
    }
}))) && (((chr(123) eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to())))))) && ((do {
    ((my  $m2) = Perlito5::Grammar::Regex->rule($str, $MATCH->to()));
    if (($m2->bool())) {
        (($MATCH)->{to} = $m2->to());
        ($MATCH->{'Perlito5::Grammar::Regex.rule'} = $m2);
        1
    }
    else {
        0
    }
}))) && (((chr(125) eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to())))))) && ((do {
    ((my  $source) = ($MATCH->{('opt_name')} . chr(123) . ' ' . 'my ' . chr(36) . 'grammar ' . chr(61) . ' ' . chr(36) . '_[0]' . chr(59) . ' ' . 'my ' . chr(36) . 'str     ' . chr(61) . ' ' . chr(36) . '_[1]' . chr(59) . ' ' . 'my ' . chr(36) . 'pos     ' . chr(61) . ' ' . chr(36) . '_[2]' . chr(59) . ' ' . 'my ' . chr(36) . 'MATCH ' . chr(61) . ' Perlito5::Match->new( str ' . chr(61) . '> ' . chr(36) . 'str, from ' . chr(61) . '> ' . chr(36) . 'pos, to ' . chr(61) . '> ' . chr(36) . 'pos, bool ' . chr(61) . '> 1 )' . chr(59) . ' ' . chr(36) . 'MATCH->bool ' . chr(61) . ' ( ' . ($MATCH->{('Perlito5::Grammar::Regex.rule')}->flat())->emit_perl5() . ')' . chr(59) . ' ' . chr(36) . 'MATCH' . chr(59) . ' ' . chr(125)));
    ((my  $ast) = Perlito5::Grammar->sub_def($source, 0));
    (($MATCH)->{capture} = $ast->flat());
;
    1
})))
}))
}))));
        $MATCH
    }
}

1;
