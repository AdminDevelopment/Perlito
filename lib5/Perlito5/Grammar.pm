# Do not edit this file - Generated by Perlito5 8.0
use v5;
use utf8;
use strict;
use warnings;
no warnings ('redefine', 'once', 'void', 'uninitialized', 'misc', 'recursion');
use Perlito5::Perl5::Runtime;
our $MATCH = Perlito5::Match->new();
package main;
package Perlito5::Grammar;
use Perlito5::Expression;
use Perlito5::Grammar::Control;
sub is_newline {
    ((my  $grammar) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    ((my  $MATCH) = Perlito5::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1)));
    ($MATCH->{('bool')} = (((do {
    ((my  $pos1) = $MATCH->{('to')});
    (((do {
    ((((chr(10) eq substr($str, $MATCH->{('to')}, 1)) && (($MATCH->{('to')} = (1 + $MATCH->{('to')}))))) && ((do {
    ((my  $last_pos) = $MATCH->{('to')});
    if ((!(((do {
    ((chr(13) eq substr($str, $MATCH->{('to')}, 1)) && (($MATCH->{('to')} = (1 + $MATCH->{('to')}))))
}))))) {
        ($MATCH->{('to')} = $last_pos)
    };
    1
})))
})) || ((do {
    ($MATCH->{('to')} = $pos1);
    (((((chr(13) eq substr($str, $MATCH->{('to')}, 1)) && (($MATCH->{('to')} = (1 + $MATCH->{('to')}))))) && ((do {
    ((my  $last_pos) = $MATCH->{('to')});
    if ((!(((do {
    ((chr(10) eq substr($str, $MATCH->{('to')}, 1)) && (($MATCH->{('to')} = (1 + $MATCH->{('to')}))))
}))))) {
        ($MATCH->{('to')} = $last_pos)
    };
    1
}))))
})))
}))));
    $MATCH
};
sub not_newline {
    ((my  $grammar) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    ((my  $MATCH) = Perlito5::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1)));
    ($MATCH->{('bool')} = (((do {
    ((my  $pos1) = $MATCH->{('to')});
    ((do {
    (((do {
    ((my  $tmp) = $MATCH);
    ($MATCH = Perlito5::Match->new(('str' => $str), ('from' => $tmp->{('to')}), ('to' => $tmp->{('to')}), ('bool' => 1)));
    ($MATCH->{('bool')} = ((do {
    ((my  $pos1) = $MATCH->{('to')});
    ((do {
    ((my  $m2) = $grammar->is_newline($str, $MATCH->{('to')}));
    if (($m2->{('bool')})) {
        ($MATCH->{('to')} = $m2->{('to')});
        1
    }
    else {
        0
    }
}))
})));
    ($tmp->{('bool')} = !($MATCH->{('bool')}));
    ($MATCH = $tmp);
    ($MATCH->{('bool')} ? 1 : 0)
})) && ((('' ne substr($str, $MATCH->{('to')}, 1)) && (($MATCH->{('to')} = (1 + $MATCH->{('to')}))))))
}))
}))));
    $MATCH
};
sub ident {
    ((my  $grammar) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    ((my  $MATCH) = Perlito5::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1)));
    ($MATCH->{('bool')} = (((do {
    ((my  $pos1) = $MATCH->{('to')});
    ((do {
    (((do {
    ((my  $tmp) = $MATCH);
    ($MATCH = Perlito5::Match->new(('str' => $str), ('from' => $tmp->{('to')}), ('to' => $tmp->{('to')}), ('bool' => 1)));
    ($MATCH->{('bool')} = ((do {
    ((my  $pos1) = $MATCH->{('to')});
    ((do {
    ((my  $m2) = $grammar->digit($str, $MATCH->{('to')}));
    if (($m2->{('bool')})) {
        ($MATCH->{('to')} = $m2->{('to')});
        1
    }
    else {
        0
    }
}))
})));
    ($tmp->{('bool')} = !($MATCH->{('bool')}));
    ($MATCH = $tmp);
    ($MATCH->{('bool')} ? 1 : 0)
})) && ((do {
    ((my  $last_match_null) = 0);
    ((my  $last_pos) = $MATCH->{('to')});
    ((my  $count) = 0);
    for ( ; ((((do {
    ((my  $m2) = $grammar->word($str, $MATCH->{('to')}));
    if (($m2->{('bool')})) {
        ($MATCH->{('to')} = $m2->{('to')});
        1
    }
    else {
        0
    }
})) && (($last_match_null < 2))));  ) {
        if ((($last_pos == $MATCH->{('to')}))) {
            ($last_match_null = ($last_match_null + 1))
        }
        else {
            ($last_match_null = 0)
        };
        ($last_pos = $MATCH->{('to')});
        ($count = ($count + 1))
    };
    ($MATCH->{('to')} = $last_pos);
    ($count > 0)
})))
}))
}))));
    $MATCH
};
sub full_ident {
    ((my  $grammar) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    ((my  $MATCH) = Perlito5::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1)));
    ($MATCH->{('bool')} = (((do {
    ((my  $pos1) = $MATCH->{('to')});
    ((do {
    (((do {
    ((my  $m2) = $grammar->ident($str, $MATCH->{('to')}));
    if (($m2->{('bool')})) {
        ($MATCH->{('to')} = $m2->{('to')});
        1
    }
    else {
        0
    }
})) && ((do {
    ((my  $last_match_null) = 0);
    ((my  $last_pos) = $MATCH->{('to')});
    for ( ; ((((do {
    ((my  $pos1) = $MATCH->{('to')});
    ((do {
    (((('::' eq substr($str, $MATCH->{('to')}, 2)) && (($MATCH->{('to')} = (2 + $MATCH->{('to')}))))) && ((do {
    ((my  $m2) = $grammar->ident($str, $MATCH->{('to')}));
    if (($m2->{('bool')})) {
        ($MATCH->{('to')} = $m2->{('to')});
        1
    }
    else {
        0
    }
})))
}))
})) && (($last_match_null < 2))));  ) {
        if ((($last_pos == $MATCH->{('to')}))) {
            ($last_match_null = ($last_match_null + 1))
        }
        else {
            ($last_match_null = 0)
        };
        ($last_pos = $MATCH->{('to')})
    };
    ($MATCH->{('to')} = $last_pos);
    1
})))
}))
}))));
    $MATCH
};
sub namespace_before_ident {
    ((my  $grammar) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    ((my  $MATCH) = Perlito5::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1)));
    ($MATCH->{('bool')} = (((do {
    ((my  $pos1) = $MATCH->{('to')});
    ((do {
    ((((do {
    ((my  $m2) = $grammar->ident($str, $MATCH->{('to')}));
    if (($m2->{('bool')})) {
        ($MATCH->{('to')} = $m2->{('to')});
        1
    }
    else {
        0
    }
})) && ((do {
    ((my  $tmp) = $MATCH);
    ($MATCH = Perlito5::Match->new(('str' => $str), ('from' => $tmp->{('to')}), ('to' => $tmp->{('to')}), ('bool' => 1)));
    ($MATCH->{('bool')} = ((do {
    ((my  $pos1) = $MATCH->{('to')});
    ((do {
    (('::' eq substr($str, $MATCH->{('to')}, 2)) && (($MATCH->{('to')} = (2 + $MATCH->{('to')}))))
}))
})));
    ($tmp->{('bool')} = ($MATCH->{('bool')} ? 1 : 0));
    ($MATCH = $tmp);
    ($MATCH->{('bool')} ? 1 : 0)
}))) && ((do {
    ((my  $last_match_null) = 0);
    ((my  $last_pos) = $MATCH->{('to')});
    for ( ; ((((do {
    ((my  $pos1) = $MATCH->{('to')});
    ((do {
    ((((('::' eq substr($str, $MATCH->{('to')}, 2)) && (($MATCH->{('to')} = (2 + $MATCH->{('to')}))))) && ((do {
    ((my  $m2) = $grammar->ident($str, $MATCH->{('to')}));
    if (($m2->{('bool')})) {
        ($MATCH->{('to')} = $m2->{('to')});
        1
    }
    else {
        0
    }
}))) && ((do {
    ((my  $tmp) = $MATCH);
    ($MATCH = Perlito5::Match->new(('str' => $str), ('from' => $tmp->{('to')}), ('to' => $tmp->{('to')}), ('bool' => 1)));
    ($MATCH->{('bool')} = ((do {
    ((my  $pos1) = $MATCH->{('to')});
    ((do {
    (('::' eq substr($str, $MATCH->{('to')}, 2)) && (($MATCH->{('to')} = (2 + $MATCH->{('to')}))))
}))
})));
    ($tmp->{('bool')} = ($MATCH->{('bool')} ? 1 : 0));
    ($MATCH = $tmp);
    ($MATCH->{('bool')} ? 1 : 0)
})))
}))
})) && (($last_match_null < 2))));  ) {
        if ((($last_pos == $MATCH->{('to')}))) {
            ($last_match_null = ($last_match_null + 1))
        }
        else {
            ($last_match_null = 0)
        };
        ($last_pos = $MATCH->{('to')})
    };
    ($MATCH->{('to')} = $last_pos);
    1
})))
}))
}))));
    $MATCH
};
sub optional_namespace_before_ident {
    ((my  $grammar) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    ((my  $MATCH) = Perlito5::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1)));
    ($MATCH->{('bool')} = (((do {
    ((my  $pos1) = $MATCH->{('to')});
    ((((do {
    ((((do {
    ((my  $m2) = $grammar->namespace_before_ident($str, $MATCH->{('to')}));
    if (($m2->{('bool')})) {
        ($MATCH->{('to')} = $m2->{('to')});
        ($MATCH->{'namespace_before_ident'} = $m2);
        1
    }
    else {
        0
    }
})) && ((('::' eq substr($str, $MATCH->{('to')}, 2)) && (($MATCH->{('to')} = (2 + $MATCH->{('to')})))))) && ((do {
    ($MATCH->{('capture')} = $MATCH->{('namespace_before_ident')}->flat());
    1
})))
})) || ((do {
    ($MATCH->{('to')} = $pos1);
    ((((('::' eq substr($str, $MATCH->{('to')}, 2)) && (($MATCH->{('to')} = (2 + $MATCH->{('to')}))))) && ((do {
    ($MATCH->{('capture')} = 'main');
    1
}))))
}))) || ((do {
    ($MATCH->{('to')} = $pos1);
    ((1 && ((do {
    ($MATCH->{('capture')} = '');
    1
}))))
})))
}))));
    $MATCH
};
sub pod_begin {
    ((my  $grammar) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    ((my  $MATCH) = Perlito5::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1)));
    ($MATCH->{('bool')} = (((do {
    ((my  $pos1) = $MATCH->{('to')});
    (((do {
    ((((do {
    ((my  $m2) = $grammar->is_newline($str, $MATCH->{('to')}));
    if (($m2->{('bool')})) {
        ($MATCH->{('to')} = $m2->{('to')});
        1
    }
    else {
        0
    }
})) && (((chr(61) . 'end' eq substr($str, $MATCH->{('to')}, 4)) && (($MATCH->{('to')} = (4 + $MATCH->{('to')})))))) && ((do {
    ((my  $last_match_null) = 0);
    ((my  $last_pos) = $MATCH->{('to')});
    for ( ; ((((do {
    ((my  $m2) = $grammar->not_newline($str, $MATCH->{('to')}));
    if (($m2->{('bool')})) {
        ($MATCH->{('to')} = $m2->{('to')});
        1
    }
    else {
        0
    }
})) && (($last_match_null < 2))));  ) {
        if ((($last_pos == $MATCH->{('to')}))) {
            ($last_match_null = ($last_match_null + 1))
        }
        else {
            ($last_match_null = 0)
        };
        ($last_pos = $MATCH->{('to')})
    };
    ($MATCH->{('to')} = $last_pos);
    1
})))
})) || ((do {
    ($MATCH->{('to')} = $pos1);
    (((((('' ne substr($str, $MATCH->{('to')}, 1)) && (($MATCH->{('to')} = (1 + $MATCH->{('to')}))))) && ((do {
    ((my  $last_match_null) = 0);
    ((my  $last_pos) = $MATCH->{('to')});
    for ( ; ((((do {
    ((my  $m2) = $grammar->not_newline($str, $MATCH->{('to')}));
    if (($m2->{('bool')})) {
        ($MATCH->{('to')} = $m2->{('to')});
        1
    }
    else {
        0
    }
})) && (($last_match_null < 2))));  ) {
        if ((($last_pos == $MATCH->{('to')}))) {
            ($last_match_null = ($last_match_null + 1))
        }
        else {
            ($last_match_null = 0)
        };
        ($last_pos = $MATCH->{('to')})
    };
    ($MATCH->{('to')} = $last_pos);
    1
}))) && ((do {
    ((my  $m2) = $grammar->pod_begin($str, $MATCH->{('to')}));
    if (($m2->{('bool')})) {
        ($MATCH->{('to')} = $m2->{('to')});
        1
    }
    else {
        0
    }
}))))
})))
}))));
    $MATCH
};
sub ws {
    ((my  $grammar) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    ((my  $MATCH) = Perlito5::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1)));
    ($MATCH->{('bool')} = (((do {
    ((my  $pos1) = $MATCH->{('to')});
    ((do {
    ((my  $last_match_null) = 0);
    ((my  $last_pos) = $MATCH->{('to')});
    ((my  $count) = 0);
    for ( ; ((((do {
    ((my  $pos1) = $MATCH->{('to')});
    ((((do {
    ((((chr(35) eq substr($str, $MATCH->{('to')}, 1)) && (($MATCH->{('to')} = (1 + $MATCH->{('to')}))))) && ((do {
    ((my  $last_match_null) = 0);
    ((my  $last_pos) = $MATCH->{('to')});
    for ( ; ((((do {
    ((my  $m2) = $grammar->not_newline($str, $MATCH->{('to')}));
    if (($m2->{('bool')})) {
        ($MATCH->{('to')} = $m2->{('to')});
        1
    }
    else {
        0
    }
})) && (($last_match_null < 2))));  ) {
        if ((($last_pos == $MATCH->{('to')}))) {
            ($last_match_null = ($last_match_null + 1))
        }
        else {
            ($last_match_null = 0)
        };
        ($last_pos = $MATCH->{('to')})
    };
    ($MATCH->{('to')} = $last_pos);
    1
})))
})) || ((do {
    ($MATCH->{('to')} = $pos1);
    ((((do {
    ((my  $pos1) = $MATCH->{('to')});
    (((do {
    ((((chr(10) eq substr($str, $MATCH->{('to')}, 1)) && (($MATCH->{('to')} = (1 + $MATCH->{('to')}))))) && ((do {
    ((my  $last_pos) = $MATCH->{('to')});
    if ((!(((do {
    ((chr(13) eq substr($str, $MATCH->{('to')}, 1)) && (($MATCH->{('to')} = (1 + $MATCH->{('to')}))))
}))))) {
        ($MATCH->{('to')} = $last_pos)
    };
    1
})))
})) || ((do {
    ($MATCH->{('to')} = $pos1);
    (((((chr(13) eq substr($str, $MATCH->{('to')}, 1)) && (($MATCH->{('to')} = (1 + $MATCH->{('to')}))))) && ((do {
    ((my  $last_pos) = $MATCH->{('to')});
    if ((!(((do {
    ((chr(10) eq substr($str, $MATCH->{('to')}, 1)) && (($MATCH->{('to')} = (1 + $MATCH->{('to')}))))
}))))) {
        ($MATCH->{('to')} = $last_pos)
    };
    1
}))))
})))
})) && ((do {
    ((my  $pos1) = $MATCH->{('to')});
    ((((do {
    ((((chr(61) . 'begin' eq substr($str, $MATCH->{('to')}, 6)) && (($MATCH->{('to')} = (6 + $MATCH->{('to')}))))) && ((do {
    ((my  $m2) = $grammar->pod_begin($str, $MATCH->{('to')}));
    if (($m2->{('bool')})) {
        ($MATCH->{('to')} = $m2->{('to')});
        1
    }
    else {
        0
    }
})))
})) || ((do {
    ($MATCH->{('to')} = $pos1);
    (((((chr(61) . 'for' eq substr($str, $MATCH->{('to')}, 4)) && (($MATCH->{('to')} = (4 + $MATCH->{('to')}))))) && ((do {
    ((my  $m2) = $grammar->pod_begin($str, $MATCH->{('to')}));
    if (($m2->{('bool')})) {
        ($MATCH->{('to')} = $m2->{('to')});
        1
    }
    else {
        0
    }
}))))
}))) || ((do {
    ($MATCH->{('to')} = $pos1);
    (1)
})))
}))))
}))) || ((do {
    ($MATCH->{('to')} = $pos1);
    (((do {
    ((my  $m2) = $grammar->space($str, $MATCH->{('to')}));
    if (($m2->{('bool')})) {
        ($MATCH->{('to')} = $m2->{('to')});
        1
    }
    else {
        0
    }
})))
})))
})) && (($last_match_null < 2))));  ) {
        if ((($last_pos == $MATCH->{('to')}))) {
            ($last_match_null = ($last_match_null + 1))
        }
        else {
            ($last_match_null = 0)
        };
        ($last_pos = $MATCH->{('to')});
        ($count = ($count + 1))
    };
    ($MATCH->{('to')} = $last_pos);
    ($count > 0)
}))
}))));
    $MATCH
};
sub opt_ws {
    ((my  $grammar) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    ((my  $MATCH) = Perlito5::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1)));
    ($MATCH->{('bool')} = (((do {
    ((my  $pos1) = $MATCH->{('to')});
    ((do {
    ((my  $last_pos) = $MATCH->{('to')});
    if ((!(((do {
    ((my  $m2) = $grammar->ws($str, $MATCH->{('to')}));
    if (($m2->{('bool')})) {
        ($MATCH->{('to')} = $m2->{('to')});
        1
    }
    else {
        0
    }
}))))) {
        ($MATCH->{('to')} = $last_pos)
    };
    1
}))
}))));
    $MATCH
};
sub opt_ws2 {
    ((my  $grammar) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    ((my  $MATCH) = Perlito5::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1)));
    ($MATCH->{('bool')} = (((do {
    ((my  $pos1) = $MATCH->{('to')});
    ((do {
    ((my  $last_pos) = $MATCH->{('to')});
    if ((!(((do {
    ((my  $m2) = $grammar->ws($str, $MATCH->{('to')}));
    if (($m2->{('bool')})) {
        ($MATCH->{('to')} = $m2->{('to')});
        1
    }
    else {
        0
    }
}))))) {
        ($MATCH->{('to')} = $last_pos)
    };
    1
}))
}))));
    $MATCH
};
sub opt_ws3 {
    ((my  $grammar) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    ((my  $MATCH) = Perlito5::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1)));
    ($MATCH->{('bool')} = (((do {
    ((my  $pos1) = $MATCH->{('to')});
    ((do {
    ((my  $last_pos) = $MATCH->{('to')});
    if ((!(((do {
    ((my  $m2) = $grammar->ws($str, $MATCH->{('to')}));
    if (($m2->{('bool')})) {
        ($MATCH->{('to')} = $m2->{('to')});
        1
    }
    else {
        0
    }
}))))) {
        ($MATCH->{('to')} = $last_pos)
    };
    1
}))
}))));
    $MATCH
};
sub declarator {
    ((my  $grammar) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    ((my  $MATCH) = Perlito5::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1)));
    ($MATCH->{('bool')} = (((do {
    ((my  $pos1) = $MATCH->{('to')});
    (((do {
    (('my' eq substr($str, $MATCH->{('to')}, 2)) && (($MATCH->{('to')} = (2 + $MATCH->{('to')}))))
})) || ((do {
    ($MATCH->{('to')} = $pos1);
    (((('state' eq substr($str, $MATCH->{('to')}, 5)) && (($MATCH->{('to')} = (5 + $MATCH->{('to')}))))))
})))
}))));
    $MATCH
};
sub exp_stmts2 {
    ((my  $grammar) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    ((my  $MATCH) = Perlito5::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1)));
    ($MATCH->{('bool')} = (((do {
    ((my  $pos1) = $MATCH->{('to')});
    ((do {
    (((do {
    ((my  $m2) = $grammar->exp_stmts($str, $MATCH->{('to')}));
    if (($m2->{('bool')})) {
        ($MATCH->{('to')} = $m2->{('to')});
        ($MATCH->{'exp_stmts'} = $m2);
        1
    }
    else {
        0
    }
})) && ((do {
    ($MATCH->{('capture')} = $MATCH->{('exp_stmts')}->flat());
    1
})))
}))
}))));
    $MATCH
};
sub exp {
    ((my  $grammar) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    ((my  $MATCH) = Perlito5::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1)));
    ($MATCH->{('bool')} = (((do {
    ((my  $pos1) = $MATCH->{('to')});
    ((do {
    (((do {
    ((my  $m2) = Perlito5::Expression->exp_parse($str, $MATCH->{('to')}));
    if (($m2->{('bool')})) {
        ($MATCH->{('to')} = $m2->{('to')});
        ($MATCH->{'Perlito5::Expression.exp_parse'} = $m2);
        1
    }
    else {
        0
    }
})) && ((do {
    ($MATCH->{('capture')} = $MATCH->{('Perlito5::Expression.exp_parse')}->flat());
    1
})))
}))
}))));
    $MATCH
};
sub exp2 {
    ((my  $grammar) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    ((my  $MATCH) = Perlito5::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1)));
    ($MATCH->{('bool')} = (((do {
    ((my  $pos1) = $MATCH->{('to')});
    ((do {
    (((do {
    ((my  $m2) = Perlito5::Expression->exp_parse($str, $MATCH->{('to')}));
    if (($m2->{('bool')})) {
        ($MATCH->{('to')} = $m2->{('to')});
        ($MATCH->{'Perlito5::Expression.exp_parse'} = $m2);
        1
    }
    else {
        0
    }
})) && ((do {
    ($MATCH->{('capture')} = $MATCH->{('Perlito5::Expression.exp_parse')}->flat());
    1
})))
}))
}))));
    $MATCH
};
sub opt_ident {
    ((my  $grammar) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    ((my  $MATCH) = Perlito5::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1)));
    ($MATCH->{('bool')} = (((do {
    ((my  $pos1) = $MATCH->{('to')});
    (((do {
    (((do {
    ((my  $m2) = $grammar->ident($str, $MATCH->{('to')}));
    if (($m2->{('bool')})) {
        ($MATCH->{('to')} = $m2->{('to')});
        ($MATCH->{'ident'} = $m2);
        1
    }
    else {
        0
    }
})) && ((do {
    ($MATCH->{('capture')} = $MATCH->{('ident')}->flat());
    1
})))
})) || ((do {
    ($MATCH->{('to')} = $pos1);
    ((1 && ((do {
    ($MATCH->{('capture')} = 'postcircumfix:<( )>');
    1
}))))
})))
}))));
    $MATCH
};
sub opt_type {
    ((my  $grammar) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    ((my  $MATCH) = Perlito5::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1)));
    ($MATCH->{('bool')} = (((do {
    ((my  $pos1) = $MATCH->{('to')});
    (((do {
    ((((do {
    ((my  $last_pos) = $MATCH->{('to')});
    if ((!(((do {
    (('::' eq substr($str, $MATCH->{('to')}, 2)) && (($MATCH->{('to')} = (2 + $MATCH->{('to')}))))
}))))) {
        ($MATCH->{('to')} = $last_pos)
    };
    1
})) && ((do {
    ((my  $m2) = $grammar->full_ident($str, $MATCH->{('to')}));
    if (($m2->{('bool')})) {
        ($MATCH->{('to')} = $m2->{('to')});
        ($MATCH->{'full_ident'} = $m2);
        1
    }
    else {
        0
    }
}))) && ((do {
    ($MATCH->{('capture')} = $MATCH->{('full_ident')}->flat());
    1
})))
})) || ((do {
    ($MATCH->{('to')} = $pos1);
    ((1 && ((do {
    ($MATCH->{('capture')} = '');
    1
}))))
})))
}))));
    $MATCH
};
sub var_sigil {
    ((my  $grammar) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    ((my  $MATCH) = Perlito5::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1)));
    ($MATCH->{('bool')} = (((do {
    ((my  $pos1) = $MATCH->{('to')});
    ((((((do {
    ((chr(36) eq substr($str, $MATCH->{('to')}, 1)) && (($MATCH->{('to')} = (1 + $MATCH->{('to')}))))
})) || ((do {
    ($MATCH->{('to')} = $pos1);
    ((((chr(37) eq substr($str, $MATCH->{('to')}, 1)) && (($MATCH->{('to')} = (1 + $MATCH->{('to')}))))))
}))) || ((do {
    ($MATCH->{('to')} = $pos1);
    ((((chr(64) eq substr($str, $MATCH->{('to')}, 1)) && (($MATCH->{('to')} = (1 + $MATCH->{('to')}))))))
}))) || ((do {
    ($MATCH->{('to')} = $pos1);
    ((((chr(38) eq substr($str, $MATCH->{('to')}, 1)) && (($MATCH->{('to')} = (1 + $MATCH->{('to')}))))))
}))) || ((do {
    ($MATCH->{('to')} = $pos1);
    (((('*' eq substr($str, $MATCH->{('to')}, 1)) && (($MATCH->{('to')} = (1 + $MATCH->{('to')}))))))
})))
}))));
    $MATCH
};
sub var_name {
    ((my  $grammar) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    ((my  $MATCH) = Perlito5::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1)));
    ($MATCH->{('bool')} = (((do {
    ((my  $pos1) = $MATCH->{('to')});
    (((do {
    ((my  $m2) = $grammar->full_ident($str, $MATCH->{('to')}));
    if (($m2->{('bool')})) {
        ($MATCH->{('to')} = $m2->{('to')});
        ($MATCH->{'full_ident'} = $m2);
        1
    }
    else {
        0
    }
})) || ((do {
    ($MATCH->{('to')} = $pos1);
    (((do {
    ((my  $m2) = $grammar->digit($str, $MATCH->{('to')}));
    if (($m2->{('bool')})) {
        ($MATCH->{('to')} = $m2->{('to')});
        ($MATCH->{'digit'} = $m2);
        1
    }
    else {
        0
    }
})))
})))
}))));
    $MATCH
};
sub var_ident {
    ((my  $grammar) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    ((my  $MATCH) = Perlito5::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1)));
    ($MATCH->{('bool')} = (((do {
    ((my  $pos1) = $MATCH->{('to')});
    ((do {
    (((((do {
    ((my  $m2) = $grammar->var_sigil($str, $MATCH->{('to')}));
    if (($m2->{('bool')})) {
        ($MATCH->{('to')} = $m2->{('to')});
        ($MATCH->{'var_sigil'} = $m2);
        1
    }
    else {
        0
    }
})) && ((do {
    ((my  $m2) = $grammar->optional_namespace_before_ident($str, $MATCH->{('to')}));
    if (($m2->{('bool')})) {
        ($MATCH->{('to')} = $m2->{('to')});
        ($MATCH->{'optional_namespace_before_ident'} = $m2);
        1
    }
    else {
        0
    }
}))) && ((do {
    ((my  $m2) = $grammar->var_name($str, $MATCH->{('to')}));
    if (($m2->{('bool')})) {
        ($MATCH->{('to')} = $m2->{('to')});
        ($MATCH->{'var_name'} = $m2);
        1
    }
    else {
        0
    }
}))) && ((do {
    ($MATCH->{('capture')} = Var->new(('sigil' => $MATCH->{('var_sigil')}->flat()), ('namespace' => $MATCH->{('optional_namespace_before_ident')}->flat()), ('name' => $MATCH->{('var_name')}->flat())));
    1
})))
}))
}))));
    $MATCH
};
sub exponent {
    ((my  $grammar) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    ((my  $MATCH) = Perlito5::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1)));
    ($MATCH->{('bool')} = (((do {
    ((my  $pos1) = $MATCH->{('to')});
    ((do {
    ((((do {
    ((my  $pos1) = $MATCH->{('to')});
    (((do {
    (('e' eq substr($str, $MATCH->{('to')}, 1)) && (($MATCH->{('to')} = (1 + $MATCH->{('to')}))))
})) || ((do {
    ($MATCH->{('to')} = $pos1);
    (((('E' eq substr($str, $MATCH->{('to')}, 1)) && (($MATCH->{('to')} = (1 + $MATCH->{('to')}))))))
})))
})) && ((do {
    ((my  $pos1) = $MATCH->{('to')});
    ((((do {
    (('+' eq substr($str, $MATCH->{('to')}, 1)) && (($MATCH->{('to')} = (1 + $MATCH->{('to')}))))
})) || ((do {
    ($MATCH->{('to')} = $pos1);
    (((('-' eq substr($str, $MATCH->{('to')}, 1)) && (($MATCH->{('to')} = (1 + $MATCH->{('to')}))))))
}))) || ((do {
    ($MATCH->{('to')} = $pos1);
    (1)
})))
}))) && ((do {
    ((my  $last_match_null) = 0);
    ((my  $last_pos) = $MATCH->{('to')});
    ((my  $count) = 0);
    for ( ; ((((do {
    ((my  $m2) = $grammar->digit($str, $MATCH->{('to')}));
    if (($m2->{('bool')})) {
        ($MATCH->{('to')} = $m2->{('to')});
        1
    }
    else {
        0
    }
})) && (($last_match_null < 2))));  ) {
        if ((($last_pos == $MATCH->{('to')}))) {
            ($last_match_null = ($last_match_null + 1))
        }
        else {
            ($last_match_null = 0)
        };
        ($last_pos = $MATCH->{('to')});
        ($count = ($count + 1))
    };
    ($MATCH->{('to')} = $last_pos);
    ($count > 0)
})))
}))
}))));
    $MATCH
};
sub val_num {
    ((my  $grammar) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    ((my  $MATCH) = Perlito5::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1)));
    ($MATCH->{('bool')} = (((do {
    ((my  $pos1) = $MATCH->{('to')});
    ((do {
    (((do {
    ((my  $pos1) = $MATCH->{('to')});
    (((do {
    ((((('.' eq substr($str, $MATCH->{('to')}, 1)) && (($MATCH->{('to')} = (1 + $MATCH->{('to')}))))) && ((do {
    ((my  $last_match_null) = 0);
    ((my  $last_pos) = $MATCH->{('to')});
    ((my  $count) = 0);
    for ( ; ((((do {
    ((my  $m2) = $grammar->digit($str, $MATCH->{('to')}));
    if (($m2->{('bool')})) {
        ($MATCH->{('to')} = $m2->{('to')});
        1
    }
    else {
        0
    }
})) && (($last_match_null < 2))));  ) {
        if ((($last_pos == $MATCH->{('to')}))) {
            ($last_match_null = ($last_match_null + 1))
        }
        else {
            ($last_match_null = 0)
        };
        ($last_pos = $MATCH->{('to')});
        ($count = ($count + 1))
    };
    ($MATCH->{('to')} = $last_pos);
    ($count > 0)
}))) && ((do {
    ((my  $last_pos) = $MATCH->{('to')});
    if ((!(((do {
    ((my  $m2) = $grammar->exponent($str, $MATCH->{('to')}));
    if (($m2->{('bool')})) {
        ($MATCH->{('to')} = $m2->{('to')});
        1
    }
    else {
        0
    }
}))))) {
        ($MATCH->{('to')} = $last_pos)
    };
    1
})))
})) || ((do {
    ($MATCH->{('to')} = $pos1);
    ((((do {
    ((my  $last_match_null) = 0);
    ((my  $last_pos) = $MATCH->{('to')});
    ((my  $count) = 0);
    for ( ; ((((do {
    ((my  $m2) = $grammar->digit($str, $MATCH->{('to')}));
    if (($m2->{('bool')})) {
        ($MATCH->{('to')} = $m2->{('to')});
        1
    }
    else {
        0
    }
})) && (($last_match_null < 2))));  ) {
        if ((($last_pos == $MATCH->{('to')}))) {
            ($last_match_null = ($last_match_null + 1))
        }
        else {
            ($last_match_null = 0)
        };
        ($last_pos = $MATCH->{('to')});
        ($count = ($count + 1))
    };
    ($MATCH->{('to')} = $last_pos);
    ($count > 0)
})) && ((do {
    ((my  $pos1) = $MATCH->{('to')});
    (((do {
    ((my  $m2) = $grammar->exponent($str, $MATCH->{('to')}));
    if (($m2->{('bool')})) {
        ($MATCH->{('to')} = $m2->{('to')});
        1
    }
    else {
        0
    }
})) || ((do {
    ($MATCH->{('to')} = $pos1);
    (((((('.' eq substr($str, $MATCH->{('to')}, 1)) && (($MATCH->{('to')} = (1 + $MATCH->{('to')}))))) && ((do {
    ((my  $last_match_null) = 0);
    ((my  $last_pos) = $MATCH->{('to')});
    ((my  $count) = 0);
    for ( ; ((((do {
    ((my  $m2) = $grammar->digit($str, $MATCH->{('to')}));
    if (($m2->{('bool')})) {
        ($MATCH->{('to')} = $m2->{('to')});
        1
    }
    else {
        0
    }
})) && (($last_match_null < 2))));  ) {
        if ((($last_pos == $MATCH->{('to')}))) {
            ($last_match_null = ($last_match_null + 1))
        }
        else {
            ($last_match_null = 0)
        };
        ($last_pos = $MATCH->{('to')});
        ($count = ($count + 1))
    };
    ($MATCH->{('to')} = $last_pos);
    ($count > 0)
}))) && ((do {
    ((my  $last_pos) = $MATCH->{('to')});
    if ((!(((do {
    ((my  $m2) = $grammar->exponent($str, $MATCH->{('to')}));
    if (($m2->{('bool')})) {
        ($MATCH->{('to')} = $m2->{('to')});
        1
    }
    else {
        0
    }
}))))) {
        ($MATCH->{('to')} = $last_pos)
    };
    1
}))))
})))
}))))
})))
})) && ((do {
    ($MATCH->{('capture')} = Val::Num->new(('num' => $MATCH->flat())));
    1
})))
}))
}))));
    $MATCH
};
sub char_any {
    ((my  $grammar) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    ((my  $MATCH) = Perlito5::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1)));
    ($MATCH->{('bool')} = (((do {
    ((my  $pos1) = $MATCH->{('to')});
    ((do {
    (('' ne substr($str, $MATCH->{('to')}, 1)) && (($MATCH->{('to')} = (1 + $MATCH->{('to')}))))
}))
}))));
    $MATCH
};
sub char_any_single_quote {
    ((my  $grammar) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    ((my  $MATCH) = Perlito5::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1)));
    ($MATCH->{('bool')} = (((do {
    ((my  $pos1) = $MATCH->{('to')});
    ((do {
    ((((do {
    ((my  $tmp) = $MATCH);
    ($MATCH = Perlito5::Match->new(('str' => $str), ('from' => $tmp->{('to')}), ('to' => $tmp->{('to')}), ('bool' => 1)));
    ($MATCH->{('bool')} = ((do {
    ((my  $pos1) = $MATCH->{('to')});
    ((do {
    ((chr(39) eq substr($str, $MATCH->{('to')}, 1)) && (($MATCH->{('to')} = (1 + $MATCH->{('to')}))))
}))
})));
    ($tmp->{('bool')} = !($MATCH->{('bool')}));
    ($MATCH = $tmp);
    ($MATCH->{('bool')} ? 1 : 0)
})) && ((('' ne substr($str, $MATCH->{('to')}, 1)) && (($MATCH->{('to')} = (1 + $MATCH->{('to')})))))) && ((do {
    ((my  $last_match_null) = 0);
    ((my  $last_pos) = $MATCH->{('to')});
    for ( ; ((((do {
    ((my  $pos1) = $MATCH->{('to')});
    ((do {
    (((do {
    ((my  $tmp) = $MATCH);
    ($MATCH = Perlito5::Match->new(('str' => $str), ('from' => $tmp->{('to')}), ('to' => $tmp->{('to')}), ('bool' => 1)));
    ($MATCH->{('bool')} = ((do {
    ((my  $pos1) = $MATCH->{('to')});
    ((do {
    ((my  $pos1) = $MATCH->{('to')});
    (((do {
    ((chr(39) eq substr($str, $MATCH->{('to')}, 1)) && (($MATCH->{('to')} = (1 + $MATCH->{('to')}))))
})) || ((do {
    ($MATCH->{('to')} = $pos1);
    ((((chr(92) eq substr($str, $MATCH->{('to')}, 1)) && (($MATCH->{('to')} = (1 + $MATCH->{('to')}))))))
})))
}))
})));
    ($tmp->{('bool')} = !($MATCH->{('bool')}));
    ($MATCH = $tmp);
    ($MATCH->{('bool')} ? 1 : 0)
})) && ((('' ne substr($str, $MATCH->{('to')}, 1)) && (($MATCH->{('to')} = (1 + $MATCH->{('to')}))))))
}))
})) && (($last_match_null < 2))));  ) {
        if ((($last_pos == $MATCH->{('to')}))) {
            ($last_match_null = ($last_match_null + 1))
        }
        else {
            ($last_match_null = 0)
        };
        ($last_pos = $MATCH->{('to')})
    };
    ($MATCH->{('to')} = $last_pos);
    1
})))
}))
}))));
    $MATCH
};
sub single_quoted_unescape {
    ((my  $grammar) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    ((my  $MATCH) = Perlito5::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1)));
    ($MATCH->{('bool')} = (((do {
    ((my  $pos1) = $MATCH->{('to')});
    ((((((do {
    ((((((chr(92) eq substr($str, $MATCH->{('to')}, 1)) && (($MATCH->{('to')} = (1 + $MATCH->{('to')}))))) && (((chr(92) eq substr($str, $MATCH->{('to')}, 1)) && (($MATCH->{('to')} = (1 + $MATCH->{('to')})))))) && ((do {
    ((my  $m2) = $grammar->single_quoted_unescape($str, $MATCH->{('to')}));
    if (($m2->{('bool')})) {
        ($MATCH->{('to')} = $m2->{('to')});
        ($MATCH->{'single_quoted_unescape'} = $m2);
        1
    }
    else {
        0
    }
}))) && ((do {
    ($MATCH->{('capture')} = (chr(92) . $MATCH->{('single_quoted_unescape')}->flat()));
    1
})))
})) || ((do {
    ($MATCH->{('to')} = $pos1);
    (((((((chr(92) eq substr($str, $MATCH->{('to')}, 1)) && (($MATCH->{('to')} = (1 + $MATCH->{('to')}))))) && (((chr(39) eq substr($str, $MATCH->{('to')}, 1)) && (($MATCH->{('to')} = (1 + $MATCH->{('to')})))))) && ((do {
    ((my  $m2) = $grammar->single_quoted_unescape($str, $MATCH->{('to')}));
    if (($m2->{('bool')})) {
        ($MATCH->{('to')} = $m2->{('to')});
        ($MATCH->{'single_quoted_unescape'} = $m2);
        1
    }
    else {
        0
    }
}))) && ((do {
    ($MATCH->{('capture')} = (chr(39) . $MATCH->{('single_quoted_unescape')}->flat()));
    1
}))))
}))) || ((do {
    ($MATCH->{('to')} = $pos1);
    ((((((chr(92) eq substr($str, $MATCH->{('to')}, 1)) && (($MATCH->{('to')} = (1 + $MATCH->{('to')}))))) && ((do {
    ((my  $m2) = $grammar->single_quoted_unescape($str, $MATCH->{('to')}));
    if (($m2->{('bool')})) {
        ($MATCH->{('to')} = $m2->{('to')});
        ($MATCH->{'single_quoted_unescape'} = $m2);
        1
    }
    else {
        0
    }
}))) && ((do {
    ($MATCH->{('capture')} = (chr(92) . $MATCH->{('single_quoted_unescape')}->flat()));
    1
}))))
}))) || ((do {
    ($MATCH->{('to')} = $pos1);
    (((((do {
    ((my  $m2) = $grammar->char_any_single_quote($str, $MATCH->{('to')}));
    if (($m2->{('bool')})) {
        ($MATCH->{('to')} = $m2->{('to')});
        ($MATCH->{'char_any_single_quote'} = $m2);
        1
    }
    else {
        0
    }
})) && ((do {
    ((my  $m2) = $grammar->single_quoted_unescape($str, $MATCH->{('to')}));
    if (($m2->{('bool')})) {
        ($MATCH->{('to')} = $m2->{('to')});
        ($MATCH->{'single_quoted_unescape'} = $m2);
        1
    }
    else {
        0
    }
}))) && ((do {
    ($MATCH->{('capture')} = ($MATCH->{('char_any_single_quote')}->flat() . $MATCH->{('single_quoted_unescape')}->flat()));
    1
}))))
}))) || ((do {
    ($MATCH->{('to')} = $pos1);
    (1)
})))
}))));
    $MATCH
};
sub char_any_double_quote {
    ((my  $grammar) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    ((my  $MATCH) = Perlito5::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1)));
    ($MATCH->{('bool')} = (((do {
    ((my  $pos1) = $MATCH->{('to')});
    ((do {
    ((((do {
    ((my  $tmp) = $MATCH);
    ($MATCH = Perlito5::Match->new(('str' => $str), ('from' => $tmp->{('to')}), ('to' => $tmp->{('to')}), ('bool' => 1)));
    ($MATCH->{('bool')} = ((do {
    ((my  $pos1) = $MATCH->{('to')});
    ((do {
    ((my  $pos1) = $MATCH->{('to')});
    ((((do {
    ((chr(34) eq substr($str, $MATCH->{('to')}, 1)) && (($MATCH->{('to')} = (1 + $MATCH->{('to')}))))
})) || ((do {
    ($MATCH->{('to')} = $pos1);
    ((((chr(36) eq substr($str, $MATCH->{('to')}, 1)) && (($MATCH->{('to')} = (1 + $MATCH->{('to')}))))))
}))) || ((do {
    ($MATCH->{('to')} = $pos1);
    ((((chr(64) eq substr($str, $MATCH->{('to')}, 1)) && (($MATCH->{('to')} = (1 + $MATCH->{('to')}))))))
})))
}))
})));
    ($tmp->{('bool')} = !($MATCH->{('bool')}));
    ($MATCH = $tmp);
    ($MATCH->{('bool')} ? 1 : 0)
})) && ((('' ne substr($str, $MATCH->{('to')}, 1)) && (($MATCH->{('to')} = (1 + $MATCH->{('to')})))))) && ((do {
    ((my  $last_match_null) = 0);
    ((my  $last_pos) = $MATCH->{('to')});
    for ( ; ((((do {
    ((my  $pos1) = $MATCH->{('to')});
    ((do {
    (((do {
    ((my  $tmp) = $MATCH);
    ($MATCH = Perlito5::Match->new(('str' => $str), ('from' => $tmp->{('to')}), ('to' => $tmp->{('to')}), ('bool' => 1)));
    ($MATCH->{('bool')} = ((do {
    ((my  $pos1) = $MATCH->{('to')});
    ((do {
    ((my  $pos1) = $MATCH->{('to')});
    (((((do {
    ((chr(34) eq substr($str, $MATCH->{('to')}, 1)) && (($MATCH->{('to')} = (1 + $MATCH->{('to')}))))
})) || ((do {
    ($MATCH->{('to')} = $pos1);
    ((((chr(36) eq substr($str, $MATCH->{('to')}, 1)) && (($MATCH->{('to')} = (1 + $MATCH->{('to')}))))))
}))) || ((do {
    ($MATCH->{('to')} = $pos1);
    ((((chr(64) eq substr($str, $MATCH->{('to')}, 1)) && (($MATCH->{('to')} = (1 + $MATCH->{('to')}))))))
}))) || ((do {
    ($MATCH->{('to')} = $pos1);
    ((((chr(92) eq substr($str, $MATCH->{('to')}, 1)) && (($MATCH->{('to')} = (1 + $MATCH->{('to')}))))))
})))
}))
})));
    ($tmp->{('bool')} = !($MATCH->{('bool')}));
    ($MATCH = $tmp);
    ($MATCH->{('bool')} ? 1 : 0)
})) && ((('' ne substr($str, $MATCH->{('to')}, 1)) && (($MATCH->{('to')} = (1 + $MATCH->{('to')}))))))
}))
})) && (($last_match_null < 2))));  ) {
        if ((($last_pos == $MATCH->{('to')}))) {
            ($last_match_null = ($last_match_null + 1))
        }
        else {
            ($last_match_null = 0)
        };
        ($last_pos = $MATCH->{('to')})
    };
    ($MATCH->{('to')} = $last_pos);
    1
})))
}))
}))));
    $MATCH
};
sub double_quoted_unescape {
    ((my  $grammar) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    ((my  $MATCH) = Perlito5::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1)));
    ($MATCH->{('bool')} = (((do {
    ((my  $pos1) = $MATCH->{('to')});
    (((do {
    ((((chr(92) eq substr($str, $MATCH->{('to')}, 1)) && (($MATCH->{('to')} = (1 + $MATCH->{('to')}))))) && ((do {
    ((my  $pos1) = $MATCH->{('to')});
    ((((((do {
    (((('c' eq substr($str, $MATCH->{('to')}, 1)) && (($MATCH->{('to')} = (1 + $MATCH->{('to')}))))) && ((do {
    ((my  $pos1) = $MATCH->{('to')});
    (((do {
    (((((('[' eq substr($str, $MATCH->{('to')}, 1)) && (($MATCH->{('to')} = (1 + $MATCH->{('to')}))))) && ((do {
    ((my  $m2) = $grammar->digits($str, $MATCH->{('to')}));
    if (($m2->{('bool')})) {
        ($MATCH->{('to')} = $m2->{('to')});
        ($MATCH->{'digits'} = $m2);
        1
    }
    else {
        0
    }
}))) && (((']' eq substr($str, $MATCH->{('to')}, 1)) && (($MATCH->{('to')} = (1 + $MATCH->{('to')})))))) && ((do {
    ($MATCH->{('capture')} = chr($MATCH->{('digits')}->flat()));
    1
})))
})) || ((do {
    ($MATCH->{('to')} = $pos1);
    ((((do {
    ((my  $m2) = $grammar->digits($str, $MATCH->{('to')}));
    if (($m2->{('bool')})) {
        ($MATCH->{('to')} = $m2->{('to')});
        ($MATCH->{'digits'} = $m2);
        1
    }
    else {
        0
    }
})) && ((do {
    ($MATCH->{('capture')} = chr($MATCH->{('digits')}->flat()));
    1
}))))
})))
})))
})) || ((do {
    ($MATCH->{('to')} = $pos1);
    ((((('e' eq substr($str, $MATCH->{('to')}, 1)) && (($MATCH->{('to')} = (1 + $MATCH->{('to')}))))) && ((do {
    ($MATCH->{('capture')} = chr(27));
    1
}))))
}))) || ((do {
    ($MATCH->{('to')} = $pos1);
    ((((('n' eq substr($str, $MATCH->{('to')}, 1)) && (($MATCH->{('to')} = (1 + $MATCH->{('to')}))))) && ((do {
    ($MATCH->{('capture')} = (chr(10)));
    1
}))))
}))) || ((do {
    ($MATCH->{('to')} = $pos1);
    ((((('t' eq substr($str, $MATCH->{('to')}, 1)) && (($MATCH->{('to')} = (1 + $MATCH->{('to')}))))) && ((do {
    ($MATCH->{('capture')} = chr(9));
    1
}))))
}))) || ((do {
    ($MATCH->{('to')} = $pos1);
    ((((do {
    ((my  $m2) = $grammar->char_any($str, $MATCH->{('to')}));
    if (($m2->{('bool')})) {
        ($MATCH->{('to')} = $m2->{('to')});
        ($MATCH->{'char_any'} = $m2);
        1
    }
    else {
        0
    }
})) && ((do {
    ($MATCH->{('capture')} = $MATCH->{('char_any')}->flat());
    1
}))))
})))
})))
})) || ((do {
    ($MATCH->{('to')} = $pos1);
    ((((do {
    ((my  $m2) = $grammar->char_any_double_quote($str, $MATCH->{('to')}));
    if (($m2->{('bool')})) {
        ($MATCH->{('to')} = $m2->{('to')});
        ($MATCH->{'char_any_double_quote'} = $m2);
        1
    }
    else {
        0
    }
})) && ((do {
    ($MATCH->{('capture')} = $MATCH->{('char_any_double_quote')}->flat());
    1
}))))
})))
}))));
    $MATCH
};
sub double_quoted_buf {
    ((my  $grammar) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    ((my  $MATCH) = Perlito5::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1)));
    ($MATCH->{('bool')} = (((do {
    ((my  $pos1) = $MATCH->{('to')});
    ((((do {
    (((do {
    ((my  $tmp) = $MATCH);
    ($MATCH = Perlito5::Match->new(('str' => $str), ('from' => $tmp->{('to')}), ('to' => $tmp->{('to')}), ('bool' => 1)));
    ($MATCH->{('bool')} = ((do {
    ((my  $pos1) = $MATCH->{('to')});
    ((do {
    ((chr(36) eq substr($str, $MATCH->{('to')}, 1)) && (($MATCH->{('to')} = (1 + $MATCH->{('to')}))))
}))
})));
    ($tmp->{('bool')} = ($MATCH->{('bool')} ? 1 : 0));
    ($MATCH = $tmp);
    ($MATCH->{('bool')} ? 1 : 0)
})) && ((do {
    ((my  $pos1) = $MATCH->{('to')});
    ((((do {
    ((((do {
    ((my  $tmp) = $MATCH);
    ($MATCH = Perlito5::Match->new(('str' => $str), ('from' => $tmp->{('to')}), ('to' => $tmp->{('to')}), ('bool' => 1)));
    ($MATCH->{('bool')} = ((do {
    ((my  $pos1) = $MATCH->{('to')});
    ((do {
    ((((chr(36) eq substr($str, $MATCH->{('to')}, 1)) && (($MATCH->{('to')} = (1 + $MATCH->{('to')}))))) && ((do {
    ((my  $m2) = $grammar->ident($str, $MATCH->{('to')}));
    if (($m2->{('bool')})) {
        ($MATCH->{('to')} = $m2->{('to')});
        1
    }
    else {
        0
    }
})))
}))
})));
    ($tmp->{('bool')} = ($MATCH->{('bool')} ? 1 : 0));
    ($MATCH = $tmp);
    ($MATCH->{('bool')} ? 1 : 0)
})) && ((do {
    ((my  $m2) = Perlito5::Expression->operator($str, $MATCH->{('to')}));
    if (($m2->{('bool')})) {
        ($MATCH->{('to')} = $m2->{('to')});
        ($MATCH->{'Perlito5::Expression.operator'} = $m2);
        1
    }
    else {
        0
    }
}))) && ((do {
    ($MATCH->{('capture')} = ($MATCH->{('Perlito5::Expression.operator')}->flat())->[1]);
    1
})))
})) || ((do {
    ($MATCH->{('to')} = $pos1);
    ((((((((chr(36) eq substr($str, $MATCH->{('to')}, 1)) && (($MATCH->{('to')} = (1 + $MATCH->{('to')}))))) && (((chr(123) eq substr($str, $MATCH->{('to')}, 1)) && (($MATCH->{('to')} = (1 + $MATCH->{('to')})))))) && ((do {
    ((my  $m2) = $grammar->ident($str, $MATCH->{('to')}));
    if (($m2->{('bool')})) {
        ($MATCH->{('to')} = $m2->{('to')});
        ($MATCH->{'ident'} = $m2);
        1
    }
    else {
        0
    }
}))) && (((chr(125) eq substr($str, $MATCH->{('to')}, 1)) && (($MATCH->{('to')} = (1 + $MATCH->{('to')})))))) && ((do {
    ($MATCH->{('capture')} = Var->new(('sigil' => chr(36)), ('name' => $MATCH->{('ident')}->flat())));
    1
}))))
}))) || ((do {
    ($MATCH->{('to')} = $pos1);
    ((((do {
    ((my  $m2) = $grammar->char_any($str, $MATCH->{('to')}));
    if (($m2->{('bool')})) {
        ($MATCH->{('to')} = $m2->{('to')});
        ($MATCH->{'char_any'} = $m2);
        1
    }
    else {
        0
    }
})) && ((do {
    ($MATCH->{('capture')} = Val::Buf->new(('buf' => $MATCH->{('char_any')}->flat())));
    1
}))))
})))
})))
})) || ((do {
    ($MATCH->{('to')} = $pos1);
    ((((do {
    ((my  $tmp) = $MATCH);
    ($MATCH = Perlito5::Match->new(('str' => $str), ('from' => $tmp->{('to')}), ('to' => $tmp->{('to')}), ('bool' => 1)));
    ($MATCH->{('bool')} = ((do {
    ((my  $pos1) = $MATCH->{('to')});
    ((do {
    ((chr(64) eq substr($str, $MATCH->{('to')}, 1)) && (($MATCH->{('to')} = (1 + $MATCH->{('to')}))))
}))
})));
    ($tmp->{('bool')} = ($MATCH->{('bool')} ? 1 : 0));
    ($MATCH = $tmp);
    ($MATCH->{('bool')} ? 1 : 0)
})) && ((do {
    ((my  $pos1) = $MATCH->{('to')});
    ((((do {
    ((((do {
    ((my  $tmp) = $MATCH);
    ($MATCH = Perlito5::Match->new(('str' => $str), ('from' => $tmp->{('to')}), ('to' => $tmp->{('to')}), ('bool' => 1)));
    ($MATCH->{('bool')} = ((do {
    ((my  $pos1) = $MATCH->{('to')});
    ((do {
    ((((chr(64) eq substr($str, $MATCH->{('to')}, 1)) && (($MATCH->{('to')} = (1 + $MATCH->{('to')}))))) && ((do {
    ((my  $m2) = $grammar->ident($str, $MATCH->{('to')}));
    if (($m2->{('bool')})) {
        ($MATCH->{('to')} = $m2->{('to')});
        1
    }
    else {
        0
    }
})))
}))
})));
    ($tmp->{('bool')} = ($MATCH->{('bool')} ? 1 : 0));
    ($MATCH = $tmp);
    ($MATCH->{('bool')} ? 1 : 0)
})) && ((do {
    ((my  $m2) = Perlito5::Expression->operator($str, $MATCH->{('to')}));
    if (($m2->{('bool')})) {
        ($MATCH->{('to')} = $m2->{('to')});
        ($MATCH->{'Perlito5::Expression.operator'} = $m2);
        1
    }
    else {
        0
    }
}))) && ((do {
    ($MATCH->{('capture')} = Apply->new(('namespace' => ''), ('code' => 'join'), ('arguments' => [Val::Buf->new(('buf' => ' ')), ($MATCH->{('Perlito5::Expression.operator')}->flat())->[1]])));
    1
})))
})) || ((do {
    ($MATCH->{('to')} = $pos1);
    ((((((((chr(64) eq substr($str, $MATCH->{('to')}, 1)) && (($MATCH->{('to')} = (1 + $MATCH->{('to')}))))) && (((chr(123) eq substr($str, $MATCH->{('to')}, 1)) && (($MATCH->{('to')} = (1 + $MATCH->{('to')})))))) && ((do {
    ((my  $m2) = $grammar->exp_stmts($str, $MATCH->{('to')}));
    if (($m2->{('bool')})) {
        ($MATCH->{('to')} = $m2->{('to')});
        ($MATCH->{'exp_stmts'} = $m2);
        1
    }
    else {
        0
    }
}))) && (((chr(125) eq substr($str, $MATCH->{('to')}, 1)) && (($MATCH->{('to')} = (1 + $MATCH->{('to')})))))) && ((do {
    ($MATCH->{('capture')} = Apply->new(('namespace' => ''), ('code' => 'join'), ('arguments' => [Val::Buf->new(('buf' => ' ')), ($MATCH->{('exp_stmts')}->flat())->[0]])));
    1
}))))
}))) || ((do {
    ($MATCH->{('to')} = $pos1);
    ((((do {
    ((my  $m2) = $grammar->char_any($str, $MATCH->{('to')}));
    if (($m2->{('bool')})) {
        ($MATCH->{('to')} = $m2->{('to')});
        ($MATCH->{'char_any'} = $m2);
        1
    }
    else {
        0
    }
})) && ((do {
    ($MATCH->{('capture')} = Val::Buf->new(('buf' => $MATCH->{('char_any')}->flat())));
    1
}))))
})))
}))))
}))) || ((do {
    ($MATCH->{('to')} = $pos1);
    ((((do {
    ((my  $m2) = $grammar->double_quoted_unescape($str, $MATCH->{('to')}));
    if (($m2->{('bool')})) {
        ($MATCH->{('to')} = $m2->{('to')});
        ($MATCH->{'double_quoted_unescape'} = $m2);
        1
    }
    else {
        0
    }
})) && ((do {
    ($MATCH->{('capture')} = Val::Buf->new(('buf' => $MATCH->{('double_quoted_unescape')}->flat())));
    1
}))))
})))
}))));
    $MATCH
};
sub val_buf {
    ((my  $grammar) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    ((my  $MATCH) = Perlito5::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1)));
    ($MATCH->{('bool')} = (((do {
    ((my  $pos1) = $MATCH->{('to')});
    (((do {
    ((((((chr(34) eq substr($str, $MATCH->{('to')}, 1)) && (($MATCH->{('to')} = (1 + $MATCH->{('to')}))))) && ((do {
    ((my  $last_match_null) = 0);
    ((my  $last_pos) = $MATCH->{('to')});
    for ( ; ((((do {
    ((my  $m2) = $grammar->double_quoted_buf($str, $MATCH->{('to')}));
    if (($m2->{('bool')})) {
        ($MATCH->{('to')} = $m2->{('to')});
        if ((exists($MATCH->{'double_quoted_buf'}))) {
            push(@{$MATCH->{'double_quoted_buf'}}, $m2 )
        }
        else {
            ($MATCH->{'double_quoted_buf'} = [$m2])
        };
        1
    }
    else {
        0
    }
})) && (($last_match_null < 2))));  ) {
        if ((($last_pos == $MATCH->{('to')}))) {
            ($last_match_null = ($last_match_null + 1))
        }
        else {
            ($last_match_null = 0)
        };
        ($last_pos = $MATCH->{('to')})
    };
    ($MATCH->{('to')} = $last_pos);
    1
}))) && (((chr(34) eq substr($str, $MATCH->{('to')}, 1)) && (($MATCH->{('to')} = (1 + $MATCH->{('to')})))))) && ((do {
    ((my  $args) = $MATCH->{('double_quoted_buf')});
    if ((!($args))) {
        ($MATCH->{('capture')} = Val::Buf->new(('buf' => '')))
    }
    else {
        ($MATCH->{('capture')} = Apply->new(('namespace' => ''), ('code' => 'list:<.>'), ('arguments' => [map($_->capture(), @{$MATCH->{('double_quoted_buf')}})])))
    };
;
    1
})))
})) || ((do {
    ($MATCH->{('to')} = $pos1);
    (((((((chr(39) eq substr($str, $MATCH->{('to')}, 1)) && (($MATCH->{('to')} = (1 + $MATCH->{('to')}))))) && ((do {
    ((my  $m2) = $grammar->single_quoted_unescape($str, $MATCH->{('to')}));
    if (($m2->{('bool')})) {
        ($MATCH->{('to')} = $m2->{('to')});
        ($MATCH->{'single_quoted_unescape'} = $m2);
        1
    }
    else {
        0
    }
}))) && (((chr(39) eq substr($str, $MATCH->{('to')}, 1)) && (($MATCH->{('to')} = (1 + $MATCH->{('to')})))))) && ((do {
    ($MATCH->{('capture')} = Val::Buf->new(('buf' => $MATCH->{('single_quoted_unescape')}->flat())));
    1
}))))
})))
}))));
    $MATCH
};
sub digits {
    ((my  $grammar) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    ((my  $MATCH) = Perlito5::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1)));
    ($MATCH->{('bool')} = (((do {
    ((my  $pos1) = $MATCH->{('to')});
    ((do {
    ((my  $last_match_null) = 0);
    ((my  $last_pos) = $MATCH->{('to')});
    ((my  $count) = 0);
    for ( ; ((((do {
    ((my  $m2) = $grammar->digit($str, $MATCH->{('to')}));
    if (($m2->{('bool')})) {
        ($MATCH->{('to')} = $m2->{('to')});
        1
    }
    else {
        0
    }
})) && (($last_match_null < 2))));  ) {
        if ((($last_pos == $MATCH->{('to')}))) {
            ($last_match_null = ($last_match_null + 1))
        }
        else {
            ($last_match_null = 0)
        };
        ($last_pos = $MATCH->{('to')});
        ($count = ($count + 1))
    };
    ($MATCH->{('to')} = $last_pos);
    ($count > 0)
}))
}))));
    $MATCH
};
sub val_int {
    ((my  $grammar) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    ((my  $MATCH) = Perlito5::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1)));
    ($MATCH->{('bool')} = (((do {
    ((my  $pos1) = $MATCH->{('to')});
    ((do {
    (((do {
    ((my  $last_match_null) = 0);
    ((my  $last_pos) = $MATCH->{('to')});
    ((my  $count) = 0);
    for ( ; ((((do {
    ((my  $m2) = $grammar->digit($str, $MATCH->{('to')}));
    if (($m2->{('bool')})) {
        ($MATCH->{('to')} = $m2->{('to')});
        1
    }
    else {
        0
    }
})) && (($last_match_null < 2))));  ) {
        if ((($last_pos == $MATCH->{('to')}))) {
            ($last_match_null = ($last_match_null + 1))
        }
        else {
            ($last_match_null = 0)
        };
        ($last_pos = $MATCH->{('to')});
        ($count = ($count + 1))
    };
    ($MATCH->{('to')} = $last_pos);
    ($count > 0)
})) && ((do {
    ($MATCH->{('capture')} = Val::Int->new(('int' => $MATCH->flat())));
    1
})))
}))
}))));
    $MATCH
};
sub exp_stmts {
    ((my  $grammar) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    ((my  $MATCH) = Perlito5::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1)));
    ($MATCH->{('bool')} = (((do {
    ((my  $pos1) = $MATCH->{('to')});
    ((do {
    (((do {
    ((my  $last_match_null) = 0);
    ((my  $last_pos) = $MATCH->{('to')});
    for ( ; ((((do {
    ((my  $m2) = Perlito5::Expression->delimited_statement($str, $MATCH->{('to')}));
    if (($m2->{('bool')})) {
        ($MATCH->{('to')} = $m2->{('to')});
        if ((exists($MATCH->{'Perlito5::Expression.delimited_statement'}))) {
            push(@{$MATCH->{'Perlito5::Expression.delimited_statement'}}, $m2 )
        }
        else {
            ($MATCH->{'Perlito5::Expression.delimited_statement'} = [$m2])
        };
        1
    }
    else {
        0
    }
})) && (($last_match_null < 2))));  ) {
        if ((($last_pos == $MATCH->{('to')}))) {
            ($last_match_null = ($last_match_null + 1))
        }
        else {
            ($last_match_null = 0)
        };
        ($last_pos = $MATCH->{('to')})
    };
    ($MATCH->{('to')} = $last_pos);
    1
})) && ((do {
    ($MATCH->{('capture')} = [map($_->capture(), @{$MATCH->{('Perlito5::Expression.delimited_statement')}})]);
    1
})))
}))
}))));
    $MATCH
};
sub opt_name {
    ((my  $grammar) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    ((my  $MATCH) = Perlito5::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1)));
    ($MATCH->{('bool')} = (((do {
    ((my  $pos1) = $MATCH->{('to')});
    ((do {
    ((my  $last_pos) = $MATCH->{('to')});
    if ((!(((do {
    ((my  $m2) = $grammar->ident($str, $MATCH->{('to')}));
    if (($m2->{('bool')})) {
        ($MATCH->{('to')} = $m2->{('to')});
        if ((exists($MATCH->{'ident'}))) {
            push(@{$MATCH->{'ident'}}, $m2 )
        }
        else {
            ($MATCH->{'ident'} = [$m2])
        };
        1
    }
    else {
        0
    }
}))))) {
        ($MATCH->{('to')} = $last_pos)
    };
    1
}))
}))));
    $MATCH
};
sub args_sig {
    ((my  $grammar) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    ((my  $MATCH) = Perlito5::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1)));
    ($MATCH->{('bool')} = (((do {
    ((my  $pos1) = $MATCH->{('to')});
    ((do {
    (((do {
    ((my  $m2) = Perlito5::Expression->list_parse($str, $MATCH->{('to')}));
    if (($m2->{('bool')})) {
        ($MATCH->{('to')} = $m2->{('to')});
        ($MATCH->{'Perlito5::Expression.list_parse'} = $m2);
        1
    }
    else {
        0
    }
})) && ((do {
    ($MATCH->{('capture')} = Sig->new(('positional' => Perlito5::Expression::expand_list($MATCH->{('Perlito5::Expression.list_parse')}->flat()->{'exp'})), ('named' => {})));
;
    1
})))
}))
}))));
    $MATCH
};
sub method_sig {
    ((my  $grammar) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    ((my  $MATCH) = Perlito5::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1)));
    ($MATCH->{('bool')} = (((do {
    ((my  $pos1) = $MATCH->{('to')});
    (((do {
    ((((((((do {
    ((my  $m2) = $grammar->opt_ws($str, $MATCH->{('to')}));
    if (($m2->{('bool')})) {
        ($MATCH->{('to')} = $m2->{('to')});
        1
    }
    else {
        0
    }
})) && ((('(' eq substr($str, $MATCH->{('to')}, 1)) && (($MATCH->{('to')} = (1 + $MATCH->{('to')})))))) && ((do {
    ((my  $m2) = $grammar->opt_ws($str, $MATCH->{('to')}));
    if (($m2->{('bool')})) {
        ($MATCH->{('to')} = $m2->{('to')});
        1
    }
    else {
        0
    }
}))) && ((do {
    ((my  $m2) = $grammar->args_sig($str, $MATCH->{('to')}));
    if (($m2->{('bool')})) {
        ($MATCH->{('to')} = $m2->{('to')});
        ($MATCH->{'args_sig'} = $m2);
        1
    }
    else {
        0
    }
}))) && ((do {
    ((my  $m2) = $grammar->opt_ws($str, $MATCH->{('to')}));
    if (($m2->{('bool')})) {
        ($MATCH->{('to')} = $m2->{('to')});
        1
    }
    else {
        0
    }
}))) && (((')' eq substr($str, $MATCH->{('to')}, 1)) && (($MATCH->{('to')} = (1 + $MATCH->{('to')})))))) && ((do {
    ($MATCH->{('capture')} = $MATCH->{('args_sig')}->flat());
    1
})))
})) || ((do {
    ($MATCH->{('to')} = $pos1);
    (((do {
    ($MATCH->{('capture')} = Sig->new(('positional' => []), ('named' => {})));
    1
})))
})))
}))));
    $MATCH
};
sub sub_def {
    ((my  $grammar) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    ((my  $MATCH) = Perlito5::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1)));
    ($MATCH->{('bool')} = (((do {
    ((my  $pos1) = $MATCH->{('to')});
    ((do {
    (((((((((((do {
    ((my  $m2) = $grammar->opt_name($str, $MATCH->{('to')}));
    if (($m2->{('bool')})) {
        ($MATCH->{('to')} = $m2->{('to')});
        ($MATCH->{'opt_name'} = $m2);
        1
    }
    else {
        0
    }
})) && ((do {
    ((my  $m2) = $grammar->opt_ws($str, $MATCH->{('to')}));
    if (($m2->{('bool')})) {
        ($MATCH->{('to')} = $m2->{('to')});
        1
    }
    else {
        0
    }
}))) && ((do {
    ((my  $m2) = $grammar->method_sig($str, $MATCH->{('to')}));
    if (($m2->{('bool')})) {
        ($MATCH->{('to')} = $m2->{('to')});
        ($MATCH->{'method_sig'} = $m2);
        1
    }
    else {
        0
    }
}))) && ((do {
    ((my  $m2) = $grammar->opt_ws($str, $MATCH->{('to')}));
    if (($m2->{('bool')})) {
        ($MATCH->{('to')} = $m2->{('to')});
        1
    }
    else {
        0
    }
}))) && (((chr(123) eq substr($str, $MATCH->{('to')}, 1)) && (($MATCH->{('to')} = (1 + $MATCH->{('to')})))))) && ((do {
    ((my  $m2) = $grammar->opt_ws($str, $MATCH->{('to')}));
    if (($m2->{('bool')})) {
        ($MATCH->{('to')} = $m2->{('to')});
        1
    }
    else {
        0
    }
}))) && ((do {
    ((my  $m2) = $grammar->exp_stmts($str, $MATCH->{('to')}));
    if (($m2->{('bool')})) {
        ($MATCH->{('to')} = $m2->{('to')});
        ($MATCH->{'exp_stmts'} = $m2);
        1
    }
    else {
        0
    }
}))) && ((do {
    ((my  $m2) = $grammar->opt_ws($str, $MATCH->{('to')}));
    if (($m2->{('bool')})) {
        ($MATCH->{('to')} = $m2->{('to')});
        1
    }
    else {
        0
    }
}))) && ((do {
    ((my  $pos1) = $MATCH->{('to')});
    (((do {
    ((chr(125) eq substr($str, $MATCH->{('to')}, 1)) && (($MATCH->{('to')} = (1 + $MATCH->{('to')}))))
})) || ((do {
    ($MATCH->{('to')} = $pos1);
    (((do {
    die('Syntax Error in sub ' . chr(39), $MATCH->{('opt_name')}->flat(), chr(39));
;
    1
})))
})))
}))) && ((do {
    ($MATCH->{('capture')} = Sub->new(('name' => $MATCH->{('opt_name')}->flat()), ('sig' => $MATCH->{('method_sig')}->flat()), ('block' => $MATCH->{('exp_stmts')}->flat())));
    1
})))
}))
}))));
    $MATCH
};

1;
