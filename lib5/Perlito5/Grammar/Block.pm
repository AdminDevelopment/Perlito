# Do not edit this file - Generated by Perlito5 9.0
use v5.10;
use Perlito5::Perl5::Runtime;
package main;
package Perlito5::Grammar::Block;
use Perlito5::Expression;
((our  %Named_block) = ('BEGIN', 1, 'UNITCHECK', 1, 'CHECK', 1, 'INIT', 1, 'END', 1));
Perlito5::Expression::add_statement('{', sub {
    Perlito5::Grammar::Block->term_block($_[0], $_[1])
});
Perlito5::Expression::add_statement('sub', sub {
    Perlito5::Grammar::Block->named_sub($_[0], $_[1])
});
for (keys(%Named_block)) {
    Perlito5::Expression::add_statement($_, sub {
    Perlito5::Grammar::Block->term_block($_[0], $_[1])
})
};
sub Perlito5::Grammar::Block::term_block {
    ((my  $self) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    ((my  $p) = $pos);
    (my  $block_name);
    ((my  $m_name) = Perlito5::Grammar->ident($str, $p));
    if ($m_name) {
        ($p = $m_name->{'to'});
        ($block_name = Perlito5::Match::flat($m_name))
    };
    ((my  $ws) = Perlito5::Grammar::Space->ws($str, $p));
    if ($ws) {
        ($p = $ws->{'to'})
    };
    if ((substr($str, $p, 1) eq '{')) {
        ((my  $m) = Perlito5::Expression->term_curly($str, $p));
        if ($m) {
            ((my  $block_start) = $p);
            ($p = $m->{'to'});
            ($ws = Perlito5::Grammar::Space->ws($str, $p));
            if ($ws) {
                ($p = $ws->{'to'})
            };
            ((my  $continue) = Perlito5::AST::Lit::Block->new('stmts', []));
            ((my  $has_continue) = 0);
            if ((!($block_name) && (substr($str, $p, 8) eq 'continue'))) {
                ($p = ($p + 8));
                ($ws = Perlito5::Grammar::Space->ws($str, $p));
                if ($ws) {
                    ($p = $ws->{'to'})
                };
                ((my  $cont) = Perlito5::Expression->term_curly($str, $p));
                if ($cont) {

                }
                else {
                    die('syntax error')
                };
                warn('continue!');
                ($continue->{'stmts'} = $cont->{'capture'}->[2]);
                ($has_continue = 1);
                ($m->{'to'} = $cont->{'to'})
            };
            ((my  $v) = Perlito5::Match::flat($m));
            ($v = Perlito5::AST::Lit::Block->new('stmts', $v->[2], 'sig', $v->[3]));
            if (($has_continue || $block_name)) {

            }
            else {
                ($v = Perlito5::Expression::block_or_hash($v))
            };
            if ((ref($v) eq 'Perlito5::AST::Lit::Block')) {
                if (($block_name eq 'BEGIN')) {
                    (do { my $m = Perlito5::Grammar->exp_stmts("do {" .                         substr($str, $block_start, ($m->{'to'} - $block_start)) . "}", 0);my $source = Perlito5::Match::flat($m)->[0]->emit_perl5(0, "scalar");eval $source;});
                    ($m->{'capture'} = Perlito5::AST::Apply->new('code', 'undef', 'namespace', '', 'arguments', []))
                }
                else {
                    ($v->{'name'} = $block_name);
                    ($m->{'capture'} = $v);
                    ($m->{'capture'}->{'continue'} = $continue)
                };
                return ($m)
            }
        }
    };
    return (0)
};
sub Perlito5::Grammar::Block::named_sub_def {
    ((my  $grammar) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    ((my  $MATCH) = {'str', $str, 'from', $pos, 'to', $pos});
    ((my  $tmp) = (((do {
    ((my  $pos1) = $MATCH->{'to'});
    ((do {
    (((((((((((do {
    ((my  $m2) = Perlito5::Grammar->optional_namespace_before_ident($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        ($MATCH->{'Perlito5::Grammar.optional_namespace_before_ident'} = $m2);
        1
    }
    else {
        0
    }
})) && ((do {
    ((my  $m2) = Perlito5::Grammar->ident($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        ($MATCH->{'Perlito5::Grammar.ident'} = $m2);
        1
    }
    else {
        0
    }
}))) && ((do {
    ((my  $m2) = Perlito5::Grammar->prototype($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        ($MATCH->{'Perlito5::Grammar.prototype'} = $m2);
        1
    }
    else {
        0
    }
}))) && ((do {
    ((my  $m2) = Perlito5::Grammar->opt_ws($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        1
    }
    else {
        0
    }
}))) && ((('{' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'})))))) && ((do {
    ((my  $m2) = Perlito5::Grammar->opt_ws($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        1
    }
    else {
        0
    }
}))) && ((do {
    ((my  $m2) = Perlito5::Grammar->exp_stmts($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        ($MATCH->{'Perlito5::Grammar.exp_stmts'} = $m2);
        1
    }
    else {
        0
    }
}))) && ((do {
    ((my  $m2) = Perlito5::Grammar->opt_ws($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        1
    }
    else {
        0
    }
}))) && ((do {
    ((my  $pos1) = $MATCH->{'to'});
    (((do {
    (('}' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'}))))
})) || ((do {
    ($MATCH->{'to'} = $pos1);
    (((do {
    die('Syntax Error in sub ' . chr(39), Perlito5::Match::flat($MATCH->{'Perlito5::Grammar.ident'}), chr(39));
    1
})))
})))
}))) && ((do {
    ((my  $name) = Perlito5::Match::flat($MATCH->{'Perlito5::Grammar.ident'}));
    ((my  $sig) = Perlito5::Match::flat($MATCH->{'Perlito5::Grammar.prototype'}));
    if (($sig eq '*undef*')) {
        ($sig = undef())
    };
    ((my  $namespace) = Perlito5::Match::flat($MATCH->{'Perlito5::Grammar.optional_namespace_before_ident'}));
    if ($name) {
        if ($namespace) {

        }
        else {
            ($namespace = $Perlito5::PKG_NAME)
        };
        ((my  $full_name) = ($namespace . '::' . $name));
        if (exists($Perlito5::PROTO->{$full_name})) {
            warn(('Subroutine ' . $full_name . ' redefined'))
        };
        ($Perlito5::PROTO->{$full_name} = $sig)
    };
    ($MATCH->{'capture'} = Perlito5::AST::Sub->new('name', $name, 'namespace', $namespace, 'sig', $sig, 'block', Perlito5::Match::flat($MATCH->{'Perlito5::Grammar.exp_stmts'})));
    1
})))
}))
}))));
    ($tmp ? $MATCH : 0)
};
sub Perlito5::Grammar::Block::named_sub {
    ((my  $self) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    if ((substr($str, $pos, 3) eq 'sub')) {

    }
    else {
        return ()
    };
    ((my  $ws) = Perlito5::Grammar::Space->ws($str, ($pos + 3)));
    if ($ws) {

    }
    else {
        return ()
    };
    ($p = $ws->{'to'});
    ((my  $m_name) = Perlito5::Grammar->ident($str, $p));
    if ($m_name) {

    }
    else {
        return ()
    };
    ((my  $block_name) = Perlito5::Match::flat($m_name));
    if (exists($Named_block{$block_name})) {
        return (Perlito5::Grammar::Block->term_block($str, $p))
    };
    return (Perlito5::Grammar::Block->named_sub_def($str, $p))
};
1;

1;
