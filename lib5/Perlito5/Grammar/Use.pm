# Do not edit this file - Generated by Perlito5 8.0
use v5;
use utf8;
use warnings;
no warnings ('redefine', 'once', 'void', 'uninitialized', 'misc', 'recursion');
use Perlito5::Perl5::Runtime;
our $MATCH = Perlito5::Match->new();
package main;
package Perlito5::Grammar::Use;
use Perlito5::Precedence;
use Perlito5::Grammar;
Perlito5::Precedence::add_term(('no' => sub {
    Perlito5::Grammar::Use->term_use($_[0], $_[1])
}));
Perlito5::Precedence::add_term(('use' => sub {
    Perlito5::Grammar::Use->term_use($_[0], $_[1])
}));
sub Perlito5::Grammar::Use::use_decl {
    ((my  $grammar) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    ((my  $MATCH) = Perlito5::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos)));
    ((my  $tmp) = (((do {
    ((my  $pos1) = $MATCH->{'to'});
    (((do {
    (('use' eq substr($str, $MATCH->{'to'}, 3)) && (($MATCH->{'to'} = (3 + $MATCH->{'to'}))))
})) || ((do {
    ($MATCH->{'to'} = $pos1);
    (((('no' eq substr($str, $MATCH->{'to'}, 2)) && (($MATCH->{'to'} = (2 + $MATCH->{'to'}))))))
})))
}))));
    ($tmp ? $MATCH : 0)
};
sub Perlito5::Grammar::Use::term_use {
    ((my  $grammar) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    ((my  $MATCH) = Perlito5::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos)));
    ((my  $tmp) = (((do {
    ((my  $pos1) = $MATCH->{'to'});
    ((do {
    (((((((do {
    ((my  $m2) = $grammar->use_decl($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        ($MATCH->{'use_decl'} = $m2);
        1
    }
    else {
        0
    }
})) && ((do {
    ((my  $m2) = Perlito5::Grammar->ws($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        1
    }
    else {
        0
    }
}))) && ((do {
    ((my  $m2) = Perlito5::Grammar->full_ident($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        ($MATCH->{'Perlito5::Grammar.full_ident'} = $m2);
        1
    }
    else {
        0
    }
}))) && ((do {
    ((my  $m) = $MATCH);
    if (!(((do {
    ((my  $pos1) = $MATCH->{'to'});
    ((do {
    (((('-' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'}))))) && ((do {
    ((my  $m2) = Perlito5::Grammar->ident($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        if (exists($MATCH->{'Perlito5::Grammar.ident'})) {
            push(@{$MATCH->{'Perlito5::Grammar.ident'}}, $m2 )
        }
        else {
            ($MATCH->{'Perlito5::Grammar.ident'} = [$m2])
        };
        1
    }
    else {
        0
    }
})))
}))
})))) {
        ($MATCH = $m)
    };
    1
}))) && ((do {
    ((my  $m2) = Perlito5::Expression->list_parse($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        ($MATCH->{'Perlito5::Expression.list_parse'} = $m2);
        1
    }
    else {
        0
    }
}))) && ((do {
    ((my  $ast) = Perlito5::AST::Use->new(('code' => $MATCH->{'use_decl'}->flat()), ('mod' => $MATCH->{'Perlito5::Grammar.full_ident'}->flat())));
    parse_time_eval($ast);
    ($MATCH->{'capture'} = ['term', $ast]);
;
    1
})))
}))
}))));
    ($tmp ? $MATCH : 0)
};
sub Perlito5::Grammar::Use::parse_time_eval {
    ((my  $self) = shift());
    if (($self->mod() eq 'strict')) {
        if (($self->code() eq 'use')) {
            Perlito5::strict->import()
        }
        else {
            if (($self->code() eq 'no')) {
                Perlito5::strict->unimport()
            }
        }
    }
};
sub Perlito5::Grammar::Use::emit_time_eval {
    ((my  $self) = shift());
    if (($self->mod() eq 'strict')) {
        if (($self->code() eq 'use')) {
            Perlito5::strict->import()
        }
        else {
            if (($self->code() eq 'no')) {
                Perlito5::strict->unimport()
            }
        }
    }
};
1;

1;
