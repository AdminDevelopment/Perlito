# Do not edit this file - Generated by Perlito5 8.0
use v5;
use utf8;
use strict;
use warnings;
no warnings ('redefine', 'once', 'void', 'uninitialized', 'misc', 'recursion');
use Perlito5::Perl5::Runtime;
our $MATCH = Perlito5::Match->new();
package main;
use v5;
package Perlito5::Grammar::String;
sub string_interpolation_parse {
    ((my  $self) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    ((my  $delimiter) = $_[3]);
    ((my  $interpolate) = $_[4]);
    ((my  $p) = $pos);
    (my  @args);
    ((my  $buf) = '');
    for ( ; ((($p < length($str)) && (substr($str, $p, length($delimiter)) ne $delimiter)));  ) {
        ((my  $m) = ($interpolate ? Perlito5::Grammar::String->double_quoted_buf($str, $p) : Perlito5::Grammar::String->single_quoted_unescape($str, $p)));
        if (($m->{'bool'})) {
            ((my  $obj) = $m->flat());
            if (((ref($obj) eq 'Perlito5::AST::Val::Buf'))) {
                ($buf = ($buf . $obj->{'buf'}));
                ($obj = undef())
            };
            if (($obj)) {
                if ((length($buf))) {
                    push(@args, Perlito5::AST::Val::Buf->new(('buf' => $buf)) );
                    ($buf = '')
                };
                push(@args, $obj )
            };
            ($p = $m->{'to'})
        }
        else {
            ($buf = ($buf . substr($str, $p, 1)));
            ($p)++
        }
    };
    if ((length($buf))) {
        push(@args, Perlito5::AST::Val::Buf->new(('buf' => $buf)) )
    };
    if ((substr($str, $p, length($delimiter)) ne $delimiter)) {
        die(('Can' . chr(39) . 't find string terminator ' . chr(39) . $delimiter . chr(39) . ' anywhere before EOF'))
    };
    ($p = ($p + length($delimiter)));
    (my  $ast);
    if ((!(@args))) {
        ($ast = Perlito5::AST::Val::Buf->new(('buf' => '')))
    }
    else {
        if (((@args == 1))) {
            ($ast = $args[0])
        }
        else {
            ($ast = Perlito5::AST::Apply->new(('namespace' => ''), ('code' => 'list:<.>'), ('arguments' => \@args)))
        }
    };
    return (Perlito5::Match->new(('str' => $str), ('from' => $pos), ('to' => $p), ('bool' => 1), ('capture' => $ast)))
};
(my  @Here_doc);
sub here_doc_wanted {
    ((my  $self) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    (my  $delimiter);
    ((my  $p) = $pos);
    if (((substr($str, $p, 2) eq '<<'))) {
        ($p = ($p + 2));
        if (((substr($str, $p, 1) eq chr(39)))) {
            ($p = ($p + 1));
            ((my  $m) = Perlito5::Grammar::String->single_quote_parse($str, $p));
            if (($m->{'bool'})) {
                ($p = $m->{'to'});
                ($delimiter = $m->flat()->{'buf'})
            }
        }
    };
    if ((!(defined($delimiter)))) {
        return (Perlito5::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 0), ('capture' => undef())))
    };
    ((my  $placeholder) = Perlito5::AST::Val::Buf->new(('buf' => 'HEREDOC')));
    push(@Here_doc, ['single_quote', sub  {
    ($placeholder->{'buf'} = $_[0])
}, $delimiter] );
    return (Perlito5::Match->new(('str' => $str), ('from' => $pos), ('to' => $p), ('bool' => 1), ('capture' => ['term', $placeholder])))
};
sub here_doc {
    ((my  $self) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    if ((!(@Here_doc))) {
        return (Perlito5::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1), ('capture' => undef())))
    };
    ((my  $p) = $pos);
    ((my  $here) = shift(@Here_doc));
    ((my  $delimiter) = $here->[2]);
    for ( ; (($p < length($str)));  ) {
        if (((substr($str, $p, length($delimiter)) eq $delimiter))) {
            $here->[1]->(substr($str, $pos, ($p - $pos)));
            return (Perlito5::Match->new(('str' => $str), ('from' => $pos), ('to' => ($p + length($delimiter))), ('bool' => 1), ('capture' => undef())))
        };
        for ( ; ((($p < length($str)) && (((substr($str, $p, 1) ne chr(10)) && (substr($str, $p, 1) ne chr(13))))));  ) {
            ($p)++
        };
        for ( ; ((($p < length($str)) && (((substr($str, $p, 1) eq chr(10)) || (substr($str, $p, 1) eq chr(13))))));  ) {
            ($p)++
        }
    };
    die(('Can' . chr(39) . 't find string terminator ' . chr(34) . $delimiter . chr(34) . ' anywhere before EOF'))
};
sub single_quote_parse {
    ((my  $self) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    return ($self->string_interpolation_parse($str, $pos, chr(39), 0))
};
sub double_quote_parse {
    ((my  $self) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    return ($self->string_interpolation_parse($str, $pos, chr(34), 1))
};
sub char_any {
    ((my  $grammar) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    ((my  $MATCH) = Perlito5::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1)));
    ($MATCH->{'bool'} = (((do {
    ((my  $pos1) = $MATCH->{'to'});
    ((do {
    (('' ne substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'}))))
}))
}))));
    $MATCH
};
sub single_quoted_unescape {
    ((my  $grammar) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    ((my  $MATCH) = Perlito5::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1)));
    ($MATCH->{'bool'} = (((do {
    ((my  $pos1) = $MATCH->{'to'});
    (((do {
    (((((chr(92) eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'}))))) && (((chr(92) eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'})))))) && ((do {
    ($MATCH->{'capture'} = Perlito5::AST::Val::Buf->new(('buf' => chr(92))));
    1
})))
})) || ((do {
    ($MATCH->{'to'} = $pos1);
    ((((((chr(92) eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'}))))) && (((chr(39) eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'})))))) && ((do {
    ($MATCH->{'capture'} = Perlito5::AST::Val::Buf->new(('buf' => chr(39))));
    1
}))))
})))
}))));
    $MATCH
};
sub double_quoted_unescape {
    ((my  $grammar) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    ((my  $MATCH) = Perlito5::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1)));
    ($MATCH->{'bool'} = (((do {
    ((my  $pos1) = $MATCH->{'to'});
    ((((((do {
    (((('c' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'}))))) && ((do {
    ((my  $pos1) = $MATCH->{'to'});
    (((do {
    (((((('[' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'}))))) && ((do {
    ((my  $m2) = Perlito5::Grammar->digits($str, $MATCH->{'to'}));
    if (($m2->{'bool'})) {
        ($MATCH->{'to'} = $m2->{'to'});
        ($MATCH->{'Perlito5::Grammar.digits'} = $m2);
        1
    }
    else {
        0
    }
}))) && (((']' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'})))))) && ((do {
    ($MATCH->{'capture'} = chr($MATCH->{'Perlito5::Grammar.digits'}->flat()));
    1
})))
})) || ((do {
    ($MATCH->{'to'} = $pos1);
    ((((do {
    ((my  $m2) = Perlito5::Grammar->digits($str, $MATCH->{'to'}));
    if (($m2->{'bool'})) {
        ($MATCH->{'to'} = $m2->{'to'});
        ($MATCH->{'Perlito5::Grammar.digits'} = $m2);
        1
    }
    else {
        0
    }
})) && ((do {
    ($MATCH->{'capture'} = chr($MATCH->{'Perlito5::Grammar.digits'}->flat()));
    1
}))))
})))
})))
})) || ((do {
    ($MATCH->{'to'} = $pos1);
    ((((('e' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'}))))) && ((do {
    ($MATCH->{'capture'} = chr(27));
    1
}))))
}))) || ((do {
    ($MATCH->{'to'} = $pos1);
    ((((('n' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'}))))) && ((do {
    ($MATCH->{'capture'} = chr(10));
    1
}))))
}))) || ((do {
    ($MATCH->{'to'} = $pos1);
    ((((('t' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'}))))) && ((do {
    ($MATCH->{'capture'} = chr(9));
    1
}))))
}))) || ((do {
    ($MATCH->{'to'} = $pos1);
    ((((do {
    ((my  $m2) = $grammar->char_any($str, $MATCH->{'to'}));
    if (($m2->{'bool'})) {
        ($MATCH->{'to'} = $m2->{'to'});
        ($MATCH->{'char_any'} = $m2);
        1
    }
    else {
        0
    }
})) && ((do {
    ($MATCH->{'capture'} = $MATCH->{'char_any'}->flat());
    1
}))))
})))
}))));
    $MATCH
};
sub double_quoted_buf {
    ((my  $grammar) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    ((my  $MATCH) = Perlito5::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1)));
    ($MATCH->{'bool'} = (((do {
    ((my  $pos1) = $MATCH->{'to'});
    ((((do {
    (((do {
    ((my  $tmp) = $MATCH);
    ($MATCH = Perlito5::Match->new(('str' => $str), ('from' => $tmp->{'to'}), ('to' => $tmp->{'to'}), ('bool' => 1)));
    ($MATCH->{'bool'} = ((do {
    ((my  $pos1) = $MATCH->{'to'});
    ((do {
    ((chr(36) eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'}))))
}))
})));
    ($tmp->{'bool'} = ($MATCH->{'bool'} ? 1 : 0));
    ($MATCH = $tmp);
    ($MATCH->{'bool'} ? 1 : 0)
})) && ((do {
    ((my  $pos1) = $MATCH->{'to'});
    (((do {
    (((do {
    ((my  $m2) = Perlito5::Expression->term_sigil($str, $MATCH->{'to'}));
    if (($m2->{'bool'})) {
        ($MATCH->{'to'} = $m2->{'to'});
        ($MATCH->{'Perlito5::Expression.term_sigil'} = $m2);
        1
    }
    else {
        0
    }
})) && ((do {
    ($MATCH->{'capture'} = $MATCH->{'Perlito5::Expression.term_sigil'}->flat()->[1]);
    1
})))
})) || ((do {
    ($MATCH->{'to'} = $pos1);
    ((((do {
    ((my  $m2) = $grammar->char_any($str, $MATCH->{'to'}));
    if (($m2->{'bool'})) {
        ($MATCH->{'to'} = $m2->{'to'});
        ($MATCH->{'char_any'} = $m2);
        1
    }
    else {
        0
    }
})) && ((do {
    ($MATCH->{'capture'} = Perlito5::AST::Val::Buf->new(('buf' => $MATCH->{'char_any'}->flat())));
    1
}))))
})))
})))
})) || ((do {
    ($MATCH->{'to'} = $pos1);
    ((((do {
    ((my  $tmp) = $MATCH);
    ($MATCH = Perlito5::Match->new(('str' => $str), ('from' => $tmp->{'to'}), ('to' => $tmp->{'to'}), ('bool' => 1)));
    ($MATCH->{'bool'} = ((do {
    ((my  $pos1) = $MATCH->{'to'});
    ((do {
    ((chr(64) eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'}))))
}))
})));
    ($tmp->{'bool'} = ($MATCH->{'bool'} ? 1 : 0));
    ($MATCH = $tmp);
    ($MATCH->{'bool'} ? 1 : 0)
})) && ((do {
    ((my  $pos1) = $MATCH->{'to'});
    (((do {
    (((do {
    ((my  $m2) = Perlito5::Expression->term_sigil($str, $MATCH->{'to'}));
    if (($m2->{'bool'})) {
        ($MATCH->{'to'} = $m2->{'to'});
        ($MATCH->{'Perlito5::Expression.term_sigil'} = $m2);
        1
    }
    else {
        0
    }
})) && ((do {
    ($MATCH->{'capture'} = Perlito5::AST::Apply->new(('namespace' => ''), ('code' => 'join'), ('arguments' => [Perlito5::AST::Val::Buf->new(('buf' => ' ')), ($MATCH->{'Perlito5::Expression.term_sigil'}->flat())->[1]])));
    1
})))
})) || ((do {
    ($MATCH->{'to'} = $pos1);
    ((((do {
    ((my  $m2) = $grammar->char_any($str, $MATCH->{'to'}));
    if (($m2->{'bool'})) {
        ($MATCH->{'to'} = $m2->{'to'});
        ($MATCH->{'char_any'} = $m2);
        1
    }
    else {
        0
    }
})) && ((do {
    ($MATCH->{'capture'} = Perlito5::AST::Val::Buf->new(('buf' => $MATCH->{'char_any'}->flat())));
    1
}))))
})))
}))))
}))) || ((do {
    ($MATCH->{'to'} = $pos1);
    ((((((chr(92) eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'}))))) && ((do {
    ((my  $m2) = $grammar->double_quoted_unescape($str, $MATCH->{'to'}));
    if (($m2->{'bool'})) {
        ($MATCH->{'to'} = $m2->{'to'});
        ($MATCH->{'double_quoted_unescape'} = $m2);
        1
    }
    else {
        0
    }
}))) && ((do {
    ($MATCH->{'capture'} = Perlito5::AST::Val::Buf->new(('buf' => $MATCH->{'double_quoted_unescape'}->flat())));
    1
}))))
})))
}))));
    $MATCH
};
sub val_buf {
    ((my  $grammar) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    ((my  $MATCH) = Perlito5::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1)));
    ($MATCH->{'bool'} = (((do {
    ((my  $pos1) = $MATCH->{'to'});
    (((do {
    (((((chr(34) eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'}))))) && ((do {
    ((my  $m2) = $grammar->double_quote_parse($str, $MATCH->{'to'}));
    if (($m2->{'bool'})) {
        ($MATCH->{'to'} = $m2->{'to'});
        ($MATCH->{'double_quote_parse'} = $m2);
        1
    }
    else {
        0
    }
}))) && ((do {
    ($MATCH->{'capture'} = $MATCH->{'double_quote_parse'}->flat());
    1
})))
})) || ((do {
    ($MATCH->{'to'} = $pos1);
    ((((((chr(39) eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'}))))) && ((do {
    ((my  $m2) = $grammar->single_quote_parse($str, $MATCH->{'to'}));
    if (($m2->{'bool'})) {
        ($MATCH->{'to'} = $m2->{'to'});
        ($MATCH->{'single_quote_parse'} = $m2);
        1
    }
    else {
        0
    }
}))) && ((do {
    ($MATCH->{'capture'} = $MATCH->{'single_quote_parse'}->flat());
    1
}))))
})))
}))));
    $MATCH
};
1;

1;
