# Do not edit this file - Generated by Perlito5 8.0
use v5;
use utf8;
use strict;
use warnings;
no warnings ('redefine', 'once', 'void', 'uninitialized', 'misc', 'recursion');
use Perlito5::Perl5::Runtime;
use Perlito5::Perl5::Prelude;
our $MATCH = Perlito5::Match->new();
{
package main;
    sub new { shift; bless { @_ }, "main" }
    package Perlito5::Grammar::Regex;
    (my  $Hash_rule_terms = bless {}, 'HASH');
    sub ws {
        my $List__ = bless \@_, "ARRAY";
        ((my  $grammar) = $List__->[0]);
        ((my  $str) = $List__->[1]);
        ((my  $pos) = $List__->[2]);
        ((my  $MATCH) = Perlito5::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1)));
        (($MATCH)->{bool} = (((do {
    ((my  $pos1) = $MATCH->to());
    ((do {
    ((my  $m2) = Perlito5::Grammar->ws($str, $MATCH->to()));
    if (($m2)) {
        (($MATCH)->{to} = $m2->to());
        1
    }
    else {
        0
    }
}))
}))));
        $MATCH
    };
    sub rule_ident {
        my $List__ = bless \@_, "ARRAY";
        ((my  $grammar) = $List__->[0]);
        ((my  $str) = $List__->[1]);
        ((my  $pos) = $List__->[2]);
        ((my  $MATCH) = Perlito5::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1)));
        (($MATCH)->{bool} = (((do {
    ((my  $pos1) = $MATCH->to());
    (((do {
    ((my  $m2) = Perlito5::Grammar->full_ident($str, $MATCH->to()));
    if (($m2)) {
        (($MATCH)->{to} = $m2->to());
        1
    }
    else {
        0
    }
})) || ((do {
    (($MATCH)->{to} = $pos1);
    (((do {
    ((my  $m2) = $grammar->digit($str, $MATCH->to()));
    if (($m2)) {
        (($MATCH)->{to} = $m2->to());
        ($MATCH->{'digit'} = $m2);
        1
    }
    else {
        0
    }
})))
})))
}))));
        $MATCH
    };
    sub any {
        my $List__ = bless \@_, "ARRAY";
        ((my  $grammar) = $List__->[0]);
        ((my  $str) = $List__->[1]);
        ((my  $pos) = $List__->[2]);
        ((my  $MATCH) = Perlito5::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1)));
        (($MATCH)->{bool} = (((do {
    ((my  $pos1) = $MATCH->to());
    ((do {
    (('' ne substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to()))))
}))
}))));
        $MATCH
    };
    sub literal {
        my $List__ = bless \@_, "ARRAY";
        ((my  $grammar) = $List__->[0]);
        ((my  $str) = $List__->[1]);
        ((my  $pos) = $List__->[2]);
        ((my  $MATCH) = Perlito5::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1)));
        (($MATCH)->{bool} = (((do {
    ((my  $pos1) = $MATCH->to());
    ((do {
    ((my  $last_match_null) = 0);
    ((my  $last_pos) = $MATCH->to());
    for ( ; ((((do {
    ((my  $pos1) = $MATCH->to());
    (((do {
    ((((chr(92) eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to()))))) && ((('' ne substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to()))))))
})) || ((do {
    (($MATCH)->{to} = $pos1);
    ((((do {
    ((my  $tmp) = $MATCH);
    ($MATCH = Perlito5::Match->new(('str' => $str), ('from' => $tmp->to()), ('to' => $tmp->to()), ('bool' => 1)));
    (($MATCH)->{bool} = ((do {
    ((my  $pos1) = $MATCH->to());
    ((do {
    ((chr(39) eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to()))))
}))
})));
    (($tmp)->{bool} = !($MATCH));
    ($MATCH = $tmp);
    ($MATCH ? 1 : 0)
})) && ((('' ne substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to())))))))
})))
})) && (($last_match_null < 2))));  ) {
        if ((($last_pos == $MATCH->to()))) {
            ($last_match_null = ($last_match_null + 1))
        }
        else {
            ($last_match_null = 0)
        };
        ($last_pos = $MATCH->to())
    };
    (($MATCH)->{to} = $last_pos);
    1
}))
}))));
        $MATCH
    };
    sub metasyntax_exp {
        my $List__ = bless \@_, "ARRAY";
        ((my  $grammar) = $List__->[0]);
        ((my  $str) = $List__->[1]);
        ((my  $pos) = $List__->[2]);
        ((my  $MATCH) = Perlito5::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1)));
        (($MATCH)->{bool} = (((do {
    ((my  $pos1) = $MATCH->to());
    ((do {
    ((my  $last_match_null) = 0);
    ((my  $last_pos) = $MATCH->to());
    ((my  $count) = 0);
    for ( ; ((((do {
    ((my  $pos1) = $MATCH->to());
    ((((((do {
    ((((chr(92) eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to()))))) && ((('' ne substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to()))))))
})) || ((do {
    (($MATCH)->{to} = $pos1);
    ((((((chr(39) eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to()))))) && ((do {
    ((my  $m2) = $grammar->literal($str, $MATCH->to()));
    if (($m2)) {
        (($MATCH)->{to} = $m2->to());
        1
    }
    else {
        0
    }
}))) && (((chr(39) eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to())))))))
}))) || ((do {
    (($MATCH)->{to} = $pos1);
    ((((((chr(123) eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to()))))) && ((do {
    ((my  $m2) = $grammar->string_code($str, $MATCH->to()));
    if (($m2)) {
        (($MATCH)->{to} = $m2->to());
        1
    }
    else {
        0
    }
}))) && (((chr(125) eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to())))))))
}))) || ((do {
    (($MATCH)->{to} = $pos1);
    (((((('<' eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to()))))) && ((do {
    ((my  $m2) = $grammar->metasyntax_exp($str, $MATCH->to()));
    if (($m2)) {
        (($MATCH)->{to} = $m2->to());
        1
    }
    else {
        0
    }
}))) && ((('>' eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to())))))))
}))) || ((do {
    (($MATCH)->{to} = $pos1);
    ((((do {
    ((my  $tmp) = $MATCH);
    ($MATCH = Perlito5::Match->new(('str' => $str), ('from' => $tmp->to()), ('to' => $tmp->to()), ('bool' => 1)));
    (($MATCH)->{bool} = ((do {
    ((my  $pos1) = $MATCH->to());
    ((do {
    (('>' eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to()))))
}))
})));
    (($tmp)->{bool} = !($MATCH));
    ($MATCH = $tmp);
    ($MATCH ? 1 : 0)
})) && ((('' ne substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to())))))))
})))
})) && (($last_match_null < 2))));  ) {
        if ((($last_pos == $MATCH->to()))) {
            ($last_match_null = ($last_match_null + 1))
        }
        else {
            ($last_match_null = 0)
        };
        ($last_pos = $MATCH->to());
        ($count = ($count + 1))
    };
    (($MATCH)->{to} = $last_pos);
    ($count > 0)
}))
}))));
        $MATCH
    };
    sub char_range {
        my $List__ = bless \@_, "ARRAY";
        ((my  $grammar) = $List__->[0]);
        ((my  $str) = $List__->[1]);
        ((my  $pos) = $List__->[2]);
        ((my  $MATCH) = Perlito5::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1)));
        (($MATCH)->{bool} = (((do {
    ((my  $pos1) = $MATCH->to());
    ((do {
    ((my  $last_match_null) = 0);
    ((my  $last_pos) = $MATCH->to());
    ((my  $count) = 0);
    for ( ; ((((do {
    ((my  $pos1) = $MATCH->to());
    (((do {
    ((((chr(92) eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to()))))) && ((('' ne substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to()))))))
})) || ((do {
    (($MATCH)->{to} = $pos1);
    ((((do {
    ((my  $tmp) = $MATCH);
    ($MATCH = Perlito5::Match->new(('str' => $str), ('from' => $tmp->to()), ('to' => $tmp->to()), ('bool' => 1)));
    (($MATCH)->{bool} = ((do {
    ((my  $pos1) = $MATCH->to());
    ((do {
    ((']' eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to()))))
}))
})));
    (($tmp)->{bool} = !($MATCH));
    ($MATCH = $tmp);
    ($MATCH ? 1 : 0)
})) && ((('' ne substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to())))))))
})))
})) && (($last_match_null < 2))));  ) {
        if ((($last_pos == $MATCH->to()))) {
            ($last_match_null = ($last_match_null + 1))
        }
        else {
            ($last_match_null = 0)
        };
        ($last_pos = $MATCH->to());
        ($count = ($count + 1))
    };
    (($MATCH)->{to} = $last_pos);
    ($count > 0)
}))
}))));
        $MATCH
    };
    sub char_class {
        my $List__ = bless \@_, "ARRAY";
        ((my  $grammar) = $List__->[0]);
        ((my  $str) = $List__->[1]);
        ((my  $pos) = $List__->[2]);
        ((my  $MATCH) = Perlito5::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1)));
        (($MATCH)->{bool} = (((do {
    ((my  $pos1) = $MATCH->to());
    (((do {
    ((my  $m2) = $grammar->rule_ident($str, $MATCH->to()));
    if (($m2)) {
        (($MATCH)->{to} = $m2->to());
        1
    }
    else {
        0
    }
})) || ((do {
    (($MATCH)->{to} = $pos1);
    (((((('[' eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to()))))) && ((do {
    ((my  $m2) = $grammar->char_range($str, $MATCH->to()));
    if (($m2)) {
        (($MATCH)->{to} = $m2->to());
        1
    }
    else {
        0
    }
}))) && (((']' eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to())))))))
})))
}))));
        $MATCH
    };
    sub string_code {
        my $List__ = bless \@_, "ARRAY";
        ((my  $grammar) = $List__->[0]);
        ((my  $str) = $List__->[1]);
        ((my  $pos) = $List__->[2]);
        ((my  $MATCH) = Perlito5::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1)));
        (($MATCH)->{bool} = (((do {
    ((my  $pos1) = $MATCH->to());
    ((do {
    ((my  $last_match_null) = 0);
    ((my  $last_pos) = $MATCH->to());
    ((my  $count) = 0);
    for ( ; ((((do {
    ((my  $pos1) = $MATCH->to());
    (((((do {
    ((((chr(92) eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to()))))) && ((('' ne substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to()))))))
})) || ((do {
    (($MATCH)->{to} = $pos1);
    ((((((chr(39) eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to()))))) && ((do {
    ((my  $m2) = $grammar->literal($str, $MATCH->to()));
    if (($m2)) {
        (($MATCH)->{to} = $m2->to());
        1
    }
    else {
        0
    }
}))) && (((chr(39) eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to())))))))
}))) || ((do {
    (($MATCH)->{to} = $pos1);
    ((((((chr(123) eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to()))))) && ((do {
    ((my  $m2) = $grammar->string_code($str, $MATCH->to()));
    if (($m2)) {
        (($MATCH)->{to} = $m2->to());
        1
    }
    else {
        0
    }
}))) && (((chr(125) eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to())))))))
}))) || ((do {
    (($MATCH)->{to} = $pos1);
    ((((do {
    ((my  $tmp) = $MATCH);
    ($MATCH = Perlito5::Match->new(('str' => $str), ('from' => $tmp->to()), ('to' => $tmp->to()), ('bool' => 1)));
    (($MATCH)->{bool} = ((do {
    ((my  $pos1) = $MATCH->to());
    ((do {
    ((chr(125) eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to()))))
}))
})));
    (($tmp)->{bool} = !($MATCH));
    ($MATCH = $tmp);
    ($MATCH ? 1 : 0)
})) && ((('' ne substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to())))))))
})))
})) && (($last_match_null < 2))));  ) {
        if ((($last_pos == $MATCH->to()))) {
            ($last_match_null = ($last_match_null + 1))
        }
        else {
            ($last_match_null = 0)
        };
        ($last_pos = $MATCH->to());
        ($count = ($count + 1))
    };
    (($MATCH)->{to} = $last_pos);
    ($count > 0)
}))
}))));
        $MATCH
    };
    sub parsed_code {
        my $List__ = bless \@_, "ARRAY";
        ((my  $grammar) = $List__->[0]);
        ((my  $str) = $List__->[1]);
        ((my  $pos) = $List__->[2]);
        ((my  $MATCH) = Perlito5::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1)));
        (($MATCH)->{bool} = (((do {
    ((my  $pos1) = $MATCH->to());
    ((do {
    (((do {
    ((my  $m2) = $grammar->string_code($str, $MATCH->to()));
    if (($m2)) {
        (($MATCH)->{to} = $m2->to());
        1
    }
    else {
        0
    }
})) && ((((do {
    ($MATCH->{capture} = (('' . $MATCH)))
})) || 1)))
}))
}))));
        $MATCH
    };
    sub named_capture_body {
        my $List__ = bless \@_, "ARRAY";
        ((my  $grammar) = $List__->[0]);
        ((my  $str) = $List__->[1]);
        ((my  $pos) = $List__->[2]);
        ((my  $MATCH) = Perlito5::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1)));
        (($MATCH)->{bool} = (((do {
    ((my  $pos1) = $MATCH->to());
    (((((do {
    (((((('(' eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to()))))) && ((do {
    ((my  $m2) = $grammar->rule($str, $MATCH->to()));
    if (($m2)) {
        (($MATCH)->{to} = $m2->to());
        ($MATCH->{'rule'} = $m2);
        1
    }
    else {
        0
    }
}))) && (((')' eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to())))))) && ((((do {
    ($MATCH->{capture} = ((do {
    (my  $Hash_a = bless {}, 'HASH');
    ($Hash_a->{'capturing_group'} = $MATCH->{'rule'}->flat());
    $Hash_a
})))
})) || 1)))
})) || ((do {
    (($MATCH)->{to} = $pos1);
    ((((((('[' eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to()))))) && ((do {
    ((my  $m2) = $grammar->rule($str, $MATCH->to()));
    if (($m2)) {
        (($MATCH)->{to} = $m2->to());
        ($MATCH->{'rule'} = $m2);
        1
    }
    else {
        0
    }
}))) && (((']' eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to())))))) && ((((do {
    ($MATCH->{capture} = ($MATCH->{'rule'}->flat()))
})) || 1))))
}))) || ((do {
    (($MATCH)->{to} = $pos1);
    ((((((('<' eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to()))))) && ((do {
    ((my  $m2) = $grammar->metasyntax_exp($str, $MATCH->to()));
    if (($m2)) {
        (($MATCH)->{to} = $m2->to());
        ($MATCH->{'metasyntax_exp'} = $m2);
        1
    }
    else {
        0
    }
}))) && ((('>' eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to())))))) && ((((do {
    ($MATCH->{capture} = (Rul::Subrule->new(('metasyntax' => $MATCH->{'metasyntax_exp'}->flat()), ('captures' => 1))))
})) || 1))))
}))) || ((do {
    (($MATCH)->{to} = $pos1);
    (((((do {
    die('invalid alias syntax')
})) || 1)))
})))
}))));
        $MATCH
    };
    sub variables {
        my $List__ = bless \@_, "ARRAY";
        ((my  $grammar) = $List__->[0]);
        ((my  $str) = $List__->[1]);
        ((my  $pos) = $List__->[2]);
        ((my  $MATCH) = Perlito5::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1)));
        (($MATCH)->{bool} = (((do {
    ((my  $pos1) = $MATCH->to());
    ((((do {
    ((((((chr(36) . '<' eq substr($str, $MATCH->to(), 2)) && ((($MATCH)->{to} = (2 + $MATCH->to()))))) && ((do {
    ((my  $m2) = $grammar->rule_ident($str, $MATCH->to()));
    if (($m2)) {
        (($MATCH)->{to} = $m2->to());
        ($MATCH->{'rule_ident'} = $m2);
        1
    }
    else {
        0
    }
}))) && ((('>' eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to())))))) && ((((do {
    ($MATCH->{capture} = ((chr(36) . 'MATCH' . chr(123) . chr(39) . $MATCH->{'rule_ident'} . chr(39) . chr(125))))
})) || 1)))
})) || ((do {
    (($MATCH)->{to} = $pos1);
    (((((do {
    ((my  $m2) = Perlito5::Grammar->var_sigil($str, $MATCH->to()));
    if (($m2)) {
        (($MATCH)->{to} = $m2->to());
        ($MATCH->{'Perlito5::Grammar.var_sigil'} = $m2);
        1
    }
    else {
        0
    }
})) && ((do {
    ((my  $m2) = Perlito5::Grammar->val_int($str, $MATCH->to()));
    if (($m2)) {
        (($MATCH)->{to} = $m2->to());
        ($MATCH->{'Perlito5::Grammar.val_int'} = $m2);
        1
    }
    else {
        0
    }
}))) && ((((do {
    ($MATCH->{capture} = (($MATCH->{'Perlito5::Grammar.var_sigil'} . chr(47) . '[' . $MATCH->{'Perlito5::Grammar.val_int'} . ']')))
})) || 1))))
}))) || ((do {
    (($MATCH)->{to} = $pos1);
    ((((((do {
    ((my  $m2) = Perlito5::Grammar->var_sigil($str, $MATCH->to()));
    if (($m2)) {
        (($MATCH)->{to} = $m2->to());
        ($MATCH->{'Perlito5::Grammar.var_sigil'} = $m2);
        1
    }
    else {
        0
    }
})) && ((do {
    ((my  $m2) = Perlito5::Grammar->var_twigil($str, $MATCH->to()));
    if (($m2)) {
        (($MATCH)->{to} = $m2->to());
        ($MATCH->{'Perlito5::Grammar.var_twigil'} = $m2);
        1
    }
    else {
        0
    }
}))) && ((do {
    ((my  $m2) = Perlito5::Grammar->full_ident($str, $MATCH->to()));
    if (($m2)) {
        (($MATCH)->{to} = $m2->to());
        ($MATCH->{'Perlito5::Grammar.full_ident'} = $m2);
        1
    }
    else {
        0
    }
}))) && ((((do {
    ($MATCH->{capture} = (Rul::Var->new(('sigil' => ('' . $MATCH->{'Perlito5::Grammar.var_sigil'})), ('twigil' => ('' . $MATCH->{'Perlito5::Grammar.var_twigil'})), ('name' => ('' . $MATCH->{'Perlito5::Grammar.full_ident'})))))
})) || 1))))
})))
}))));
        $MATCH
    };
    sub rule_terms {
        my $List__ = bless \@_, "ARRAY";
        ((my  $grammar) = $List__->[0]);
        ((my  $str) = $List__->[1]);
        ((my  $pos) = $List__->[2]);
        ((my  $MATCH) = Perlito5::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1)));
        (($MATCH)->{bool} = (((do {
    ((my  $pos1) = $MATCH->to());
    ((((((((((((((((do {
    (((((('(' eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to()))))) && ((do {
    ((my  $m2) = $grammar->rule($str, $MATCH->to()));
    if (($m2)) {
        (($MATCH)->{to} = $m2->to());
        ($MATCH->{'rule'} = $m2);
        1
    }
    else {
        0
    }
}))) && (((')' eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to())))))) && ((((do {
    ($MATCH->{capture} = (Rul::Capture->new(('rule_exp' => $MATCH->{'rule'}->flat()))))
})) || 1)))
})) || ((do {
    (($MATCH)->{to} = $pos1);
    ((((((('<(' eq substr($str, $MATCH->to(), 2)) && ((($MATCH)->{to} = (2 + $MATCH->to()))))) && ((do {
    ((my  $m2) = $grammar->rule($str, $MATCH->to()));
    if (($m2)) {
        (($MATCH)->{to} = $m2->to());
        ($MATCH->{'rule'} = $m2);
        1
    }
    else {
        0
    }
}))) && (((')>' eq substr($str, $MATCH->to(), 2)) && ((($MATCH)->{to} = (2 + $MATCH->to())))))) && ((((do {
    ($MATCH->{capture} = (Rul::CaptureResult->new(('rule_exp' => $MATCH->{'rule'}->flat()))))
})) || 1))))
}))) || ((do {
    (($MATCH)->{to} = $pos1);
    (((((((('<after' eq substr($str, $MATCH->to(), 6)) && ((($MATCH)->{to} = (6 + $MATCH->to()))))) && ((do {
    ((my  $m2) = $grammar->ws($str, $MATCH->to()));
    if (($m2)) {
        (($MATCH)->{to} = $m2->to());
        1
    }
    else {
        0
    }
}))) && ((do {
    ((my  $m2) = $grammar->rule($str, $MATCH->to()));
    if (($m2)) {
        (($MATCH)->{to} = $m2->to());
        ($MATCH->{'rule'} = $m2);
        1
    }
    else {
        0
    }
}))) && ((('>' eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to())))))) && ((((do {
    ($MATCH->{capture} = (Rul::After->new(('rule_exp' => $MATCH->{'rule'}->flat()))))
})) || 1))))
}))) || ((do {
    (($MATCH)->{to} = $pos1);
    (((((((('<before' eq substr($str, $MATCH->to(), 7)) && ((($MATCH)->{to} = (7 + $MATCH->to()))))) && ((do {
    ((my  $m2) = $grammar->ws($str, $MATCH->to()));
    if (($m2)) {
        (($MATCH)->{to} = $m2->to());
        1
    }
    else {
        0
    }
}))) && ((do {
    ((my  $m2) = $grammar->rule($str, $MATCH->to()));
    if (($m2)) {
        (($MATCH)->{to} = $m2->to());
        ($MATCH->{'rule'} = $m2);
        1
    }
    else {
        0
    }
}))) && ((('>' eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to())))))) && ((((do {
    ($MATCH->{capture} = (Rul::Before->new(('rule_exp' => $MATCH->{'rule'}->flat()))))
})) || 1))))
}))) || ((do {
    (($MATCH)->{to} = $pos1);
    (((((((('<' . chr(33) . 'before' eq substr($str, $MATCH->to(), 8)) && ((($MATCH)->{to} = (8 + $MATCH->to()))))) && ((do {
    ((my  $m2) = $grammar->ws($str, $MATCH->to()));
    if (($m2)) {
        (($MATCH)->{to} = $m2->to());
        1
    }
    else {
        0
    }
}))) && ((do {
    ((my  $m2) = $grammar->rule($str, $MATCH->to()));
    if (($m2)) {
        (($MATCH)->{to} = $m2->to());
        ($MATCH->{'rule'} = $m2);
        1
    }
    else {
        0
    }
}))) && ((('>' eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to())))))) && ((((do {
    ($MATCH->{capture} = (Rul::NotBefore->new(('rule_exp' => $MATCH->{'rule'}->flat()))))
})) || 1))))
}))) || ((do {
    (($MATCH)->{to} = $pos1);
    ((((((('<' . chr(33) eq substr($str, $MATCH->to(), 2)) && ((($MATCH)->{to} = (2 + $MATCH->to()))))) && ((do {
    ((my  $m2) = $grammar->metasyntax_exp($str, $MATCH->to()));
    if (($m2)) {
        (($MATCH)->{to} = $m2->to());
        ($MATCH->{'metasyntax_exp'} = $m2);
        1
    }
    else {
        0
    }
}))) && ((('>' eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to())))))) && ((((do {
    ($MATCH->{capture} = ((do {
    (my  $Hash_a = bless {}, 'HASH');
    ($Hash_a->{'negate'} = (do {
    (my  $Hash_a = bless {}, 'HASH');
    ($Hash_a->{'metasyntax'} = $MATCH->{'metasyntax_exp'}->flat());
    $Hash_a
}));
    $Hash_a
})))
})) || 1))))
}))) || ((do {
    (($MATCH)->{to} = $pos1);
    ((((((('<+' eq substr($str, $MATCH->to(), 2)) && ((($MATCH)->{to} = (2 + $MATCH->to()))))) && ((do {
    ((my  $m2) = $grammar->char_class($str, $MATCH->to()));
    if (($m2)) {
        (($MATCH)->{to} = $m2->to());
        ($MATCH->{'char_class'} = $m2);
        1
    }
    else {
        0
    }
}))) && ((('>' eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to())))))) && ((((do {
    ($MATCH->{capture} = (Rul::CharClass->new(('chars' => ('' . $MATCH->{'char_class'})))))
})) || 1))))
}))) || ((do {
    (($MATCH)->{to} = $pos1);
    ((((((('<-' eq substr($str, $MATCH->to(), 2)) && ((($MATCH)->{to} = (2 + $MATCH->to()))))) && ((do {
    ((my  $m2) = $grammar->char_class($str, $MATCH->to()));
    if (($m2)) {
        (($MATCH)->{to} = $m2->to());
        ($MATCH->{'char_class'} = $m2);
        1
    }
    else {
        0
    }
}))) && ((('>' eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to())))))) && ((((do {
    ($MATCH->{capture} = (Rul::NegateCharClass->new(('chars' => ('' . $MATCH->{'char_class'})))))
})) || 1))))
}))) || ((do {
    (($MATCH)->{to} = $pos1);
    (((((((chr(39) eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to()))))) && ((do {
    ((my  $m2) = $grammar->literal($str, $MATCH->to()));
    if (($m2)) {
        (($MATCH)->{to} = $m2->to());
        ($MATCH->{'literal'} = $m2);
        1
    }
    else {
        0
    }
}))) && (((chr(39) eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to())))))) && ((((do {
    ($MATCH->{capture} = (Rul::Constant->new(('constant' => $MATCH->{'literal'}->flat()))))
})) || 1))))
}))) || ((do {
    (($MATCH)->{to} = $pos1);
    ((((((((('<' eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to()))))) && (((chr(39) eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to())))))) && ((do {
    ((my  $m2) = $grammar->literal($str, $MATCH->to()));
    if (($m2)) {
        (($MATCH)->{to} = $m2->to());
        ($MATCH->{'literal'} = $m2);
        1
    }
    else {
        0
    }
}))) && (((chr(39) eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to())))))) && ((('>' eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to())))))) && ((((do {
    ($MATCH->{capture} = (Rul::Constant->new(('constant' => $MATCH->{'literal'}->flat()))))
})) || 1))))
}))) || ((do {
    (($MATCH)->{to} = $pos1);
    ((((('<' eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to()))))) && ((do {
    ((my  $pos1) = $MATCH->to());
    (((((do {
    ((((do {
    ((my  $m2) = $grammar->variables($str, $MATCH->to()));
    if (($m2)) {
        (($MATCH)->{to} = $m2->to());
        ($MATCH->{'variables'} = $m2);
        1
    }
    else {
        0
    }
})) && ((('>' eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to())))))) && ((((do {
    ($MATCH->{capture} = (Rul::InterpolateVar->new(('var' => $MATCH->{'variables'}->flat()))))
})) || 1)))
})) || ((do {
    (($MATCH)->{to} = $pos1);
    (((((((chr(63) eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to()))))) && ((do {
    ((my  $m2) = $grammar->metasyntax_exp($str, $MATCH->to()));
    if (($m2)) {
        (($MATCH)->{to} = $m2->to());
        ($MATCH->{'metasyntax_exp'} = $m2);
        1
    }
    else {
        0
    }
}))) && ((('>' eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to())))))) && ((((do {
    ($MATCH->{capture} = (Rul::Subrule->new(('metasyntax' => $MATCH->{'metasyntax_exp'}->flat()), ('captures' => 0))))
})) || 1))))
}))) || ((do {
    (($MATCH)->{to} = $pos1);
    ((((((('.' eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to()))))) && ((do {
    ((my  $m2) = $grammar->metasyntax_exp($str, $MATCH->to()));
    if (($m2)) {
        (($MATCH)->{to} = $m2->to());
        ($MATCH->{'metasyntax_exp'} = $m2);
        1
    }
    else {
        0
    }
}))) && ((('>' eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to())))))) && ((((do {
    ($MATCH->{capture} = (Rul::Subrule->new(('metasyntax' => $MATCH->{'metasyntax_exp'}->flat()), ('captures' => 0))))
})) || 1))))
}))) || ((do {
    (($MATCH)->{to} = $pos1);
    (((((do {
    ((my  $m2) = $grammar->metasyntax_exp($str, $MATCH->to()));
    if (($m2)) {
        (($MATCH)->{to} = $m2->to());
        ($MATCH->{'metasyntax_exp'} = $m2);
        1
    }
    else {
        0
    }
})) && ((('>' eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to())))))) && ((((do {
    ($MATCH->{capture} = (Rul::Subrule->new(('metasyntax' => $MATCH->{'metasyntax_exp'}->flat()), ('captures' => 1))))
})) || 1))))
})))
}))))
}))) || ((do {
    (($MATCH)->{to} = $pos1);
    (((((((chr(123) eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to()))))) && ((do {
    ((my  $m2) = $grammar->parsed_code($str, $MATCH->to()));
    if (($m2)) {
        (($MATCH)->{to} = $m2->to());
        ($MATCH->{'parsed_code'} = $m2);
        1
    }
    else {
        0
    }
}))) && (((chr(125) eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to())))))) && ((((do {
    ($MATCH->{capture} = (Rul::Block->new(('closure' => $MATCH->{'parsed_code'}->flat()))))
})) || 1))))
}))) || ((do {
    (($MATCH)->{to} = $pos1);
    (((((chr(92) eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to()))))) && ((do {
    ((my  $pos1) = $MATCH->to());
    ((((do {
    ((((((('c' eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to()))))) && ((('[' eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to())))))) && ((do {
    ((my  $m2) = Perlito5::Grammar->digits($str, $MATCH->to()));
    if (($m2)) {
        (($MATCH)->{to} = $m2->to());
        ($MATCH->{'Perlito5::Grammar.digits'} = $m2);
        1
    }
    else {
        0
    }
}))) && (((']' eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to())))))) && ((((do {
    ($MATCH->{capture} = (Rul::Constant->new(('constant' => chr($MATCH->{'Perlito5::Grammar.digits'})))))
})) || 1)))
})) || ((do {
    (($MATCH)->{to} = $pos1);
    (((((('c' eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to()))))) && ((do {
    ((my  $m2) = Perlito5::Grammar->digits($str, $MATCH->to()));
    if (($m2)) {
        (($MATCH)->{to} = $m2->to());
        ($MATCH->{'Perlito5::Grammar.digits'} = $m2);
        1
    }
    else {
        0
    }
}))) && ((((do {
    ($MATCH->{capture} = (Rul::Constant->new(('constant' => chr($MATCH->{'Perlito5::Grammar.digits'})))))
})) || 1))))
}))) || ((do {
    (($MATCH)->{to} = $pos1);
    ((((do {
    ((my  $m2) = $grammar->any($str, $MATCH->to()));
    if (($m2)) {
        (($MATCH)->{to} = $m2->to());
        ($MATCH->{'any'} = $m2);
        1
    }
    else {
        0
    }
})) && ((((do {
    ($MATCH->{capture} = (Rul::SpecialChar->new(('char' => $MATCH->{'any'}->flat()))))
})) || 1))))
})))
}))))
}))) || ((do {
    (($MATCH)->{to} = $pos1);
    ((((('.' eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to()))))) && ((((do {
    ($MATCH->{capture} = (Rul::Dot->new()))
})) || 1))))
}))) || ((do {
    (($MATCH)->{to} = $pos1);
    ((((((('[' eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to()))))) && ((do {
    ((my  $m2) = $grammar->rule($str, $MATCH->to()));
    if (($m2)) {
        (($MATCH)->{to} = $m2->to());
        ($MATCH->{'rule'} = $m2);
        1
    }
    else {
        0
    }
}))) && (((']' eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to())))))) && ((((do {
    ($MATCH->{capture} = ($MATCH->{'rule'}->flat()))
})) || 1))))
})))
}))));
        $MATCH
    };
    sub rule_term {
        my $List__ = bless \@_, "ARRAY";
        ((my  $grammar) = $List__->[0]);
        ((my  $str) = $List__->[1]);
        ((my  $pos) = $List__->[2]);
        ((my  $MATCH) = Perlito5::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1)));
        (($MATCH)->{bool} = (((do {
    ((my  $pos1) = $MATCH->to());
    ((((do {
    (((do {
    ((my  $m2) = $grammar->variables($str, $MATCH->to()));
    if (($m2)) {
        (($MATCH)->{to} = $m2->to());
        ($MATCH->{'variables'} = $m2);
        1
    }
    else {
        0
    }
})) && ((do {
    ((my  $pos1) = $MATCH->to());
    (((do {
    ((((((do {
    ((my  $last_pos) = $MATCH->to());
    if ((!(((do {
    ((my  $m2) = $grammar->ws($str, $MATCH->to()));
    if (($m2)) {
        (($MATCH)->{to} = $m2->to());
        1
    }
    else {
        0
    }
}))))) {
        (($MATCH)->{to} = $last_pos)
    };
    1
})) && (((chr(61) eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to())))))) && ((do {
    ((my  $last_pos) = $MATCH->to());
    if ((!(((do {
    ((my  $m2) = $grammar->ws($str, $MATCH->to()));
    if (($m2)) {
        (($MATCH)->{to} = $m2->to());
        1
    }
    else {
        0
    }
}))))) {
        (($MATCH)->{to} = $last_pos)
    };
    1
}))) && ((do {
    ((my  $m2) = $grammar->named_capture_body($str, $MATCH->to()));
    if (($m2)) {
        (($MATCH)->{to} = $m2->to());
        ($MATCH->{'named_capture_body'} = $m2);
        1
    }
    else {
        0
    }
}))) && ((((do {
    ($MATCH->{capture} = (Rul::NamedCapture->new(('rule_exp' => $MATCH->{'named_capture_body'}->flat()), ('capture_ident' => $MATCH->{'variables'}->flat()))))
})) || 1)))
})) || ((do {
    (($MATCH)->{to} = $pos1);
    (((((do {
    ($MATCH->{capture} = ($MATCH->{'variables'}->flat()))
})) || 1)))
})))
})))
})) || ((do {
    (($MATCH)->{to} = $pos1);
    ((((do {
    ((my  $m2) = $grammar->rule_terms($str, $MATCH->to()));
    if (($m2)) {
        (($MATCH)->{to} = $m2->to());
        ($MATCH->{'rule_terms'} = $m2);
        1
    }
    else {
        0
    }
})) && ((((do {
    ($MATCH->{capture} = ($MATCH->{'rule_terms'}->flat()))
})) || 1))))
}))) || ((do {
    (($MATCH)->{to} = $pos1);
    (((((do {
    ((my  $tmp) = $MATCH);
    ($MATCH = Perlito5::Match->new(('str' => $str), ('from' => $tmp->to()), ('to' => $tmp->to()), ('bool' => 1)));
    (($MATCH)->{bool} = ((do {
    ((my  $pos1) = $MATCH->to());
    ((((((((((((do {
    ((']' eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to()))))
})) || ((do {
    (($MATCH)->{to} = $pos1);
    ((((chr(125) eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to()))))))
}))) || ((do {
    (($MATCH)->{to} = $pos1);
    ((((')' eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to()))))))
}))) || ((do {
    (($MATCH)->{to} = $pos1);
    (((('>' eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to()))))))
}))) || ((do {
    (($MATCH)->{to} = $pos1);
    ((((':' eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to()))))))
}))) || ((do {
    (($MATCH)->{to} = $pos1);
    ((((chr(63) eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to()))))))
}))) || ((do {
    (($MATCH)->{to} = $pos1);
    (((('+' eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to()))))))
}))) || ((do {
    (($MATCH)->{to} = $pos1);
    (((('*' eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to()))))))
}))) || ((do {
    (($MATCH)->{to} = $pos1);
    ((((chr(124) eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to()))))))
}))) || ((do {
    (($MATCH)->{to} = $pos1);
    ((((chr(38) eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to()))))))
}))) || ((do {
    (($MATCH)->{to} = $pos1);
    ((((chr(47) eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to()))))))
})))
})));
    (($tmp)->{bool} = !($MATCH));
    ($MATCH = $tmp);
    ($MATCH ? 1 : 0)
})) && ((do {
    ((my  $m2) = $grammar->any($str, $MATCH->to()));
    if (($m2)) {
        (($MATCH)->{to} = $m2->to());
        ($MATCH->{'any'} = $m2);
        1
    }
    else {
        0
    }
}))) && ((((do {
    ($MATCH->{capture} = (Rul::Constant->new(('constant' => $MATCH->{'any'}->flat()))))
})) || 1))))
})))
}))));
        $MATCH
    };
    sub quant_exp {
        my $List__ = bless \@_, "ARRAY";
        ((my  $grammar) = $List__->[0]);
        ((my  $str) = $List__->[1]);
        ((my  $pos) = $List__->[2]);
        ((my  $MATCH) = Perlito5::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1)));
        (($MATCH)->{bool} = (((do {
    ((my  $pos1) = $MATCH->to());
    (((do {
    ((((('**' eq substr($str, $MATCH->to(), 2)) && ((($MATCH)->{to} = (2 + $MATCH->to()))))) && ((do {
    ((my  $m2) = Perlito5::Grammar->opt_ws($str, $MATCH->to()));
    if (($m2)) {
        (($MATCH)->{to} = $m2->to());
        1
    }
    else {
        0
    }
}))) && ((do {
    ((my  $pos1) = $MATCH->to());
    (((do {
    (((do {
    ((my  $m2) = Perlito5::Grammar->val_int($str, $MATCH->to()));
    if (($m2)) {
        (($MATCH)->{to} = $m2->to());
        ($MATCH->{'Perlito5::Grammar.val_int'} = $m2);
        1
    }
    else {
        0
    }
})) && ((((do {
    ($MATCH->{capture} = ($MATCH->{'Perlito5::Grammar.val_int'}->flat()))
})) || 1)))
})) || ((do {
    (($MATCH)->{to} = $pos1);
    ((((do {
    ((my  $m2) = $grammar->rule_term($str, $MATCH->to()));
    if (($m2)) {
        (($MATCH)->{to} = $m2->to());
        ($MATCH->{'rule_term'} = $m2);
        1
    }
    else {
        0
    }
})) && ((((do {
    ($MATCH->{capture} = ($MATCH->{'rule_term'}->flat()))
})) || 1))))
})))
})))
})) || ((do {
    (($MATCH)->{to} = $pos1);
    (((do {
    ((my  $pos1) = $MATCH->to());
    ((((do {
    ((chr(63) eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to()))))
})) || ((do {
    (($MATCH)->{to} = $pos1);
    (((('*' eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to()))))))
}))) || ((do {
    (($MATCH)->{to} = $pos1);
    (((('+' eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to()))))))
})))
})))
})))
}))));
        $MATCH
    };
    sub greedy_exp {
        my $List__ = bless \@_, "ARRAY";
        ((my  $grammar) = $List__->[0]);
        ((my  $str) = $List__->[1]);
        ((my  $pos) = $List__->[2]);
        ((my  $MATCH) = Perlito5::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1)));
        (($MATCH)->{bool} = (((do {
    ((my  $pos1) = $MATCH->to());
    ((((do {
    ((chr(63) eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to()))))
})) || ((do {
    (($MATCH)->{to} = $pos1);
    (((('+' eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to()))))))
}))) || ((do {
    (($MATCH)->{to} = $pos1);
    (1)
})))
}))));
        $MATCH
    };
    sub quantifier {
        my $List__ = bless \@_, "ARRAY";
        ((my  $grammar) = $List__->[0]);
        ((my  $str) = $List__->[1]);
        ((my  $pos) = $List__->[2]);
        ((my  $MATCH) = Perlito5::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1)));
        (($MATCH)->{bool} = (((do {
    ((my  $pos1) = $MATCH->to());
    ((do {
    (((((do {
    ((my  $m2) = Perlito5::Grammar->opt_ws($str, $MATCH->to()));
    if (($m2)) {
        (($MATCH)->{to} = $m2->to());
        ($MATCH->{'Perlito5::Grammar.opt_ws'} = $m2);
        1
    }
    else {
        0
    }
})) && ((do {
    ((my  $m2) = $grammar->rule_term($str, $MATCH->to()));
    if (($m2)) {
        (($MATCH)->{to} = $m2->to());
        ($MATCH->{'rule_term'} = $m2);
        1
    }
    else {
        0
    }
}))) && ((do {
    ((my  $m2) = Perlito5::Grammar->opt_ws2($str, $MATCH->to()));
    if (($m2)) {
        (($MATCH)->{to} = $m2->to());
        ($MATCH->{'Perlito5::Grammar.opt_ws2'} = $m2);
        1
    }
    else {
        0
    }
}))) && ((do {
    ((my  $pos1) = $MATCH->to());
    (((do {
    (((((do {
    ((my  $m2) = $grammar->quant_exp($str, $MATCH->to()));
    if (($m2)) {
        (($MATCH)->{to} = $m2->to());
        ($MATCH->{'quant_exp'} = $m2);
        1
    }
    else {
        0
    }
})) && ((do {
    ((my  $m2) = $grammar->greedy_exp($str, $MATCH->to()));
    if (($m2)) {
        (($MATCH)->{to} = $m2->to());
        ($MATCH->{'greedy_exp'} = $m2);
        1
    }
    else {
        0
    }
}))) && ((do {
    ((my  $m2) = Perlito5::Grammar->opt_ws3($str, $MATCH->to()));
    if (($m2)) {
        (($MATCH)->{to} = $m2->to());
        ($MATCH->{'Perlito5::Grammar.opt_ws3'} = $m2);
        1
    }
    else {
        0
    }
}))) && ((((do {
    ($MATCH->{capture} = (Rul::Quantifier->new(('term' => $MATCH->{'rule_term'}->flat()), ('quant' => $MATCH->{'quant_exp'}->flat()), ('greedy' => $MATCH->{'greedy_exp'}->flat()), ('ws1' => $MATCH->{'Perlito5::Grammar.opt_ws'}->flat()), ('ws2' => $MATCH->{'Perlito5::Grammar.opt_ws2'}->flat()), ('ws3' => $MATCH->{'Perlito5::Grammar.opt_ws3'}->flat()))))
})) || 1)))
})) || ((do {
    (($MATCH)->{to} = $pos1);
    (((((do {
    ($MATCH->{capture} = ($MATCH->{'rule_term'}->flat()))
})) || 1)))
})))
})))
}))
}))));
        $MATCH
    };
    sub concat_list {
        my $List__ = bless \@_, "ARRAY";
        ((my  $grammar) = $List__->[0]);
        ((my  $str) = $List__->[1]);
        ((my  $pos) = $List__->[2]);
        ((my  $MATCH) = Perlito5::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1)));
        (($MATCH)->{bool} = (((do {
    ((my  $pos1) = $MATCH->to());
    (((do {
    (((do {
    ((my  $m2) = $grammar->quantifier($str, $MATCH->to()));
    if (($m2)) {
        (($MATCH)->{to} = $m2->to());
        ($MATCH->{'quantifier'} = $m2);
        1
    }
    else {
        0
    }
})) && ((do {
    ((my  $pos1) = $MATCH->to());
    (((do {
    (((do {
    ((my  $m2) = $grammar->concat_list($str, $MATCH->to()));
    if (($m2)) {
        (($MATCH)->{to} = $m2->to());
        ($MATCH->{'concat_list'} = $m2);
        1
    }
    else {
        0
    }
})) && ((((do {
    ($MATCH->{capture} = ((do {
    (my  $List_a = bless [], 'ARRAY');
    (my  $List_v = bless [], 'ARRAY');
    push( @{$List_a}, $MATCH->{'quantifier'}->flat() );
    ($List_v = (($MATCH->{'concat_list'}->flat())));
    for my $x ( @{(bless [0 .. ((scalar( @{$List_v} ) - 1))], 'ARRAY')} ) {
        push( @{$List_a}, $List_v->[$x] )
    };
    $List_a
})))
})) || 1)))
})) || ((do {
    (($MATCH)->{to} = $pos1);
    (((((do {
    ($MATCH->{capture} = ((do {
    (my  $List_a = bless [], 'ARRAY');
    (my  $List_v = bless [], 'ARRAY');
    push( @{$List_a}, $MATCH->{'quantifier'}->flat() );
    $List_a
})))
})) || 1)))
})))
})))
})) || ((do {
    (($MATCH)->{to} = $pos1);
    (((((do {
    ($MATCH->{capture} = ((do {
    (my  $List_a = bless [], 'ARRAY');
    (my  $List_v = bless [], 'ARRAY');
    $List_a
})))
})) || 1)))
})))
}))));
        $MATCH
    };
    sub concat_exp {
        my $List__ = bless \@_, "ARRAY";
        ((my  $grammar) = $List__->[0]);
        ((my  $str) = $List__->[1]);
        ((my  $pos) = $List__->[2]);
        ((my  $MATCH) = Perlito5::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1)));
        (($MATCH)->{bool} = (((do {
    ((my  $pos1) = $MATCH->to());
    ((do {
    (((do {
    ((my  $m2) = $grammar->concat_list($str, $MATCH->to()));
    if (($m2)) {
        (($MATCH)->{to} = $m2->to());
        ($MATCH->{'concat_list'} = $m2);
        1
    }
    else {
        0
    }
})) && ((((do {
    ($MATCH->{capture} = (Rul::Concat->new(('concat' => $MATCH->{'concat_list'}->flat()))))
})) || 1)))
}))
}))));
        $MATCH
    };
    sub or_list_exp {
        my $List__ = bless \@_, "ARRAY";
        ((my  $grammar) = $List__->[0]);
        ((my  $str) = $List__->[1]);
        ((my  $pos) = $List__->[2]);
        ((my  $MATCH) = Perlito5::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1)));
        (($MATCH)->{bool} = (((do {
    ((my  $pos1) = $MATCH->to());
    (((do {
    (((do {
    ((my  $m2) = $grammar->concat_exp($str, $MATCH->to()));
    if (($m2)) {
        (($MATCH)->{to} = $m2->to());
        ($MATCH->{'concat_exp'} = $m2);
        1
    }
    else {
        0
    }
})) && ((do {
    ((my  $pos1) = $MATCH->to());
    (((do {
    (((((chr(124) eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to()))))) && ((do {
    ((my  $m2) = $grammar->or_list_exp($str, $MATCH->to()));
    if (($m2)) {
        (($MATCH)->{to} = $m2->to());
        ($MATCH->{'or_list_exp'} = $m2);
        1
    }
    else {
        0
    }
}))) && ((((do {
    ($MATCH->{capture} = ((do {
    (my  $List_a = bless [], 'ARRAY');
    (my  $List_v = bless [], 'ARRAY');
    push( @{$List_a}, $MATCH->{'concat_exp'}->flat() );
    ($List_v = (($MATCH->{'or_list_exp'}->flat())));
    for my $x ( @{(bless [0 .. ((scalar( @{$List_v} ) - 1))], 'ARRAY')} ) {
        push( @{$List_a}, $List_v->[$x] )
    };
    $List_a
})))
})) || 1)))
})) || ((do {
    (($MATCH)->{to} = $pos1);
    (((((do {
    ($MATCH->{capture} = ((do {
    (my  $List_a = bless [], 'ARRAY');
    (my  $List_v = bless [], 'ARRAY');
    push( @{$List_a}, $MATCH->{'concat_exp'}->flat() );
    $List_a
})))
})) || 1)))
})))
})))
})) || ((do {
    (($MATCH)->{to} = $pos1);
    (((((do {
    ($MATCH->{capture} = ((do {
    (my  $List_a = bless [], 'ARRAY');
    (my  $List_v = bless [], 'ARRAY');
    $List_a
})))
})) || 1)))
})))
}))));
        $MATCH
    };
    sub rule {
        my $List__ = bless \@_, "ARRAY";
        ((my  $grammar) = $List__->[0]);
        ((my  $str) = $List__->[1]);
        ((my  $pos) = $List__->[2]);
        ((my  $MATCH) = Perlito5::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1)));
        (($MATCH)->{bool} = (((do {
    ((my  $pos1) = $MATCH->to());
    ((do {
    ((((do {
    ((my  $pos1) = $MATCH->to());
    (((do {
    (((do {
    ((my  $last_pos) = $MATCH->to());
    if ((!(((do {
    ((my  $m2) = $grammar->ws($str, $MATCH->to()));
    if (($m2)) {
        (($MATCH)->{to} = $m2->to());
        1
    }
    else {
        0
    }
}))))) {
        (($MATCH)->{to} = $last_pos)
    };
    1
})) && (((chr(124) eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to()))))))
})) || ((do {
    (($MATCH)->{to} = $pos1);
    (1)
})))
})) && ((do {
    ((my  $m2) = $grammar->or_list_exp($str, $MATCH->to()));
    if (($m2)) {
        (($MATCH)->{to} = $m2->to());
        ($MATCH->{'or_list_exp'} = $m2);
        1
    }
    else {
        0
    }
}))) && ((((do {
    ($MATCH->{capture} = (Rul::Or->new(('or_list' => $MATCH->{'or_list_exp'}->flat()))))
})) || 1)))
}))
}))));
        $MATCH
    }
}

1;
