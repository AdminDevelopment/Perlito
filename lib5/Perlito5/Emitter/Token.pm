# Do not edit this file - Generated by Perlito5 9.0
use v5;
use Perlito5::Perl5::Runtime;
package main;
use v5;
package Rul;
sub Rul::new {
    ((my  $class) = shift());
    bless({@_}, $class)
};
sub Rul::constant {
    ((my  $str) = shift());
    ((my  $len) = length($str));
    if (($str eq chr(92))) {
        ($str = chr(92) . chr(92))
    };
    if (($str eq chr(39))) {
        ($str = chr(92) . chr(39))
    };
    if ($len) {
        ('( ' . chr(39) . $str . chr(39) . ' eq substr( $str, $MATCH->{"to"}, ' . $len . ') ' . '&& ( $MATCH->{"to"} = ' . $len . ' + $MATCH->{"to"} )' . ')')
    }
    else {
        return ('1')
    }
};
package Rul::Quantifier;
sub Rul::Quantifier::new {
    ((my  $class) = shift());
    bless({@_}, $class)
};
sub Rul::Quantifier::term {
    $_[0]->{    'term'}
};
sub Rul::Quantifier::quant {
    $_[0]->{    'quant'}
};
sub Rul::Quantifier::greedy {
    $_[0]->{    'greedy'}
};
sub Rul::Quantifier::emit_perl5 {
    ((my  $self) = $_[0]);
    if ((($self->{'quant'} eq '') && ($self->{'greedy'} eq ''))) {
        return ($self->{'term'}->emit_perl5())
    };
    if ((($self->{'quant'} eq '+') && ($self->{'greedy'} eq ''))) {
        $self->{'term'}->set_captures_to_array();
        return (('(do { ' . 'my $last_match_null = 0; ' . 'my $m = $MATCH; ' . 'my $to = $MATCH->{"to"}; ' . 'my $count = 0; ' . 'while (' . $self->{'term'}->emit_perl5() . ' && ($last_match_null < 2)) ' . '{ ' . 'if ($to == $MATCH->{"to"}) { ' . '$last_match_null = $last_match_null + 1; ' . '} ' . 'else { ' . '$last_match_null = 0; ' . '}; ' . '$m = $MATCH; ' . '$to = $MATCH->{"to"}; ' . '$count = $count + 1; ' . '}; ' . '$MATCH = $m; ' . '$MATCH->{"to"} = $to; ' . '$count > 0; ' . '})'))
    };
    if ((($self->{'quant'} eq '*') && ($self->{'greedy'} eq ''))) {
        $self->{'term'}->set_captures_to_array();
        return (('(do { ' . 'my $last_match_null = 0; ' . 'my $m = $MATCH; ' . 'my $to = $MATCH->{"to"}; ' . 'while (' . $self->{'term'}->emit_perl5() . ' && ($last_match_null < 2)) ' . '{ ' . 'if ($to == $MATCH->{"to"}) { ' . '$last_match_null = $last_match_null + 1; ' . '} ' . 'else { ' . '$last_match_null = 0; ' . '}; ' . '$m = $MATCH; ' . '$to = $MATCH->{"to"}; ' . '}; ' . '$MATCH = $m; ' . '$MATCH->{"to"} = $to; ' . '1 ' . '})'))
    };
    if ((($self->{'quant'} eq '?') && ($self->{'greedy'} eq ''))) {
        $self->{'term'}->set_captures_to_array();
        return (('(do { ' . 'my $m = $MATCH; ' . 'if (!(do {' . $self->{'term'}->emit_perl5() . '})) ' . '{ ' . '$MATCH = $m; ' . '}; ' . '1 ' . '})'))
    };
    warn('Rul::Quantifier:  not implemented');
    $self->{'term'}->emit_perl5()
};
sub Rul::Quantifier::set_captures_to_array {
    ((my  $self) = $_[0]);
    $self->{'term'}->set_captures_to_array()
};
package Rul::Or;
sub Rul::Or::new {
    ((my  $class) = shift());
    bless({@_}, $class)
};
sub Rul::Or::or_list {
    $_[0]->{    'or_list'}
};
sub Rul::Or::emit_perl5 {
    ((my  $self) = $_[0]);
    ('(do { ' . 'my $pos1 = $MATCH->{"to"}; (do { ' . join('}) || (do { $MATCH->{"to"} = $pos1; ', map($_->emit_perl5(), @{$self->{'or_list'}})) . '}) })')
};
sub Rul::Or::set_captures_to_array {
    ((my  $self) = $_[0]);
    map($_->set_captures_to_array(), @{$self->{'or_list'}})
};
package Rul::Concat;
sub Rul::Concat::new {
    ((my  $class) = shift());
    bless({@_}, $class)
};
sub Rul::Concat::concat {
    $_[0]->{    'concat'}
};
sub Rul::Concat::emit_perl5 {
    ((my  $self) = $_[0]);
    ('(' . join(' && ', map($_->emit_perl5(), @{$self->{'concat'}})) . ')')
};
sub Rul::Concat::set_captures_to_array {
    ((my  $self) = $_[0]);
    map($_->set_captures_to_array(), @{$self->{'concat'}})
};
package Rul::Perlito5::AST::Subrule;
sub Rul::Perlito5::AST::Subrule::new {
    ((my  $class) = shift());
    bless({@_}, $class)
};
sub Rul::Perlito5::AST::Subrule::metasyntax {
    $_[0]->{    'metasyntax'}
};
sub Rul::Perlito5::AST::Subrule::captures {
    $_[0]->{    'captures'}
};
sub Rul::Perlito5::AST::Subrule::emit_perl5 {
    ((my  $self) = $_[0]);
    ((my  $meth) = (((1 + index($self->{'metasyntax'}, '.'))) ? Perlito5::Runtime::_replace($self->{'metasyntax'}, '.', '->') : (('$grammar->' . $self->{'metasyntax'}))));
    (my  $code);
    if (($self->{'captures'} == 1)) {
        ($code = ('if ($m2) { $MATCH->{"to"} = $m2->{"to"}; $MATCH->{' . chr(39) . $self->{'metasyntax'} . chr(39) . '} = $m2; 1 } else { 0 }; '))
    }
    else {
        if (($self->{'captures'} > 1)) {
            ($code = ('if ($m2) { ' . '$MATCH->{"to"} = $m2->{"to"}; ' . 'if (exists $MATCH->{' . chr(39) . $self->{'metasyntax'} . chr(39) . '}) { ' . 'push @{ $MATCH->{' . chr(39) . $self->{'metasyntax'} . chr(39) . '} }, $m2; ' . '} ' . 'else { ' . '$MATCH->{' . chr(39) . $self->{'metasyntax'} . chr(39) . '} = [ $m2 ]; ' . '}; ' . '1 ' . '} else { 0 }; '))
        }
        else {
            ($code = 'if ($m2) { $MATCH->{"to"} = $m2->{"to"}; 1 } else { 0 }; ')
        }
    };
    ('(do { ' . 'my $m2 = ' . $meth . '($str, $MATCH->{"to"}); ' . $code . '})')
};
sub Rul::Perlito5::AST::Subrule::set_captures_to_array {
    ((my  $self) = $_[0]);
    if (($self->{'captures'} > 0)) {
        ($self->{'captures'} = ($self->{'captures'} + 1))
    }
};
package Rul::Constant;
sub Rul::Constant::new {
    ((my  $class) = shift());
    bless({@_}, $class)
};
sub Rul::Constant::constant {
    $_[0]->{    'constant'}
};
sub Rul::Constant::emit_perl5 {
    ((my  $self) = $_[0]);
    ((my  $str) = $self->{'constant'});
    Rul::constant($str)
};
sub Rul::Constant::set_captures_to_array {
    ((my  $self) = $_[0])
};
package Rul::Perlito5::AST::Dot;
sub Rul::Perlito5::AST::Dot::new {
    ((my  $class) = shift());
    bless({@_}, $class)
};
sub Rul::Perlito5::AST::Dot::emit_perl5 {
    ((my  $self) = $_[0]);
    ('( ' . chr(39) . chr(39) . ' ne substr( $str, $MATCH->{"to"}, 1 ) ' . '&& ($MATCH->{"to"} = 1 + $MATCH->{"to"})' . ')')
};
sub Rul::Perlito5::AST::Dot::set_captures_to_array {
    ((my  $self) = $_[0])
};
package Rul::SpecialChar;
sub Rul::SpecialChar::new {
    ((my  $class) = shift());
    bless({@_}, $class)
};
sub Rul::SpecialChar::char {
    $_[0]->{    'char'}
};
sub Rul::SpecialChar::emit_perl5 {
    ((my  $self) = $_[0]);
    ((my  $char) = $self->{'char'});
    if (($char eq 'n')) {
        return (Rul::Perlito5::AST::Subrule->new(('metasyntax' => 'is_newline'), ('captures' => 0))->emit_perl5())
    };
    if (($char eq 'N')) {
        return (Rul::Perlito5::AST::Subrule->new(('metasyntax' => 'not_newline'), ('captures' => 0))->emit_perl5())
    };
    if (($char eq 'd')) {
        return (Rul::Perlito5::AST::Subrule->new(('metasyntax' => 'digit'), ('captures' => 0))->emit_perl5())
    };
    if (($char eq 's')) {
        return (Rul::Perlito5::AST::Subrule->new(('metasyntax' => 'space'), ('captures' => 0))->emit_perl5())
    };
    if (($char eq 't')) {
        return (Rul::constant(chr(9)))
    };
    return (Rul::constant($char))
};
sub Rul::SpecialChar::set_captures_to_array {
    ((my  $self) = $_[0])
};
package Rul::Block;
sub Rul::Block::new {
    ((my  $class) = shift());
    bless({@_}, $class)
};
sub Rul::Block::closure {
    $_[0]->{    'closure'}
};
sub Rul::Block::emit_perl5 {
    ((my  $self) = $_[0]);
    ('(do { ' . $self->{'closure'} . '; 1 })')
};
sub Rul::Block::set_captures_to_array {
    ((my  $self) = $_[0])
};
package Rul::Before;
sub Rul::Before::new {
    ((my  $class) = shift());
    bless({@_}, $class)
};
sub Rul::Before::rule_exp {
    $_[0]->{    'rule_exp'}
};
sub Rul::Before::emit_perl5 {
    ((my  $self) = $_[0]);
    ('(do { ' . 'my $tmp = $MATCH; ' . '$MATCH = { ' . chr(39) . 'str' . chr(39) . ' => $str, ' . chr(39) . 'from' . chr(39) . ' => $tmp->{"to"}, ' . chr(39) . 'to' . chr(39) . ' => $tmp->{"to"} }; ' . 'my $res = ' . $self->{'rule_exp'}->emit_perl5() . '; ' . '$MATCH = $res ? $tmp : 0; ' . '})')
};
sub Rul::Before::set_captures_to_array {
    ((my  $self) = $_[0])
};
package Rul::NotBefore;
sub Rul::NotBefore::new {
    ((my  $class) = shift());
    bless({@_}, $class)
};
sub Rul::NotBefore::rule_exp {
    $_[0]->{    'rule_exp'}
};
sub Rul::NotBefore::emit_perl5 {
    ((my  $self) = $_[0]);
    ('(do { ' . 'my $tmp = $MATCH; ' . '$MATCH = { ' . chr(39) . 'str' . chr(39) . ' => $str, ' . chr(39) . 'from' . chr(39) . ' => $tmp->{"to"}, ' . chr(39) . 'to' . chr(39) . ' => $tmp->{"to"} }; ' . 'my $res = ' . $self->{'rule_exp'}->emit_perl5() . '; ' . '$MATCH = $res ? 0 : $tmp; ' . '})')
};
sub Rul::NotBefore::set_captures_to_array {
    ((my  $self) = $_[0])
};
1;

1;
