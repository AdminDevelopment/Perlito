# Do not edit this file - Generated by Perlito5 8.0
use v5;
use utf8;
use strict;
use warnings;
no warnings ('redefine', 'once', 'void', 'uninitialized', 'misc', 'recursion');
use Perlito5::Perl5::Runtime;
our $MATCH = Perlito5::Match->new();
package main;
use v5;
package Lit::Array;
sub expand_interpolation {
    ((my  $self) = $_[0]);
    ((my  $needs_interpolation) = 0);
    (my  @items);
    for my $item (@{$self->{('array1')}}) {
        if ((($item->isa('Apply') && ((($item->code() eq 'circumfix:<( )>') || ($item->code() eq 'list:<,>')))))) {
            for my $arg (@{$item->arguments()}) {
                push(@items, $arg )
            }
        }
        else {
            push(@items, $item )
        }
    };
    for my $item (@items) {
        if (((($item->isa('Var') && ($item->sigil() eq chr(64))) || ($item->isa('Apply') && (((($item->code() eq 'prefix:<' . chr(64) . '>') || ($item->code() eq 'infix:<..>')) || ($item->code() eq 'map'))))))) {
            ($needs_interpolation = 1)
        }
    };
    if ((($needs_interpolation && (scalar(@items) == 1)))) {
        return (Apply->new(('arguments' => [    $items[0]]), ('code' => 'circumfix:<[ ]>'), ('namespace' => '')))
    };
    (my  @s);
    for my $item (@items) {
        if (((($item->isa('Var') && ($item->sigil() eq chr(64))) || ($item->isa('Apply') && (((($item->code() eq 'prefix:<' . chr(64) . '>') || ($item->code() eq 'infix:<..>')) || ($item->code() eq 'map'))))))) {
            push(@s, Apply->new(('arguments' => [    Var->new(('name' => 'v'), ('namespace' => ''), ('sigil' => chr(64))),
    $item]), ('code' => 'infix:<' . chr(61) . '>'), ('namespace' => '')) );
            push(@s, For->new(('body' => Lit::Block->new(('sig' => Var->new(('name' => 'x'), ('namespace' => ''), ('sigil' => chr(36)))), ('stmts' => [    Apply->new(('arguments' => [    Var->new(('name' => 'a'), ('namespace' => ''), ('sigil' => chr(64))),
    Index->new(('index_exp' => Var->new(('name' => 'x'), ('namespace' => ''), ('sigil' => chr(36)))), ('obj' => Var->new(('name' => 'v'), ('namespace' => ''), ('sigil' => chr(36)))))]), ('code' => 'push'), ('namespace' => ''))]))), ('cond' => Apply->new(('arguments' => [    Val::Int->new(('int' => 0)),
    Apply->new(('arguments' => [    Apply->new(('arguments' => [    Apply->new(('arguments' => [    Var->new(('name' => 'v'), ('namespace' => ''), ('sigil' => chr(64)))]), ('code' => 'scalar'), ('namespace' => '')),
    Val::Int->new(('int' => 1))]), ('code' => 'infix:<->'), ('namespace' => ''))]), ('code' => 'circumfix:<( )>'), ('namespace' => ''))]), ('code' => 'infix:<..>'), ('namespace' => ''))), ('topic' => undef())) )
        }
        else {
            push(@s, Apply->new(('arguments' => [    Var->new(('name' => 'a'), ('namespace' => ''), ('sigil' => chr(64))),
    $item]), ('code' => 'push'), ('namespace' => '')) )
        }
    };
    return (Do->new(('block' => Lit::Block->new(('sig' => undef()), ('stmts' => [    Decl->new(('decl' => 'my'), ('type' => ''), ('var' => Var->new(('name' => 'a'), ('namespace' => ''), ('sigil' => chr(64))))),
    Decl->new(('decl' => 'my'), ('type' => ''), ('var' => Var->new(('name' => 'v'), ('namespace' => ''), ('sigil' => chr(64))))),
    @s,
    Apply->new(('arguments' => [    Var->new(('name' => 'a'), ('namespace' => ''), ('sigil' => chr(64)))]), ('code' => 'prefix:<' . chr(92) . '>'), ('namespace' => ''))])))))
};
package Lit::Hash;
sub expand_interpolation {
    ((my  $self) = $_[0]);
    (my  @items);
    for my $item (@{$self->{('hash1')}}) {
        if ((($item->isa('Apply') && ((($item->code() eq 'circumfix:<( )>') || ($item->code() eq 'list:<,>')))))) {
            for my $arg (@{$item->arguments()}) {
                push(@items, $arg )
            }
        }
        else {
            push(@items, $item )
        }
    };
    (my  @s);
    for my $item (@items) {
        if ((($item->isa('Apply') && ($item->code() eq 'infix:<' . chr(61) . '>>')))) {
            push(@s, Apply->new(('arguments' => [    Lookup->new(('index_exp' => $item->arguments()->[0]), ('obj' => Var->new(('name' => 'a'), ('namespace' => ''), ('sigil' => chr(36))))),
    $item->arguments()->[1]]), ('code' => 'infix:<' . chr(61) . '>'), ('namespace' => '')) )
        }
        else {
            if (((($item->isa('Var') && ($item->sigil() eq chr(37))) || ($item->isa('Apply') && ($item->code() eq 'prefix:<' . chr(37) . '>'))))) {
                ((my  $v) = $item);
                if ($item->isa('Var')) {
                    ($v = Var->new(('sigil' => chr(36)), ('namespace' => $item->namespace()), ('name' => $item->name())))
                };
                push(@s, For->new(('body' => Lit::Block->new(('sig' => Var->new(('name' => 'p'), ('namespace' => ''), ('sigil' => chr(36)))), ('stmts' => [    Apply->new(('arguments' => [    Lookup->new(('index_exp' => Var->new(('name' => 'p'), ('namespace' => ''), ('sigil' => chr(36)))), ('obj' => Var->new(('name' => 'a'), ('namespace' => ''), ('sigil' => chr(36))))),
    Lookup->new(('index_exp' => Var->new(('name' => 'p'), ('namespace' => ''), ('sigil' => chr(36)))), ('obj' => $v))]), ('code' => 'infix:<' . chr(61) . '>'), ('namespace' => ''))]))), ('cond' => Apply->new(('arguments' => [    $item]), ('code' => 'keys'), ('namespace' => ''))), ('topic' => undef())) )
            }
            else {
                if (((($item->isa('Var') && ($item->sigil() eq chr(64))) || ($item->isa('Apply') && ($item->code() eq 'prefix:<' . chr(64) . '>'))))) {
                    push(@s, Do->new(('block' => Lit::Block->new(('sig' => undef()), ('stmts' => [    Apply->new(('arguments' => [    Decl->new(('decl' => 'my'), ('type' => ''), ('var' => Var->new(('name' => '_i'), ('namespace' => ''), ('sigil' => chr(36))))),
    Val::Int->new(('int' => 0))]), ('code' => 'infix:<' . chr(61) . '>'), ('namespace' => '')),
    Apply->new(('arguments' => [    Decl->new(('decl' => 'my'), ('type' => ''), ('var' => Var->new(('name' => '_a'), ('namespace' => ''), ('sigil' => chr(64))))),
    $item]), ('code' => 'infix:<' . chr(61) . '>'), ('namespace' => '')),
    While->new(('body' => Lit::Block->new(('sig' => undef()), ('stmts' => [    Apply->new(('arguments' => [    Lookup->new(('index_exp' => Index->new(('index_exp' => Var->new(('name' => '_i'), ('namespace' => ''), ('sigil' => chr(36)))), ('obj' => Var->new(('name' => '_a'), ('namespace' => ''), ('sigil' => chr(36)))))), ('obj' => Var->new(('name' => 'a'), ('namespace' => ''), ('sigil' => chr(36))))),
    Index->new(('index_exp' => Apply->new(('arguments' => [    Var->new(('name' => '_i'), ('namespace' => ''), ('sigil' => chr(36))),
    Val::Int->new(('int' => 1))]), ('code' => 'infix:<+>'), ('namespace' => ''))), ('obj' => Var->new(('name' => '_a'), ('namespace' => ''), ('sigil' => chr(36)))))]), ('code' => 'infix:<' . chr(61) . '>'), ('namespace' => '')),
    Apply->new(('arguments' => [    Var->new(('name' => '_i'), ('namespace' => ''), ('sigil' => chr(36))),
    Apply->new(('arguments' => [    Var->new(('name' => '_i'), ('namespace' => ''), ('sigil' => chr(36))),
    Val::Int->new(('int' => 2))]), ('code' => 'infix:<+>'), ('namespace' => ''))]), ('code' => 'infix:<' . chr(61) . '>'), ('namespace' => ''))]))), ('cond' => Apply->new(('arguments' => [    Apply->new(('arguments' => [    Var->new(('name' => '_i'), ('namespace' => ''), ('sigil' => chr(36))),
    Apply->new(('arguments' => [    Var->new(('name' => '_a'), ('namespace' => ''), ('sigil' => chr(64)))]), ('code' => 'scalar'), ('namespace' => ''))]), ('code' => 'infix:<<>'), ('namespace' => ''))]), ('code' => 'circumfix:<( )>'), ('namespace' => ''))))])))) )
                }
                else {
                    die('Error in hash composer: ', $item)
                }
            }
        }
    };
    return (Do->new(('block' => Lit::Block->new(('sig' => undef()), ('stmts' => [    Decl->new(('decl' => 'my'), ('type' => ''), ('var' => Var->new(('name' => 'a'), ('namespace' => ''), ('sigil' => chr(37))))),
    @s,
    Apply->new(('arguments' => [    Var->new(('name' => 'a'), ('namespace' => ''), ('sigil' => chr(37)))]), ('code' => 'prefix:<' . chr(92) . '>'), ('namespace' => ''))])))))
};
package Apply;
((my  %op) = (('infix:<+' . chr(61) . '>' => 'infix:<+>'), ('infix:<-' . chr(61) . '>' => 'infix:<->'), ('infix:<*' . chr(61) . '>' => 'infix:<*>'), ('infix:<' . chr(47) . chr(61) . '>' => 'infix:<' . chr(47) . '>'), ('infix:<' . chr(124) . chr(124) . chr(61) . '>' => 'infix:<' . chr(124) . chr(124) . '>'), ('infix:<' . chr(38) . chr(38) . chr(61) . '>' => 'infix:<' . chr(38) . chr(38) . '>'), ('infix:<' . chr(124) . chr(61) . '>' => 'infix:<' . chr(124) . '>'), ('infix:<' . chr(38) . chr(61) . '>' => 'infix:<' . chr(38) . '>'), ('infix:<' . chr(47) . chr(47) . chr(61) . '>' => 'infix:<' . chr(47) . chr(47) . '>'), ('infix:<.' . chr(61) . '>' => 'list:<.>')));
sub op_assign {
    ((my  $self) = $_[0]);
    ((my  $code) = $self->{('code')});
    if (ref($code)) {
        return (0)
    };
    if ((exists($op{$code}))) {
        return (Apply->new(('code' => 'infix:<' . chr(61) . '>'), ('arguments' => [    $self->{('arguments')}->[0],
    Apply->new(('code' => $op{$code}), ('arguments' => $self->{('arguments')}))])))
    };
    return (0)
};
package Do;
sub simplify {
    ((my  $self) = $_[0]);
    (my  $block);
    if (($self->{('block')}->isa('Lit::Block'))) {
        ($block = $self->{('block')}->stmts())
    }
    else {
        ($block = [    $self->{('block')}])
    };
    if (((scalar(@{$block}) == 1))) {
        ((my  $stmt) = $block->[0]);
        if ((($stmt->isa('Apply') && ($stmt->code() eq 'circumfix:<( )>')))) {
            ((my  $args) = $stmt->arguments());
            return (Do->new(('block' => $args->[0]))->simplify())
        };
        if (($stmt->isa('Do'))) {
            return ($stmt->simplify())
        }
    };
    return (Do->new(('block' => $block)))
};

1;
