# Do not edit this file - Generated by Perlito5 8.0
use v5;
use utf8;
use strict;
use warnings;
no warnings ('redefine', 'once', 'void', 'uninitialized', 'misc', 'recursion');
use Perlito5::Perl5::Runtime;
our $MATCH = Perlito5::Match->new();
package main;
package Perlito5::Expression;
use Perlito5::Precedence;
use Perlito5::Grammar;
use Perlito5::Grammar::Bareword;
sub Perlito5::Expression::expand_list {
    ((my  $param_list) = shift());
    if ((((ref($param_list) eq 'Perlito5::AST::Apply') && ($param_list->code() eq 'list:<,>')))) {
        ((my  $args) = []);
        for my $v (@{$param_list->arguments()}) {
            if ((defined($v))) {
                push(@{$args}, $v )
            }
        };
        return ($args)
    }
    else {
        if ((($param_list eq '*undef*'))) {
            return ([])
        }
        else {
            return ([$param_list])
        }
    }
};
sub Perlito5::Expression::block_or_hash {
    ((my  $o) = shift());
    if ((defined($o->sig()))) {
        return ($o)
    };
    ((my  $stmts) = $o->stmts());
    if (((!((defined($stmts))) || (scalar(@{$stmts}) == 0)))) {
        return (Perlito5::AST::Apply->new(('code' => 'circumfix:<{ }>'), ('namespace' => ''), ('arguments' => [])))
    };
    if (((scalar(@{$stmts}) != 1))) {
        return ($o)
    };
    ((my  $stmt) = $stmts->[0]);
    if (((ref($stmt) eq 'Perlito5::AST::Var'))) {
        return (Perlito5::AST::Apply->new(('code' => 'circumfix:<{ }>'), ('namespace' => ''), ('arguments' => [$stmt])))
    };
    if (((ref($stmt) ne 'Perlito5::AST::Apply'))) {
        return ($o)
    };
    if ((($stmt->code() eq 'infix:<=>>'))) {
        return (Perlito5::AST::Apply->new(('code' => 'circumfix:<{ }>'), ('namespace' => ''), ('arguments' => [$stmt])))
    };
    if ((($stmt->code() ne 'list:<,>'))) {
        return ($o)
    };
    for my $item (@{$stmt->arguments()}) {
        if ((((ref($item) eq 'Perlito5::AST::Apply') && ($item->code() eq 'infix:<=>>')))) {
            return (Perlito5::AST::Apply->new(('code' => 'circumfix:<{ }>'), ('namespace' => ''), ('arguments' => expand_list($stmt))))
        }
    };
    return ($o)
};
sub Perlito5::Expression::pop_term {
    ((my  $num_stack) = shift());
    ((my  $v) = pop(@{$num_stack}));
    if (((ref($v) eq 'ARRAY'))) {
        if ((($v->[1] eq 'methcall_no_params'))) {
            ($v = Perlito5::AST::Call->new(('invocant' => undef()), ('method' => $v->[2]), ('arguments' => [])));
            return ($v)
        };
        if ((($v->[1] eq 'funcall_no_params'))) {
            ($v = Perlito5::AST::Apply->new(('code' => $v->[3]), ('namespace' => $v->[2])));
            return ($v)
        };
        if ((($v->[1] eq 'methcall'))) {
            if (($v->[3])->{'end_block'}) {
                unshift(@{$num_stack}, ($v->[3])->{'end_block'})
            };
            ((my  $param_list) = expand_list(($v->[3])->{'exp'}));
            ($v = Perlito5::AST::Call->new(('invocant' => undef()), ('method' => $v->[2]), ('arguments' => $param_list)));
            return ($v)
        };
        if ((($v->[1] eq 'funcall'))) {
            if (($v->[4])->{'end_block'}) {
                unshift(@{$num_stack}, ($v->[4])->{'end_block'})
            };
            ((my  $param_list) = expand_list(($v->[4])->{'exp'}));
            ($v = Perlito5::AST::Apply->new(('code' => $v->[3]), ('arguments' => $param_list), ('namespace' => $v->[2])));
            return ($v)
        };
        if ((($v->[1] eq '( )'))) {
            ((my  $param_list) = expand_list($v->[2]));
            ($v = Perlito5::AST::Apply->new(('code' => 'circumfix:<( )>'), ('arguments' => $param_list), ('namespace' => '')));
            return ($v)
        };
        if ((($v->[1] eq '[ ]'))) {
            ((my  $param_list) = expand_list($v->[2]));
            ($v = Perlito5::AST::Apply->new(('code' => 'circumfix:<[ ]>'), ('arguments' => $param_list), ('namespace' => '')));
            return ($v)
        };
        if ((($v->[1] eq 'block'))) {
            ($v = Perlito5::AST::Lit::Block->new(('stmts' => $v->[2]), ('sig' => $v->[3])));
            ($v = block_or_hash($v));
            return ($v)
        };
        if ((($v->[1] eq '.( )'))) {
            ($v = Perlito5::AST::Call->new(('invocant' => undef()), ('method' => 'postcircumfix:<( )>'), ('arguments' => $v->[2])));
            return ($v)
        };
        if ((($v->[1] eq '.[ ]'))) {
            ($v = Perlito5::AST::Index->new(('obj' => undef()), ('index_exp' => $v->[2])));
            return ($v)
        };
        if ((($v->[1] eq '.{ }'))) {
            ($v = Perlito5::AST::Lookup->new(('obj' => undef()), ('index_exp' => $v->[2])));
            return ($v)
        };
        if ((((ref($v->[1]) eq 'ARRAY') && (scalar($v->[1]) == 2)))) {
            ($v = Perlito5::AST::Apply->new(('code' => 'pair'), ('arguments' => $v->[1]), ('namespace' => '')));
            return ($v)
        };
        return ($v->[1])
    };
    return ($v)
};
sub Perlito5::Expression::reduce_postfix {
    ((my  $op) = shift());
    ((my  $value) = shift());
    ((my  $v) = $op);
    if ((($v->[1] eq 'methcall_no_params'))) {
        ($v = Perlito5::AST::Call->new(('invocant' => $value), ('method' => $v->[2]), ('arguments' => [])));
        return ($v)
    };
    if ((($v->[1] eq 'funcall_no_params'))) {
        die('unexpected function call');
        push(@{$v}, $value );
        return ($v)
    };
    if ((($v->[1] eq 'methcall'))) {
        ((my  $param_list) = expand_list($v->[3]->{'exp'}));
        ($v = Perlito5::AST::Call->new(('invocant' => $value), ('method' => $v->[2]), ('arguments' => $param_list)));
        return ($v)
    };
    if ((($v->[1] eq 'funcall'))) {
        die('unexpected function call');
        push(@{$v}, $value );
        return ($v)
    };
    if ((($v->[1] eq '( )'))) {
        ((my  $param_list) = expand_list($v->[2]));
        if ((((ref($value) eq 'Perlito5::AST::Apply') && !((defined($value->arguments())))))) {
            ($value->{'arguments'} = $param_list);
            return ($value)
        };
        if ((((ref($value) eq 'Perlito5::AST::Call') && !((defined($value->arguments())))))) {
            ($value->{'arguments'} = $param_list);
            return ($value)
        };
        ($v = Perlito5::AST::Call->new(('invocant' => $value), ('method' => 'postcircumfix:<( )>'), ('arguments' => $param_list)));
        return ($v)
    };
    if ((($v->[1] eq '[ ]'))) {
        ($v = Perlito5::AST::Index->new(('obj' => $value), ('index_exp' => $v->[2])));
        return ($v)
    };
    if ((($v->[1] eq 'block'))) {
        ($v = Perlito5::AST::Lookup->new(('obj' => $value), ('index_exp' => ($v->[2])->[0])));
        return ($v)
    };
    if ((($v->[1] eq '.( )'))) {
        ((my  $param_list) = expand_list($v->[2]));
        ($v = Perlito5::AST::Call->new(('invocant' => $value), ('method' => 'postcircumfix:<( )>'), ('arguments' => $param_list)));
        return ($v)
    };
    if ((($v->[1] eq '.[ ]'))) {
        ($v = Perlito5::AST::Call->new(('invocant' => $value), ('method' => 'postcircumfix:<[ ]>'), ('arguments' => $v->[2])));
        return ($v)
    };
    if ((($v->[1] eq '.{ }'))) {
        ($v = Perlito5::AST::Call->new(('invocant' => $value), ('method' => 'postcircumfix:<{ }>'), ('arguments' => $v->[2])));
        return ($v)
    };
    push(@{$op}, $value );
    return ($op)
};
((my  $reduce_to_ast) = sub {
    ((my  $op_stack) = shift());
    ((my  $num_stack) = shift());
    ((my  $last_op) = shift(@{$op_stack}));
    if ((($last_op->[0] eq 'prefix'))) {
        push(@{$num_stack}, Perlito5::AST::Apply->new(('namespace' => ''), ('code' => ('prefix:<' . $last_op->[1] . '>')), ('arguments' => [pop_term($num_stack)])) )
    }
    else {
        if ((($last_op->[0] eq 'postfix'))) {
            push(@{$num_stack}, Perlito5::AST::Apply->new(('namespace' => ''), ('code' => ('postfix:<' . $last_op->[1] . '>')), ('arguments' => [pop_term($num_stack)])) )
        }
        else {
            if ((($last_op->[0] eq 'postfix_or_term'))) {
                push(@{$num_stack}, reduce_postfix($last_op, pop_term($num_stack)) )
            }
            else {
                if ((Perlito5::Precedence::is_assoc_type('list', $last_op->[1]))) {
                    (my  $arg);
                    if (((scalar(@{$num_stack}) < 2))) {
                        ((my  $v2) = pop_term($num_stack));
                        if ((((ref($v2) eq 'Perlito5::AST::Apply') && ($v2->code() eq (('list:<' . $last_op->[1] . '>')))))) {
                            push(@{$num_stack}, Perlito5::AST::Apply->new(('namespace' => $v2->namespace()), ('code' => $v2->code()), ('arguments' => [@{$v2->arguments()}, undef()])) )
                        }
                        else {
                            push(@{$num_stack}, Perlito5::AST::Apply->new(('namespace' => ''), ('code' => ('list:<' . $last_op->[1] . '>')), ('arguments' => [$v2, undef()])) )
                        };
                        return ()
                    }
                    else {
                        ((my  $v2) = pop_term($num_stack));
                        ($arg = [pop_term($num_stack), $v2])
                    };
                    if (((((ref($arg->[0]) eq 'Perlito5::AST::Apply') && ($last_op->[0] eq 'infix')) && (($arg->[0]->code() eq ('list:<' . $last_op->[1] . '>')))))) {
                        push(@{$num_stack}, Perlito5::AST::Apply->new(('namespace' => ''), ('code' => ($arg->[0])->code()), ('arguments' => [@{($arg->[0])->arguments()}, $arg->[1]])) );
                        return ()
                    };
                    push(@{$num_stack}, Perlito5::AST::Apply->new(('namespace' => ''), ('code' => ('list:<' . $last_op->[1] . '>')), ('arguments' => $arg)) )
                }
                else {
                    if ((Perlito5::Precedence::is_assoc_type('chain', $last_op->[1]))) {
                        if (((scalar(@{$num_stack}) < 2))) {
                            die(('Missing value after operator ' . $last_op->[1]))
                        };
                        ((my  $v2) = pop_term($num_stack));
                        ((my  $arg) = [pop_term($num_stack), $v2]);
                        push(@{$num_stack}, Perlito5::AST::Apply->new(('namespace' => ''), ('code' => ('infix:<' . $last_op->[1] . '>')), ('arguments' => $arg)) )
                    }
                    else {
                        if ((($last_op->[0] eq 'ternary'))) {
                            if (((scalar(@{$num_stack}) < 2))) {
                                die('Missing value after ternary operator')
                            };
                            ((my  $v2) = pop_term($num_stack));
                            push(@{$num_stack}, Perlito5::AST::Apply->new(('namespace' => ''), ('code' => ('ternary:<' . $last_op->[1] . '>')), ('arguments' => [pop_term($num_stack), $last_op->[2], $v2])) )
                        }
                        else {
                            if (((scalar(@{$num_stack}) < 2))) {
                                die(('missing value after operator ' . chr(39) . $last_op->[1] . chr(39)))
                            };
                            ((my  $v2) = pop_term($num_stack));
                            push(@{$num_stack}, Perlito5::AST::Apply->new(('namespace' => ''), ('code' => ('infix:<' . $last_op->[1] . '>')), ('arguments' => [pop_term($num_stack), $v2])) )
                        }
                    }
                }
            }
        }
    }
});
sub Perlito5::Expression::term_arrow {
    ((my  $grammar) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    ((my  $MATCH) = Perlito5::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1)));
    ($MATCH->{'bool'} = (((do {
    ((my  $pos1) = $MATCH->{'to'});
    ((do {
    ((((('->' eq substr($str, $MATCH->{'to'}, 2)) && (($MATCH->{'to'} = (2 + $MATCH->{'to'}))))) && ((do {
    ((my  $m2) = Perlito5::Grammar->opt_ws($str, $MATCH->{'to'}));
    if (($m2->{'bool'})) {
        ($MATCH->{'to'} = $m2->{'to'});
        1
    }
    else {
        0
    }
}))) && ((do {
    ((my  $pos1) = $MATCH->{'to'});
    (((((do {
    (((((('(' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'}))))) && ((do {
    ((my  $m2) = $grammar->paren_parse($str, $MATCH->{'to'}));
    if (($m2->{'bool'})) {
        ($MATCH->{'to'} = $m2->{'to'});
        ($MATCH->{'paren_parse'} = $m2);
        1
    }
    else {
        0
    }
}))) && (((')' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'})))))) && ((do {
    ($MATCH->{'capture'} = ['postfix_or_term', '.( )', $MATCH->{'paren_parse'}->flat()]);
    1
})))
})) || ((do {
    ($MATCH->{'to'} = $pos1);
    ((((((('[' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'}))))) && ((do {
    ((my  $m2) = $grammar->square_parse($str, $MATCH->{'to'}));
    if (($m2->{'bool'})) {
        ($MATCH->{'to'} = $m2->{'to'});
        ($MATCH->{'square_parse'} = $m2);
        1
    }
    else {
        0
    }
}))) && (((']' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'})))))) && ((do {
    ($MATCH->{'capture'} = ['postfix_or_term', '.[ ]', $MATCH->{'square_parse'}->flat()]);
    1
}))))
}))) || ((do {
    ($MATCH->{'to'} = $pos1);
    ((((((('{' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'}))))) && ((do {
    ((my  $m2) = $grammar->curly_parse($str, $MATCH->{'to'}));
    if (($m2->{'bool'})) {
        ($MATCH->{'to'} = $m2->{'to'});
        ($MATCH->{'curly_parse'} = $m2);
        1
    }
    else {
        0
    }
}))) && ((('}' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'})))))) && ((do {
    ($MATCH->{'capture'} = ['postfix_or_term', '.{ }', $MATCH->{'curly_parse'}->flat()]);
    1
}))))
}))) || ((do {
    ($MATCH->{'to'} = $pos1);
    (((((do {
    ((my  $m2) = Perlito5::Grammar->ident($str, $MATCH->{'to'}));
    if (($m2->{'bool'})) {
        ($MATCH->{'to'} = $m2->{'to'});
        ($MATCH->{'Perlito5::Grammar.ident'} = $m2);
        1
    }
    else {
        0
    }
})) && ((do {
    ((my  $m2) = Perlito5::Grammar->opt_ws($str, $MATCH->{'to'}));
    if (($m2->{'bool'})) {
        ($MATCH->{'to'} = $m2->{'to'});
        1
    }
    else {
        0
    }
}))) && ((do {
    ((my  $pos1) = $MATCH->{'to'});
    (((do {
    (((((('(' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'}))))) && ((do {
    ((my  $m2) = $grammar->paren_parse($str, $MATCH->{'to'}));
    if (($m2->{'bool'})) {
        ($MATCH->{'to'} = $m2->{'to'});
        ($MATCH->{'paren_parse'} = $m2);
        1
    }
    else {
        0
    }
}))) && (((')' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'})))))) && ((do {
    ($MATCH->{'capture'} = ['postfix_or_term', 'methcall', $MATCH->{'Perlito5::Grammar.ident'}->flat(), {('end_block' => undef()), ('exp' => $MATCH->{'paren_parse'}->flat()), ('terminated' => 0)}]);
    1
})))
})) || ((do {
    ($MATCH->{'to'} = $pos1);
    (((do {
    ($MATCH->{'capture'} = ['postfix_or_term', 'methcall_no_params', $MATCH->{'Perlito5::Grammar.ident'}->flat()]);
    1
})))
})))
}))))
})))
})))
}))
}))));
    $MATCH
};
sub Perlito5::Expression::term_sigil {
    ((my  $grammar) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    ((my  $MATCH) = Perlito5::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1)));
    ($MATCH->{'bool'} = (((do {
    ((my  $pos1) = $MATCH->{'to'});
    ((do {
    (((do {
    ((my  $m2) = Perlito5::Grammar->var_sigil($str, $MATCH->{'to'}));
    if (($m2->{'bool'})) {
        ($MATCH->{'to'} = $m2->{'to'});
        ($MATCH->{'Perlito5::Grammar.var_sigil'} = $m2);
        1
    }
    else {
        0
    }
})) && ((do {
    ((my  $pos1) = $MATCH->{'to'});
    (((do {
    (((('{' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'}))))) && ((do {
    ((my  $pos1) = $MATCH->{'to'});
    (((do {
    (((((do {
    ((my  $m2) = Perlito5::Grammar->optional_namespace_before_ident($str, $MATCH->{'to'}));
    if (($m2->{'bool'})) {
        ($MATCH->{'to'} = $m2->{'to'});
        ($MATCH->{'Perlito5::Grammar.optional_namespace_before_ident'} = $m2);
        1
    }
    else {
        0
    }
})) && ((do {
    ((my  $m2) = Perlito5::Grammar->var_name($str, $MATCH->{'to'}));
    if (($m2->{'bool'})) {
        ($MATCH->{'to'} = $m2->{'to'});
        ($MATCH->{'Perlito5::Grammar.var_name'} = $m2);
        1
    }
    else {
        0
    }
}))) && ((('}' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'})))))) && ((do {
    ($MATCH->{'capture'} = ['term', Perlito5::AST::Var->new(('sigil' => $MATCH->{'Perlito5::Grammar.var_sigil'}->flat()), ('namespace' => $MATCH->{'Perlito5::Grammar.optional_namespace_before_ident'}->flat()), ('name' => $MATCH->{'Perlito5::Grammar.var_name'}->flat()))]);
    1
})))
})) || ((do {
    ($MATCH->{'to'} = $pos1);
    (((((do {
    ((my  $m2) = $grammar->curly_parse($str, $MATCH->{'to'}));
    if (($m2->{'bool'})) {
        ($MATCH->{'to'} = $m2->{'to'});
        ($MATCH->{'curly_parse'} = $m2);
        1
    }
    else {
        0
    }
})) && ((('}' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'})))))) && ((do {
    ($MATCH->{'capture'} = ['term', Perlito5::AST::Apply->new(('arguments' => [$MATCH->{'curly_parse'}->flat()]), ('code' => ('prefix:<' . $MATCH->{'Perlito5::Grammar.var_sigil'}->flat() . '>')), ('namespace' => ''))]);
    1
}))))
})))
})))
})) || ((do {
    ($MATCH->{'to'} = $pos1);
    (((((do {
    ((my  $m2) = Perlito5::Grammar->optional_namespace_before_ident($str, $MATCH->{'to'}));
    if (($m2->{'bool'})) {
        ($MATCH->{'to'} = $m2->{'to'});
        ($MATCH->{'Perlito5::Grammar.optional_namespace_before_ident'} = $m2);
        1
    }
    else {
        0
    }
})) && ((do {
    ((my  $m2) = Perlito5::Grammar->var_name($str, $MATCH->{'to'}));
    if (($m2->{'bool'})) {
        ($MATCH->{'to'} = $m2->{'to'});
        ($MATCH->{'Perlito5::Grammar.var_name'} = $m2);
        1
    }
    else {
        0
    }
}))) && ((do {
    ($MATCH->{'capture'} = ['term', Perlito5::AST::Var->new(('sigil' => $MATCH->{'Perlito5::Grammar.var_sigil'}->flat()), ('namespace' => $MATCH->{'Perlito5::Grammar.optional_namespace_before_ident'}->flat()), ('name' => $MATCH->{'Perlito5::Grammar.var_name'}->flat()))]);
    1
}))))
})))
})))
}))
}))));
    $MATCH
};
sub Perlito5::Expression::term_digit {
    ((my  $grammar) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    ((my  $MATCH) = Perlito5::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1)));
    ($MATCH->{'bool'} = (((do {
    ((my  $pos1) = $MATCH->{'to'});
    (((do {
    (((do {
    ((my  $m2) = Perlito5::Grammar->val_num($str, $MATCH->{'to'}));
    if (($m2->{'bool'})) {
        ($MATCH->{'to'} = $m2->{'to'});
        ($MATCH->{'Perlito5::Grammar.val_num'} = $m2);
        1
    }
    else {
        0
    }
})) && ((do {
    ($MATCH->{'capture'} = ['term', $MATCH->{'Perlito5::Grammar.val_num'}->flat()]);
    1
})))
})) || ((do {
    ($MATCH->{'to'} = $pos1);
    ((((do {
    ((my  $m2) = Perlito5::Grammar->val_int($str, $MATCH->{'to'}));
    if (($m2->{'bool'})) {
        ($MATCH->{'to'} = $m2->{'to'});
        ($MATCH->{'Perlito5::Grammar.val_int'} = $m2);
        1
    }
    else {
        0
    }
})) && ((do {
    ($MATCH->{'capture'} = ['term', $MATCH->{'Perlito5::Grammar.val_int'}->flat()]);
    1
}))))
})))
}))));
    $MATCH
};
sub Perlito5::Expression::term_ternary {
    ((my  $grammar) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    ((my  $MATCH) = Perlito5::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1)));
    ($MATCH->{'bool'} = (((do {
    ((my  $pos1) = $MATCH->{'to'});
    ((do {
    (((((('?' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'}))))) && ((do {
    ((my  $m2) = $grammar->ternary5_parse($str, $MATCH->{'to'}));
    if (($m2->{'bool'})) {
        ($MATCH->{'to'} = $m2->{'to'});
        ($MATCH->{'ternary5_parse'} = $m2);
        1
    }
    else {
        0
    }
}))) && (((':' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'})))))) && ((do {
    ($MATCH->{'capture'} = ['op', '?? !!', $MATCH->{'ternary5_parse'}->flat()]);
    1
})))
}))
}))));
    $MATCH
};
sub Perlito5::Expression::term_paren {
    ((my  $grammar) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    ((my  $MATCH) = Perlito5::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1)));
    ($MATCH->{'bool'} = (((do {
    ((my  $pos1) = $MATCH->{'to'});
    ((do {
    (((((('(' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'}))))) && ((do {
    ((my  $m2) = $grammar->paren_parse($str, $MATCH->{'to'}));
    if (($m2->{'bool'})) {
        ($MATCH->{'to'} = $m2->{'to'});
        ($MATCH->{'paren_parse'} = $m2);
        1
    }
    else {
        0
    }
}))) && (((')' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'})))))) && ((do {
    ($MATCH->{'capture'} = ['postfix_or_term', '( )', $MATCH->{'paren_parse'}->flat()]);
    1
})))
}))
}))));
    $MATCH
};
sub Perlito5::Expression::term_square {
    ((my  $grammar) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    ((my  $MATCH) = Perlito5::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1)));
    ($MATCH->{'bool'} = (((do {
    ((my  $pos1) = $MATCH->{'to'});
    ((do {
    (((((('[' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'}))))) && ((do {
    ((my  $m2) = $grammar->square_parse($str, $MATCH->{'to'}));
    if (($m2->{'bool'})) {
        ($MATCH->{'to'} = $m2->{'to'});
        ($MATCH->{'square_parse'} = $m2);
        1
    }
    else {
        0
    }
}))) && (((']' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'})))))) && ((do {
    ($MATCH->{'capture'} = ['postfix_or_term', '[ ]', $MATCH->{'square_parse'}->flat()]);
    1
})))
}))
}))));
    $MATCH
};
sub Perlito5::Expression::term_curly {
    ((my  $grammar) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    ((my  $MATCH) = Perlito5::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1)));
    ($MATCH->{'bool'} = (((do {
    ((my  $pos1) = $MATCH->{'to'});
    ((do {
    (((((((('{' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'}))))) && ((do {
    ((my  $last_pos) = $MATCH->{'to'});
    if ((!(((do {
    ((my  $m2) = Perlito5::Grammar->ws($str, $MATCH->{'to'}));
    if (($m2->{'bool'})) {
        ($MATCH->{'to'} = $m2->{'to'});
        1
    }
    else {
        0
    }
}))))) {
        ($MATCH->{'to'} = $last_pos)
    };
    1
}))) && ((do {
    ((my  $m2) = Perlito5::Grammar->exp_stmts($str, $MATCH->{'to'}));
    if (($m2->{'bool'})) {
        ($MATCH->{'to'} = $m2->{'to'});
        ($MATCH->{'Perlito5::Grammar.exp_stmts'} = $m2);
        1
    }
    else {
        0
    }
}))) && ((do {
    ((my  $last_pos) = $MATCH->{'to'});
    if ((!(((do {
    ((my  $m2) = Perlito5::Grammar->ws($str, $MATCH->{'to'}));
    if (($m2->{'bool'})) {
        ($MATCH->{'to'} = $m2->{'to'});
        1
    }
    else {
        0
    }
}))))) {
        ($MATCH->{'to'} = $last_pos)
    };
    1
}))) && ((('}' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'})))))) && ((do {
    ($MATCH->{'capture'} = ['postfix_or_term', 'block', $MATCH->{'Perlito5::Grammar.exp_stmts'}->flat()]);
    1
})))
}))
}))));
    $MATCH
};
sub Perlito5::Expression::term_declarator {
    ((my  $grammar) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    ((my  $MATCH) = Perlito5::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1)));
    ($MATCH->{'bool'} = (((do {
    ((my  $pos1) = $MATCH->{'to'});
    ((do {
    (((((((do {
    ((my  $m2) = Perlito5::Grammar->declarator($str, $MATCH->{'to'}));
    if (($m2->{'bool'})) {
        ($MATCH->{'to'} = $m2->{'to'});
        ($MATCH->{'Perlito5::Grammar.declarator'} = $m2);
        1
    }
    else {
        0
    }
})) && ((do {
    ((my  $m2) = Perlito5::Grammar->ws($str, $MATCH->{'to'}));
    if (($m2->{'bool'})) {
        ($MATCH->{'to'} = $m2->{'to'});
        1
    }
    else {
        0
    }
}))) && ((do {
    ((my  $m2) = Perlito5::Grammar->opt_type($str, $MATCH->{'to'}));
    if (($m2->{'bool'})) {
        ($MATCH->{'to'} = $m2->{'to'});
        ($MATCH->{'Perlito5::Grammar.opt_type'} = $m2);
        1
    }
    else {
        0
    }
}))) && ((do {
    ((my  $m2) = Perlito5::Grammar->opt_ws($str, $MATCH->{'to'}));
    if (($m2->{'bool'})) {
        ($MATCH->{'to'} = $m2->{'to'});
        1
    }
    else {
        0
    }
}))) && ((do {
    ((my  $m2) = Perlito5::Grammar->var_ident($str, $MATCH->{'to'}));
    if (($m2->{'bool'})) {
        ($MATCH->{'to'} = $m2->{'to'});
        ($MATCH->{'Perlito5::Grammar.var_ident'} = $m2);
        1
    }
    else {
        0
    }
}))) && ((do {
    ($MATCH->{'capture'} = ['term', Perlito5::AST::Decl->new(('decl' => $MATCH->{'Perlito5::Grammar.declarator'}->flat()), ('type' => $MATCH->{'Perlito5::Grammar.opt_type'}->flat()), ('var' => $MATCH->{'Perlito5::Grammar.var_ident'}->flat()))]);
    1
})))
}))
}))));
    $MATCH
};
sub Perlito5::Expression::term_sub {
    ((my  $grammar) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    ((my  $MATCH) = Perlito5::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1)));
    ($MATCH->{'bool'} = (((do {
    ((my  $pos1) = $MATCH->{'to'});
    ((do {
    (((((('sub' eq substr($str, $MATCH->{'to'}, 3)) && (($MATCH->{'to'} = (3 + $MATCH->{'to'}))))) && ((do {
    ((my  $m2) = Perlito5::Grammar->ws($str, $MATCH->{'to'}));
    if (($m2->{'bool'})) {
        ($MATCH->{'to'} = $m2->{'to'});
        1
    }
    else {
        0
    }
}))) && ((do {
    ((my  $m2) = Perlito5::Grammar->sub_def($str, $MATCH->{'to'}));
    if (($m2->{'bool'})) {
        ($MATCH->{'to'} = $m2->{'to'});
        ($MATCH->{'Perlito5::Grammar.sub_def'} = $m2);
        1
    }
    else {
        0
    }
}))) && ((do {
    ($MATCH->{'capture'} = ['term', $MATCH->{'Perlito5::Grammar.sub_def'}->flat()]);
    1
})))
}))
}))));
    $MATCH
};
sub Perlito5::Expression::term_do {
    ((my  $grammar) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    ((my  $MATCH) = Perlito5::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1)));
    ($MATCH->{'bool'} = (((do {
    ((my  $pos1) = $MATCH->{'to'});
    ((do {
    (((((('do' eq substr($str, $MATCH->{'to'}, 2)) && (($MATCH->{'to'} = (2 + $MATCH->{'to'}))))) && ((do {
    ((my  $m2) = Perlito5::Grammar->ws($str, $MATCH->{'to'}));
    if (($m2->{'bool'})) {
        ($MATCH->{'to'} = $m2->{'to'});
        1
    }
    else {
        0
    }
}))) && ((do {
    ((my  $m2) = $grammar->statement_parse($str, $MATCH->{'to'}));
    if (($m2->{'bool'})) {
        ($MATCH->{'to'} = $m2->{'to'});
        ($MATCH->{'statement_parse'} = $m2);
        1
    }
    else {
        0
    }
}))) && ((do {
    ($MATCH->{'capture'} = ['term', Perlito5::AST::Do->new(('block' => $MATCH->{'statement_parse'}->flat()))]);
    1
})))
}))
}))));
    $MATCH
};
sub Perlito5::Expression::term_use {
    ((my  $grammar) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    ((my  $MATCH) = Perlito5::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1)));
    ($MATCH->{'bool'} = (((do {
    ((my  $pos1) = $MATCH->{'to'});
    ((do {
    (((((((('use' eq substr($str, $MATCH->{'to'}, 3)) && (($MATCH->{'to'} = (3 + $MATCH->{'to'}))))) && ((do {
    ((my  $m2) = Perlito5::Grammar->ws($str, $MATCH->{'to'}));
    if (($m2->{'bool'})) {
        ($MATCH->{'to'} = $m2->{'to'});
        1
    }
    else {
        0
    }
}))) && ((do {
    ((my  $m2) = Perlito5::Grammar->full_ident($str, $MATCH->{'to'}));
    if (($m2->{'bool'})) {
        ($MATCH->{'to'} = $m2->{'to'});
        ($MATCH->{'Perlito5::Grammar.full_ident'} = $m2);
        1
    }
    else {
        0
    }
}))) && ((do {
    ((my  $last_pos) = $MATCH->{'to'});
    if ((!(((do {
    ((my  $pos1) = $MATCH->{'to'});
    ((do {
    (((('-' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'}))))) && ((do {
    ((my  $m2) = Perlito5::Grammar->ident($str, $MATCH->{'to'}));
    if (($m2->{'bool'})) {
        ($MATCH->{'to'} = $m2->{'to'});
        if ((exists($MATCH->{'Perlito5::Grammar.ident'}))) {
            push(@{$MATCH->{'Perlito5::Grammar.ident'}}, $m2 )
        }
        else {
            ($MATCH->{'Perlito5::Grammar.ident'} = [$m2])
        };
        1
    }
    else {
        0
    }
})))
}))
}))))) {
        ($MATCH->{'to'} = $last_pos)
    };
    1
}))) && ((do {
    ((my  $m2) = $grammar->list_parse($str, $MATCH->{'to'}));
    if (($m2->{'bool'})) {
        ($MATCH->{'to'} = $m2->{'to'});
        ($MATCH->{'list_parse'} = $m2);
        1
    }
    else {
        0
    }
}))) && ((do {
    ($MATCH->{'capture'} = ['term', Perlito5::AST::Use->new(('mod' => $MATCH->{'Perlito5::Grammar.full_ident'}->flat()))]);
    1
})))
}))
}))));
    $MATCH
};
sub Perlito5::Expression::term_package {
    ((my  $grammar) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    ((my  $MATCH) = Perlito5::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1)));
    ($MATCH->{'bool'} = (((do {
    ((my  $pos1) = $MATCH->{'to'});
    ((do {
    (((((('package' eq substr($str, $MATCH->{'to'}, 7)) && (($MATCH->{'to'} = (7 + $MATCH->{'to'}))))) && ((do {
    ((my  $m2) = Perlito5::Grammar->ws($str, $MATCH->{'to'}));
    if (($m2->{'bool'})) {
        ($MATCH->{'to'} = $m2->{'to'});
        1
    }
    else {
        0
    }
}))) && ((do {
    ((my  $m2) = Perlito5::Grammar->full_ident($str, $MATCH->{'to'}));
    if (($m2->{'bool'})) {
        ($MATCH->{'to'} = $m2->{'to'});
        ($MATCH->{'Perlito5::Grammar.full_ident'} = $m2);
        1
    }
    else {
        0
    }
}))) && ((do {
    ((my  $name) = $MATCH->{'Perlito5::Grammar.full_ident'}->flat());
    ($Perlito5::PKG_NAME = $name);
    ($MATCH->{'capture'} = ['term', Perlito5::AST::Apply->new(('code' => 'package'), ('arguments' => []), ('namespace' => $name))]);
    1
})))
}))
}))));
    $MATCH
};
sub Perlito5::Expression::term_space {
    ((my  $grammar) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    ((my  $MATCH) = Perlito5::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1)));
    ($MATCH->{'bool'} = (((do {
    ((my  $pos1) = $MATCH->{'to'});
    ((do {
    (((do {
    ((my  $m2) = Perlito5::Grammar->ws($str, $MATCH->{'to'}));
    if (($m2->{'bool'})) {
        ($MATCH->{'to'} = $m2->{'to'});
        1
    }
    else {
        0
    }
})) && ((do {
    ($MATCH->{'capture'} = ['space', ' ']);
    1
})))
}))
}))));
    $MATCH
};
sub Perlito5::Expression::has_newline_after {
    ((my  $grammar) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    ((my  $MATCH) = Perlito5::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1)));
    ($MATCH->{'bool'} = (((do {
    ((my  $pos1) = $MATCH->{'to'});
    ((((do {
    (('#' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'}))))
})) || ((do {
    ($MATCH->{'to'} = $pos1);
    (((do {
    ((my  $m2) = Perlito5::Grammar->is_newline($str, $MATCH->{'to'}));
    if (($m2->{'bool'})) {
        ($MATCH->{'to'} = $m2->{'to'});
        1
    }
    else {
        0
    }
})))
}))) || ((do {
    ($MATCH->{'to'} = $pos1);
    ((((do {
    ((my  $m2) = Perlito5::Grammar->space($str, $MATCH->{'to'}));
    if (($m2->{'bool'})) {
        ($MATCH->{'to'} = $m2->{'to'});
        1
    }
    else {
        0
    }
})) && ((do {
    ((my  $m2) = $grammar->has_newline_after($str, $MATCH->{'to'}));
    if (($m2->{'bool'})) {
        ($MATCH->{'to'} = $m2->{'to'});
        1
    }
    else {
        0
    }
}))))
})))
}))));
    $MATCH
};
sub Perlito5::Expression::has_no_comma_or_colon_after {
    ((my  $grammar) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    ((my  $MATCH) = Perlito5::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1)));
    ($MATCH->{'bool'} = (((do {
    ((my  $pos1) = $MATCH->{'to'});
    ((do {
    ((((do {
    ((my  $m2) = Perlito5::Grammar->ws($str, $MATCH->{'to'}));
    if (($m2->{'bool'})) {
        ($MATCH->{'to'} = $m2->{'to'});
        1
    }
    else {
        0
    }
})) && ((do {
    ((my  $tmp) = $MATCH);
    ($MATCH = Perlito5::Match->new(('str' => $str), ('from' => $tmp->{'to'}), ('to' => $tmp->{'to'}), ('bool' => 1)));
    ($MATCH->{'bool'} = ((do {
    ((my  $pos1) = $MATCH->{'to'});
    ((do {
    ((my  $pos1) = $MATCH->{'to'});
    (((do {
    ((',' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'}))))
})) || ((do {
    ($MATCH->{'to'} = $pos1);
    ((((':' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'}))))))
})))
}))
})));
    ($tmp->{'bool'} = !($MATCH->{'bool'}));
    ($MATCH = $tmp);
    ($MATCH->{'bool'} ? 1 : 0)
}))) && ((('' ne substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'}))))))
}))
}))));
    $MATCH
};
((my  $List_end_token) = [{}, {(':' => 1), (']' => 1), (')' => 1), ('}' => 1), (';' => 1)}, {('or' => 1), ('if' => 1)}, {('for' => 1), ('and' => 1)}, {('else' => 1), ('when' => 1)}, {('while' => 1), ('elsif' => 1)}, {('unless' => 1)}, {('foreach' => 1)}]);
((my  $List_end_token_chars) = [7, 6, 5, 4, 3, 2, 1]);
((my  $Expr_end_token) = [{}, {(']' => 1), (')' => 1), ('}' => 1), (';' => 1)}, {('if' => 1)}, {('for' => 1)}, {('else' => 1), ('when' => 1)}, {('while' => 1), ('elsif' => 1)}, {('unless' => 1)}, {('foreach' => 1)}]);
((my  $Expr_end_token_chars) = [7, 6, 5, 4, 3, 2, 1]);
sub Perlito5::Expression::list_parse {
    ((my  $self) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    (my  $expr);
    ((my  $last_pos) = $pos);
    ((my  $is_first_token) = 1);
    ((my  $lexer_stack) = []);
    ((my  $terminated) = 0);
    ((my  $last_token_was_space) = 1);
    ((my  $get_token) = sub {
    (my  $v);
    if ((scalar(@{$lexer_stack}))) {
        ($v = pop(@{$lexer_stack}));
        if (((($is_first_token && (($v->[0] eq 'op'))) && !((Perlito5::Precedence::is_fixity_type('prefix', $v->[1])))))) {
            ($v->[0] = 'end')
        }
    }
    else {
        ((my  $m) = Perlito5::Precedence->op_parse($str, $last_pos));
        if ((!($m->bool()))) {
            return (['end', '*end*'])
        };
        ($v = $m->flat());
        if (((($is_first_token && (($v->[0] eq 'op'))) && !((Perlito5::Precedence::is_fixity_type('prefix', $v->[1])))))) {
            ($v->[0] = 'end')
        };
        if ((($v->[0] ne 'end'))) {
            ($last_pos = $m->to())
        }
    };
    if ((((($v->[0] eq 'postfix_or_term') && ($v->[1] eq 'block')) && $last_token_was_space))) {
        if (($self->has_newline_after($str, $last_pos)->bool())) {
            ($terminated = 1);
            push(@{$lexer_stack}, ['end', '*end*'] )
        }
        else {
            if (($self->has_no_comma_or_colon_after($str, $last_pos)->bool())) {
                ($terminated = 1);
                push(@{$lexer_stack}, ['end', '*end*'] )
            }
        }
    };
    ($last_token_was_space = (($v->[0] eq 'space')));
    ($is_first_token = 0);
    return ($v)
});
    ((my  $prec) = Perlito5::Precedence->new(('get_token' => $get_token), ('reduce' => $reduce_to_ast), ('end_token' => $List_end_token), ('end_token_chars' => $List_end_token_chars)));
    ((my  $res) = $prec->precedence_parse());
    if (((scalar(@{$res}) == 0))) {
        return (Perlito5::Match->new(('str' => $str), ('from' => $pos), ('to' => $last_pos), ('bool' => 1), ('capture' => {('exp' => '*undef*'), ('end_block' => undef()), ('terminated' => undef())})))
    };
    (my  $block);
    if (((scalar(@{$res}) > 1))) {
        ($block = pop(@{$res}));
        ($block = Perlito5::AST::Lit::Block->new(('stmts' => $block->[2]), ('sig' => $block->[3])))
    };
    ((my  $result) = pop_term($res));
    if (((scalar(@{$res}) > 0))) {
        ($block = pop(@{$res}));
        ($block = Perlito5::AST::Lit::Block->new(('stmts' => $block->[2]), ('sig' => $block->[3])))
    };
    return (Perlito5::Match->new(('str' => $str), ('from' => $pos), ('to' => $last_pos), ('bool' => 1), ('capture' => {('exp' => $result), ('end_block' => $block), ('terminated' => $terminated)})))
};
sub Perlito5::Expression::circumfix_parse {
    ((my  $self) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    ((my  $delimiter) = $_[3]);
    (my  $expr);
    ((my  $last_pos) = $pos);
    ((my  $get_token) = sub {
    ((my  $m) = Perlito5::Precedence->op_parse($str, $last_pos));
    if ((!($m->bool()))) {
        die('Expected closing delimiter: ', $delimiter, ' near ', $last_pos)
    };
    ((my  $v) = $m->flat());
    if ((($v->[0] ne 'end'))) {
        ($last_pos = $m->to())
    };
    return ($v)
});
    (my  @delim_token);
    ($delim_token[length($delimiter)] = {($delimiter => 1)});
    ((my  $prec) = Perlito5::Precedence->new(('get_token' => $get_token), ('reduce' => $reduce_to_ast), ('end_token' => \@delim_token), ('end_token_chars' => [length($delimiter)])));
    ((my  $res) = $prec->precedence_parse());
    ($res = pop_term($res));
    if ((!((defined($res))))) {
        ($res = '*undef*')
    };
    return (Perlito5::Match->new(('str' => $str), ('from' => $pos), ('to' => $last_pos), ('bool' => 1), ('capture' => $res)))
};
sub Perlito5::Expression::ternary5_parse {
    ((my  $self) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    return ($self->circumfix_parse($str, $pos, ':'))
};
sub Perlito5::Expression::curly_parse {
    ((my  $self) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    return ($self->circumfix_parse($str, $pos, '}'))
};
sub Perlito5::Expression::square_parse {
    ((my  $self) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    return ($self->circumfix_parse($str, $pos, ']'))
};
sub Perlito5::Expression::paren_parse {
    ((my  $self) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    return ($self->circumfix_parse($str, $pos, ')'))
};
sub Perlito5::Expression::exp_parse {
    ((my  $self) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    (my  $expr);
    ((my  $last_pos) = $pos);
    ((my  $lexer_stack) = []);
    ((my  $terminated) = 0);
    ((my  $get_token) = sub {
    (my  $v);
    if ((scalar(@{$lexer_stack}))) {
        ($v = pop(@{$lexer_stack}))
    }
    else {
        ((my  $m) = Perlito5::Precedence->op_parse($str, $last_pos));
        if ((!($m->bool()))) {
            return (['end', '*end*'])
        };
        ($v = $m->flat());
        if ((($v->[0] ne 'end'))) {
            ($last_pos = $m->to())
        }
    };
    if (((((((($v->[0] eq 'postfix_or_term') && ($v->[1] eq 'block'))) || ((($v->[0] eq 'term') && (ref($v->[1]) eq 'Perlito5::AST::Sub')))) || ((($v->[0] eq 'term') && (ref($v->[1]) eq 'Perlito5::AST::Do')))) || ((($v->[0] eq 'term') && (ref($v->[1]) eq 'Perlito5::AST::CompUnit')))))) {
        if (($self->has_newline_after($str, $last_pos)->bool())) {
            ($terminated = 1);
            push(@{$lexer_stack}, ['end', '*end*'] )
        }
    };
    return ($v)
});
    ((my  $prec) = Perlito5::Precedence->new(('get_token' => $get_token), ('reduce' => $reduce_to_ast), ('end_token' => $Expr_end_token), ('end_token_chars' => $Expr_end_token_chars)));
    ((my  $res) = $prec->precedence_parse());
    if (((scalar(@{$res}) == 0))) {
        return (Perlito5::Match->new(('bool' => 0)))
    };
    (my  $block);
    if (((scalar(@{$res}) > 1))) {
        ($block = pop(@{$res}));
        ($block = Perlito5::AST::Lit::Block->new(('stmts' => $block->[2]), ('sig' => $block->[3])))
    };
    ((my  $result) = pop_term($res));
    if (((scalar(@{$res}) > 0))) {
        ($block = pop(@{$res}));
        if ((!(((ref($block) eq 'Perlito5::AST::Lit::Block'))))) {
            ($block = Perlito5::AST::Lit::Block->new(('stmts' => $block->[2]), ('sig' => $block->[3])))
        }
    };
    return (Perlito5::Match->new(('str' => $str), ('from' => $pos), ('to' => $last_pos), ('bool' => 1), ('capture' => {('exp' => $result), ('end_block' => $block), ('terminated' => $terminated)})))
};
sub Perlito5::Expression::exp_stmt {
    ((my  $grammar) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    ((my  $MATCH) = Perlito5::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1)));
    ($MATCH->{'bool'} = (((do {
    ((my  $pos1) = $MATCH->{'to'});
    ((((((do {
    (((do {
    ((my  $m2) = Perlito5::Grammar->if($str, $MATCH->{'to'}));
    if (($m2->{'bool'})) {
        ($MATCH->{'to'} = $m2->{'to'});
        ($MATCH->{'Perlito5::Grammar.if'} = $m2);
        1
    }
    else {
        0
    }
})) && ((do {
    ($MATCH->{'capture'} = $MATCH->{'Perlito5::Grammar.if'}->flat());
    1
})))
})) || ((do {
    ($MATCH->{'to'} = $pos1);
    ((((do {
    ((my  $m2) = Perlito5::Grammar->unless($str, $MATCH->{'to'}));
    if (($m2->{'bool'})) {
        ($MATCH->{'to'} = $m2->{'to'});
        ($MATCH->{'Perlito5::Grammar.unless'} = $m2);
        1
    }
    else {
        0
    }
})) && ((do {
    ($MATCH->{'capture'} = $MATCH->{'Perlito5::Grammar.unless'}->flat());
    1
}))))
}))) || ((do {
    ($MATCH->{'to'} = $pos1);
    ((((do {
    ((my  $m2) = Perlito5::Grammar->when($str, $MATCH->{'to'}));
    if (($m2->{'bool'})) {
        ($MATCH->{'to'} = $m2->{'to'});
        ($MATCH->{'Perlito5::Grammar.when'} = $m2);
        1
    }
    else {
        0
    }
})) && ((do {
    ($MATCH->{'capture'} = $MATCH->{'Perlito5::Grammar.when'}->flat());
    1
}))))
}))) || ((do {
    ($MATCH->{'to'} = $pos1);
    ((((do {
    ((my  $m2) = Perlito5::Grammar->for($str, $MATCH->{'to'}));
    if (($m2->{'bool'})) {
        ($MATCH->{'to'} = $m2->{'to'});
        ($MATCH->{'Perlito5::Grammar.for'} = $m2);
        1
    }
    else {
        0
    }
})) && ((do {
    ($MATCH->{'capture'} = $MATCH->{'Perlito5::Grammar.for'}->flat());
    1
}))))
}))) || ((do {
    ($MATCH->{'to'} = $pos1);
    ((((do {
    ((my  $m2) = Perlito5::Grammar->while($str, $MATCH->{'to'}));
    if (($m2->{'bool'})) {
        ($MATCH->{'to'} = $m2->{'to'});
        ($MATCH->{'Perlito5::Grammar.while'} = $m2);
        1
    }
    else {
        0
    }
})) && ((do {
    ($MATCH->{'capture'} = $MATCH->{'Perlito5::Grammar.while'}->flat());
    1
}))))
})))
}))));
    $MATCH
};
sub Perlito5::Expression::statement_modifier {
    ((my  $grammar) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    ((my  $MATCH) = Perlito5::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1)));
    ($MATCH->{'bool'} = (((do {
    ((my  $pos1) = $MATCH->{'to'});
    (((((((do {
    (('if' eq substr($str, $MATCH->{'to'}, 2)) && (($MATCH->{'to'} = (2 + $MATCH->{'to'}))))
})) || ((do {
    ($MATCH->{'to'} = $pos1);
    (((('unless' eq substr($str, $MATCH->{'to'}, 6)) && (($MATCH->{'to'} = (6 + $MATCH->{'to'}))))))
}))) || ((do {
    ($MATCH->{'to'} = $pos1);
    (((('when' eq substr($str, $MATCH->{'to'}, 4)) && (($MATCH->{'to'} = (4 + $MATCH->{'to'}))))))
}))) || ((do {
    ($MATCH->{'to'} = $pos1);
    (((('foreach' eq substr($str, $MATCH->{'to'}, 7)) && (($MATCH->{'to'} = (7 + $MATCH->{'to'}))))))
}))) || ((do {
    ($MATCH->{'to'} = $pos1);
    (((('for' eq substr($str, $MATCH->{'to'}, 3)) && (($MATCH->{'to'} = (3 + $MATCH->{'to'}))))))
}))) || ((do {
    ($MATCH->{'to'} = $pos1);
    (((('while' eq substr($str, $MATCH->{'to'}, 5)) && (($MATCH->{'to'} = (5 + $MATCH->{'to'}))))))
})))
}))));
    $MATCH
};
sub Perlito5::Expression::delimited_statement {
    ((my  $grammar) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    ((my  $MATCH) = Perlito5::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1)));
    ($MATCH->{'bool'} = (((do {
    ((my  $pos1) = $MATCH->{'to'});
    ((do {
    (((do {
    ((my  $last_pos) = $MATCH->{'to'});
    if ((!(((do {
    ((my  $m2) = Perlito5::Grammar->ws($str, $MATCH->{'to'}));
    if (($m2->{'bool'})) {
        ($MATCH->{'to'} = $m2->{'to'});
        1
    }
    else {
        0
    }
}))))) {
        ($MATCH->{'to'} = $last_pos)
    };
    1
})) && ((do {
    ((my  $pos1) = $MATCH->{'to'});
    (((do {
    ((((';' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'}))))) && ((do {
    ((my  $last_pos) = $MATCH->{'to'});
    if ((!(((do {
    ((my  $m2) = Perlito5::Grammar->ws($str, $MATCH->{'to'}));
    if (($m2->{'bool'})) {
        ($MATCH->{'to'} = $m2->{'to'});
        1
    }
    else {
        0
    }
}))))) {
        ($MATCH->{'to'} = $last_pos)
    };
    1
})))
})) || ((do {
    ($MATCH->{'to'} = $pos1);
    ((((((do {
    ((my  $m2) = $grammar->statement_parse($str, $MATCH->{'to'}));
    if (($m2->{'bool'})) {
        ($MATCH->{'to'} = $m2->{'to'});
        ($MATCH->{'statement_parse'} = $m2);
        1
    }
    else {
        0
    }
})) && ((do {
    ((my  $last_pos) = $MATCH->{'to'});
    if ((!(((do {
    ((';' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'}))))
}))))) {
        ($MATCH->{'to'} = $last_pos)
    };
    1
}))) && ((do {
    ((my  $last_pos) = $MATCH->{'to'});
    if ((!(((do {
    ((my  $m2) = Perlito5::Grammar->ws($str, $MATCH->{'to'}));
    if (($m2->{'bool'})) {
        ($MATCH->{'to'} = $m2->{'to'});
        1
    }
    else {
        0
    }
}))))) {
        ($MATCH->{'to'} = $last_pos)
    };
    1
}))) && ((do {
    ($MATCH->{'capture'} = $MATCH->{'statement_parse'}->flat());
    1
}))))
})))
})))
}))
}))));
    $MATCH
};
sub Perlito5::Expression::statement_parse {
    ((my  $self) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    (my  $expr);
    ((my  $last_pos) = $pos);
    ((my  $lexer_stack) = []);
    (my  $res);
    ($res = $self->exp_stmt($str, $pos));
    if (($res->bool())) {
        return ($res)
    };
    ($res = $self->exp_parse($str, $pos));
    if ((!($res->bool()))) {
        return ($res)
    };
    if (((ref($res->flat()->{'exp'}) eq 'Perlito5::AST::Lit::Block'))) {
        ($res->flat()->{'exp'} = Perlito5::AST::Do->new(('block' => $res->flat()->{'exp'})))
    };
    if (($res->flat()->{'end_block'})) {
        die('Unexpected block after expression near ', $pos)
    };
    if (($res->flat()->{'terminated'})) {
        ($res->{'capture'} = $res->flat()->{'exp'});
        return ($res)
    };
    ((my  $modifier) = $self->statement_modifier($str, $res->to()));
    if ((!($modifier->bool()))) {
        ($res->{'capture'} = $res->flat()->{'exp'});
        return ($res)
    };
    ((my  $modifier_exp) = $self->exp_parse($str, $modifier->to()));
    if ((!($modifier_exp->bool()))) {
        die('Expected expression after ' . chr(39), $modifier->flat(), chr(39))
    };
    if (($modifier_exp->flat()->{'end_block'})) {
        die('Unexpected block after expression near ', $modifier->to())
    };
    ($modifier = $modifier->flat());
    if ((($modifier eq 'if'))) {
        return (Perlito5::Match->new(('str' => $str), ('from' => $pos), ('to' => $modifier_exp->to()), ('bool' => 1), ('capture' => Perlito5::AST::If->new(('cond' => $modifier_exp->flat()->{'exp'}), ('body' => Perlito5::AST::Lit::Block->new(('stmts' => [$res->flat()->{'exp'}]))), ('otherwise' => Perlito5::AST::Lit::Block->new(('stmts' => [])))))))
    };
    if ((($modifier eq 'unless'))) {
        return (Perlito5::Match->new(('str' => $str), ('from' => $pos), ('to' => $modifier_exp->to()), ('bool' => 1), ('capture' => Perlito5::AST::If->new(('cond' => $modifier_exp->flat()->{'exp'}), ('body' => Perlito5::AST::Lit::Block->new(('stmts' => []))), ('otherwise' => Perlito5::AST::Lit::Block->new(('stmts' => [$res->flat()->{'exp'}])))))))
    };
    if ((($modifier eq 'while'))) {
        return (Perlito5::Match->new(('str' => $str), ('from' => $pos), ('to' => $modifier_exp->to()), ('bool' => 1), ('capture' => Perlito5::AST::While->new(('cond' => $modifier_exp->flat()->{'exp'}), ('body' => Perlito5::AST::Lit::Block->new(('stmts' => [$res->flat()->{'exp'}])))))))
    };
    if (((($modifier eq 'for') || ($modifier eq 'foreach')))) {
        return (Perlito5::Match->new(('str' => $str), ('from' => $pos), ('to' => $modifier_exp->to()), ('bool' => 1), ('capture' => Perlito5::AST::For->new(('cond' => $modifier_exp->flat()->{'exp'}), ('body' => Perlito5::AST::Lit::Block->new(('stmts' => [$res->flat()->{'exp'}])))))))
    };
    die(('Unexpected statement modifier ' . chr(39) . $modifier . chr(39)))
};
1;

1;
