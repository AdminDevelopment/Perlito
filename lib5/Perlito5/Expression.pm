# Do not edit this file - Generated by Perlito5 9.0
use v5;
use Perlito5::Perl5::Runtime;
package main;
package Perlito5::Expression;
use Perlito5::Precedence;
use Perlito5::Grammar::Bareword;
sub Perlito5::Expression::expand_list {
    ((my  $param_list) = shift());
    if (((ref($param_list) eq 'Perlito5::AST::Apply') && ($param_list->code() eq 'list:<,>'))) {
        ((my  $args) = []);
        for my $v (@{$param_list->arguments()}) {
            if (defined($v)) {
                push(@{$args}, $v )
            }
        };
        return ($args)
    }
    else {
        if (($param_list eq '*undef*')) {
            return ([])
        }
        else {
            return ([$param_list])
        }
    }
};
sub Perlito5::Expression::block_or_hash {
    ((my  $o) = shift());
    if (defined($o->sig())) {
        return ($o)
    };
    ((my  $stmts) = $o->stmts());
    if ((!((defined($stmts))) || (scalar(@{$stmts}) == 0))) {
        return (Perlito5::AST::Apply->new(('code' => 'circumfix:<{ }>'), ('namespace' => ''), ('arguments' => [])))
    };
    if ((scalar(@{$stmts}) != 1)) {
        return ($o)
    };
    ((my  $stmt) = $stmts->[0]);
    if ((ref($stmt) eq 'Perlito5::AST::Var')) {
        return (Perlito5::AST::Apply->new(('code' => 'circumfix:<{ }>'), ('namespace' => ''), ('arguments' => [$stmt])))
    };
    if ((ref($stmt) ne 'Perlito5::AST::Apply')) {
        return ($o)
    };
    if (($stmt->code() eq 'infix:<=>>')) {
        return (Perlito5::AST::Apply->new(('code' => 'circumfix:<{ }>'), ('namespace' => ''), ('arguments' => [$stmt])))
    };
    if (($stmt->code() ne 'list:<,>')) {
        return ($o)
    };
    for my $item (@{$stmt->arguments()}) {
        if (((ref($item) eq 'Perlito5::AST::Apply') && ($item->code() eq 'infix:<=>>'))) {
            return (Perlito5::AST::Apply->new(('code' => 'circumfix:<{ }>'), ('namespace' => ''), ('arguments' => expand_list($stmt))))
        }
    };
    return ($o)
};
sub Perlito5::Expression::pop_term {
    ((my  $num_stack) = shift());
    ((my  $v) = pop(@{$num_stack}));
    if ((ref($v) eq 'ARRAY')) {
        if (($v->[1] eq 'methcall_no_params')) {
            ($v = Perlito5::AST::Call->new(('invocant' => undef()), ('method' => $v->[2]), ('arguments' => [])));
            return ($v)
        };
        if (($v->[1] eq 'funcall_no_params')) {
            ($v = Perlito5::AST::Apply->new(('code' => $v->[3]), ('namespace' => $v->[2]), ('arguments' => []), ('bareword' => 1)));
            return ($v)
        };
        if (($v->[1] eq 'methcall')) {
            ((my  $param_list) = expand_list(($v->[3])->{'exp'}));
            ($v = Perlito5::AST::Call->new(('invocant' => undef()), ('method' => $v->[2]), ('arguments' => $param_list)));
            return ($v)
        };
        if (($v->[1] eq 'funcall')) {
            ((my  $param_list) = expand_list(($v->[4])->{'exp'}));
            ($v = Perlito5::AST::Apply->new(('code' => $v->[3]), ('arguments' => $param_list), ('namespace' => $v->[2])));
            return ($v)
        };
        if (($v->[1] eq '( )')) {
            ((my  $param_list) = expand_list($v->[2]));
            ($v = Perlito5::AST::Apply->new(('code' => 'circumfix:<( )>'), ('arguments' => $param_list), ('namespace' => '')));
            return ($v)
        };
        if (($v->[1] eq '[ ]')) {
            ((my  $param_list) = expand_list($v->[2]));
            ($v = Perlito5::AST::Apply->new(('code' => 'circumfix:<[ ]>'), ('arguments' => $param_list), ('namespace' => '')));
            return ($v)
        };
        if (($v->[1] eq 'block')) {
            ($v = Perlito5::AST::Lit::Block->new(('stmts' => $v->[2]), ('sig' => $v->[3])));
            ($v = block_or_hash($v));
            return ($v)
        };
        if (($v->[1] eq '.( )')) {
            ($v = Perlito5::AST::Call->new(('invocant' => undef()), ('method' => 'postcircumfix:<( )>'), ('arguments' => $v->[2])));
            return ($v)
        };
        if (($v->[1] eq '.[ ]')) {
            ($v = Perlito5::AST::Index->new(('obj' => undef()), ('index_exp' => $v->[2])));
            return ($v)
        };
        if (($v->[1] eq '.{ }')) {
            ($v = Perlito5::AST::Lookup->new(('obj' => undef()), ('index_exp' => $v->[2])));
            return ($v)
        };
        if (((ref($v->[1]) eq 'ARRAY') && (scalar($v->[1]) == 2))) {
            ($v = Perlito5::AST::Apply->new(('code' => 'pair'), ('arguments' => $v->[1]), ('namespace' => '')));
            return ($v)
        };
        return ($v->[1])
    };
    return ($v)
};
sub Perlito5::Expression::reduce_postfix {
    ((my  $op) = shift());
    ((my  $value) = shift());
    ((my  $v) = $op);
    if (($v->[1] eq 'methcall_no_params')) {
        ($v = Perlito5::AST::Call->new(('invocant' => $value), ('method' => $v->[2]), ('arguments' => [])));
        return ($v)
    };
    if (($v->[1] eq 'funcall_no_params')) {
        die('unexpected function call')
    };
    if (($v->[1] eq 'methcall')) {
        ((my  $param_list) = expand_list($v->[3]->{'exp'}));
        ($v = Perlito5::AST::Call->new(('invocant' => $value), ('method' => $v->[2]), ('arguments' => $param_list)));
        return ($v)
    };
    if (($v->[1] eq 'funcall')) {
        die('unexpected function call')
    };
    if (($v->[1] eq '( )')) {
        ((my  $param_list) = expand_list($v->[2]));
        if (((ref($value) eq 'Perlito5::AST::Apply') && !((defined($value->arguments()))))) {
            ($value->{'arguments'} = $param_list);
            return ($value)
        };
        if (((ref($value) eq 'Perlito5::AST::Call') && !((defined($value->arguments()))))) {
            ($value->{'arguments'} = $param_list);
            return ($value)
        };
        ($v = Perlito5::AST::Call->new(('invocant' => $value), ('method' => 'postcircumfix:<( )>'), ('arguments' => $param_list)));
        return ($v)
    };
    if (($v->[1] eq '[ ]')) {
        ($v = Perlito5::AST::Index->new(('obj' => $value), ('index_exp' => $v->[2])));
        return ($v)
    };
    if (($v->[1] eq 'block')) {
        ($v = Perlito5::AST::Lookup->new(('obj' => $value), ('index_exp' => ($v->[2])->[0])));
        return ($v)
    };
    if (($v->[1] eq '.( )')) {
        ((my  $param_list) = expand_list($v->[2]));
        ($v = Perlito5::AST::Call->new(('invocant' => $value), ('method' => 'postcircumfix:<( )>'), ('arguments' => $param_list)));
        return ($v)
    };
    if (($v->[1] eq '.[ ]')) {
        ($v = Perlito5::AST::Call->new(('invocant' => $value), ('method' => 'postcircumfix:<[ ]>'), ('arguments' => $v->[2])));
        return ($v)
    };
    if (($v->[1] eq '.{ }')) {
        ($v = Perlito5::AST::Call->new(('invocant' => $value), ('method' => 'postcircumfix:<{ }>'), ('arguments' => $v->[2])));
        return ($v)
    };
    push(@{$op}, $value );
    return ($op)
};
((my  $reduce_to_ast) = sub {
    ((my  $op_stack) = shift());
    ((my  $num_stack) = shift());
    ((my  $last_op) = shift(@{$op_stack}));
    if (($last_op->[0] eq 'prefix')) {
        push(@{$num_stack}, Perlito5::AST::Apply->new(('namespace' => ''), ('code' => ('prefix:<' . $last_op->[1] . '>')), ('arguments' => [pop_term($num_stack)])) )
    }
    else {
        if (($last_op->[0] eq 'postfix')) {
            push(@{$num_stack}, Perlito5::AST::Apply->new(('namespace' => ''), ('code' => ('postfix:<' . $last_op->[1] . '>')), ('arguments' => [pop_term($num_stack)])) )
        }
        else {
            if (($last_op->[0] eq 'postfix_or_term')) {
                push(@{$num_stack}, reduce_postfix($last_op, pop_term($num_stack)) )
            }
            else {
                if (Perlito5::Precedence::is_assoc_type('list', $last_op->[1])) {
                    (my  $arg);
                    if ((scalar(@{$num_stack}) < 2)) {
                        ((my  $v2) = pop_term($num_stack));
                        if (((ref($v2) eq 'Perlito5::AST::Apply') && ($v2->code() eq (('list:<' . $last_op->[1] . '>'))))) {
                            push(@{$num_stack}, Perlito5::AST::Apply->new(('namespace' => $v2->namespace()), ('code' => $v2->code()), ('arguments' => [@{$v2->arguments()}, undef()])) )
                        }
                        else {
                            push(@{$num_stack}, Perlito5::AST::Apply->new(('namespace' => ''), ('code' => ('list:<' . $last_op->[1] . '>')), ('arguments' => [$v2, undef()])) )
                        };
                        return ()
                    }
                    else {
                        ((my  $v2) = pop_term($num_stack));
                        ($arg = [pop_term($num_stack), $v2])
                    };
                    if ((((ref($arg->[0]) eq 'Perlito5::AST::Apply') && ($last_op->[0] eq 'infix')) && (($arg->[0]->code() eq ('list:<' . $last_op->[1] . '>'))))) {
                        push(@{$num_stack}, Perlito5::AST::Apply->new(('namespace' => ''), ('code' => ($arg->[0])->code()), ('arguments' => [@{($arg->[0])->arguments()}, $arg->[1]])) );
                        return ()
                    };
                    push(@{$num_stack}, Perlito5::AST::Apply->new(('namespace' => ''), ('code' => ('list:<' . $last_op->[1] . '>')), ('arguments' => $arg)) )
                }
                else {
                    if (Perlito5::Precedence::is_assoc_type('chain', $last_op->[1])) {
                        if ((scalar(@{$num_stack}) < 2)) {
                            die(('Missing value after operator ' . $last_op->[1]))
                        };
                        ((my  $v2) = pop_term($num_stack));
                        ((my  $arg) = [pop_term($num_stack), $v2]);
                        push(@{$num_stack}, Perlito5::AST::Apply->new(('namespace' => ''), ('code' => ('infix:<' . $last_op->[1] . '>')), ('arguments' => $arg)) )
                    }
                    else {
                        if (($last_op->[0] eq 'ternary')) {
                            if ((scalar(@{$num_stack}) < 2)) {
                                die('Missing value after ternary operator')
                            };
                            ((my  $v2) = pop_term($num_stack));
                            push(@{$num_stack}, Perlito5::AST::Apply->new(('namespace' => ''), ('code' => ('ternary:<' . $last_op->[1] . '>')), ('arguments' => [pop_term($num_stack), $last_op->[2], $v2])) )
                        }
                        else {
                            if ((scalar(@{$num_stack}) < 2)) {
                                die(('missing value after operator ' . chr(39) . $last_op->[1] . chr(39)))
                            };
                            ((my  $v2) = pop_term($num_stack));
                            push(@{$num_stack}, Perlito5::AST::Apply->new(('namespace' => ''), ('code' => ('infix:<' . $last_op->[1] . '>')), ('arguments' => [pop_term($num_stack), $v2])) )
                        }
                    }
                }
            }
        }
    }
});
sub Perlito5::Expression::term_arrow {
    ((my  $grammar) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    ((my  $MATCH) = {('str' => $str), ('from' => $pos), ('to' => $pos)});
    ((my  $tmp) = (((do {
    ((my  $pos1) = $MATCH->{'to'});
    ((do {
    ((((('->' eq substr($str, $MATCH->{'to'}, 2)) && (($MATCH->{'to'} = (2 + $MATCH->{'to'}))))) && ((do {
    ((my  $m2) = Perlito5::Grammar::Space->opt_ws($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        1
    }
    else {
        0
    }
}))) && ((do {
    ((my  $pos1) = $MATCH->{'to'});
    ((((((do {
    (((((('(' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'}))))) && ((do {
    ((my  $m2) = $grammar->paren_parse($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        ($MATCH->{'paren_parse'} = $m2);
        1
    }
    else {
        0
    }
}))) && (((')' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'})))))) && ((do {
    ($MATCH->{'capture'} = ['postfix_or_term', '.( )', Perlito5::Match::flat($MATCH->{'paren_parse'})]);
    1
})))
})) || ((do {
    ($MATCH->{'to'} = $pos1);
    ((((((('[' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'}))))) && ((do {
    ((my  $m2) = $grammar->square_parse($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        ($MATCH->{'square_parse'} = $m2);
        1
    }
    else {
        0
    }
}))) && (((']' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'})))))) && ((do {
    ($MATCH->{'capture'} = ['postfix_or_term', '.[ ]', Perlito5::Match::flat($MATCH->{'square_parse'})]);
    1
}))))
}))) || ((do {
    ($MATCH->{'to'} = $pos1);
    ((((((('{' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'}))))) && ((do {
    ((my  $m2) = $grammar->curly_parse($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        ($MATCH->{'curly_parse'} = $m2);
        1
    }
    else {
        0
    }
}))) && ((('}' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'})))))) && ((do {
    ($MATCH->{'capture'} = ['postfix_or_term', '.{ }', Perlito5::Match::flat($MATCH->{'curly_parse'})]);
    1
}))))
}))) || ((do {
    ($MATCH->{'to'} = $pos1);
    ((((((('$' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'}))))) && ((do {
    ((my  $m2) = Perlito5::Grammar->ident($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        ($MATCH->{'Perlito5::Grammar.ident'} = $m2);
        1
    }
    else {
        0
    }
}))) && ((do {
    ((my  $m2) = Perlito5::Grammar::Space->opt_ws($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        1
    }
    else {
        0
    }
}))) && ((do {
    ((my  $pos1) = $MATCH->{'to'});
    (((do {
    (((((('(' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'}))))) && ((do {
    ((my  $m2) = $grammar->paren_parse($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        ($MATCH->{'paren_parse'} = $m2);
        1
    }
    else {
        0
    }
}))) && (((')' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'})))))) && ((do {
    ($MATCH->{'capture'} = ['postfix_or_term', 'methcall', Perlito5::AST::Var->new(('sigil' => '$'), ('namespace' => ''), ('name' => Perlito5::Match::flat($MATCH->{'Perlito5::Grammar.ident'}))), {('exp' => Perlito5::Match::flat($MATCH->{'paren_parse'})), ('terminated' => 0)}]);
    1
})))
})) || ((do {
    ($MATCH->{'to'} = $pos1);
    (((do {
    ($MATCH->{'capture'} = ['postfix_or_term', 'methcall_no_params', Perlito5::AST::Var->new(('sigil' => '$'), ('namespace' => ''), ('name' => Perlito5::Match::flat($MATCH->{'Perlito5::Grammar.ident'})))]);
    1
})))
})))
}))))
}))) || ((do {
    ($MATCH->{'to'} = $pos1);
    (((((do {
    ((my  $m2) = Perlito5::Grammar->full_ident($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        ($MATCH->{'Perlito5::Grammar.full_ident'} = $m2);
        1
    }
    else {
        0
    }
})) && ((do {
    ((my  $m2) = Perlito5::Grammar::Space->opt_ws($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        1
    }
    else {
        0
    }
}))) && ((do {
    ((my  $pos1) = $MATCH->{'to'});
    (((do {
    (((((('(' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'}))))) && ((do {
    ((my  $m2) = $grammar->paren_parse($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        ($MATCH->{'paren_parse'} = $m2);
        1
    }
    else {
        0
    }
}))) && (((')' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'})))))) && ((do {
    ($MATCH->{'capture'} = ['postfix_or_term', 'methcall', Perlito5::Match::flat($MATCH->{'Perlito5::Grammar.full_ident'}), {('exp' => Perlito5::Match::flat($MATCH->{'paren_parse'})), ('terminated' => 0)}]);
    1
})))
})) || ((do {
    ($MATCH->{'to'} = $pos1);
    (((do {
    ($MATCH->{'capture'} = ['postfix_or_term', 'methcall_no_params', Perlito5::Match::flat($MATCH->{'Perlito5::Grammar.full_ident'})]);
    1
})))
})))
}))))
})))
})))
}))
}))));
    ($tmp ? $MATCH : 0)
};
((my  %special_var) = (('$_' => 1), ('$&' => 1), ('$`' => 1), ('$' . chr(39) => 1), ('$+' => 1), ('@+' => 1), ('%+' => 1), ('$.' => 1), ('$/' => 1), ('$|' => 1), ('$,' => 1), ('$' . chr(92) => 1), ('$"' => 1), ('$;' => 1), ('$%' => 1), ('$=' => 1), ('$-' => 1), ('@-' => 1), ('%-' => 1), ('$~' => 1), ('$^' => 1), ('$:' => 1), ('$?' => 1), ('$!' => 1), ('%!' => 1), ('$@' => 1), ('$$' => 1), ('$<' => 1), ('$>' => 1), ('$(' => 1), ('$)' => 1), ('$[' => 1), ('$]' => 1), ('@_' => 1), ('$#' => 1), ('$*' => 1), ('$#+' => 1), ('$#-' => 1), ('$#_' => 1)));
sub Perlito5::Expression::term_special_var {
    ((my  $self) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    ((my  $len) = 0);
    ((my  $s) = substr($str, $pos, 3));
    if (exists($special_var{$s})) {
        ($len = 3)
    }
    else {
        ($s = substr($str, $pos, 2));
        if (exists($special_var{$s})) {
            ($len = 2)
        }
    };
    if ($len) {
        ((my  $c0) = substr($str, (($pos + $len) - 1), 1));
        ((my  $c1) = substr($str, ($pos + $len), 1));
        if (((((((($c0 eq '$') || ($c0 eq '@')) || ($c0 eq '%')) || ($c0 eq '*')) || ($c0 eq '&'))) && ((((((((($c1 eq '$') || ($c1 eq '@')) || ($c1 eq '%')) || ($c1 eq '*')) || ($c1 eq '&')) || ((($c1 ge 'a') && ($c1 le 'z')))) || ((($c1 ge 'A') && ($c1 le 'Z')))) || ((($c1 ge '0') && ($c1 le '9'))))))) {

        }
        else {
            return ({('str' => $str), ('from' => $pos), ('to' => ($pos + $len)), ('capture' => ['term', Perlito5::AST::Var->new(('sigil' => substr($s, 0, ($len - 1))), ('namespace' => ''), ('name' => substr($s, ($len - 1), 1)))])})
        }
    };
    return (0)
};
sub Perlito5::Expression::var_sigil_or_pseudo {
    ((my  $grammar) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    ((my  $MATCH) = {('str' => $str), ('from' => $pos), ('to' => $pos)});
    ((my  $tmp) = (((do {
    ((my  $pos1) = $MATCH->{'to'});
    (((((((do {
    (('$#' eq substr($str, $MATCH->{'to'}, 2)) && (($MATCH->{'to'} = (2 + $MATCH->{'to'}))))
})) || ((do {
    ($MATCH->{'to'} = $pos1);
    (((('$' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'}))))))
}))) || ((do {
    ($MATCH->{'to'} = $pos1);
    (((('%' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'}))))))
}))) || ((do {
    ($MATCH->{'to'} = $pos1);
    (((('@' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'}))))))
}))) || ((do {
    ($MATCH->{'to'} = $pos1);
    (((('&' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'}))))))
}))) || ((do {
    ($MATCH->{'to'} = $pos1);
    (((('*' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'}))))))
})))
}))));
    ($tmp ? $MATCH : 0)
};
sub Perlito5::Expression::term_sigil {
    ((my  $grammar) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    ((my  $MATCH) = {('str' => $str), ('from' => $pos), ('to' => $pos)});
    ((my  $tmp) = (((do {
    ((my  $pos1) = $MATCH->{'to'});
    (((do {
    ((((do {
    ((my  $m2) = $grammar->var_sigil_or_pseudo($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        ($MATCH->{'var_sigil_or_pseudo'} = $m2);
        1
    }
    else {
        0
    }
})) && ((do {
    ((my  $m2) = Perlito5::Grammar::Space->opt_ws($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        1
    }
    else {
        0
    }
}))) && ((do {
    ((my  $pos1) = $MATCH->{'to'});
    ((((do {
    (((('{' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'}))))) && ((do {
    ((my  $pos1) = $MATCH->{'to'});
    ((((do {
    (((((do {
    ((my  $m2) = Perlito5::Grammar->optional_namespace_before_ident($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        ($MATCH->{'Perlito5::Grammar.optional_namespace_before_ident'} = $m2);
        1
    }
    else {
        0
    }
})) && ((do {
    ((my  $m2) = Perlito5::Grammar->var_name($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        ($MATCH->{'Perlito5::Grammar.var_name'} = $m2);
        1
    }
    else {
        0
    }
}))) && ((('}' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'})))))) && ((do {
    ($MATCH->{'capture'} = ['term', Perlito5::AST::Var->new(('sigil' => Perlito5::Match::flat($MATCH->{'var_sigil_or_pseudo'})), ('namespace' => Perlito5::Match::flat($MATCH->{'Perlito5::Grammar.optional_namespace_before_ident'})), ('name' => Perlito5::Match::flat($MATCH->{'Perlito5::Grammar.var_name'})))]);
    1
})))
})) || ((do {
    ($MATCH->{'to'} = $pos1);
    ((((((('^' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'}))))) && ((do {
    ((my  $m2) = Perlito5::Grammar->var_name($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        ($MATCH->{'Perlito5::Grammar.var_name'} = $m2);
        1
    }
    else {
        0
    }
}))) && ((('}' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'})))))) && ((do {
    ($MATCH->{'capture'} = ['term', Perlito5::AST::Var->new(('sigil' => Perlito5::Match::flat($MATCH->{'var_sigil_or_pseudo'})), ('namespace' => 'main'), ('name' => ('^' . Perlito5::Match::flat($MATCH->{'Perlito5::Grammar.var_name'}))))]);
    1
}))))
}))) || ((do {
    ($MATCH->{'to'} = $pos1);
    (((((do {
    ((my  $m2) = $grammar->curly_parse($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        ($MATCH->{'curly_parse'} = $m2);
        1
    }
    else {
        0
    }
})) && ((('}' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'})))))) && ((do {
    ($MATCH->{'capture'} = ['term', Perlito5::AST::Apply->new(('arguments' => [Perlito5::Match::flat($MATCH->{'curly_parse'})]), ('code' => ('prefix:<' . Perlito5::Match::flat($MATCH->{'var_sigil_or_pseudo'}) . '>')), ('namespace' => ''))]);
    1
}))))
})))
})))
})) || ((do {
    ($MATCH->{'to'} = $pos1);
    (((((('^' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'}))))) && ((do {
    ((my  $m2) = Perlito5::Grammar->word($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        ($MATCH->{'Perlito5::Grammar.word'} = $m2);
        1
    }
    else {
        0
    }
}))) && ((do {
    ($MATCH->{'capture'} = ['term', Perlito5::AST::Var->new(('sigil' => Perlito5::Match::flat($MATCH->{'var_sigil_or_pseudo'})), ('namespace' => 'main'), ('name' => ('^' . Perlito5::Match::flat($MATCH->{'Perlito5::Grammar.word'}))))]);
    1
}))))
}))) || ((do {
    ($MATCH->{'to'} = $pos1);
    (((((do {
    ((my  $m2) = Perlito5::Grammar->optional_namespace_before_ident($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        ($MATCH->{'Perlito5::Grammar.optional_namespace_before_ident'} = $m2);
        1
    }
    else {
        0
    }
})) && ((do {
    ((my  $m2) = Perlito5::Grammar->var_name($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        ($MATCH->{'Perlito5::Grammar.var_name'} = $m2);
        1
    }
    else {
        0
    }
}))) && ((do {
    ($MATCH->{'capture'} = ['term', Perlito5::AST::Var->new(('sigil' => Perlito5::Match::flat($MATCH->{'var_sigil_or_pseudo'})), ('namespace' => Perlito5::Match::flat($MATCH->{'Perlito5::Grammar.optional_namespace_before_ident'})), ('name' => Perlito5::Match::flat($MATCH->{'Perlito5::Grammar.var_name'})))]);
    1
}))))
})))
})))
})) || ((do {
    ($MATCH->{'to'} = $pos1);
    ((((do {
    ((my  $m2) = $grammar->term_special_var($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        ($MATCH->{'term_special_var'} = $m2);
        1
    }
    else {
        0
    }
})) && ((do {
    ($MATCH->{'capture'} = $MATCH->{'term_special_var'}->{'capture'});
    1
}))))
})))
}))));
    ($tmp ? $MATCH : 0)
};
sub Perlito5::Expression::term_digit {
    ((my  $grammar) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    ((my  $MATCH) = {('str' => $str), ('from' => $pos), ('to' => $pos)});
    ((my  $tmp) = (((do {
    ((my  $pos1) = $MATCH->{'to'});
    (((do {
    (((do {
    ((my  $m2) = Perlito5::Grammar->val_num($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        ($MATCH->{'Perlito5::Grammar.val_num'} = $m2);
        1
    }
    else {
        0
    }
})) && ((do {
    ($MATCH->{'capture'} = ['term', Perlito5::Match::flat($MATCH->{'Perlito5::Grammar.val_num'})]);
    1
})))
})) || ((do {
    ($MATCH->{'to'} = $pos1);
    ((((do {
    ((my  $m2) = Perlito5::Grammar->val_int($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        ($MATCH->{'Perlito5::Grammar.val_int'} = $m2);
        1
    }
    else {
        0
    }
})) && ((do {
    ($MATCH->{'capture'} = ['term', Perlito5::Match::flat($MATCH->{'Perlito5::Grammar.val_int'})]);
    1
}))))
})))
}))));
    ($tmp ? $MATCH : 0)
};
sub Perlito5::Expression::term_ternary {
    ((my  $grammar) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    ((my  $MATCH) = {('str' => $str), ('from' => $pos), ('to' => $pos)});
    ((my  $tmp) = (((do {
    ((my  $pos1) = $MATCH->{'to'});
    ((do {
    (((((('?' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'}))))) && ((do {
    ((my  $m2) = $grammar->ternary5_parse($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        ($MATCH->{'ternary5_parse'} = $m2);
        1
    }
    else {
        0
    }
}))) && (((':' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'})))))) && ((do {
    ($MATCH->{'capture'} = ['op', '? :', Perlito5::Match::flat($MATCH->{'ternary5_parse'})]);
    1
})))
}))
}))));
    ($tmp ? $MATCH : 0)
};
sub Perlito5::Expression::term_paren {
    ((my  $grammar) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    ((my  $MATCH) = {('str' => $str), ('from' => $pos), ('to' => $pos)});
    ((my  $tmp) = (((do {
    ((my  $pos1) = $MATCH->{'to'});
    ((do {
    (((((('(' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'}))))) && ((do {
    ((my  $m2) = $grammar->paren_parse($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        ($MATCH->{'paren_parse'} = $m2);
        1
    }
    else {
        0
    }
}))) && (((')' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'})))))) && ((do {
    ($MATCH->{'capture'} = ['postfix_or_term', '( )', Perlito5::Match::flat($MATCH->{'paren_parse'})]);
    1
})))
}))
}))));
    ($tmp ? $MATCH : 0)
};
sub Perlito5::Expression::term_square {
    ((my  $grammar) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    ((my  $MATCH) = {('str' => $str), ('from' => $pos), ('to' => $pos)});
    ((my  $tmp) = (((do {
    ((my  $pos1) = $MATCH->{'to'});
    ((do {
    (((((('[' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'}))))) && ((do {
    ((my  $m2) = $grammar->square_parse($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        ($MATCH->{'square_parse'} = $m2);
        1
    }
    else {
        0
    }
}))) && (((']' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'})))))) && ((do {
    ($MATCH->{'capture'} = ['postfix_or_term', '[ ]', Perlito5::Match::flat($MATCH->{'square_parse'})]);
    1
})))
}))
}))));
    ($tmp ? $MATCH : 0)
};
sub Perlito5::Expression::term_curly {
    ((my  $grammar) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    ((my  $MATCH) = {('str' => $str), ('from' => $pos), ('to' => $pos)});
    ((my  $tmp) = (((do {
    ((my  $pos1) = $MATCH->{'to'});
    ((do {
    (((((((('{' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'}))))) && ((do {
    ((my  $m) = $MATCH);
    if (!(((do {
    ((my  $m2) = Perlito5::Grammar::Space->ws($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        1
    }
    else {
        0
    }
})))) {
        ($MATCH = $m)
    };
    1
}))) && ((do {
    ((my  $m2) = Perlito5::Grammar->exp_stmts($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        ($MATCH->{'Perlito5::Grammar.exp_stmts'} = $m2);
        1
    }
    else {
        0
    }
}))) && ((do {
    ((my  $m) = $MATCH);
    if (!(((do {
    ((my  $m2) = Perlito5::Grammar::Space->ws($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        1
    }
    else {
        0
    }
})))) {
        ($MATCH = $m)
    };
    1
}))) && ((('}' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'})))))) && ((do {
    ($MATCH->{'capture'} = ['postfix_or_term', 'block', Perlito5::Match::flat($MATCH->{'Perlito5::Grammar.exp_stmts'})]);
    1
})))
}))
}))));
    ($tmp ? $MATCH : 0)
};
sub Perlito5::Expression::declarator {
    ((my  $grammar) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    ((my  $MATCH) = {('str' => $str), ('from' => $pos), ('to' => $pos)});
    ((my  $tmp) = (((do {
    ((my  $pos1) = $MATCH->{'to'});
    (((((do {
    (('my' eq substr($str, $MATCH->{'to'}, 2)) && (($MATCH->{'to'} = (2 + $MATCH->{'to'}))))
})) || ((do {
    ($MATCH->{'to'} = $pos1);
    (((('state' eq substr($str, $MATCH->{'to'}, 5)) && (($MATCH->{'to'} = (5 + $MATCH->{'to'}))))))
}))) || ((do {
    ($MATCH->{'to'} = $pos1);
    (((('our' eq substr($str, $MATCH->{'to'}, 3)) && (($MATCH->{'to'} = (3 + $MATCH->{'to'}))))))
}))) || ((do {
    ($MATCH->{'to'} = $pos1);
    (((('local' eq substr($str, $MATCH->{'to'}, 5)) && (($MATCH->{'to'} = (5 + $MATCH->{'to'}))))))
})))
}))));
    ($tmp ? $MATCH : 0)
};
sub Perlito5::Expression::term_declarator {
    ((my  $grammar) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    ((my  $MATCH) = {('str' => $str), ('from' => $pos), ('to' => $pos)});
    ((my  $tmp) = (((do {
    ((my  $pos1) = $MATCH->{'to'});
    ((do {
    (((((((do {
    ((my  $m2) = $grammar->declarator($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        ($MATCH->{'declarator'} = $m2);
        1
    }
    else {
        0
    }
})) && ((do {
    ((my  $m2) = Perlito5::Grammar::Space->ws($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        1
    }
    else {
        0
    }
}))) && ((do {
    ((my  $m2) = Perlito5::Grammar->opt_type($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        ($MATCH->{'Perlito5::Grammar.opt_type'} = $m2);
        1
    }
    else {
        0
    }
}))) && ((do {
    ((my  $m2) = Perlito5::Grammar::Space->opt_ws($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        1
    }
    else {
        0
    }
}))) && ((do {
    ((my  $m2) = Perlito5::Grammar->var_ident($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        ($MATCH->{'Perlito5::Grammar.var_ident'} = $m2);
        1
    }
    else {
        0
    }
}))) && ((do {
    ($MATCH->{'capture'} = ['term', Perlito5::AST::Decl->new(('decl' => Perlito5::Match::flat($MATCH->{'declarator'})), ('type' => Perlito5::Match::flat($MATCH->{'Perlito5::Grammar.opt_type'})), ('var' => Perlito5::Match::flat($MATCH->{'Perlito5::Grammar.var_ident'})))]);
    1
})))
}))
}))));
    ($tmp ? $MATCH : 0)
};
sub Perlito5::Expression::term_return {
    ((my  $grammar) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    ((my  $MATCH) = {('str' => $str), ('from' => $pos), ('to' => $pos)});
    ((my  $tmp) = (((do {
    ((my  $pos1) = $MATCH->{'to'});
    ((do {
    (((((('return' eq substr($str, $MATCH->{'to'}, 6)) && (($MATCH->{'to'} = (6 + $MATCH->{'to'}))))) && ((do {
    ((my  $m2) = Perlito5::Grammar::Space->opt_ws($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        1
    }
    else {
        0
    }
}))) && ((do {
    ((my  $m2) = $grammar->list_parse($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        ($MATCH->{'list_parse'} = $m2);
        1
    }
    else {
        0
    }
}))) && ((do {
    ((my  $args) = Perlito5::Match::flat($MATCH->{'list_parse'})->{'exp'});
    ($MATCH->{'capture'} = ['term', Perlito5::AST::Apply->new(('code' => 'return'), ('arguments' => (($args eq '*undef*') ? [] : [$args])), ('namespace' => ''))]);
    1
})))
}))
}))));
    ($tmp ? $MATCH : 0)
};
sub Perlito5::Expression::term_anon_sub {
    ((my  $grammar) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    ((my  $MATCH) = {('str' => $str), ('from' => $pos), ('to' => $pos)});
    ((my  $tmp) = (((do {
    ((my  $pos1) = $MATCH->{'to'});
    ((do {
    (((((('sub' eq substr($str, $MATCH->{'to'}, 3)) && (($MATCH->{'to'} = (3 + $MATCH->{'to'}))))) && ((do {
    ((my  $m2) = Perlito5::Grammar::Space->opt_ws($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        1
    }
    else {
        0
    }
}))) && ((do {
    ((my  $m2) = Perlito5::Grammar->anon_sub_def($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        ($MATCH->{'Perlito5::Grammar.anon_sub_def'} = $m2);
        1
    }
    else {
        0
    }
}))) && ((do {
    ($MATCH->{'capture'} = ['term', Perlito5::Match::flat($MATCH->{'Perlito5::Grammar.anon_sub_def'})]);
    1
})))
}))
}))));
    ($tmp ? $MATCH : 0)
};
sub Perlito5::Expression::term_do {
    ((my  $grammar) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    ((my  $MATCH) = {('str' => $str), ('from' => $pos), ('to' => $pos)});
    ((my  $tmp) = (((do {
    ((my  $pos1) = $MATCH->{'to'});
    ((do {
    ((((((('do' eq substr($str, $MATCH->{'to'}, 2)) && (($MATCH->{'to'} = (2 + $MATCH->{'to'}))))) && ((do {
    ((my  $m2) = Perlito5::Grammar::Space->ws($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        1
    }
    else {
        0
    }
}))) && ((do {
    ((my  $tmp) = $MATCH);
    ($MATCH = {('str' => $str), ('from' => $tmp->{'to'}), ('to' => $tmp->{'to'})});
    ((my  $res) = ((do {
    ((my  $pos1) = $MATCH->{'to'});
    ((do {
    (('{' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'}))))
}))
})));
    ($MATCH = ($res ? $tmp : 0))
}))) && ((do {
    ((my  $m2) = $grammar->statement_parse($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        ($MATCH->{'statement_parse'} = $m2);
        1
    }
    else {
        0
    }
}))) && ((do {
    ($MATCH->{'capture'} = ['term', Perlito5::AST::Do->new(('block' => Perlito5::Match::flat($MATCH->{'statement_parse'})))]);
    1
})))
}))
}))));
    ($tmp ? $MATCH : 0)
};
sub Perlito5::Expression::term_package {
    ((my  $grammar) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    ((my  $MATCH) = {('str' => $str), ('from' => $pos), ('to' => $pos)});
    ((my  $tmp) = (((do {
    ((my  $pos1) = $MATCH->{'to'});
    ((do {
    (((((('package' eq substr($str, $MATCH->{'to'}, 7)) && (($MATCH->{'to'} = (7 + $MATCH->{'to'}))))) && ((do {
    ((my  $m2) = Perlito5::Grammar::Space->ws($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        1
    }
    else {
        0
    }
}))) && ((do {
    ((my  $m2) = Perlito5::Grammar->full_ident($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        ($MATCH->{'Perlito5::Grammar.full_ident'} = $m2);
        1
    }
    else {
        0
    }
}))) && ((do {
    ((my  $name) = Perlito5::Match::flat($MATCH->{'Perlito5::Grammar.full_ident'}));
    ($Perlito5::PKG_NAME = $name);
    ($MATCH->{'capture'} = ['term', Perlito5::AST::Apply->new(('code' => 'package'), ('arguments' => []), ('namespace' => $name))]);
    1
})))
}))
}))));
    ($tmp ? $MATCH : 0)
};
sub Perlito5::Expression::term_eval {
    ((my  $grammar) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    ((my  $MATCH) = {('str' => $str), ('from' => $pos), ('to' => $pos)});
    ((my  $tmp) = (((do {
    ((my  $pos1) = $MATCH->{'to'});
    ((do {
    ((((((('eval' eq substr($str, $MATCH->{'to'}, 4)) && (($MATCH->{'to'} = (4 + $MATCH->{'to'}))))) && ((do {
    ((my  $m2) = Perlito5::Grammar::Space->opt_ws($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        1
    }
    else {
        0
    }
}))) && ((do {
    ((my  $tmp) = $MATCH);
    ($MATCH = {('str' => $str), ('from' => $tmp->{'to'}), ('to' => $tmp->{'to'})});
    ((my  $res) = ((do {
    ((my  $pos1) = $MATCH->{'to'});
    ((do {
    (('{' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'}))))
}))
})));
    ($MATCH = ($res ? $tmp : 0))
}))) && ((do {
    ((my  $m2) = $grammar->term_curly($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        ($MATCH->{'term_curly'} = $m2);
        1
    }
    else {
        0
    }
}))) && ((do {
    ($MATCH->{'capture'} = ['term', Perlito5::AST::Apply->new(('code' => 'eval'), ('arguments' => [Perlito5::AST::Do->new(('block' => Perlito5::AST::Lit::Block->new(('stmts' => Perlito5::Match::flat($MATCH->{'term_curly'})->[2]))))]), ('namespace' => ''))]);
    1
})))
}))
}))));
    ($tmp ? $MATCH : 0)
};
sub Perlito5::Expression::map_or_sort {
    ((my  $grammar) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    ((my  $MATCH) = {('str' => $str), ('from' => $pos), ('to' => $pos)});
    ((my  $tmp) = (((do {
    ((my  $pos1) = $MATCH->{'to'});
    ((((do {
    (('map' eq substr($str, $MATCH->{'to'}, 3)) && (($MATCH->{'to'} = (3 + $MATCH->{'to'}))))
})) || ((do {
    ($MATCH->{'to'} = $pos1);
    (((('sort' eq substr($str, $MATCH->{'to'}, 4)) && (($MATCH->{'to'} = (4 + $MATCH->{'to'}))))))
}))) || ((do {
    ($MATCH->{'to'} = $pos1);
    (((('grep' eq substr($str, $MATCH->{'to'}, 4)) && (($MATCH->{'to'} = (4 + $MATCH->{'to'}))))))
})))
}))));
    ($tmp ? $MATCH : 0)
};
sub Perlito5::Expression::term_map_or_sort {
    ((my  $grammar) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    ((my  $MATCH) = {('str' => $str), ('from' => $pos), ('to' => $pos)});
    ((my  $tmp) = (((do {
    ((my  $pos1) = $MATCH->{'to'});
    ((do {
    (((((((do {
    ((my  $m2) = $grammar->map_or_sort($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        ($MATCH->{'map_or_sort'} = $m2);
        1
    }
    else {
        0
    }
})) && ((do {
    ((my  $m2) = Perlito5::Grammar::Space->opt_ws($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        1
    }
    else {
        0
    }
}))) && ((do {
    ((my  $tmp) = $MATCH);
    ($MATCH = {('str' => $str), ('from' => $tmp->{'to'}), ('to' => $tmp->{'to'})});
    ((my  $res) = ((do {
    ((my  $pos1) = $MATCH->{'to'});
    ((do {
    (('{' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'}))))
}))
})));
    ($MATCH = ($res ? $tmp : 0))
}))) && ((do {
    ((my  $m2) = $grammar->term_curly($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        ($MATCH->{'term_curly'} = $m2);
        1
    }
    else {
        0
    }
}))) && ((do {
    ((my  $m2) = $grammar->list_parse($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        ($MATCH->{'list_parse'} = $m2);
        1
    }
    else {
        0
    }
}))) && ((do {
    ($MATCH->{'capture'} = ['term', Perlito5::AST::Apply->new(('code' => Perlito5::Match::flat($MATCH->{'map_or_sort'})), ('arguments' => [Perlito5::AST::Lit::Block->new(('stmts' => Perlito5::Match::flat($MATCH->{'term_curly'})->[2])), @{Perlito5::Match::flat(expand_list($MATCH->{'list_parse'})->{'exp'})}]), ('namespace' => ''))]);
    1
})))
}))
}))));
    ($tmp ? $MATCH : 0)
};
((my  $Argument_end_token) = {(':' => 1), (']' => 1), (')' => 1), ('}' => 1), (';' => 1), (',' => 1), ('<' => 1), ('>' => 1), ('=' => 1), ('&' => 1), ('|' => 1), ('^' => 1), ('or' => 1), ('if' => 1), ('=>' => 1), ('lt' => 1), ('le' => 1), ('gt' => 1), ('ge' => 1), ('<=' => 1), ('>=' => 1), ('==' => 1), ('!=' => 1), ('ne' => 1), ('eq' => 1), ('..' => 1), ('~~' => 1), ('&&' => 1), ('||' => 1), ('+=' => 1), ('-=' => 1), ('*=' => 1), ('/=' => 1), ('x=' => 1), ('|=' => 1), ('&=' => 1), ('.=' => 1), ('^=' => 1), ('%=' => 1), ('//' => 1), ('for' => 1), ('and' => 1), ('xor' => 1), ('...' => 1), ('<=>' => 1), ('cmp' => 1), ('<<=' => 1), ('>>=' => 1), ('||=' => 1), ('&&=' => 1), ('//=' => 1), ('**=' => 1), ('when' => 1), ('while' => 1), ('unless' => 1), ('foreach' => 1)});
((my  $Argument_end_token_chars) = [7, 6, 5, 4, 3, 2, 1]);
((my  $List_end_token) = {(':' => 1), (']' => 1), (')' => 1), ('}' => 1), (';' => 1), ('or' => 1), ('if' => 1), ('for' => 1), ('and' => 1), ('xor' => 1), ('else' => 1), ('when' => 1), ('while' => 1), ('elsif' => 1), ('unless' => 1), ('foreach' => 1)});
((my  $List_end_token_chars) = [7, 6, 5, 4, 3, 2, 1]);
((my  $Expr_end_token) = {(']' => 1), (')' => 1), ('}' => 1), (';' => 1), ('if' => 1), ('for' => 1), ('else' => 1), ('when' => 1), ('while' => 1), ('elsif' => 1), ('unless' => 1), ('foreach' => 1)});
((my  $Expr_end_token_chars) = [7, 6, 5, 4, 3, 2, 1]);
sub Perlito5::Expression::op_parse_spc {
    ((my  $self) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    ((my  $last_is_term) = $_[3]);
    ((my  $m) = Perlito5::Precedence->op_parse($str, $pos, $last_is_term));
    if (!($m)) {
        return ($m)
    };
    ((my  $spc) = Perlito5::Grammar::Space->ws($str, $m->{'to'}));
    if ($spc) {
        ($m->{'to'} = $spc->{'to'})
    };
    return ($m)
};
sub Perlito5::Expression::argument_parse {
    ((my  $self) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    (my  $expr);
    ((my  $last_pos) = $pos);
    ((my  $is_first_token) = 1);
    ((my  $lexer_stack) = []);
    ((my  $terminated) = 0);
    ((my  $last_token_was_space) = 1);
    (my  $last_is_term);
    ((my  $get_token) = sub {
    (my  $v);
    if (scalar(@{$lexer_stack})) {
        ($v = pop(@{$lexer_stack}));
        if ((($is_first_token && (($v->[0] eq 'op'))) && !((Perlito5::Precedence::is_fixity_type('prefix', $v->[1]))))) {
            ($v->[0] = 'end')
        }
    }
    else {
        ((my  $m) = Perlito5::Expression->op_parse_spc($str, $last_pos, $last_is_term));
        if (!($m)) {
            return (['end', '*end*'])
        };
        ($v = Perlito5::Match::flat($m));
        if (($v->[0] eq 'space')) {

        }
        else {
            ($last_is_term = Perlito5::Precedence::is_term($v))
        };
        if ((($is_first_token && (($v->[0] eq 'op'))) && !((Perlito5::Precedence::is_fixity_type('prefix', $v->[1]))))) {
            ($v->[0] = 'end')
        };
        if (($v->[0] ne 'end')) {
            ($last_pos = $m->{'to'})
        }
    };
    ($last_token_was_space = (($v->[0] eq 'space')));
    ($is_first_token = 0);
    return ($v)
});
    ((my  $prec) = Perlito5::Precedence->new(('get_token' => $get_token), ('reduce' => $reduce_to_ast), ('end_token' => $Argument_end_token), ('end_token_chars' => $Argument_end_token_chars)));
    ((my  $res) = $prec->precedence_parse());
    if ((scalar(@{$res}) == 0)) {
        return ({('str' => $str), ('from' => $pos), ('to' => $last_pos), ('capture' => {('exp' => '*undef*'), ('terminated' => undef())})})
    };
    ((my  $result) = pop_term($res));
    return ({('str' => $str), ('from' => $pos), ('to' => $last_pos), ('capture' => {('exp' => $result), ('terminated' => $terminated)})})
};
sub Perlito5::Expression::list_parse {
    ((my  $self) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    (my  $expr);
    ((my  $last_pos) = $pos);
    ((my  $is_first_token) = 1);
    ((my  $lexer_stack) = []);
    ((my  $terminated) = 0);
    ((my  $last_token_was_space) = 1);
    (my  $last_is_term);
    ((my  $get_token) = sub {
    (my  $v);
    if (scalar(@{$lexer_stack})) {
        ($v = pop(@{$lexer_stack}));
        if ((($is_first_token && (($v->[0] eq 'op'))) && !((Perlito5::Precedence::is_fixity_type('prefix', $v->[1]))))) {
            ($v->[0] = 'end')
        }
    }
    else {
        ((my  $m) = Perlito5::Expression->op_parse_spc($str, $last_pos, $last_is_term));
        if (!($m)) {
            return (['end', '*end*'])
        };
        ($v = Perlito5::Match::flat($m));
        if (($v->[0] eq 'space')) {

        }
        else {
            ($last_is_term = Perlito5::Precedence::is_term($v))
        };
        if ((($is_first_token && (($v->[0] eq 'op'))) && !((Perlito5::Precedence::is_fixity_type('prefix', $v->[1]))))) {
            ($v->[0] = 'end')
        };
        if (($v->[0] ne 'end')) {
            ($last_pos = $m->{'to'})
        }
    };
    ($last_token_was_space = (($v->[0] eq 'space')));
    ($is_first_token = 0);
    return ($v)
});
    ((my  $prec) = Perlito5::Precedence->new(('get_token' => $get_token), ('reduce' => $reduce_to_ast), ('end_token' => $List_end_token), ('end_token_chars' => $List_end_token_chars)));
    ((my  $res) = $prec->precedence_parse());
    if ((scalar(@{$res}) == 0)) {
        return ({('str' => $str), ('from' => $pos), ('to' => $last_pos), ('capture' => {('exp' => '*undef*'), ('terminated' => undef())})})
    };
    ((my  $result) = pop_term($res));
    return ({('str' => $str), ('from' => $pos), ('to' => $last_pos), ('capture' => {('exp' => $result), ('terminated' => $terminated)})})
};
sub Perlito5::Expression::circumfix_parse {
    ((my  $self) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    ((my  $delimiter) = $_[3]);
    (my  $expr);
    ((my  $last_pos) = $pos);
    (my  $last_is_term);
    ((my  $get_token) = sub {
    ((my  $m) = Perlito5::Expression->op_parse_spc($str, $last_pos, $last_is_term));
    if (!($m)) {
        die('Expected closing delimiter: ', $delimiter, ' near ', $last_pos)
    };
    ((my  $v) = $m->{'capture'});
    if (($v->[0] eq 'space')) {

    }
    else {
        ($last_is_term = Perlito5::Precedence::is_term($v))
    };
    if (($v->[0] ne 'end')) {
        ($last_pos = $m->{'to'})
    };
    return ($v)
});
    (my  %delim_token);
    ($delim_token{$delimiter} = 1);
    ((my  $prec) = Perlito5::Precedence->new(('get_token' => $get_token), ('reduce' => $reduce_to_ast), ('end_token' => \%delim_token), ('end_token_chars' => [length($delimiter)])));
    ((my  $res) = $prec->precedence_parse());
    ($res = pop_term($res));
    if (!((defined($res)))) {
        ($res = '*undef*')
    };
    return ({('str' => $str), ('from' => $pos), ('to' => $last_pos), ('capture' => $res)})
};
sub Perlito5::Expression::ternary5_parse {
    ((my  $self) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    return ($self->circumfix_parse($str, $pos, ':'))
};
sub Perlito5::Expression::curly_parse {
    ((my  $self) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    return ($self->circumfix_parse($str, $pos, '}'))
};
sub Perlito5::Expression::square_parse {
    ((my  $self) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    return ($self->circumfix_parse($str, $pos, ']'))
};
sub Perlito5::Expression::paren_parse {
    ((my  $self) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    return ($self->circumfix_parse($str, $pos, ')'))
};
sub Perlito5::Expression::exp_parse {
    ((my  $self) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    (my  $expr);
    ((my  $last_pos) = $pos);
    ((my  $lexer_stack) = []);
    ((my  $terminated) = 0);
    (my  $last_is_term);
    ((my  $get_token) = sub {
    (my  $v);
    if (scalar(@{$lexer_stack})) {
        ($v = pop(@{$lexer_stack}))
    }
    else {
        ((my  $m) = Perlito5::Expression->op_parse_spc($str, $last_pos, $last_is_term));
        if (!($m)) {
            return (['end', '*end*'])
        };
        ($v = $m->{'capture'});
        if (($v->[0] eq 'space')) {

        }
        else {
            ($last_is_term = Perlito5::Precedence::is_term($v))
        };
        if (($v->[0] ne 'end')) {
            ($last_pos = $m->{'to'})
        }
    };
    return ($v)
});
    ((my  $prec) = Perlito5::Precedence->new(('get_token' => $get_token), ('reduce' => $reduce_to_ast), ('end_token' => $Expr_end_token), ('end_token_chars' => $Expr_end_token_chars)));
    ((my  $res) = $prec->precedence_parse());
    if ((scalar(@{$res}) == 0)) {
        return (0)
    };
    ((my  $result) = pop_term($res));
    return ({('str' => $str), ('from' => $pos), ('to' => $last_pos), ('capture' => {('exp' => $result), ('terminated' => $terminated)})})
};
((my  @Statement_chars) = (9, 8, 7, 6, 5, 4, 3, 2, 1));
((my  %Statement) = (('if' => sub {
    Perlito5::Grammar->if($_[0], $_[1])
}), ('unless' => sub {
    Perlito5::Grammar->unless($_[0], $_[1])
}), ('when' => sub {
    Perlito5::Grammar->when($_[0], $_[1])
}), ('for' => sub {
    Perlito5::Grammar->for($_[0], $_[1])
}), ('while' => sub {
    Perlito5::Grammar->while($_[0], $_[1])
}), ('sub' => sub {
    Perlito5::Grammar->named_sub($_[0], $_[1])
})));
sub Perlito5::Expression::add_statement {
    ((my  $name) = shift());
    ((my  $param) = shift());
    ($Statement{$name} = $param)
};
sub Perlito5::Expression::exp_stmt {
    ((my  $self) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    for my $len (@Statement_chars) {
        ((my  $term) = substr($str, $pos, $len));
        if (exists($Statement{$term})) {
            ((my  $m) = $Statement{$term}->($str, $pos));
            if ($m) {
                return ($m)
            }
        }
    };
    return (0)
};
((my  @Modifier_chars) = (7, 6, 5, 4, 3, 2));
((my  %Modifier) = (('if' => 1), ('unless' => 1), ('when' => 1), ('for' => 1), ('foreach' => 1), ('while' => 1)));
sub Perlito5::Expression::statement_modifier {
    ((my  $self) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    ((my  $expression) = $_[3]);
    for my $len (@Modifier_chars) {
        ((my  $term) = substr($str, $pos, $len));
        if (exists($Modifier{$term})) {
            ((my  $m) = $self->modifier($str, ($pos + $len), $term, $expression));
            if ($m) {
                return ($m)
            }
        }
    };
    return (0)
};
sub Perlito5::Expression::modifier {
    ((my  $self) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    ((my  $modifier) = $_[3]);
    ((my  $expression) = $_[4]);
    ((my  $modifier_exp) = $self->exp_parse($str, $pos));
    if (!($modifier_exp)) {
        die('Expected expression after ' . chr(39), Perlito5::Match::flat($modifier), chr(39))
    };
    if (($modifier eq 'if')) {
        return ({('str' => $str), ('from' => $pos), ('to' => $modifier_exp->{'to'}), ('capture' => Perlito5::AST::If->new(('cond' => Perlito5::Match::flat($modifier_exp)->{'exp'}), ('body' => Perlito5::AST::Lit::Block->new(('stmts' => [$expression]))), ('otherwise' => Perlito5::AST::Lit::Block->new(('stmts' => [])))))})
    };
    if (($modifier eq 'unless')) {
        return ({('str' => $str), ('from' => $pos), ('to' => $modifier_exp->{'to'}), ('capture' => Perlito5::AST::If->new(('cond' => Perlito5::Match::flat($modifier_exp)->{'exp'}), ('body' => Perlito5::AST::Lit::Block->new(('stmts' => []))), ('otherwise' => Perlito5::AST::Lit::Block->new(('stmts' => [$expression])))))})
    };
    if (($modifier eq 'while')) {
        return ({('str' => $str), ('from' => $pos), ('to' => $modifier_exp->{'to'}), ('capture' => Perlito5::AST::While->new(('cond' => Perlito5::Match::flat($modifier_exp)->{'exp'}), ('body' => Perlito5::AST::Lit::Block->new(('stmts' => [$expression])))))})
    };
    if ((($modifier eq 'for') || ($modifier eq 'foreach'))) {
        return ({('str' => $str), ('from' => $pos), ('to' => $modifier_exp->{'to'}), ('capture' => Perlito5::AST::For->new(('cond' => Perlito5::Match::flat($modifier_exp)->{'exp'}), ('body' => Perlito5::AST::Lit::Block->new(('stmts' => [$expression])))))})
    };
    die(('Unexpected statement modifier ' . chr(39) . $modifier . chr(39)))
};
sub Perlito5::Expression::delimited_statement {
    ((my  $grammar) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    ((my  $MATCH) = {('str' => $str), ('from' => $pos), ('to' => $pos)});
    ((my  $tmp) = (((do {
    ((my  $pos1) = $MATCH->{'to'});
    ((do {
    (((do {
    ((my  $m) = $MATCH);
    if (!(((do {
    ((my  $m2) = Perlito5::Grammar::Space->ws($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        1
    }
    else {
        0
    }
})))) {
        ($MATCH = $m)
    };
    1
})) && ((do {
    ((my  $pos1) = $MATCH->{'to'});
    (((do {
    ((((';' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'}))))) && ((do {
    ((my  $m) = $MATCH);
    if (!(((do {
    ((my  $m2) = Perlito5::Grammar::Space->ws($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        1
    }
    else {
        0
    }
})))) {
        ($MATCH = $m)
    };
    1
})))
})) || ((do {
    ($MATCH->{'to'} = $pos1);
    ((((((do {
    ((my  $m2) = $grammar->statement_parse($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        ($MATCH->{'statement_parse'} = $m2);
        1
    }
    else {
        0
    }
})) && ((do {
    ((my  $m) = $MATCH);
    if (!(((do {
    ((';' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'}))))
})))) {
        ($MATCH = $m)
    };
    1
}))) && ((do {
    ((my  $m) = $MATCH);
    if (!(((do {
    ((my  $m2) = Perlito5::Grammar::Space->ws($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        1
    }
    else {
        0
    }
})))) {
        ($MATCH = $m)
    };
    1
}))) && ((do {
    ($MATCH->{'capture'} = $MATCH->{'statement_parse'}->{'capture'});
    1
}))))
})))
})))
}))
}))));
    ($tmp ? $MATCH : 0)
};
sub Perlito5::Expression::statement_parse {
    ((my  $self) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    ((my  $res) = $self->exp_stmt($str, $pos));
    if ($res) {
        return ($res)
    };
    ($res = $self->exp_parse($str, $pos));
    if (!($res)) {
        return ($res)
    };
    if (Perlito5::Match::flat($res)->{'terminated'}) {
        ($res->{'capture'} = Perlito5::Match::flat($res)->{'exp'});
        return ($res)
    };
    ((my  $modifier) = $self->statement_modifier($str, $res->{'to'}, Perlito5::Match::flat($res)->{'exp'}));
    if (!($modifier)) {
        ($res->{'capture'} = Perlito5::Match::flat($res)->{'exp'});
        return ($res)
    };
    return ($modifier)
};
1;

1;
