# Do not edit this file - Generated by Perlito5 8.0
use v5;
use utf8;
use strict;
use warnings;
no warnings ('redefine', 'once', 'void', 'uninitialized', 'misc', 'recursion');
use Perlito5::Perl5::Runtime;
our $MATCH = Perlito5::Match->new();
package main;
package Perlito5::Expression;
use Perlito5::Precedence;
use Perlito5::Grammar;
use Perlito5::Perl5::Emitter;
sub expand_list {
    ((my  $param_list) = shift());
    if ((((ref($param_list) eq 'Apply') && ($param_list->code() eq 'list:<,>')))) {
        ((my  $args) = (do {
    (my  @a);
    (my  @v);
    \@a
}));
        for my $v (@{$param_list->arguments()}) {
            if ((defined($v))) {
                push(@{$args}, $v )
            }
        };
        return ($args)
    }
    else {
        if ((($param_list eq '*undef*'))) {
            return ((do {
    (my  @a);
    (my  @v);
    \@a
}))
        }
        else {
            return ((do {
    (my  @a);
    (my  @v);
    push(@a, $param_list );
    \@a
}))
        }
    }
};
sub block_or_hash {
    ((my  $o) = shift());
    if ((defined($o->sig()))) {
        return ($o)
    };
    ((my  $stmts) = $o->stmts());
    if (((!((defined($stmts))) || (scalar(@{$stmts}) == 0)))) {
        return (Lit::Hash->new(('hash1' => (do {
    (my  @a);
    (my  @v);
    \@a
}))))
    };
    if (((scalar(@{$stmts}) != 1))) {
        return ($o)
    };
    ((my  $stmt) = $stmts->[0]);
    if (((ref($stmt) eq 'Var'))) {
        return (Lit::Hash->new(('hash1' => (do {
    (my  @a);
    (my  @v);
    push(@a, $stmt );
    \@a
}))))
    };
    if (((ref($stmt) ne 'Apply'))) {
        return ($o)
    };
    if ((($stmt->code() eq 'infix:<' . chr(61) . '>>'))) {
        return (Lit::Hash->new(('hash1' => (do {
    (my  @a);
    (my  @v);
    push(@a, $stmt );
    \@a
}))))
    };
    if ((($stmt->code() ne 'list:<,>'))) {
        return ($o)
    };
    for my $item (@{$stmt->arguments()}) {
        if ((((ref($item) eq 'Apply') && ($item->code() eq 'infix:<' . chr(61) . '>>')))) {
            return (Lit::Hash->new(('hash1' => expand_list($stmt))))
        }
    };
    return ($o)
};
sub pop_term {
    ((my  $num_stack) = shift());
    ((my  $v) = pop(@{$num_stack}));
    if (((ref($v) eq 'ARRAY'))) {
        if ((($v->[1] eq 'methcall_no_params'))) {
            ($v = Call->new(('invocant' => undef()), ('method' => $v->[2]), ('arguments' => (do {
    (my  @a);
    (my  @v);
    \@a
}))));
            return ($v)
        };
        if ((($v->[1] eq 'funcall_no_params'))) {
            ($v = Apply->new(('code' => $v->[3]), ('namespace' => $v->[2])));
            return ($v)
        };
        if ((($v->[1] eq 'methcall'))) {
            if (($v->[3])->{'end_block'}) {
                unshift(@{$num_stack}, ($v->[3])->{'end_block'})
            };
            ((my  $param_list) = expand_list(($v->[3])->{'exp'}));
            ($v = Call->new(('invocant' => undef()), ('method' => $v->[2]), ('arguments' => $param_list)));
            return ($v)
        };
        if ((($v->[1] eq 'funcall'))) {
            if (($v->[4])->{'end_block'}) {
                unshift(@{$num_stack}, ($v->[4])->{'end_block'})
            };
            ((my  $param_list) = expand_list(($v->[4])->{'exp'}));
            ($v = Apply->new(('code' => $v->[3]), ('arguments' => $param_list), ('namespace' => $v->[2])));
            return ($v)
        };
        if ((($v->[1] eq '( )'))) {
            ((my  $param_list) = expand_list($v->[2]));
            ($v = Apply->new(('code' => 'circumfix:<( )>'), ('arguments' => $param_list), ('namespace' => '')));
            return ($v)
        };
        if ((($v->[1] eq '[ ]'))) {
            ((my  $param_list) = expand_list($v->[2]));
            ($v = Lit::Array->new(('array1' => $param_list)));
            return ($v)
        };
        if ((($v->[1] eq 'block'))) {
            ($v = Lit::Block->new(('stmts' => $v->[2]), ('sig' => $v->[3])));
            ($v = block_or_hash($v));
            return ($v)
        };
        if ((($v->[1] eq '.( )'))) {
            ($v = Call->new(('invocant' => undef()), ('method' => 'postcircumfix:<( )>'), ('arguments' => $v->[2])));
            return ($v)
        };
        if ((($v->[1] eq '.[ ]'))) {
            ($v = Index->new(('obj' => undef()), ('index_exp' => $v->[2])));
            return ($v)
        };
        if ((($v->[1] eq '.' . chr(123) . ' ' . chr(125)))) {
            ($v = Lookup->new(('obj' => undef()), ('index_exp' => $v->[2])));
            return ($v)
        };
        if ((((ref($v->[1]) eq 'ARRAY') && (scalar($v->[1]) == 2)))) {
            ($v = Apply->new(('code' => 'pair'), ('arguments' => $v->[1]), ('namespace' => '')));
            return ($v)
        };
        return ($v->[1])
    };
    return ($v)
};
sub reduce_postfix {
    ((my  $op) = shift());
    ((my  $value) = shift());
    ((my  $v) = $op);
    if ((($v->[1] eq 'methcall_no_params'))) {
        ($v = Call->new(('invocant' => $value), ('method' => $v->[2]), ('arguments' => (do {
    (my  @a);
    (my  @v);
    \@a
}))));
        return ($v)
    };
    if ((($v->[1] eq 'funcall_no_params'))) {
        die(('unexpected function call'));
        push(@{$v}, $value );
        return ($v)
    };
    if ((($v->[1] eq 'methcall'))) {
        ((my  $param_list) = expand_list($v->[3]->{'exp'}));
        ($v = Call->new(('invocant' => $value), ('method' => $v->[2]), ('arguments' => $param_list)));
        return ($v)
    };
    if ((($v->[1] eq 'funcall'))) {
        die(('unexpected function call'));
        push(@{$v}, $value );
        return ($v)
    };
    if ((($v->[1] eq '( )'))) {
        ((my  $param_list) = expand_list($v->[2]));
        if ((((ref($value) eq 'Apply') && !((defined($value->arguments())))))) {
            ($value->{'arguments'} = $param_list);
            return ($value)
        };
        if ((((ref($value) eq 'Call') && !((defined($value->arguments())))))) {
            ($value->{'arguments'} = $param_list);
            return ($value)
        };
        ($v = Call->new(('invocant' => $value), ('method' => 'postcircumfix:<( )>'), ('arguments' => $param_list)));
        return ($v)
    };
    if ((($v->[1] eq '[ ]'))) {
        ($v = Index->new(('obj' => $value), ('index_exp' => $v->[2])));
        return ($v)
    };
    if ((($v->[1] eq 'block'))) {
        ($v = Lookup->new(('obj' => $value), ('index_exp' => ($v->[2])->[0])));
        return ($v)
    };
    if ((($v->[1] eq '.( )'))) {
        ((my  $param_list) = expand_list($v->[2]));
        ($v = Call->new(('invocant' => $value), ('method' => 'postcircumfix:<( )>'), ('arguments' => $param_list)));
        return ($v)
    };
    if ((($v->[1] eq '.[ ]'))) {
        ($v = Call->new(('invocant' => $value), ('method' => 'postcircumfix:<[ ]>'), ('arguments' => $v->[2])));
        return ($v)
    };
    if ((($v->[1] eq '.' . chr(123) . ' ' . chr(125)))) {
        ($v = Call->new(('invocant' => $value), ('method' => 'postcircumfix:<' . chr(123) . ' ' . chr(125) . '>'), ('arguments' => $v->[2])));
        return ($v)
    };
    push(@{$op}, $value );
    return ($op)
};
((my  $reduce_to_ast) = sub  {
    ((my  $op_stack) = shift());
    ((my  $num_stack) = shift());
    ((my  $last_op) = shift(@{$op_stack}));
    if ((($last_op->[0] eq 'prefix'))) {
        push(@{$num_stack}, Apply->new(('namespace' => ''), ('code' => ('prefix:<' . $last_op->[1] . '>')), ('arguments' => (do {
    (my  @a);
    (my  @v);
    push(@a, pop_term($num_stack) );
    \@a
}))) )
    }
    else {
        if ((($last_op->[0] eq 'postfix'))) {
            push(@{$num_stack}, Apply->new(('namespace' => ''), ('code' => ('postfix:<' . $last_op->[1] . '>')), ('arguments' => (do {
    (my  @a);
    (my  @v);
    push(@a, pop_term($num_stack) );
    \@a
}))) )
        }
        else {
            if ((($last_op->[0] eq 'postfix_or_term'))) {
                push(@{$num_stack}, reduce_postfix($last_op, pop_term($num_stack)) )
            }
            else {
                if ((Perlito5::Precedence::is_assoc_type('list', $last_op->[1]))) {
                    (my  $arg);
                    if (((scalar(@{$num_stack}) < 2))) {
                        ((my  $v2) = pop_term($num_stack));
                        if ((((ref($v2) eq 'Apply') && ($v2->code() eq (('list:<' . $last_op->[1] . '>')))))) {
                            push(@{$num_stack}, Apply->new(('namespace' => $v2->namespace()), ('code' => $v2->code()), ('arguments' => (do {
    (my  @a);
    (my  @v);
    (@v = @{$v2->arguments()});
    for my $x ((0 .. ((scalar(@v) - 1)))) {
        push(@a, $v[$x] )
    };
    push(@a, undef() );
    \@a
}))) )
                        }
                        else {
                            push(@{$num_stack}, Apply->new(('namespace' => ''), ('code' => ('list:<' . $last_op->[1] . '>')), ('arguments' => (do {
    (my  @a);
    (my  @v);
    push(@a, $v2 );
    push(@a, undef() );
    \@a
}))) )
                        };
                        return ()
                    }
                    else {
                        ((my  $v2) = pop_term($num_stack));
                        ($arg = (do {
    (my  @a);
    (my  @v);
    push(@a, pop_term($num_stack) );
    push(@a, $v2 );
    \@a
}))
                    };
                    if (((((ref($arg->[0]) eq 'Apply') && ($last_op->[0] eq 'infix')) && (($arg->[0]->code() eq ('list:<' . $last_op->[1] . '>')))))) {
                        push(@{$num_stack}, Apply->new(('namespace' => ''), ('code' => ($arg->[0])->code()), ('arguments' => (do {
    (my  @a);
    (my  @v);
    (@v = @{($arg->[0])->arguments()});
    for my $x ((0 .. ((scalar(@v) - 1)))) {
        push(@a, $v[$x] )
    };
    push(@a, $arg->[1] );
    \@a
}))) );
                        return ()
                    };
                    push(@{$num_stack}, Apply->new(('namespace' => ''), ('code' => ('list:<' . $last_op->[1] . '>')), ('arguments' => $arg)) )
                }
                else {
                    if ((Perlito5::Precedence::is_assoc_type('chain', $last_op->[1]))) {
                        if (((scalar(@{$num_stack}) < 2))) {
                            die(('Missing value after operator ' . $last_op->[1]))
                        };
                        ((my  $v2) = pop_term($num_stack));
                        ((my  $arg) = (do {
    (my  @a);
    (my  @v);
    push(@a, pop_term($num_stack) );
    push(@a, $v2 );
    \@a
}));
                        push(@{$num_stack}, Apply->new(('namespace' => ''), ('code' => ('infix:<' . $last_op->[1] . '>')), ('arguments' => $arg)) )
                    }
                    else {
                        if ((($last_op->[0] eq 'ternary'))) {
                            if (((scalar(@{$num_stack}) < 2))) {
                                die(('Missing value after ternary operator'))
                            };
                            ((my  $v2) = pop_term($num_stack));
                            push(@{$num_stack}, Apply->new(('namespace' => ''), ('code' => ('ternary:<' . $last_op->[1] . '>')), ('arguments' => (do {
    (my  @a);
    (my  @v);
    push(@a, pop_term($num_stack) );
    push(@a, $last_op->[2] );
    push(@a, $v2 );
    \@a
}))) )
                        }
                        else {
                            if (((scalar(@{$num_stack}) < 2))) {
                                die(('missing value after operator ' . chr(39) . $last_op->[1] . (chr(39))))
                            };
                            ((my  $v2) = pop_term($num_stack));
                            push(@{$num_stack}, Apply->new(('namespace' => ''), ('code' => ('infix:<' . $last_op->[1] . '>')), ('arguments' => (do {
    (my  @a);
    (my  @v);
    push(@a, pop_term($num_stack) );
    push(@a, $v2 );
    \@a
}))) )
                        }
                    }
                }
            }
        }
    }
});
sub operator {
    ((my  $grammar) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    ((my  $MATCH) = Perlito5::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1)));
    ($MATCH->{('bool')} = (((do {
    ((my  $pos1) = $MATCH->to());
    ((((((((((((((((((((do {
    ((((((do {
    ((my  $m2) = Perlito5::Grammar->var_sigil($str, $MATCH->to()));
    if (($m2->bool())) {
        ($MATCH->{('to')} = $m2->to());
        ($MATCH->{'Perlito5::Grammar.var_sigil'} = $m2);
        1
    }
    else {
        0
    }
})) && (((chr(123) eq substr($str, $MATCH->to(), 1)) && (($MATCH->{('to')} = (1 + $MATCH->to())))))) && ((do {
    ((my  $m2) = $grammar->curly_parse($str, $MATCH->to()));
    if (($m2->bool())) {
        ($MATCH->{('to')} = $m2->to());
        ($MATCH->{'curly_parse'} = $m2);
        1
    }
    else {
        0
    }
}))) && (((chr(125) eq substr($str, $MATCH->to(), 1)) && (($MATCH->{('to')} = (1 + $MATCH->to())))))) && ((do {
    ($MATCH->{('capture')} = (do {
    (my  @a);
    (my  @v);
    push(@a, 'term' );
    push(@a, Apply->new(('arguments' => (do {
    (my  @a);
    (my  @v);
    push(@a, $MATCH->{('curly_parse')}->flat() );
    \@a
})), ('code' => ('prefix:<' . $MATCH->{('Perlito5::Grammar.var_sigil')}->flat() . '>')), ('namespace' => '')) );
    \@a
}));
    1
})))
})) || ((do {
    ($MATCH->{('to')} = $pos1);
    ((((('->' eq substr($str, $MATCH->to(), 2)) && (($MATCH->{('to')} = (2 + $MATCH->to()))))) && ((do {
    ((my  $pos1) = $MATCH->to());
    ((((do {
    (((((('(' eq substr($str, $MATCH->to(), 1)) && (($MATCH->{('to')} = (1 + $MATCH->to()))))) && ((do {
    ((my  $m2) = $grammar->paren_parse($str, $MATCH->to()));
    if (($m2->bool())) {
        ($MATCH->{('to')} = $m2->to());
        ($MATCH->{'paren_parse'} = $m2);
        1
    }
    else {
        0
    }
}))) && (((')' eq substr($str, $MATCH->to(), 1)) && (($MATCH->{('to')} = (1 + $MATCH->to())))))) && ((do {
    ($MATCH->{('capture')} = (do {
    (my  @a);
    (my  @v);
    push(@a, 'postfix_or_term' );
    push(@a, '.( )' );
    push(@a, $MATCH->{('paren_parse')}->flat() );
    \@a
}));
    1
})))
})) || ((do {
    ($MATCH->{('to')} = $pos1);
    ((((((('[' eq substr($str, $MATCH->to(), 1)) && (($MATCH->{('to')} = (1 + $MATCH->to()))))) && ((do {
    ((my  $m2) = $grammar->square_parse($str, $MATCH->to()));
    if (($m2->bool())) {
        ($MATCH->{('to')} = $m2->to());
        ($MATCH->{'square_parse'} = $m2);
        1
    }
    else {
        0
    }
}))) && (((']' eq substr($str, $MATCH->to(), 1)) && (($MATCH->{('to')} = (1 + $MATCH->to())))))) && ((do {
    ($MATCH->{('capture')} = (do {
    (my  @a);
    (my  @v);
    push(@a, 'postfix_or_term' );
    push(@a, '.[ ]' );
    push(@a, $MATCH->{('square_parse')}->flat() );
    \@a
}));
    1
}))))
}))) || ((do {
    ($MATCH->{('to')} = $pos1);
    (((((((chr(123) eq substr($str, $MATCH->to(), 1)) && (($MATCH->{('to')} = (1 + $MATCH->to()))))) && ((do {
    ((my  $m2) = $grammar->curly_parse($str, $MATCH->to()));
    if (($m2->bool())) {
        ($MATCH->{('to')} = $m2->to());
        ($MATCH->{'curly_parse'} = $m2);
        1
    }
    else {
        0
    }
}))) && (((chr(125) eq substr($str, $MATCH->to(), 1)) && (($MATCH->{('to')} = (1 + $MATCH->to())))))) && ((do {
    ($MATCH->{('capture')} = (do {
    (my  @a);
    (my  @v);
    push(@a, 'postfix_or_term' );
    push(@a, '.' . chr(123) . ' ' . chr(125) );
    push(@a, $MATCH->{('curly_parse')}->flat() );
    \@a
}));
    1
}))))
})))
}))))
}))) || ((do {
    ($MATCH->{('to')} = $pos1);
    ((((((('(' eq substr($str, $MATCH->to(), 1)) && (($MATCH->{('to')} = (1 + $MATCH->to()))))) && ((do {
    ((my  $m2) = $grammar->paren_parse($str, $MATCH->to()));
    if (($m2->bool())) {
        ($MATCH->{('to')} = $m2->to());
        ($MATCH->{'paren_parse'} = $m2);
        1
    }
    else {
        0
    }
}))) && (((')' eq substr($str, $MATCH->to(), 1)) && (($MATCH->{('to')} = (1 + $MATCH->to())))))) && ((do {
    ($MATCH->{('capture')} = (do {
    (my  @a);
    (my  @v);
    push(@a, 'postfix_or_term' );
    push(@a, '( )' );
    push(@a, $MATCH->{('paren_parse')}->flat() );
    \@a
}));
    1
}))))
}))) || ((do {
    ($MATCH->{('to')} = $pos1);
    ((((((('[' eq substr($str, $MATCH->to(), 1)) && (($MATCH->{('to')} = (1 + $MATCH->to()))))) && ((do {
    ((my  $m2) = $grammar->square_parse($str, $MATCH->to()));
    if (($m2->bool())) {
        ($MATCH->{('to')} = $m2->to());
        ($MATCH->{'square_parse'} = $m2);
        1
    }
    else {
        0
    }
}))) && (((']' eq substr($str, $MATCH->to(), 1)) && (($MATCH->{('to')} = (1 + $MATCH->to())))))) && ((do {
    ($MATCH->{('capture')} = (do {
    (my  @a);
    (my  @v);
    push(@a, 'postfix_or_term' );
    push(@a, '[ ]' );
    push(@a, $MATCH->{('square_parse')}->flat() );
    \@a
}));
    1
}))))
}))) || ((do {
    ($MATCH->{('to')} = $pos1);
    (((((((((chr(123) eq substr($str, $MATCH->to(), 1)) && (($MATCH->{('to')} = (1 + $MATCH->to()))))) && ((do {
    ((my  $last_pos) = $MATCH->to());
    if ((!(((do {
    ((my  $m2) = Perlito5::Grammar->ws($str, $MATCH->to()));
    if (($m2->bool())) {
        ($MATCH->{('to')} = $m2->to());
        1
    }
    else {
        0
    }
}))))) {
        ($MATCH->{('to')} = $last_pos)
    };
    1
}))) && ((do {
    ((my  $m2) = Perlito5::Grammar->exp_stmts($str, $MATCH->to()));
    if (($m2->bool())) {
        ($MATCH->{('to')} = $m2->to());
        ($MATCH->{'Perlito5::Grammar.exp_stmts'} = $m2);
        1
    }
    else {
        0
    }
}))) && ((do {
    ((my  $last_pos) = $MATCH->to());
    if ((!(((do {
    ((my  $m2) = Perlito5::Grammar->ws($str, $MATCH->to()));
    if (($m2->bool())) {
        ($MATCH->{('to')} = $m2->to());
        1
    }
    else {
        0
    }
}))))) {
        ($MATCH->{('to')} = $last_pos)
    };
    1
}))) && (((chr(125) eq substr($str, $MATCH->to(), 1)) && (($MATCH->{('to')} = (1 + $MATCH->to())))))) && ((do {
    ($MATCH->{('capture')} = (do {
    (my  @a);
    (my  @v);
    push(@a, 'postfix_or_term' );
    push(@a, 'block' );
    push(@a, $MATCH->{('Perlito5::Grammar.exp_stmts')}->flat() );
    \@a
}));
    1
}))))
}))) || ((do {
    ($MATCH->{('to')} = $pos1);
    ((((((('sub' eq substr($str, $MATCH->to(), 3)) && (($MATCH->{('to')} = (3 + $MATCH->to()))))) && ((do {
    ((my  $m2) = Perlito5::Grammar->ws($str, $MATCH->to()));
    if (($m2->bool())) {
        ($MATCH->{('to')} = $m2->to());
        1
    }
    else {
        0
    }
}))) && ((do {
    ((my  $m2) = Perlito5::Grammar->sub_def($str, $MATCH->to()));
    if (($m2->bool())) {
        ($MATCH->{('to')} = $m2->to());
        ($MATCH->{'Perlito5::Grammar.sub_def'} = $m2);
        1
    }
    else {
        0
    }
}))) && ((do {
    ($MATCH->{('capture')} = (do {
    (my  @a);
    (my  @v);
    push(@a, 'term' );
    push(@a, $MATCH->{('Perlito5::Grammar.sub_def')}->flat() );
    \@a
}));
    1
}))))
}))) || ((do {
    ($MATCH->{('to')} = $pos1);
    ((((((('token' eq substr($str, $MATCH->to(), 5)) && (($MATCH->{('to')} = (5 + $MATCH->to()))))) && ((do {
    ((my  $m2) = Perlito5::Grammar->ws($str, $MATCH->to()));
    if (($m2->bool())) {
        ($MATCH->{('to')} = $m2->to());
        1
    }
    else {
        0
    }
}))) && ((do {
    ((my  $m2) = Perlito5::Grammar->token($str, $MATCH->to()));
    if (($m2->bool())) {
        ($MATCH->{('to')} = $m2->to());
        ($MATCH->{'Perlito5::Grammar.token'} = $m2);
        1
    }
    else {
        0
    }
}))) && ((do {
    ($MATCH->{('capture')} = (do {
    (my  @a);
    (my  @v);
    push(@a, 'term' );
    push(@a, $MATCH->{('Perlito5::Grammar.token')}->flat() );
    \@a
}));
    1
}))))
}))) || ((do {
    ($MATCH->{('to')} = $pos1);
    ((((((('do' eq substr($str, $MATCH->to(), 2)) && (($MATCH->{('to')} = (2 + $MATCH->to()))))) && ((do {
    ((my  $m2) = Perlito5::Grammar->ws($str, $MATCH->to()));
    if (($m2->bool())) {
        ($MATCH->{('to')} = $m2->to());
        1
    }
    else {
        0
    }
}))) && ((do {
    ((my  $m2) = $grammar->statement_parse($str, $MATCH->to()));
    if (($m2->bool())) {
        ($MATCH->{('to')} = $m2->to());
        ($MATCH->{'statement_parse'} = $m2);
        1
    }
    else {
        0
    }
}))) && ((do {
    ($MATCH->{('capture')} = (do {
    (my  @a);
    (my  @v);
    push(@a, 'term' );
    push(@a, Do->new(('block' => $MATCH->{('statement_parse')}->flat())) );
    \@a
}));
    1
}))))
}))) || ((do {
    ($MATCH->{('to')} = $pos1);
    (((((((chr(63) eq substr($str, $MATCH->to(), 1)) && (($MATCH->{('to')} = (1 + $MATCH->to()))))) && ((do {
    ((my  $m2) = $grammar->ternary5_parse($str, $MATCH->to()));
    if (($m2->bool())) {
        ($MATCH->{('to')} = $m2->to());
        ($MATCH->{'ternary5_parse'} = $m2);
        1
    }
    else {
        0
    }
}))) && (((':' eq substr($str, $MATCH->to(), 1)) && (($MATCH->{('to')} = (1 + $MATCH->to())))))) && ((do {
    ($MATCH->{('capture')} = (do {
    (my  @a);
    (my  @v);
    push(@a, 'op' );
    push(@a, chr(63) . chr(63) . ' ' . chr(33) . chr(33) );
    push(@a, $MATCH->{('ternary5_parse')}->flat() );
    \@a
}));
    1
}))))
}))) || ((do {
    ($MATCH->{('to')} = $pos1);
    ((((do {
    ((my  $m2) = Perlito5::Grammar->var_ident($str, $MATCH->to()));
    if (($m2->bool())) {
        ($MATCH->{('to')} = $m2->to());
        ($MATCH->{'Perlito5::Grammar.var_ident'} = $m2);
        1
    }
    else {
        0
    }
})) && ((do {
    ($MATCH->{('capture')} = (do {
    (my  @a);
    (my  @v);
    push(@a, 'term' );
    push(@a, $MATCH->{('Perlito5::Grammar.var_ident')}->flat() );
    \@a
}));
    1
}))))
}))) || ((do {
    ($MATCH->{('to')} = $pos1);
    ((((do {
    ((my  $m2) = Perlito5::Precedence->op_parse($str, $MATCH->to()));
    if (($m2->bool())) {
        ($MATCH->{('to')} = $m2->to());
        ($MATCH->{'Perlito5::Precedence.op_parse'} = $m2);
        1
    }
    else {
        0
    }
})) && ((do {
    ($MATCH->{('capture')} = $MATCH->{('Perlito5::Precedence.op_parse')}->flat());
    1
}))))
}))) || ((do {
    ($MATCH->{('to')} = $pos1);
    ((((((((('use' eq substr($str, $MATCH->to(), 3)) && (($MATCH->{('to')} = (3 + $MATCH->to()))))) && ((do {
    ((my  $m2) = Perlito5::Grammar->ws($str, $MATCH->to()));
    if (($m2->bool())) {
        ($MATCH->{('to')} = $m2->to());
        1
    }
    else {
        0
    }
}))) && ((do {
    ((my  $m2) = Perlito5::Grammar->full_ident($str, $MATCH->to()));
    if (($m2->bool())) {
        ($MATCH->{('to')} = $m2->to());
        ($MATCH->{'Perlito5::Grammar.full_ident'} = $m2);
        1
    }
    else {
        0
    }
}))) && ((do {
    ((my  $last_pos) = $MATCH->to());
    if ((!(((do {
    ((my  $pos1) = $MATCH->to());
    ((do {
    (((('-' eq substr($str, $MATCH->to(), 1)) && (($MATCH->{('to')} = (1 + $MATCH->to()))))) && ((do {
    ((my  $m2) = Perlito5::Grammar->ident($str, $MATCH->to()));
    if (($m2->bool())) {
        ($MATCH->{('to')} = $m2->to());
        if ((exists($MATCH->{'Perlito5::Grammar.ident'}))) {
            push(@{$MATCH->{'Perlito5::Grammar.ident'}}, $m2 )
        }
        else {
            ($MATCH->{'Perlito5::Grammar.ident'} = (do {
    (my  @a);
    (my  @v);
    push(@a, $m2 );
    \@a
}))
        };
        1
    }
    else {
        0
    }
})))
}))
}))))) {
        ($MATCH->{('to')} = $last_pos)
    };
    1
}))) && ((do {
    ((my  $m2) = $grammar->list_parse($str, $MATCH->to()));
    if (($m2->bool())) {
        ($MATCH->{('to')} = $m2->to());
        ($MATCH->{'list_parse'} = $m2);
        1
    }
    else {
        0
    }
}))) && ((do {
    ($MATCH->{('capture')} = (do {
    (my  @a);
    (my  @v);
    push(@a, 'term' );
    push(@a, Use->new(('mod' => $MATCH->{('Perlito5::Grammar.full_ident')}->flat())) );
    \@a
}));
    1
}))))
}))) || ((do {
    ($MATCH->{('to')} = $pos1);
    ((((((('package' eq substr($str, $MATCH->to(), 7)) && (($MATCH->{('to')} = (7 + $MATCH->to()))))) && ((do {
    ((my  $m2) = Perlito5::Grammar->ws($str, $MATCH->to()));
    if (($m2->bool())) {
        ($MATCH->{('to')} = $m2->to());
        1
    }
    else {
        0
    }
}))) && ((do {
    ((my  $m2) = Perlito5::Grammar->full_ident($str, $MATCH->to()));
    if (($m2->bool())) {
        ($MATCH->{('to')} = $m2->to());
        ($MATCH->{'Perlito5::Grammar.full_ident'} = $m2);
        1
    }
    else {
        0
    }
}))) && ((do {
    ($MATCH->{('capture')} = (do {
    (my  @a);
    (my  @v);
    push(@a, 'term' );
    push(@a, Apply->new(('code' => 'package'), ('arguments' => (do {
    (my  @a);
    (my  @v);
    \@a
})), ('namespace' => $MATCH->{('Perlito5::Grammar.full_ident')}->flat())) );
    \@a
}));
    1
}))))
}))) || ((do {
    ($MATCH->{('to')} = $pos1);
    ((((((((do {
    ((my  $m2) = Perlito5::Grammar->declarator($str, $MATCH->to()));
    if (($m2->bool())) {
        ($MATCH->{('to')} = $m2->to());
        ($MATCH->{'Perlito5::Grammar.declarator'} = $m2);
        1
    }
    else {
        0
    }
})) && ((do {
    ((my  $m2) = Perlito5::Grammar->ws($str, $MATCH->to()));
    if (($m2->bool())) {
        ($MATCH->{('to')} = $m2->to());
        1
    }
    else {
        0
    }
}))) && ((do {
    ((my  $m2) = Perlito5::Grammar->opt_type($str, $MATCH->to()));
    if (($m2->bool())) {
        ($MATCH->{('to')} = $m2->to());
        ($MATCH->{'Perlito5::Grammar.opt_type'} = $m2);
        1
    }
    else {
        0
    }
}))) && ((do {
    ((my  $m2) = Perlito5::Grammar->opt_ws($str, $MATCH->to()));
    if (($m2->bool())) {
        ($MATCH->{('to')} = $m2->to());
        1
    }
    else {
        0
    }
}))) && ((do {
    ((my  $m2) = Perlito5::Grammar->var_ident($str, $MATCH->to()));
    if (($m2->bool())) {
        ($MATCH->{('to')} = $m2->to());
        ($MATCH->{'Perlito5::Grammar.var_ident'} = $m2);
        1
    }
    else {
        0
    }
}))) && ((do {
    ($MATCH->{('capture')} = (do {
    (my  @a);
    (my  @v);
    push(@a, 'term' );
    push(@a, Decl->new(('decl' => $MATCH->{('Perlito5::Grammar.declarator')}->flat()), ('type' => $MATCH->{('Perlito5::Grammar.opt_type')}->flat()), ('var' => $MATCH->{('Perlito5::Grammar.var_ident')}->flat())) );
    \@a
}));
    1
}))))
}))) || ((do {
    ($MATCH->{('to')} = $pos1);
    (((((('->' eq substr($str, $MATCH->to(), 2)) && (($MATCH->{('to')} = (2 + $MATCH->to()))))) && ((do {
    ((my  $m2) = Perlito5::Grammar->ident($str, $MATCH->to()));
    if (($m2->bool())) {
        ($MATCH->{('to')} = $m2->to());
        ($MATCH->{'Perlito5::Grammar.ident'} = $m2);
        1
    }
    else {
        0
    }
}))) && ((do {
    ((my  $pos1) = $MATCH->to());
    ((((do {
    ((((((':' eq substr($str, $MATCH->to(), 1)) && (($MATCH->{('to')} = (1 + $MATCH->to()))))) && ((do {
    ((my  $last_pos) = $MATCH->to());
    if ((!(((do {
    ((my  $m2) = Perlito5::Grammar->ws($str, $MATCH->to()));
    if (($m2->bool())) {
        ($MATCH->{('to')} = $m2->to());
        1
    }
    else {
        0
    }
}))))) {
        ($MATCH->{('to')} = $last_pos)
    };
    1
}))) && ((do {
    ((my  $m2) = $grammar->list_parse($str, $MATCH->to()));
    if (($m2->bool())) {
        ($MATCH->{('to')} = $m2->to());
        ($MATCH->{'list_parse'} = $m2);
        1
    }
    else {
        0
    }
}))) && ((do {
    ($MATCH->{('capture')} = (do {
    (my  @a);
    (my  @v);
    push(@a, 'postfix_or_term' );
    push(@a, 'methcall' );
    push(@a, $MATCH->{('Perlito5::Grammar.ident')}->flat() );
    push(@a, $MATCH->{('list_parse')}->flat() );
    \@a
}));
    1
})))
})) || ((do {
    ($MATCH->{('to')} = $pos1);
    ((((((('(' eq substr($str, $MATCH->to(), 1)) && (($MATCH->{('to')} = (1 + $MATCH->to()))))) && ((do {
    ((my  $m2) = $grammar->paren_parse($str, $MATCH->to()));
    if (($m2->bool())) {
        ($MATCH->{('to')} = $m2->to());
        ($MATCH->{'paren_parse'} = $m2);
        1
    }
    else {
        0
    }
}))) && (((')' eq substr($str, $MATCH->to(), 1)) && (($MATCH->{('to')} = (1 + $MATCH->to())))))) && ((do {
    ($MATCH->{('capture')} = (do {
    (my  @a);
    (my  @v);
    push(@a, 'postfix_or_term' );
    push(@a, 'methcall' );
    push(@a, $MATCH->{('Perlito5::Grammar.ident')}->flat() );
    push(@a, (do {
    (my  %a);
    ($a{'end_block'} = undef());
    ($a{'exp'} = $MATCH->{('paren_parse')}->flat());
    ($a{'terminated'} = 0);
    \%a
}) );
    \@a
}));
    1
}))))
}))) || ((do {
    ($MATCH->{('to')} = $pos1);
    (((do {
    ($MATCH->{('capture')} = (do {
    (my  @a);
    (my  @v);
    push(@a, 'postfix_or_term' );
    push(@a, 'methcall_no_params' );
    push(@a, $MATCH->{('Perlito5::Grammar.ident')}->flat() );
    \@a
}));
    1
})))
})))
}))))
}))) || ((do {
    ($MATCH->{('to')} = $pos1);
    ((((do {
    ((my  $tmp) = $MATCH);
    ($MATCH = Perlito5::Match->new(('str' => $str), ('from' => $tmp->to()), ('to' => $tmp->to()), ('bool' => 1)));
    ($MATCH->{('bool')} = ((do {
    ((my  $pos1) = $MATCH->to());
    ((do {
    ((my  $m2) = Perlito5::Grammar->digit($str, $MATCH->to()));
    if (($m2->bool())) {
        ($MATCH->{('to')} = $m2->to());
        1
    }
    else {
        0
    }
}))
})));
    ($tmp->{('bool')} = ($MATCH->bool() ? 1 : 0));
    ($MATCH = $tmp);
    ($MATCH->bool() ? 1 : 0)
})) && ((do {
    ((my  $pos1) = $MATCH->to());
    (((do {
    (((do {
    ((my  $m2) = Perlito5::Grammar->val_num($str, $MATCH->to()));
    if (($m2->bool())) {
        ($MATCH->{('to')} = $m2->to());
        ($MATCH->{'Perlito5::Grammar.val_num'} = $m2);
        1
    }
    else {
        0
    }
})) && ((do {
    ($MATCH->{('capture')} = (do {
    (my  @a);
    (my  @v);
    push(@a, 'term' );
    push(@a, $MATCH->{('Perlito5::Grammar.val_num')}->flat() );
    \@a
}));
    1
})))
})) || ((do {
    ($MATCH->{('to')} = $pos1);
    ((((do {
    ((my  $m2) = Perlito5::Grammar->val_int($str, $MATCH->to()));
    if (($m2->bool())) {
        ($MATCH->{('to')} = $m2->to());
        ($MATCH->{'Perlito5::Grammar.val_int'} = $m2);
        1
    }
    else {
        0
    }
})) && ((do {
    ($MATCH->{('capture')} = (do {
    (my  @a);
    (my  @v);
    push(@a, 'term' );
    push(@a, $MATCH->{('Perlito5::Grammar.val_int')}->flat() );
    \@a
}));
    1
}))))
})))
}))))
}))) || ((do {
    ($MATCH->{('to')} = $pos1);
    ((((((do {
    ((my  $tmp) = $MATCH);
    ($MATCH = Perlito5::Match->new(('str' => $str), ('from' => $tmp->to()), ('to' => $tmp->to()), ('bool' => 1)));
    ($MATCH->{('bool')} = ((do {
    ((my  $pos1) = $MATCH->to());
    ((do {
    ((my  $m2) = Perlito5::Grammar->word($str, $MATCH->to()));
    if (($m2->bool())) {
        ($MATCH->{('to')} = $m2->to());
        1
    }
    else {
        0
    }
}))
})));
    ($tmp->{('bool')} = ($MATCH->bool() ? 1 : 0));
    ($MATCH = $tmp);
    ($MATCH->bool() ? 1 : 0)
})) && ((do {
    ((my  $m2) = Perlito5::Grammar->optional_namespace_before_ident($str, $MATCH->to()));
    if (($m2->bool())) {
        ($MATCH->{('to')} = $m2->to());
        ($MATCH->{'Perlito5::Grammar.optional_namespace_before_ident'} = $m2);
        1
    }
    else {
        0
    }
}))) && ((do {
    ((my  $m2) = Perlito5::Grammar->ident($str, $MATCH->to()));
    if (($m2->bool())) {
        ($MATCH->{('to')} = $m2->to());
        ($MATCH->{'Perlito5::Grammar.ident'} = $m2);
        1
    }
    else {
        0
    }
}))) && ((do {
    ((my  $pos1) = $MATCH->to());
    (((((do {
    (((do {
    ((my  $tmp) = $MATCH);
    ($MATCH = Perlito5::Match->new(('str' => $str), ('from' => $tmp->to()), ('to' => $tmp->to()), ('bool' => 1)));
    ($MATCH->{('bool')} = ((do {
    ((my  $pos1) = $MATCH->to());
    ((do {
    (((do {
    ((my  $last_pos) = $MATCH->to());
    if ((!(((do {
    ((my  $m2) = Perlito5::Grammar->ws($str, $MATCH->to()));
    if (($m2->bool())) {
        ($MATCH->{('to')} = $m2->to());
        1
    }
    else {
        0
    }
}))))) {
        ($MATCH->{('to')} = $last_pos)
    };
    1
})) && (((chr(61) . '>' eq substr($str, $MATCH->to(), 2)) && (($MATCH->{('to')} = (2 + $MATCH->to()))))))
}))
})));
    ($tmp->{('bool')} = ($MATCH->bool() ? 1 : 0));
    ($MATCH = $tmp);
    ($MATCH->bool() ? 1 : 0)
})) && ((do {
    ((my  $namespace) = $MATCH->{('Perlito5::Grammar.optional_namespace_before_ident')}->flat());
    ((my  $name) = $MATCH->{('Perlito5::Grammar.ident')}->flat());
    if (($namespace)) {
        ($name = ($namespace . '::' . $name))
    };
    ($MATCH->{('capture')} = (do {
    (my  @a);
    (my  @v);
    push(@a, 'term' );
    push(@a, Val::Buf->new(('buf' => $name)) );
    \@a
}));
    1
})))
})) || ((do {
    ($MATCH->{('to')} = $pos1);
    (((((do {
    ((my  $m2) = Perlito5::Grammar->ws($str, $MATCH->to()));
    if (($m2->bool())) {
        ($MATCH->{('to')} = $m2->to());
        1
    }
    else {
        0
    }
})) && ((do {
    ((my  $m2) = $grammar->list_parse($str, $MATCH->to()));
    if (($m2->bool())) {
        ($MATCH->{('to')} = $m2->to());
        ($MATCH->{'list_parse'} = $m2);
        1
    }
    else {
        0
    }
}))) && ((do {
    ($MATCH->{('capture')} = (do {
    (my  @a);
    (my  @v);
    push(@a, 'postfix_or_term' );
    push(@a, 'funcall' );
    push(@a, $MATCH->{('Perlito5::Grammar.optional_namespace_before_ident')}->flat() );
    push(@a, $MATCH->{('Perlito5::Grammar.ident')}->flat() );
    push(@a, $MATCH->{('list_parse')}->flat() );
    \@a
}));
    1
}))))
}))) || ((do {
    ($MATCH->{('to')} = $pos1);
    ((((do {
    ((my  $tmp) = $MATCH);
    ($MATCH = Perlito5::Match->new(('str' => $str), ('from' => $tmp->to()), ('to' => $tmp->to()), ('bool' => 1)));
    ($MATCH->{('bool')} = ((do {
    ((my  $pos1) = $MATCH->to());
    ((do {
    (('->' eq substr($str, $MATCH->to(), 2)) && (($MATCH->{('to')} = (2 + $MATCH->to()))))
}))
})));
    ($tmp->{('bool')} = ($MATCH->bool() ? 1 : 0));
    ($MATCH = $tmp);
    ($MATCH->bool() ? 1 : 0)
})) && ((do {
    ((my  $namespace) = $MATCH->{('Perlito5::Grammar.optional_namespace_before_ident')}->flat());
    ((my  $name) = $MATCH->{('Perlito5::Grammar.ident')}->flat());
    if (($namespace)) {
        ($name = ($namespace . '::' . $name))
    };
    ($MATCH->{('capture')} = (do {
    (my  @a);
    (my  @v);
    push(@a, 'term' );
    push(@a, Proto->new(('name' => $name)) );
    \@a
}));
    1
}))))
}))) || ((do {
    ($MATCH->{('to')} = $pos1);
    (((do {
    ($MATCH->{('capture')} = (do {
    (my  @a);
    (my  @v);
    push(@a, 'postfix_or_term' );
    push(@a, 'funcall_no_params' );
    push(@a, $MATCH->{('Perlito5::Grammar.optional_namespace_before_ident')}->flat() );
    push(@a, $MATCH->{('Perlito5::Grammar.ident')}->flat() );
    \@a
}));
    1
})))
})))
}))))
}))) || ((do {
    ($MATCH->{('to')} = $pos1);
    ((((do {
    ((my  $m2) = Perlito5::Grammar->val_buf($str, $MATCH->to()));
    if (($m2->bool())) {
        ($MATCH->{('to')} = $m2->to());
        ($MATCH->{'Perlito5::Grammar.val_buf'} = $m2);
        1
    }
    else {
        0
    }
})) && ((do {
    ($MATCH->{('capture')} = (do {
    (my  @a);
    (my  @v);
    push(@a, 'term' );
    push(@a, $MATCH->{('Perlito5::Grammar.val_buf')}->flat() );
    \@a
}));
    1
}))))
}))) || ((do {
    ($MATCH->{('to')} = $pos1);
    ((((do {
    ((my  $m2) = Perlito5::Grammar->ws($str, $MATCH->to()));
    if (($m2->bool())) {
        ($MATCH->{('to')} = $m2->to());
        1
    }
    else {
        0
    }
})) && ((do {
    ($MATCH->{('capture')} = (do {
    (my  @a);
    (my  @v);
    push(@a, 'space' );
    push(@a, ' ' );
    \@a
}));
    1
}))))
})))
}))));
    $MATCH
};
sub has_newline_after {
    ((my  $grammar) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    ((my  $MATCH) = Perlito5::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1)));
    ($MATCH->{('bool')} = (((do {
    ((my  $pos1) = $MATCH->to());
    ((((do {
    ((chr(35) eq substr($str, $MATCH->to(), 1)) && (($MATCH->{('to')} = (1 + $MATCH->to()))))
})) || ((do {
    ($MATCH->{('to')} = $pos1);
    (((do {
    ((my  $m2) = Perlito5::Grammar->is_newline($str, $MATCH->to()));
    if (($m2->bool())) {
        ($MATCH->{('to')} = $m2->to());
        1
    }
    else {
        0
    }
})))
}))) || ((do {
    ($MATCH->{('to')} = $pos1);
    ((((do {
    ((my  $m2) = Perlito5::Grammar->space($str, $MATCH->to()));
    if (($m2->bool())) {
        ($MATCH->{('to')} = $m2->to());
        1
    }
    else {
        0
    }
})) && ((do {
    ((my  $m2) = $grammar->has_newline_after($str, $MATCH->to()));
    if (($m2->bool())) {
        ($MATCH->{('to')} = $m2->to());
        1
    }
    else {
        0
    }
}))))
})))
}))));
    $MATCH
};
sub has_no_comma_or_colon_after {
    ((my  $grammar) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    ((my  $MATCH) = Perlito5::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1)));
    ($MATCH->{('bool')} = (((do {
    ((my  $pos1) = $MATCH->to());
    ((do {
    ((((do {
    ((my  $m2) = Perlito5::Grammar->ws($str, $MATCH->to()));
    if (($m2->bool())) {
        ($MATCH->{('to')} = $m2->to());
        1
    }
    else {
        0
    }
})) && ((do {
    ((my  $tmp) = $MATCH);
    ($MATCH = Perlito5::Match->new(('str' => $str), ('from' => $tmp->to()), ('to' => $tmp->to()), ('bool' => 1)));
    ($MATCH->{('bool')} = ((do {
    ((my  $pos1) = $MATCH->to());
    ((do {
    ((my  $pos1) = $MATCH->to());
    (((do {
    ((',' eq substr($str, $MATCH->to(), 1)) && (($MATCH->{('to')} = (1 + $MATCH->to()))))
})) || ((do {
    ($MATCH->{('to')} = $pos1);
    ((((':' eq substr($str, $MATCH->to(), 1)) && (($MATCH->{('to')} = (1 + $MATCH->to()))))))
})))
}))
})));
    ($tmp->{('bool')} = !($MATCH->bool()));
    ($MATCH = $tmp);
    ($MATCH->bool() ? 1 : 0)
}))) && ((('' ne substr($str, $MATCH->to(), 1)) && (($MATCH->{('to')} = (1 + $MATCH->to()))))))
}))
}))));
    $MATCH
};
sub list_parse {
    ((my  $self) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    (my  $expr);
    ((my  $last_pos) = $pos);
    ((my  $is_first_token) = 1);
    ((my  $lexer_stack) = (do {
    (my  @a);
    (my  @v);
    \@a
}));
    ((my  $terminated) = 0);
    ((my  $last_token_was_space) = 1);
    ((my  $get_token) = sub  {
    (my  $v);
    if ((scalar(@{$lexer_stack}))) {
        ($v = pop(@{$lexer_stack}));
        if (((($is_first_token && (($v->[0] eq 'op'))) && !((Perlito5::Precedence::is_fixity_type('prefix', $v->[1])))))) {
            ($v->[0] = 'end')
        }
    }
    else {
        ((my  $m) = $self->operator($str, $last_pos));
        if ((!($m->bool()))) {
            return ((do {
    (my  @a);
    (my  @v);
    push(@a, 'end' );
    push(@a, '*end*' );
    \@a
}))
        };
        ($v = $m->flat());
        if (((($is_first_token && (($v->[0] eq 'op'))) && !((Perlito5::Precedence::is_fixity_type('prefix', $v->[1])))))) {
            ($v->[0] = 'end')
        };
        if ((($v->[0] ne 'end'))) {
            ($last_pos = $m->to())
        }
    };
    if ((((($v->[0] eq 'postfix_or_term') && ($v->[1] eq 'block')) && $last_token_was_space))) {
        if (($self->has_newline_after($str, $last_pos)->bool())) {
            ($terminated = 1);
            push(@{$lexer_stack}, (do {
    (my  @a);
    (my  @v);
    push(@a, 'end' );
    push(@a, '*end*' );
    \@a
}) )
        }
        else {
            if (($self->has_no_comma_or_colon_after($str, $last_pos)->bool())) {
                ($terminated = 1);
                push(@{$lexer_stack}, (do {
    (my  @a);
    (my  @v);
    push(@a, 'end' );
    push(@a, '*end*' );
    \@a
}) )
            }
        }
    };
    ($last_token_was_space = (($v->[0] eq 'space')));
    ($is_first_token = 0);
    return ($v)
});
    ((my  $prec) = Perlito5::Precedence->new(('get_token' => $get_token), ('reduce' => $reduce_to_ast), ('end_token' => (do {
    (my  @a);
    (my  @v);
    push(@a, 'and' );
    push(@a, 'or' );
    push(@a, ':' );
    push(@a, ']' );
    push(@a, ')' );
    push(@a, chr(125) );
    push(@a, chr(59) );
    push(@a, 'if' );
    push(@a, 'else' );
    push(@a, 'elsif' );
    push(@a, 'unless' );
    push(@a, 'when' );
    push(@a, 'foreach' );
    push(@a, 'for' );
    push(@a, 'while' );
    \@a
}))));
    ((my  $res) = $prec->precedence_parse());
    if (((scalar(@{$res}) == 0))) {
        return (Perlito5::Match->new(('str' => $str), ('from' => $pos), ('to' => $last_pos), ('bool' => 1), ('capture' => (do {
    (my  %a);
    ($a{'exp'} = '*undef*');
    ($a{'end_block'} = undef());
    ($a{'terminated'} = undef());
    \%a
}))))
    };
    (my  $block);
    if (((scalar(@{$res}) > 1))) {
        ($block = pop(@{$res}));
        ($block = Lit::Block->new(('stmts' => $block->[2]), ('sig' => $block->[3])))
    };
    ((my  $result) = pop_term($res));
    if (((scalar(@{$res}) > 0))) {
        ($block = pop(@{$res}));
        ($block = Lit::Block->new(('stmts' => $block->[2]), ('sig' => $block->[3])))
    };
    return (Perlito5::Match->new(('str' => $str), ('from' => $pos), ('to' => $last_pos), ('bool' => 1), ('capture' => (do {
    (my  %a);
    ($a{'exp'} = $result);
    ($a{'end_block'} = $block);
    ($a{'terminated'} = $terminated);
    \%a
}))))
};
sub circumfix_parse {
    ((my  $self) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    ((my  $delimiter) = $_[3]);
    (my  $expr);
    ((my  $last_pos) = $pos);
    ((my  $get_token) = sub  {
    ((my  $m) = $self->operator($str, $last_pos));
    if ((!($m->bool()))) {
        die(('Expected closing delimiter: '), @{$delimiter}, ' near ', $last_pos)
    };
    ((my  $v) = $m->flat());
    if ((($v->[0] ne 'end'))) {
        ($last_pos = $m->to())
    };
    return ($v)
});
    ((my  $prec) = Perlito5::Precedence->new(('get_token' => $get_token), ('reduce' => $reduce_to_ast), ('end_token' => $delimiter)));
    ((my  $res) = $prec->precedence_parse());
    ($res = pop_term($res));
    if ((!((defined($res))))) {
        ($res = '*undef*')
    };
    return (Perlito5::Match->new(('str' => $str), ('from' => $pos), ('to' => $last_pos), ('bool' => 1), ('capture' => $res)))
};
sub ternary5_parse {
    ((my  $self) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    return ($self->circumfix_parse($str, $pos, (do {
    (my  @a);
    (my  @v);
    push(@a, ':' );
    \@a
})))
};
sub curly_parse {
    ((my  $self) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    return ($self->circumfix_parse($str, $pos, (do {
    (my  @a);
    (my  @v);
    push(@a, chr(125) );
    \@a
})))
};
sub square_parse {
    ((my  $self) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    return ($self->circumfix_parse($str, $pos, (do {
    (my  @a);
    (my  @v);
    push(@a, ']' );
    \@a
})))
};
sub paren_parse {
    ((my  $self) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    return ($self->circumfix_parse($str, $pos, (do {
    (my  @a);
    (my  @v);
    push(@a, ')' );
    \@a
})))
};
sub exp_parse {
    ((my  $self) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    (my  $expr);
    ((my  $last_pos) = $pos);
    ((my  $lexer_stack) = (do {
    (my  @a);
    (my  @v);
    \@a
}));
    ((my  $terminated) = 0);
    ((my  $get_token) = sub  {
    (my  $v);
    if ((scalar(@{$lexer_stack}))) {
        ($v = pop(@{$lexer_stack}))
    }
    else {
        ((my  $m) = $self->operator($str, $last_pos));
        if ((!($m->bool()))) {
            return ((do {
    (my  @a);
    (my  @v);
    push(@a, 'end' );
    push(@a, '*end*' );
    \@a
}))
        };
        ($v = $m->flat());
        if ((($v->[0] ne 'end'))) {
            ($last_pos = $m->to())
        }
    };
    if (((((((($v->[0] eq 'postfix_or_term') && ($v->[1] eq 'block'))) || ((($v->[0] eq 'term') && (ref($v->[1]) eq 'Sub')))) || ((($v->[0] eq 'term') && (ref($v->[1]) eq 'Do')))) || ((($v->[0] eq 'term') && (ref($v->[1]) eq 'CompUnit')))))) {
        if (($self->has_newline_after($str, $last_pos)->bool())) {
            ($terminated = 1);
            push(@{$lexer_stack}, (do {
    (my  @a);
    (my  @v);
    push(@a, 'end' );
    push(@a, '*end*' );
    \@a
}) )
        }
    };
    return ($v)
});
    ((my  $prec) = Perlito5::Precedence->new(('get_token' => $get_token), ('reduce' => $reduce_to_ast), ('end_token' => (do {
    (my  @a);
    (my  @v);
    push(@a, ']' );
    push(@a, ')' );
    push(@a, chr(125) );
    push(@a, chr(59) );
    push(@a, 'if' );
    push(@a, 'else' );
    push(@a, 'elsif' );
    push(@a, 'unless' );
    push(@a, 'when' );
    push(@a, 'foreach' );
    push(@a, 'for' );
    push(@a, 'while' );
    \@a
}))));
    ((my  $res) = $prec->precedence_parse());
    if (((scalar(@{$res}) == 0))) {
        return (Perlito5::Match->new(('bool' => 0)))
    };
    (my  $block);
    if (((scalar(@{$res}) > 1))) {
        ($block = pop(@{$res}));
        ($block = Lit::Block->new(('stmts' => $block->[2]), ('sig' => $block->[3])))
    };
    ((my  $result) = pop_term($res));
    if (((scalar(@{$res}) > 0))) {
        ($block = pop(@{$res}));
        if ((!(((ref($block) eq 'Lit::Block'))))) {
            ($block = Lit::Block->new(('stmts' => $block->[2]), ('sig' => $block->[3])))
        }
    };
    return (Perlito5::Match->new(('str' => $str), ('from' => $pos), ('to' => $last_pos), ('bool' => 1), ('capture' => (do {
    (my  %a);
    ($a{'exp'} = $result);
    ($a{'end_block'} = $block);
    ($a{'terminated'} = $terminated);
    \%a
}))))
};
sub exp_stmt {
    ((my  $grammar) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    ((my  $MATCH) = Perlito5::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1)));
    ($MATCH->{('bool')} = (((do {
    ((my  $pos1) = $MATCH->to());
    ((((((do {
    (((do {
    ((my  $m2) = Perlito5::Grammar->if($str, $MATCH->to()));
    if (($m2->bool())) {
        ($MATCH->{('to')} = $m2->to());
        ($MATCH->{'Perlito5::Grammar.if'} = $m2);
        1
    }
    else {
        0
    }
})) && ((do {
    ($MATCH->{('capture')} = $MATCH->{('Perlito5::Grammar.if')}->flat());
    1
})))
})) || ((do {
    ($MATCH->{('to')} = $pos1);
    ((((do {
    ((my  $m2) = Perlito5::Grammar->unless($str, $MATCH->to()));
    if (($m2->bool())) {
        ($MATCH->{('to')} = $m2->to());
        ($MATCH->{'Perlito5::Grammar.unless'} = $m2);
        1
    }
    else {
        0
    }
})) && ((do {
    ($MATCH->{('capture')} = $MATCH->{('Perlito5::Grammar.unless')}->flat());
    1
}))))
}))) || ((do {
    ($MATCH->{('to')} = $pos1);
    ((((do {
    ((my  $m2) = Perlito5::Grammar->when($str, $MATCH->to()));
    if (($m2->bool())) {
        ($MATCH->{('to')} = $m2->to());
        ($MATCH->{'Perlito5::Grammar.when'} = $m2);
        1
    }
    else {
        0
    }
})) && ((do {
    ($MATCH->{('capture')} = $MATCH->{('Perlito5::Grammar.when')}->flat());
    1
}))))
}))) || ((do {
    ($MATCH->{('to')} = $pos1);
    ((((do {
    ((my  $m2) = Perlito5::Grammar->for($str, $MATCH->to()));
    if (($m2->bool())) {
        ($MATCH->{('to')} = $m2->to());
        ($MATCH->{'Perlito5::Grammar.for'} = $m2);
        1
    }
    else {
        0
    }
})) && ((do {
    ($MATCH->{('capture')} = $MATCH->{('Perlito5::Grammar.for')}->flat());
    1
}))))
}))) || ((do {
    ($MATCH->{('to')} = $pos1);
    ((((do {
    ((my  $m2) = Perlito5::Grammar->while($str, $MATCH->to()));
    if (($m2->bool())) {
        ($MATCH->{('to')} = $m2->to());
        ($MATCH->{'Perlito5::Grammar.while'} = $m2);
        1
    }
    else {
        0
    }
})) && ((do {
    ($MATCH->{('capture')} = $MATCH->{('Perlito5::Grammar.while')}->flat());
    1
}))))
})))
}))));
    $MATCH
};
sub statement_modifier {
    ((my  $grammar) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    ((my  $MATCH) = Perlito5::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1)));
    ($MATCH->{('bool')} = (((do {
    ((my  $pos1) = $MATCH->to());
    (((((((do {
    (('if' eq substr($str, $MATCH->to(), 2)) && (($MATCH->{('to')} = (2 + $MATCH->to()))))
})) || ((do {
    ($MATCH->{('to')} = $pos1);
    (((('unless' eq substr($str, $MATCH->to(), 6)) && (($MATCH->{('to')} = (6 + $MATCH->to()))))))
}))) || ((do {
    ($MATCH->{('to')} = $pos1);
    (((('when' eq substr($str, $MATCH->to(), 4)) && (($MATCH->{('to')} = (4 + $MATCH->to()))))))
}))) || ((do {
    ($MATCH->{('to')} = $pos1);
    (((('foreach' eq substr($str, $MATCH->to(), 7)) && (($MATCH->{('to')} = (7 + $MATCH->to()))))))
}))) || ((do {
    ($MATCH->{('to')} = $pos1);
    (((('for' eq substr($str, $MATCH->to(), 3)) && (($MATCH->{('to')} = (3 + $MATCH->to()))))))
}))) || ((do {
    ($MATCH->{('to')} = $pos1);
    (((('while' eq substr($str, $MATCH->to(), 5)) && (($MATCH->{('to')} = (5 + $MATCH->to()))))))
})))
}))));
    $MATCH
};
sub delimited_statement {
    ((my  $grammar) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    ((my  $MATCH) = Perlito5::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1)));
    ($MATCH->{('bool')} = (((do {
    ((my  $pos1) = $MATCH->to());
    ((do {
    (((do {
    ((my  $last_pos) = $MATCH->to());
    if ((!(((do {
    ((my  $m2) = Perlito5::Grammar->ws($str, $MATCH->to()));
    if (($m2->bool())) {
        ($MATCH->{('to')} = $m2->to());
        1
    }
    else {
        0
    }
}))))) {
        ($MATCH->{('to')} = $last_pos)
    };
    1
})) && ((do {
    ((my  $pos1) = $MATCH->to());
    (((do {
    ((((chr(59) eq substr($str, $MATCH->to(), 1)) && (($MATCH->{('to')} = (1 + $MATCH->to()))))) && ((do {
    ((my  $last_pos) = $MATCH->to());
    if ((!(((do {
    ((my  $m2) = Perlito5::Grammar->ws($str, $MATCH->to()));
    if (($m2->bool())) {
        ($MATCH->{('to')} = $m2->to());
        1
    }
    else {
        0
    }
}))))) {
        ($MATCH->{('to')} = $last_pos)
    };
    1
})))
})) || ((do {
    ($MATCH->{('to')} = $pos1);
    ((((((do {
    ((my  $m2) = $grammar->statement_parse($str, $MATCH->to()));
    if (($m2->bool())) {
        ($MATCH->{('to')} = $m2->to());
        ($MATCH->{'statement_parse'} = $m2);
        1
    }
    else {
        0
    }
})) && ((do {
    ((my  $last_pos) = $MATCH->to());
    if ((!(((do {
    ((chr(59) eq substr($str, $MATCH->to(), 1)) && (($MATCH->{('to')} = (1 + $MATCH->to()))))
}))))) {
        ($MATCH->{('to')} = $last_pos)
    };
    1
}))) && ((do {
    ((my  $last_pos) = $MATCH->to());
    if ((!(((do {
    ((my  $m2) = Perlito5::Grammar->ws($str, $MATCH->to()));
    if (($m2->bool())) {
        ($MATCH->{('to')} = $m2->to());
        1
    }
    else {
        0
    }
}))))) {
        ($MATCH->{('to')} = $last_pos)
    };
    1
}))) && ((do {
    ($MATCH->{('capture')} = $MATCH->{('statement_parse')}->flat());
    1
}))))
})))
})))
}))
}))));
    $MATCH
};
sub statement_parse {
    ((my  $self) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    (my  $expr);
    ((my  $last_pos) = $pos);
    ((my  $lexer_stack) = (do {
    (my  @a);
    (my  @v);
    \@a
}));
    (my  $res);
    ($res = $self->exp_stmt($str, $pos));
    if (($res->bool())) {
        return ($res)
    };
    ($res = $self->exp_parse($str, $pos));
    if ((!($res->bool()))) {
        return ($res)
    };
    if (((ref($res->flat()->{'exp'}) eq 'Lit::Block'))) {
        ($res->flat()->{'exp'} = Do->new(('block' => $res->flat()->{'exp'})))
    };
    if (($res->flat()->{'end_block'})) {
        die(('Unexpected block after expression near '), $pos)
    };
    if (($res->flat()->{'terminated'})) {
        ($res->{('capture')} = $res->flat()->{'exp'});
        return ($res)
    };
    ((my  $modifier) = $self->statement_modifier($str, $res->to()));
    if ((!($modifier->bool()))) {
        ($res->{('capture')} = $res->flat()->{'exp'});
        return ($res)
    };
    ((my  $modifier_exp) = $self->exp_parse($str, $modifier->to()));
    if ((!($modifier_exp->bool()))) {
        die(('Expected expression after ' . chr(39)), $modifier->flat(), (chr(39)))
    };
    if (($modifier_exp->flat()->{'end_block'})) {
        die(('Unexpected block after expression near '), $modifier->to())
    };
    ($modifier = $modifier->flat());
    if ((($modifier eq 'if'))) {
        return (Perlito5::Match->new(('str' => $str), ('from' => $pos), ('to' => $modifier_exp->to()), ('bool' => 1), ('capture' => If->new(('cond' => $modifier_exp->flat()->{'exp'}), ('body' => Lit::Block->new(('stmts' => (do {
    (my  @a);
    (my  @v);
    push(@a, $res->flat()->{'exp'} );
    \@a
})))), ('otherwise' => Lit::Block->new(('stmts' => (do {
    (my  @a);
    (my  @v);
    \@a
}))))))))
    };
    if ((($modifier eq 'unless'))) {
        return (Perlito5::Match->new(('str' => $str), ('from' => $pos), ('to' => $modifier_exp->to()), ('bool' => 1), ('capture' => If->new(('cond' => $modifier_exp->flat()->{'exp'}), ('body' => Lit::Block->new(('stmts' => (do {
    (my  @a);
    (my  @v);
    \@a
})))), ('otherwise' => Lit::Block->new(('stmts' => (do {
    (my  @a);
    (my  @v);
    push(@a, $res->flat()->{'exp'} );
    \@a
}))))))))
    };
    if ((($modifier eq 'while'))) {
        return (Perlito5::Match->new(('str' => $str), ('from' => $pos), ('to' => $modifier_exp->to()), ('bool' => 1), ('capture' => While->new(('cond' => $modifier_exp->flat()->{'exp'}), ('body' => Lit::Block->new(('stmts' => (do {
    (my  @a);
    (my  @v);
    push(@a, $res->flat()->{'exp'} );
    \@a
}))))))))
    };
    if (((($modifier eq 'for') || ($modifier eq 'foreach')))) {
        return (Perlito5::Match->new(('str' => $str), ('from' => $pos), ('to' => $modifier_exp->to()), ('bool' => 1), ('capture' => For->new(('cond' => $modifier_exp->flat()->{'exp'}), ('body' => Lit::Block->new(('stmts' => (do {
    (my  @a);
    (my  @v);
    push(@a, $res->flat()->{'exp'} );
    \@a
}))))))))
    };
    die(('Unexpected statement modifier ' . chr(39) . $modifier . chr(39)))
};
1;

1;
