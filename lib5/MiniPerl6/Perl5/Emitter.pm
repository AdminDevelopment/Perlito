# Do not edit this file - Generated by MiniPerl6 6.0
use v5;
use strict;
use MiniPerl6::Perl5::Runtime;
our $MATCH = MiniPerl6::Match->new();
{
package Perl5;
sub new { shift; bless { @_ }, "Perl5" }
sub to_str { my $op = $_[0]; my $args = $_[1]; my  $List_s; for my $cond ( @{$args || []} ) { if ((Main::bool(Main::isa($cond, 'Val::Buf')))) { push( @{$List_s}, $cond->emit() ) } else { push( @{$List_s}, '("" . ' . $cond->emit() . ')' ) } }; return('(' . Main::join($List_s, $op) . ')') };
sub to_bool { my $op = $_[0]; my $args = $_[1]; my  $List_s; for my $cond ( @{$args || []} ) { if (((Main::bool(Main::isa($cond, 'Val::Int')) || Main::bool(Main::isa($cond, 'Val::Num'))))) { push( @{$List_s}, '(' . $cond->emit() . ' != 0 )' ) } else { if ((((Main::bool(Main::isa($cond, 'Apply')) && Main::bool(($cond->code() eq 'infix:<||>'))) || ((Main::bool(Main::isa($cond, 'Apply')) && Main::bool(($cond->code() eq 'infix:<&&>'))) || ((Main::bool(Main::isa($cond, 'Apply')) && Main::bool(($cond->code() eq 'prefix:<!>'))) || ((Main::bool(Main::isa($cond, 'Apply')) && Main::bool(($cond->code() eq 'prefix:<?>'))) || Main::bool(Main::isa($cond, 'Val::Bit')))))))) { push( @{$List_s}, $cond->emit() ) } else { push( @{$List_s}, 'Main::bool(' . $cond->emit() . ')' ) } } }; return('(' . Main::join($List_s, $op) . ')') }
}

{
package CompUnit;
sub new { shift; bless { @_ }, "CompUnit" }
sub name { $_[0]->{name} };
sub attributes { $_[0]->{attributes} };
sub methods { $_[0]->{methods} };
sub body { $_[0]->{body} };
sub emit { my $self = $_[0]; '{
' . 'package ' . $self->{name} . ';' . '
' . 'sub new { shift; bless { @_ }, "' . $self->{name} . '" }' . '
' . Main::join([ map { $_->emit() } @{ $self->{body} } ], ';' . '
') . '
' . '}
' . '
' };
sub emit_perl5_program { my $comp_units = $_[0]; (my  $str = ''); for my $comp_unit ( @{$comp_units || []} ) { ($str = $str . $comp_unit->emit()) }; return($str) }
}

{
package Val::Int;
sub new { shift; bless { @_ }, "Val::Int" }
sub int { $_[0]->{int} };
sub emit { my $self = $_[0]; $self->{int} }
}

{
package Val::Bit;
sub new { shift; bless { @_ }, "Val::Bit" }
sub bit { $_[0]->{bit} };
sub emit { my $self = $_[0]; $self->{bit} }
}

{
package Val::Num;
sub new { shift; bless { @_ }, "Val::Num" }
sub num { $_[0]->{num} };
sub emit { my $self = $_[0]; $self->{num} }
}

{
package Val::Buf;
sub new { shift; bless { @_ }, "Val::Buf" }
sub buf { $_[0]->{buf} };
sub emit { my $self = $_[0]; '\'' . Main::perl_escape_string($self->{buf}) . '\'' }
}

{
package Val::Undef;
sub new { shift; bless { @_ }, "Val::Undef" }
sub emit { my $self = $_[0]; '(undef)' }
}

{
package Val::Object;
sub new { shift; bless { @_ }, "Val::Object" }
sub class { $_[0]->{class} };
sub fields { $_[0]->{fields} };
sub emit { my $self = $_[0]; 'bless(' . Main::perl($self->{fields}, ) . ', ' . Main::perl($self->{class}, ) . ')' }
}

{
package Lit::Array;
sub new { shift; bless { @_ }, "Lit::Array" }
sub array1 { $_[0]->{array1} };
sub emit { my $self = $_[0]; my  $List_s; for my $item ( @{$self->{array1} || []} ) { if (((Main::bool(Main::isa($item, 'Var')) && Main::bool(($item->sigil() eq '@'))))) { push( @{$List_s}, '@{' . $item->emit() . '}' ) } else { push( @{$List_s}, $item->emit() ) } }; '[' . Main::join($List_s, ', ') . ']' }
}

{
package Lit::Hash;
sub new { shift; bless { @_ }, "Lit::Hash" }
sub hash1 { $_[0]->{hash1} };
sub emit { my $self = $_[0]; (my  $fields = $self->{hash1}); (my  $str = ''); for my $field ( @{$fields || []} ) { ($str = $str . $field->[0]->emit() . ' => ' . $field->[1]->emit() . ',') }; '{ ' . $str . ' }' }
}

{
package Lit::Code;
sub new { shift; bless { @_ }, "Lit::Code" }

}

{
package Lit::Object;
sub new { shift; bless { @_ }, "Lit::Object" }
sub class { $_[0]->{class} };
sub fields { $_[0]->{fields} };
sub emit { my $self = $_[0]; (my  $fields = $self->{fields}); (my  $str = ''); for my $field ( @{$fields || []} ) { ($str = $str . $field->[0]->emit() . ' => ' . $field->[1]->emit() . ',') }; $self->{class} . '->new( ' . $str . ' )' }
}

{
package Index;
sub new { shift; bless { @_ }, "Index" }
sub obj { $_[0]->{obj} };
sub index_exp { $_[0]->{index_exp} };
sub emit { my $self = $_[0]; $self->{obj}->emit() . '->[' . $self->{index_exp}->emit() . ']' }
}

{
package Lookup;
sub new { shift; bless { @_ }, "Lookup" }
sub obj { $_[0]->{obj} };
sub index_exp { $_[0]->{index_exp} };
sub emit { my $self = $_[0]; $self->{obj}->emit() . '->{' . $self->{index_exp}->emit() . '}' }
}

{
package Var;
sub new { shift; bless { @_ }, "Var" }
sub sigil { $_[0]->{sigil} };
sub twigil { $_[0]->{twigil} };
sub namespace { $_[0]->{namespace} };
sub name { $_[0]->{name} };
sub emit { my $self = $_[0]; (my  $table = { '$' => '$','@' => '$List_','%' => '$Hash_','&' => '$Code_', }); (my  $ns = ''); if ((Main::bool($self->{namespace}))) { ($ns = $self->{namespace} . '::') } else { if (((Main::bool(($self->{sigil} eq '@')) && (Main::bool(($self->{twigil} eq '*')) && Main::bool(($self->{name} eq 'ARGS')))))) { return('(\\@ARGV)') } else {  };if ((Main::bool(($self->{twigil} eq '.')))) { return('$self->{' . $self->{name} . '}') } else {  };if ((Main::bool(($self->{name} eq '/')))) { return($table->{$self->{sigil}} . 'MATCH') } else {  } }; return($table->{$self->{sigil}} . $ns . $self->{name}) };
sub plain_name { my $self = $_[0]; if ((Main::bool($self->{namespace}))) { return($self->{namespace} . '::' . $self->{name}) } else {  }; return($self->{name}) }
}

{
package Bind;
sub new { shift; bless { @_ }, "Bind" }
sub parameters { $_[0]->{parameters} };
sub arguments { $_[0]->{arguments} };
sub emit { my $self = $_[0]; if ((Main::bool(Main::isa($self->{parameters}, 'Call')))) { (my  $a = $self->{parameters});return('((' . $a->invocant()->emit() . ')->{' . $a->method() . '} = ' . $self->{arguments}->emit() . ')') } else {  }; if ((Main::bool(Main::isa($self->{parameters}, 'Lit::Array')))) { (my  $a = $self->{parameters}->array1());(my  $str = 'do { ');(my  $i = 0);for my $var ( @{$a || []} ) { (my  $bind = Bind->new( 'parameters' => $var,'arguments' => Index->new( 'obj' => $self->{arguments},'index_exp' => Val::Int->new( 'int' => $i, ), ), ));($str = $str . ' ' . $bind->emit() . '; ');($i = ($i + 1)) };return($str . $self->{parameters}->emit() . ' }') } else {  }; if ((Main::bool(Main::isa($self->{parameters}, 'Lit::Hash')))) { (my  $a = $self->{parameters}->hash1());(my  $b = $self->{arguments}->hash1());(my  $str = 'do { ');(my  $i = 0);my  $arg;for my $var ( @{$a || []} ) { ($arg = Val::Undef->new(  ));for my $var2 ( @{$b || []} ) { if ((Main::bool(($var2->[0]->buf() eq $var->[0]->buf())))) { ($arg = $var2->[1]) } else {  } };(my  $bind = Bind->new( 'parameters' => $var->[1],'arguments' => $arg, ));($str = $str . ' ' . $bind->emit() . '; ');($i = ($i + 1)) };return($str . $self->{parameters}->emit() . ' }') } else {  }; if ((Main::bool(Main::isa($self->{parameters}, 'Lit::Object')))) { (my  $class = $self->{parameters}->class());(my  $a = $self->{parameters}->fields());(my  $b = $self->{arguments});(my  $str = 'do { ');(my  $i = 0);my  $arg;for my $var ( @{$a || []} ) { (my  $bind = Bind->new( 'parameters' => $var->[1],'arguments' => Call->new( 'invocant' => $b,'method' => $var->[0]->buf(),'arguments' => [],'hyper' => 0, ), ));($str = $str . ' ' . $bind->emit() . '; ');($i = ($i + 1)) };return($str . $self->{parameters}->emit() . ' }') } else {  }; '(' . $self->{parameters}->emit() . ' = ' . $self->{arguments}->emit() . ')' }
}

{
package Proto;
sub new { shift; bless { @_ }, "Proto" }
sub name { $_[0]->{name} };
sub emit { my $self = $_[0]; ("" . $self->{name}) }
}

{
package Call;
sub new { shift; bless { @_ }, "Call" }
sub invocant { $_[0]->{invocant} };
sub hyper { $_[0]->{hyper} };
sub method { $_[0]->{method} };
sub arguments { $_[0]->{arguments} };
sub emit { my $self = $_[0]; (my  $invocant = $self->{invocant}->emit()); if ((Main::bool(($invocant eq 'self')))) { ($invocant = '$self') } else {  }; if ((Main::bool(($self->{method} eq 'shift')))) { if ((Main::bool($self->{hyper}))) { die('not implemented') } else { return('shift( @{' . $invocant . '} )') } } else {  }; if (((Main::bool(($self->{method} eq 'values')) || Main::bool(($self->{method} eq 'keys'))))) { if ((Main::bool($self->{hyper}))) { die('not implemented') } else { return('[' . $self->{method} . '( %{' . $invocant . '} )' . ']') } } else {  }; if (((Main::bool(($self->{method} eq 'perl')) || (Main::bool(($self->{method} eq 'yaml')) || (Main::bool(($self->{method} eq 'say')) || (Main::bool(($self->{method} eq 'join')) || (Main::bool(($self->{method} eq 'chars')) || Main::bool(($self->{method} eq 'isa'))))))))) { if ((Main::bool($self->{hyper}))) { return('[ map { Main::' . $self->{method} . '( $_, ' . ', ' . Main::join([ map { $_->emit() } @{ $self->{arguments} } ], ', ') . ')' . ' } @{ ' . $invocant . ' } ]') } else { return('Main::' . $self->{method} . '(' . $invocant . ', ' . Main::join([ map { $_->emit() } @{ $self->{arguments} } ], ', ') . ')') } } else {  }; if ((Main::bool(($self->{method} eq 'push')))) { return('push( @{' . $invocant . '}, ' . Main::join([ map { $_->emit() } @{ $self->{arguments} } ], ', ') . ' )') } else {  }; if ((Main::bool(($self->{method} eq 'unshift')))) { return('unshift( @{' . $invocant . '}, ' . Main::join([ map { $_->emit() } @{ $self->{arguments} } ], ', ') . ' )') } else {  }; if ((Main::bool(($self->{method} eq 'pop')))) { return('pop( @{' . $invocant . '} )') } else {  }; if ((Main::bool(($self->{method} eq 'shift')))) { return('shift( @{' . $invocant . '} )') } else {  }; if ((Main::bool(($self->{method} eq 'elems')))) { return('scalar( @{' . $invocant . '} )') } else {  }; (my  $meth = $self->{method}); if ((Main::bool(($meth eq 'postcircumfix:<( )>')))) { ($meth = '') } else {  }; (my  $call = '->' . $meth . '(' . Main::join([ map { $_->emit() } @{ $self->{arguments} } ], ', ') . ')'); if ((Main::bool($self->{hyper}))) { if (((Main::bool(Main::isa($self->{invocant}, 'Apply')) && Main::bool(($self->{invocant}->code() eq 'prefix:<@>'))))) {  } else { ($invocant = '@{ ' . $invocant . ' }') };return('[ map { $_' . $call . ' } ' . $invocant . ' ]') } else { $invocant . $call } }
}

{
package Apply;
sub new { shift; bless { @_ }, "Apply" }
sub code { $_[0]->{code} };
sub arguments { $_[0]->{arguments} };
sub namespace { $_[0]->{namespace} };
sub emit { my $self = $_[0]; (my  $ns = ''); if ((Main::bool($self->{namespace}))) { ($ns = $self->{namespace} . '::') } else {  }; (my  $code = $ns . $self->{code}); if ((Main::bool(Main::isa($code, 'Str')))) {  } else { return('(' . $self->{code}->emit() . ')->(' . Main::join([ map { $_->emit() } @{ $self->{arguments} } ], ', ') . ')') }; if ((Main::bool(($code eq 'self')))) { return('$self') } else {  }; if ((Main::bool(($code eq 'False')))) { return('0') } else {  }; if ((Main::bool(($code eq 'True')))) { return('1') } else {  }; if ((Main::bool(($code eq 'make')))) { return('($MATCH->{capture} = (' . Main::join([ map { $_->emit() } @{ $self->{arguments} } ], ', ') . '))') } else {  }; if ((Main::bool(($code eq 'say')))) { return('Main::say(' . Main::join([ map { $_->emit() } @{ $self->{arguments} } ], ', ') . ')') } else {  }; if ((Main::bool(($code eq 'print')))) { return('Main::print(' . Main::join([ map { $_->emit() } @{ $self->{arguments} } ], ', ') . ')') } else {  }; if ((Main::bool(($code eq 'warn')))) { return('warn(' . Main::join([ map { $_->emit() } @{ $self->{arguments} } ], ', ') . ')') } else {  }; if ((Main::bool(($code eq 'array')))) { return('@{' . Main::join([ map { $_->emit() } @{ $self->{arguments} } ], ' ') . '}') } else {  }; if ((Main::bool(($code eq 'pop')))) { return('pop( @{' . Main::join([ map { $_->emit() } @{ $self->{arguments} } ], ' ') . '} )') } else {  }; if ((Main::bool(($code eq 'push')))) { return('push( @{' . $self->{arguments}->[0]->emit() . '}, ' . $self->{arguments}->[1]->emit() . ' )') } else {  }; if ((Main::bool(($code eq 'shift')))) { return('shift( @{' . Main::join([ map { $_->emit() } @{ $self->{arguments} } ], ' ') . '} )') } else {  }; if ((Main::bool(($code eq 'Int')))) { return('(0+' . $self->{arguments}->[0]->emit() . ')') } else {  }; if ((Main::bool(($code eq 'Num')))) { return('(0+' . $self->{arguments}->[0]->emit() . ')') } else {  }; if ((Main::bool(($code eq 'bool')))) { return('Main::bool(' . Main::join([ map { $_->emit() } @{ $self->{arguments} } ], ', ') . ')') } else {  }; if ((Main::bool(($code eq 'prefix:<~>')))) { return('("" . ' . Main::join([ map { $_->emit() } @{ $self->{arguments} } ], ' ') . ')') } else {  }; if ((Main::bool(($code eq 'prefix:<!>')))) { return('!' . Perl5::to_bool(' && ', $self->{arguments})) } else {  }; if ((Main::bool(($code eq 'prefix:<?>')))) { return(Perl5::to_bool(' && ', $self->{arguments})) } else {  }; if ((Main::bool(($code eq 'prefix:<$>')))) { return('${' . Main::join([ map { $_->emit() } @{ $self->{arguments} } ], ' ') . '}') } else {  }; if ((Main::bool(($code eq 'prefix:<@>')))) { return('@{' . Main::join([ map { $_->emit() } @{ $self->{arguments} } ], ' ') . ' || []}') } else {  }; if ((Main::bool(($code eq 'prefix:<%>')))) { return('%{' . Main::join([ map { $_->emit() } @{ $self->{arguments} } ], ' ') . '}') } else {  }; if ((Main::bool(($code eq 'infix:<~>')))) { return('' . Main::join([ map { $_->emit() } @{ $self->{arguments} } ], ' . ') . '') } else {  }; if ((Main::bool(($code eq 'infix:<+>')))) { return('(' . Main::join([ map { $_->emit() } @{ $self->{arguments} } ], ' + ') . ')') } else {  }; if ((Main::bool(($code eq 'infix:<->')))) { return('(' . Main::join([ map { $_->emit() } @{ $self->{arguments} } ], ' - ') . ')') } else {  }; if ((Main::bool(($code eq 'infix:<*>')))) { return('(' . Main::join([ map { $_->emit() } @{ $self->{arguments} } ], ' * ') . ')') } else {  }; if ((Main::bool(($code eq 'infix:</>')))) { return('(' . Main::join([ map { $_->emit() } @{ $self->{arguments} } ], ' / ') . ')') } else {  }; if ((Main::bool(($code eq 'infix:<>>')))) { return('(' . Main::join([ map { $_->emit() } @{ $self->{arguments} } ], ' > ') . ')') } else {  }; if ((Main::bool(($code eq 'infix:<<>')))) { return('(' . Main::join([ map { $_->emit() } @{ $self->{arguments} } ], ' < ') . ')') } else {  }; if ((Main::bool(($code eq 'infix:<>=>')))) { return('(' . Main::join([ map { $_->emit() } @{ $self->{arguments} } ], ' >= ') . ')') } else {  }; if ((Main::bool(($code eq 'infix:<<=>')))) { return('(' . Main::join([ map { $_->emit() } @{ $self->{arguments} } ], ' <= ') . ')') } else {  }; if ((Main::bool(($code eq 'infix:<x>')))) { return('(' . Main::join([ map { $_->emit() } @{ $self->{arguments} } ], ' x ') . ')') } else {  }; if ((Main::bool(($code eq 'infix:<&&>')))) { return(Perl5::to_bool(' && ', $self->{arguments})) } else {  }; if ((Main::bool(($code eq 'infix:<||>')))) { return(Perl5::to_bool(' || ', $self->{arguments})) } else {  }; if ((Main::bool(($code eq 'infix:<eq>')))) { return(Perl5::to_str(' eq ', $self->{arguments})) } else {  }; if ((Main::bool(($code eq 'infix:<ne>')))) { return(Perl5::to_str(' ne ', $self->{arguments})) } else {  }; if ((Main::bool(($code eq 'infix:<==>')))) { return('(' . Main::join([ map { $_->emit() } @{ $self->{arguments} } ], ' == ') . ')') } else {  }; if ((Main::bool(($code eq 'infix:<!=>')))) { return('(' . Main::join([ map { $_->emit() } @{ $self->{arguments} } ], ' != ') . ')') } else {  }; if ((Main::bool(($code eq 'ternary:<?? !!>')))) { (my  $cond = $self->{arguments}->[0]);if (((Main::bool(Main::isa($cond, 'Var')) && Main::bool(($cond->sigil() eq '@'))))) { ($cond = Apply->new( 'code' => 'prefix:<@>','arguments' => [$cond], )) } else {  };return('(' . Perl5::to_bool(' && ', [$cond]) . ' ? ' . $self->{arguments}->[1]->emit() . ' : ' . $self->{arguments}->[2]->emit() . ')') } else {  }; $code . '(' . Main::join([ map { $_->emit() } @{ $self->{arguments} } ], ', ') . ')' }
}

{
package Return;
sub new { shift; bless { @_ }, "Return" }
sub result { $_[0]->{result} };
sub emit { my $self = $_[0]; return('return(' . $self->{result}->emit() . ')') }
}

{
package If;
sub new { shift; bless { @_ }, "If" }
sub cond { $_[0]->{cond} };
sub body { $_[0]->{body} };
sub otherwise { $_[0]->{otherwise} };
sub emit { my $self = $_[0]; (my  $cond = $self->{cond}); if (((Main::bool(Main::isa($cond, 'Apply')) && Main::bool(($cond->code() eq 'prefix:<!>'))))) { (my  $if = If->new( 'cond' => $cond->arguments()->[0],'body' => $self->{otherwise},'otherwise' => $self->{body}, ));return($if->emit()) } else {  }; return('if (' . Perl5::to_bool(' && ', [$cond]) . ') { ' . Main::join([ map { $_->emit() } @{ $self->{body} } ], ';') . ' } ' . 'else { ' . Main::join([ map { $_->emit() } @{ $self->{otherwise} } ], ';') . ' }') }
}

{
package While;
sub new { shift; bless { @_ }, "While" }
sub init { $_[0]->{init} };
sub cond { $_[0]->{cond} };
sub continue { $_[0]->{continue} };
sub body { $_[0]->{body} };
sub emit { my $self = $_[0]; (my  $cond = $self->{cond}); if (((Main::bool(Main::isa($cond, 'Var')) && Main::bool(($cond->sigil() eq '@'))))) { ($cond = Apply->new( 'code' => 'prefix:<@>','arguments' => [$cond], )) } else {  }; 'for ( ' . ((Main::bool($self->{init})) ? $self->{init}->emit() . '; ' : '; ') . ((Main::bool($cond)) ? Perl5::to_bool(' && ', [$cond]) . '; ' : '; ') . ((Main::bool($self->{continue})) ? $self->{continue}->emit() . ' ' : ' ') . ') { ' . Main::join([ map { $_->emit() } @{ $self->{body} } ], '; ') . ' }' }
}

{
package For;
sub new { shift; bless { @_ }, "For" }
sub cond { $_[0]->{cond} };
sub body { $_[0]->{body} };
sub topic { $_[0]->{topic} };
sub emit { my $self = $_[0]; (my  $cond = $self->{cond}); if (((Main::bool(Main::isa($cond, 'Var')) && Main::bool(($cond->sigil() eq '@'))))) { ($cond = Apply->new( 'code' => 'prefix:<@>','arguments' => [$cond], )) } else {  }; return('for my ' . $self->{topic}->emit() . ' ( ' . $cond->emit() . ' ) { ' . Main::join([ map { $_->emit() } @{ $self->{body} } ], ';') . ' }') }
}

{
package Decl;
sub new { shift; bless { @_ }, "Decl" }
sub decl { $_[0]->{decl} };
sub type { $_[0]->{type} };
sub var { $_[0]->{var} };
sub emit { my $self = $_[0]; (my  $decl = $self->{decl}); (my  $name = $self->{var}->plain_name()); ((Main::bool(($decl eq 'has'))) ? 'sub ' . $name . ' { $_[0]->{' . $name . '} }' : $self->{decl} . ' ' . $self->{type} . ' ' . $self->{var}->emit()) }
}

{
package Sig;
sub new { shift; bless { @_ }, "Sig" }
sub invocant { $_[0]->{invocant} };
sub positional { $_[0]->{positional} };
sub named { $_[0]->{named} };
sub emit { my $self = $_[0]; ' print \'Signature - TODO\'; die \'Signature - TODO\'; ' }
}

{
package Method;
sub new { shift; bless { @_ }, "Method" }
sub name { $_[0]->{name} };
sub sig { $_[0]->{sig} };
sub block { $_[0]->{block} };
sub emit { my $self = $_[0]; (my  $sig = $self->{sig}); (my  $invocant = $sig->invocant()); (my  $pos = $sig->positional()); (my  $str = ''); (my  $i = 1); for my $field ( @{$pos || []} ) { ($str = $str . 'my ' . $field->emit() . ' = $_[' . $i . ']; ');($i = ($i + 1)) }; 'sub ' . $self->{name} . ' { ' . 'my ' . $invocant->emit() . ' = $_[0]; ' . $str . Main::join([ map { $_->emit() } @{ $self->{block} } ], '; ') . ' }' }
}

{
package Sub;
sub new { shift; bless { @_ }, "Sub" }
sub name { $_[0]->{name} };
sub sig { $_[0]->{sig} };
sub block { $_[0]->{block} };
sub emit { my $self = $_[0]; (my  $sig = $self->{sig}); (my  $pos = $sig->positional()); (my  $str = ''); (my  $i = 0); for my $field ( @{$pos || []} ) { ($str = $str . 'my ' . $field->emit() . ' = $_[' . $i . ']; ');($i = ($i + 1)) }; 'sub ' . $self->{name} . ' { ' . $str . Main::join([ map { $_->emit() } @{ $self->{block} } ], '; ') . ' }' }
}

{
package Do;
sub new { shift; bless { @_ }, "Do" }
sub block { $_[0]->{block} };
sub emit { my $self = $_[0]; 'do { ' . Main::join([ map { $_->emit() } @{ $self->{block} } ], '; ') . ' }' }
}

{
package Use;
sub new { shift; bless { @_ }, "Use" }
sub mod { $_[0]->{mod} };
sub emit { my $self = $_[0]; 'use ' . $self->{mod} }
}

1;
