# Do not edit this file - Generated by Perlito 7.0
use v5;
use utf8;
use strict;
use warnings;
no warnings ('redefine', 'once', 'void', 'uninitialized', 'misc', 'recursion');
use Perlito::Perl5::Runtime;
use Perlito::Perl5::Prelude;
our $MATCH = Perlito::Match->new();
{
package GLOBAL;
    sub new { shift; bless { @_ }, "GLOBAL" }

    # use v6 
;
    {
    package Perlito::Grammar;
        sub new { shift; bless { @_ }, "Perlito::Grammar" }
        sub unless {
            my $grammar = $_[0];
            my $str = $_[1];
            my $pos = $_[2];
            (my  $MATCH = undef);
            ($MATCH = Perlito::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1)));
            (($MATCH)->{bool} = ((do {
    ((my  $pos1 = undef) = $MATCH->to());
    (do {
    Main::and(Main::and(Main::and(Main::and(Main::and(Main::and(Main::and(Main::and((Main::and(('u' eq substr($str, $MATCH->to(), 1)), sub { ((($MATCH)->{to} = (1 + $MATCH->to()))) })), sub { (Main::and(('n' eq substr($str, $MATCH->to(), 1)), sub { ((($MATCH)->{to} = (1 + $MATCH->to()))) })) }), sub { (Main::and(('l' eq substr($str, $MATCH->to(), 1)), sub { ((($MATCH)->{to} = (1 + $MATCH->to()))) })) }), sub { (Main::and(('e' eq substr($str, $MATCH->to(), 1)), sub { ((($MATCH)->{to} = (1 + $MATCH->to()))) })) }), sub { (Main::and(('s' eq substr($str, $MATCH->to(), 1)), sub { ((($MATCH)->{to} = (1 + $MATCH->to()))) })) }), sub { (Main::and(('s' eq substr($str, $MATCH->to(), 1)), sub { ((($MATCH)->{to} = (1 + $MATCH->to()))) })) }), sub { (do {
    ((my  $m2 = undef) = $grammar->ws($str, $MATCH->to()));
    if (Main::bool($m2)) {
        (($MATCH)->{to} = $m2->to());
        1
    }
    else {
        0
    }
}) }), sub { (do {
    ((my  $m2 = undef) = $grammar->exp($str, $MATCH->to()));
    if (Main::bool($m2)) {
        (($MATCH)->{to} = $m2->to());
        ($MATCH->{'exp'} = $m2);
        1
    }
    else {
        0
    }
}) }), sub { (Main::or((do {
    ((my  $body = undef) = (${$MATCH->{'exp'}})->{'end_block'});
    if (Main::bool(!Main::bool((defined($body))))) {
        die('Missing code block in ' . chr(39) . 'unless' . chr(39))
    };
    ($MATCH->{capture} = (If->new(('cond' => (${$MATCH->{'exp'}})->{'exp'}), ('body' => Lit::Block->new(('stmts' => do {
    (my  $List_a = []);
    (my  $List_v = []);
    $List_a
}))), ('otherwise' => $body))))
}), sub { 1 })) })
})
})));
            $MATCH
        };
        sub if {
            my $grammar = $_[0];
            my $str = $_[1];
            my $pos = $_[2];
            (my  $MATCH = undef);
            ($MATCH = Perlito::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1)));
            (($MATCH)->{bool} = ((do {
    ((my  $pos1 = undef) = $MATCH->to());
    (do {
    Main::and(Main::and(Main::and(Main::and((Main::and(('i' eq substr($str, $MATCH->to(), 1)), sub { ((($MATCH)->{to} = (1 + $MATCH->to()))) })), sub { (Main::and(('f' eq substr($str, $MATCH->to(), 1)), sub { ((($MATCH)->{to} = (1 + $MATCH->to()))) })) }), sub { (do {
    ((my  $m2 = undef) = $grammar->ws($str, $MATCH->to()));
    if (Main::bool($m2)) {
        (($MATCH)->{to} = $m2->to());
        1
    }
    else {
        0
    }
}) }), sub { (do {
    ((my  $m2 = undef) = $grammar->exp($str, $MATCH->to()));
    if (Main::bool($m2)) {
        (($MATCH)->{to} = $m2->to());
        ($MATCH->{'exp'} = $m2);
        1
    }
    else {
        0
    }
}) }), sub { (do {
    ((my  $pos1 = undef) = $MATCH->to());
    Main::or(Main::or((do {
    Main::and(Main::and(Main::and(Main::and(Main::and(Main::and((do {
    ((my  $m2 = undef) = $grammar->opt_ws($str, $MATCH->to()));
    if (Main::bool($m2)) {
        (($MATCH)->{to} = $m2->to());
        1
    }
    else {
        0
    }
}), sub { (Main::and(('e' eq substr($str, $MATCH->to(), 1)), sub { ((($MATCH)->{to} = (1 + $MATCH->to()))) })) }), sub { (Main::and(('l' eq substr($str, $MATCH->to(), 1)), sub { ((($MATCH)->{to} = (1 + $MATCH->to()))) })) }), sub { (Main::and(('s' eq substr($str, $MATCH->to(), 1)), sub { ((($MATCH)->{to} = (1 + $MATCH->to()))) })) }), sub { (Main::and(('e' eq substr($str, $MATCH->to(), 1)), sub { ((($MATCH)->{to} = (1 + $MATCH->to()))) })) }), sub { (do {
    ((my  $m2 = undef) = $grammar->exp2($str, $MATCH->to()));
    if (Main::bool($m2)) {
        (($MATCH)->{to} = $m2->to());
        ($MATCH->{'exp2'} = $m2);
        1
    }
    else {
        0
    }
}) }), sub { (Main::or((do {
    ((my  $body = undef) = (${$MATCH->{'exp'}})->{'end_block'});
    ((my  $otherwise = undef) = (${$MATCH->{'exp2'}})->{'exp'});
    if (Main::bool(!Main::bool((defined($body))))) {
        die('Missing code block in ' . chr(39) . 'if' . chr(39))
    };
    if (Main::bool(!Main::bool((defined($otherwise))))) {
        die('Missing code block in ' . chr(39) . 'else' . chr(39))
    };
    if (Main::bool(Main::isa($otherwise, 'Lit::Hash'))) {
        ($otherwise = Lit::Block->new(('stmts' => $otherwise->hash1())))
    };
    ($MATCH->{capture} = (If->new(('cond' => (${$MATCH->{'exp'}})->{'exp'}), ('body' => $body), ('otherwise' => $otherwise))))
}), sub { 1 })) })
}), sub { (do {
    (($MATCH)->{to} = $pos1);
    (Main::and(Main::and(Main::and(Main::and(Main::and((do {
    ((my  $m2 = undef) = $grammar->opt_ws($str, $MATCH->to()));
    if (Main::bool($m2)) {
        (($MATCH)->{to} = $m2->to());
        1
    }
    else {
        0
    }
}), sub { (Main::and(('e' eq substr($str, $MATCH->to(), 1)), sub { ((($MATCH)->{to} = (1 + $MATCH->to()))) })) }), sub { (Main::and(('l' eq substr($str, $MATCH->to(), 1)), sub { ((($MATCH)->{to} = (1 + $MATCH->to()))) })) }), sub { (Main::and(('s' eq substr($str, $MATCH->to(), 1)), sub { ((($MATCH)->{to} = (1 + $MATCH->to()))) })) }), sub { (do {
    ((my  $m2 = undef) = $grammar->if($str, $MATCH->to()));
    if (Main::bool($m2)) {
        (($MATCH)->{to} = $m2->to());
        ($MATCH->{'if'} = $m2);
        1
    }
    else {
        0
    }
}) }), sub { (Main::or((do {
    ((my  $body = undef) = (${$MATCH->{'exp'}})->{'end_block'});
    if (Main::bool(!Main::bool((defined($body))))) {
        die('Missing code block in ' . chr(39) . 'if' . chr(39))
    };
    ($MATCH->{capture} = (If->new(('cond' => (${$MATCH->{'exp'}})->{'exp'}), ('body' => $body), ('otherwise' => Lit::Block->new(('stmts' => do {
    (my  $List_a = []);
    (my  $List_v = []);
    push( @{$List_a}, ${$MATCH->{'if'}} );
    $List_a
}))))))
}), sub { 1 })) }))
}) }), sub { (do {
    (($MATCH)->{to} = $pos1);
    ((Main::or((do {
    ((my  $body = undef) = (${$MATCH->{'exp'}})->{'end_block'});
    if (Main::bool(!Main::bool((defined($body))))) {
        die('Missing code block in ' . chr(39) . 'if' . chr(39))
    };
    ($MATCH->{capture} = (If->new(('cond' => (${$MATCH->{'exp'}})->{'exp'}), ('body' => $body), ('otherwise' => do {
    (my  $List_a = []);
    (my  $List_v = []);
    $List_a
}))))
}), sub { 1 })))
}) })
}) })
})
})));
            $MATCH
        };
        sub when {
            my $grammar = $_[0];
            my $str = $_[1];
            my $pos = $_[2];
            (my  $MATCH = undef);
            ($MATCH = Perlito::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1)));
            (($MATCH)->{bool} = ((do {
    ((my  $pos1 = undef) = $MATCH->to());
    (do {
    Main::and(Main::and(Main::and(Main::and(Main::and(Main::and((Main::and(('w' eq substr($str, $MATCH->to(), 1)), sub { ((($MATCH)->{to} = (1 + $MATCH->to()))) })), sub { (Main::and(('h' eq substr($str, $MATCH->to(), 1)), sub { ((($MATCH)->{to} = (1 + $MATCH->to()))) })) }), sub { (Main::and(('e' eq substr($str, $MATCH->to(), 1)), sub { ((($MATCH)->{to} = (1 + $MATCH->to()))) })) }), sub { (Main::and(('n' eq substr($str, $MATCH->to(), 1)), sub { ((($MATCH)->{to} = (1 + $MATCH->to()))) })) }), sub { (do {
    ((my  $m2 = undef) = $grammar->ws($str, $MATCH->to()));
    if (Main::bool($m2)) {
        (($MATCH)->{to} = $m2->to());
        1
    }
    else {
        0
    }
}) }), sub { (do {
    ((my  $m2 = undef) = $grammar->exp($str, $MATCH->to()));
    if (Main::bool($m2)) {
        (($MATCH)->{to} = $m2->to());
        ($MATCH->{'exp'} = $m2);
        1
    }
    else {
        0
    }
}) }), sub { (Main::or((do {
    ((my  $body = undef) = (${$MATCH->{'exp'}})->{'end_block'});
    if (Main::bool(!Main::bool((defined($body))))) {
        die('Missing code block in ' . chr(39) . 'when' . chr(39))
    };
    ($MATCH->{capture} = (When->new(('parameters' => (${$MATCH->{'exp'}})->{'exp'}), ('body' => $body))))
}), sub { 1 })) })
})
})));
            $MATCH
        };
        sub for {
            my $grammar = $_[0];
            my $str = $_[1];
            my $pos = $_[2];
            (my  $MATCH = undef);
            ($MATCH = Perlito::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1)));
            (($MATCH)->{bool} = ((do {
    ((my  $pos1 = undef) = $MATCH->to());
    (do {
    Main::and(Main::and(Main::and(Main::and(Main::and((Main::and(('f' eq substr($str, $MATCH->to(), 1)), sub { ((($MATCH)->{to} = (1 + $MATCH->to()))) })), sub { (Main::and(('o' eq substr($str, $MATCH->to(), 1)), sub { ((($MATCH)->{to} = (1 + $MATCH->to()))) })) }), sub { (Main::and(('r' eq substr($str, $MATCH->to(), 1)), sub { ((($MATCH)->{to} = (1 + $MATCH->to()))) })) }), sub { (do {
    ((my  $m2 = undef) = $grammar->ws($str, $MATCH->to()));
    if (Main::bool($m2)) {
        (($MATCH)->{to} = $m2->to());
        1
    }
    else {
        0
    }
}) }), sub { (do {
    ((my  $m2 = undef) = $grammar->exp($str, $MATCH->to()));
    if (Main::bool($m2)) {
        (($MATCH)->{to} = $m2->to());
        ($MATCH->{'exp'} = $m2);
        1
    }
    else {
        0
    }
}) }), sub { (Main::or((do {
    ((my  $body = undef) = (${$MATCH->{'exp'}})->{'end_block'});
    if (Main::bool(!Main::bool((defined($body))))) {
        die('Missing code block in ' . chr(39) . 'when' . chr(39))
    };
    ($MATCH->{capture} = (For->new(('cond' => (${$MATCH->{'exp'}})->{'exp'}), ('topic' => undef), ('body' => $body))))
}), sub { 1 })) })
})
})));
            $MATCH
        };
        sub while {
            my $grammar = $_[0];
            my $str = $_[1];
            my $pos = $_[2];
            (my  $MATCH = undef);
            ($MATCH = Perlito::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1)));
            (($MATCH)->{bool} = ((do {
    ((my  $pos1 = undef) = $MATCH->to());
    (do {
    Main::and(Main::and(Main::and(Main::and(Main::and(Main::and(Main::and((Main::and(('w' eq substr($str, $MATCH->to(), 1)), sub { ((($MATCH)->{to} = (1 + $MATCH->to()))) })), sub { (Main::and(('h' eq substr($str, $MATCH->to(), 1)), sub { ((($MATCH)->{to} = (1 + $MATCH->to()))) })) }), sub { (Main::and(('i' eq substr($str, $MATCH->to(), 1)), sub { ((($MATCH)->{to} = (1 + $MATCH->to()))) })) }), sub { (Main::and(('l' eq substr($str, $MATCH->to(), 1)), sub { ((($MATCH)->{to} = (1 + $MATCH->to()))) })) }), sub { (Main::and(('e' eq substr($str, $MATCH->to(), 1)), sub { ((($MATCH)->{to} = (1 + $MATCH->to()))) })) }), sub { (do {
    ((my  $m2 = undef) = $grammar->ws($str, $MATCH->to()));
    if (Main::bool($m2)) {
        (($MATCH)->{to} = $m2->to());
        1
    }
    else {
        0
    }
}) }), sub { (do {
    ((my  $m2 = undef) = $grammar->exp($str, $MATCH->to()));
    if (Main::bool($m2)) {
        (($MATCH)->{to} = $m2->to());
        ($MATCH->{'exp'} = $m2);
        1
    }
    else {
        0
    }
}) }), sub { (Main::or((do {
    ((my  $body = undef) = (${$MATCH->{'exp'}})->{'end_block'});
    if (Main::bool(!Main::bool((defined($body))))) {
        die('Missing code block in ' . chr(39) . 'while' . chr(39))
    };
    ($MATCH->{capture} = (While->new(('cond' => (${$MATCH->{'exp'}})->{'exp'}), ('body' => $body))))
}), sub { 1 })) })
})
})));
            $MATCH
        };
        sub loop {
            my $grammar = $_[0];
            my $str = $_[1];
            my $pos = $_[2];
            (my  $MATCH = undef);
            ($MATCH = Perlito::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1)));
            (($MATCH)->{bool} = ((do {
    ((my  $pos1 = undef) = $MATCH->to());
    (do {
    Main::and(Main::and(Main::and(Main::and(Main::and(Main::and((Main::and(('l' eq substr($str, $MATCH->to(), 1)), sub { ((($MATCH)->{to} = (1 + $MATCH->to()))) })), sub { (Main::and(('o' eq substr($str, $MATCH->to(), 1)), sub { ((($MATCH)->{to} = (1 + $MATCH->to()))) })) }), sub { (Main::and(('o' eq substr($str, $MATCH->to(), 1)), sub { ((($MATCH)->{to} = (1 + $MATCH->to()))) })) }), sub { (Main::and(('p' eq substr($str, $MATCH->to(), 1)), sub { ((($MATCH)->{to} = (1 + $MATCH->to()))) })) }), sub { (do {
    ((my  $m2 = undef) = $grammar->ws($str, $MATCH->to()));
    if (Main::bool($m2)) {
        (($MATCH)->{to} = $m2->to());
        1
    }
    else {
        0
    }
}) }), sub { (do {
    ((my  $m2 = undef) = $grammar->exp($str, $MATCH->to()));
    if (Main::bool($m2)) {
        (($MATCH)->{to} = $m2->to());
        ($MATCH->{'exp'} = $m2);
        1
    }
    else {
        0
    }
}) }), sub { (Main::or((do {
    ((my  $body = undef) = (${$MATCH->{'exp'}})->{'end_block'});
    if (Main::bool(!Main::bool((defined($body))))) {
        ($body = (${$MATCH->{'exp'}})->{'exp'});
        if (Main::bool(Main::isa($body, 'Lit::Block'))) {
            ($MATCH->{capture} = (While->new(('cond' => Val::Bit->new(('bit' => 1))), ('body' => $body))))
        }
        else {
            die('Missing code block in ' . chr(39) . 'loop' . chr(39))
        }
    }
    else {
        die(chr(39) . 'loop' . chr(39) . ' with parameters is not implemented')
    }
}), sub { 1 })) })
})
})));
            $MATCH
        }
    }


}

1;
