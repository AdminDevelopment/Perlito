# Do not edit this file - Generated by Perlito 6.0
use v5;
use utf8;
use strict;
use warnings;
no warnings ('redefine', 'once', 'void', 'uninitialized', 'misc', 'recursion');
use Perlito::Perl5::Runtime;
our $MATCH = Perlito::Match->new();
{
package GLOBAL;
sub new { shift; bless { @_ }, "GLOBAL" }
{
package Lit::Array;
sub new { shift; bless { @_ }, "Lit::Array" }
sub array1 { $_[0]->{array1} };
sub expand_interpolation { my $self = $_[0]; ((my  $needs_interpolation = undef) = 0); (my  $List_items = []); for my $item ( @{$self->{array1} || []} ) { if (Main::bool((Main::isa($item, 'Apply') && ((($item->code() eq 'circumfix:<( )>') || ($item->code() eq 'list:<,>')))))) { for my $arg ( @{(($item->arguments()) || []) || []} ) { push( @{$List_items}, $arg ) } } else { push( @{$List_items}, $item ) } }; for my $item ( @{$List_items || []} ) { if (Main::bool(((Main::isa($item, 'Var') && ($item->sigil() eq '@')) || (Main::isa($item, 'Apply') && ((($item->code() eq 'prefix:<@>') || ($item->code() eq 'infix:<..>'))))))) { ($needs_interpolation = 1) }  }; if (Main::bool(($needs_interpolation && (scalar( @{$List_items} ) == 1)))) { return($List_items->[0]) } ; if (Main::bool($needs_interpolation)) { (my  $List_s = []); for my $item ( @{$List_items || []} ) { if (Main::bool(((Main::isa($item, 'Var') && ($item->sigil() eq '@')) || (Main::isa($item, 'Apply') && ((($item->code() eq 'prefix:<@>') || ($item->code() eq 'infix:<..>'))))))) { push( @{$List_s}, Apply->new(('arguments' => [Var->new(('name' => 'v'), ('namespace' => ''), ('sigil' => '@'), ('twigil' => '')), $item]), ('code' => 'infix:<=>'), ('namespace' => '')) ); push( @{$List_s}, For->new(('body' => Lit::Block->new(('sig' => Var->new(('name' => 'x'), ('namespace' => ''), ('sigil' => '$'), ('twigil' => ''))), ('stmts' => [Call->new(('arguments' => [Index->new(('index_exp' => Var->new(('name' => 'x'), ('namespace' => ''), ('sigil' => '$'), ('twigil' => ''))), ('obj' => Var->new(('name' => 'v'), ('namespace' => ''), ('sigil' => '@'), ('twigil' => ''))))]), ('hyper' => ''), ('invocant' => Var->new(('name' => 'a'), ('namespace' => ''), ('sigil' => '@'), ('twigil' => ''))), ('method' => 'push'))]))), ('cond' => Apply->new(('arguments' => [Val::Int->new(('int' => 0)), Apply->new(('arguments' => [Apply->new(('arguments' => [Call->new(('arguments' => []), ('hyper' => ''), ('invocant' => Var->new(('name' => 'v'), ('namespace' => ''), ('sigil' => '@'), ('twigil' => ''))), ('method' => 'elems')), Val::Int->new(('int' => 1))]), ('code' => 'infix:<->'), ('namespace' => ''))]), ('code' => 'circumfix:<( )>'), ('namespace' => ''))]), ('code' => 'infix:<..>'), ('namespace' => ''))), ('topic' => undef)) ) } else { push( @{$List_s}, Call->new(('arguments' => [$item]), ('hyper' => ''), ('invocant' => Var->new(('name' => 'a'), ('namespace' => ''), ('sigil' => '@'), ('twigil' => ''))), ('method' => 'push')) ) } }; return(Do->new(('block' => Lit::Block->new(('sig' => undef), ('stmts' => do { (my  $List_a = []); (my  $List_v = []); push( @{$List_a}, Decl->new(('decl' => 'my'), ('type' => ''), ('var' => Var->new(('name' => 'a'), ('namespace' => ''), ('sigil' => '@'), ('twigil' => '')))) ); push( @{$List_a}, Decl->new(('decl' => 'my'), ('type' => ''), ('var' => Var->new(('name' => 'v'), ('namespace' => ''), ('sigil' => '@'), ('twigil' => '')))) ); ($List_v = $List_s); for my $x ( @{[0 .. ((scalar( @{$List_v} ) - 1))] || []} ) { push( @{$List_a}, $List_v->[$x] ) }; push( @{$List_a}, Var->new(('name' => 'a'), ('namespace' => ''), ('sigil' => '@'), ('twigil' => '')) ); $List_a }))))) } else { return(Lit::Array->new(('array1' => $List_items))) } }
}


}

1;
