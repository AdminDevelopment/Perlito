# Do not edit this file - Generated by MiniPerl6 6.0
use v5;
use utf8;
use strict;
use warnings;
no warnings ('redefine', 'once', 'void', 'uninitialized', 'misc', 'recursion');
use MiniPerl6::Perl5::Runtime;
our $MATCH = MiniPerl6::Match->new();
{
package GLOBAL;
sub new { shift; bless { @_ }, "GLOBAL" }
{
package Test;
sub new { shift; bless { @_ }, "Test" }
my  $num_of_tests_run;
my  $num_of_tests_failed;
my  $num_of_tests_badpass;
my  $num_of_tests_planned;
my  $testing_started;
sub plan { my $number_of_tests = $_[0]; ($testing_started = 1); ($num_of_tests_planned = $number_of_tests); Main::say('1..' . $number_of_tests) };
sub ok { my $cond = $_[0]; my $desc = $_[1]; my $todo = $_[2]; my $depends = $_[3]; Test::proclaim($cond, 'ok! ' . $desc, $todo, $depends) };
sub is { my $got = $_[0]; my $expected = $_[1]; my $desc = $_[2]; my $todo = $_[3]; my $depends = $_[4]; (my  $test = ($got eq $expected)); Test::proclaim($test, 'is! ' . $desc, $todo, $got, $expected, $depends) };
sub is_deeply { my $got = $_[0]; my $expected = $_[1]; my $desc = $_[2]; my $todo = $_[3]; my $depends = $_[4]; (my  $got_perl = Main::perl($got, )); (my  $expected_perl = Main::perl($expected, )); (my  $test = (($got_perl eq $expected_perl))); Test::proclaim($test, 'is deeply! ' . $desc, $todo, $got_perl, $expected_perl, $depends) };
sub isnt { my $got = $_[0]; my $expected = $_[1]; my $desc = $_[2]; my $todo = $_[3]; my $depends = $_[4]; (my  $test = ((($got eq $expected)) ? 0 : 1)); Test::proclaim($test, 'isnt! ' . $desc, $todo, $got, $expected, $depends, { ('negate' => 1), }) };
sub cmp_ok { my $got = $_[0]; my $Code_compare_func = $_[1]; my $expected = $_[2]; my $desc = $_[3]; my $todo = $_[4]; my $depends = $_[5]; Main::say('### Test::cmp_ok not implemented') };
sub like { Main::say('### Test::like not implemented') };
sub unlike { Main::say('### Test::unlike not implemented') };
sub eval_dies_ok { Main::say('### Test::eval_dies_ok not implemented') };
sub isa_ok { Main::say('### Test::isa_ok not implemented') };
sub use_ok { Main::say('### Test::use_ok not implemented') };
sub throws_ok { Main::say('### Test::throws_ok not implemented') };
sub dies_ok { Main::say('### Test::dies_ok not implemented') };
sub lives_ok { Main::say('### Test::lives_ok not implemented') };
sub skip { my $reason = $_[0]; my $depends = $_[1]; Test::proclaim(1, '', 'skip ' . $reason, $depends) };
sub pass { my $desc = $_[0]; Test::proclaim(1, 'pass! ' . $desc) };
sub flunk { my $desc = $_[0]; my $todo = $_[1]; my $depends = $_[2]; Test::proclaim(0, 'flunk! ' . $desc, $todo, $depends) };
sub proclaim { my $cond = $_[0]; my $desc = $_[1]; my $todo = $_[2]; my $got = $_[3]; my $expected = $_[4]; my $depends = $_[5]; my $negate = $_[6]; ($testing_started = 1); ($num_of_tests_run = ($num_of_tests_run + 1)); if (Main::bool(($cond))) { Main::say('ok ', $num_of_tests_run) } else { Main::say('not ok ', $num_of_tests_run); Test::report_failure($todo, $got, $expected, $negate) }; return($cond) };
sub report_failure { my $todo = $_[0]; my $got = $_[1]; my $expected = $_[2]; my $negate = $_[3]; Main::say('### Test::report_failure not implemented') };
sub test_ends { if (Main::bool((($testing_started ? 0 : 1)))) { return() } ; if (Main::bool((($num_of_tests_planned ? 0 : 1)))) { Main::say('1..' . $num_of_tests_run) } ; if (Main::bool((($num_of_tests_planned != $num_of_tests_run)))) { Main::say('# Looks like you planned ' . $num_of_tests_planned . ' tests, but ran ' . $num_of_tests_run) } ; if (Main::bool(($num_of_tests_failed))) { Main::say('# Looks like you failed ' . $num_of_tests_failed . ' tests of ' . $num_of_tests_run) } ; ($num_of_tests_run = 0); ($num_of_tests_failed = 0); ($num_of_tests_planned = 0); ($testing_started = 0) }
}


}

1;
