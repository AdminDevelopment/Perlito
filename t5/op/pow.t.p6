# Do not edit this file - Generated by Perlito5 9.0
use v6;
{
    package main {
        Any;
        my $bits_in_uv = int(0.001 + log(~0 + 1) / log(2));
        my @pow = ([3, 30, 1e-14], [4, 32, 0], [5, 20, 1e-14], [2.5, 10, 1e-14], [-2, 69, 0], [-3, 30, 1e-14]);
        my $tests;
        $tests += $_.[1]
            for @pow;
        plan('tests' => 13 + $bits_in_uv + $tests);
        is((-3)**0, 1, 'negative ** 0 = 1');
        is((-3)**1, -3, 'negative ** 1 = self');
        is((-3)**2, 9, 'negative ** 2 = positive');
        is((-3)**3, -27, '(negative int) ** (odd power) is negative');
        is(3**0, 1, 'positive ** 0 = 1');
        is(3**1, 3, 'positive ** 1 = self');
        is(3**2, 9, 'positive ** 2 = positive');
        is(3**3, 27, '(positive int) ** (odd power) is positive');
        is(-3**0, -1);
        is(-3**1, -3);
        is(-3**2, -9);
        is(-3**3, -27);
        my $remainder = $bits_in_uv & 3;
        cmp_ok($remainder, '==', 0, 'Sanity check bits in UV calculation') or printf('# ~0 is %d (0x%d) which gives ' ~ $bits_in_uv ~ ' bits' ~ chr(10), ~0, ~0);
        for 0 .. $bits_in_uv - 1 -> $n {
            my $pow = 2**$n;
            my $int = 1 << $n;
            cmp_ok($pow, '==', $int, '2 ** ' ~ $n ~ ' vs 1 << ' ~ $n)
        }
        for @pow -> $pow {
            my($base, $max, $range) = @($pow);
            my $expect = 1;
            for 0 .. $max - 1 -> $n {
                my $got = $base**$n;
                within($got, $expect, $range, $base ~ ' ** ' ~ $n ~ ' got[' ~ $got ~ '] expect[' ~ $expect ~ ']');
                $expect *= $base
            }
        }
    }
}

