
use v5.10;
use feature 'say';

# Do not edit this file - Generated by Perlito5 9.018

{
    package main;
    undef();
    package Perlito5;
    {
        {
            package main;
            package feature;
            sub feature::import {}
            sub feature::unimport {}
            1
        }
    }
    {
        {
            package main;
            package Perlito5;
            $VERSION = 9.018;
            1
        }
    }
    {
        {
            package main;
            package Perlito5::Compiler;
            # use strict
            {
                {
                    package main;
                    package warnings;
                    sub warnings::import {
                        $Perlito5::WARNINGS = 1
                    }
                    sub warnings::unimport {
                        $Perlito5::WARNINGS = 0
                    }
                    1
                }
            }
            {
                {
                    package main;
                    undef();
                    package Perlito5::Match;
                    sub Perlito5::Match::flat {
                        my $self = $_[0];
                        defined($self->{'capture'}) ? $self->{'capture'} : substr($self->{'str'}, $self->{'from'}, ($self->{'to'} - $self->{'from'}))
                    }
                    1
                }
            }
            {
                {
                    package main;
                    package Perlito5::Grammar;
                    {
                        {
                            package main;
                            package Perlito5::Grammar::Expression;
                            {
                                {
                                    package main;
                                    package Perlito5::Grammar::Precedence;
                                    undef();
                                    sub Perlito5::Grammar::Precedence::new {
                                        my $class = shift;
                                        bless({@_}, $class)
                                    }
                                    my $Operator = {};
                                    my $Precedence = {};
                                    my $PrefixPrecedence = {};
                                    my $Assoc = {};
                                    sub Perlito5::Grammar::Precedence::is_assoc_type {
                                        my $assoc_type = shift;
                                        my $op_name = shift;
                                        return $Assoc->{$assoc_type}->{$op_name}
                                    }
                                    sub Perlito5::Grammar::Precedence::is_fixity_type {
                                        my $fixity_type = shift;
                                        my $op_name = shift;
                                        return $Operator->{$fixity_type}->{$op_name}
                                    }
                                    sub Perlito5::Grammar::Precedence::is_term {
                                        my $token = shift;
                                        ($token->[0] eq 'term') || ($token->[0] eq 'postfix_or_term') || ($token->[0] eq 'postfix')
                                    }
                                    sub Perlito5::Grammar::Precedence::is_num {
                                        $_[0] ge 0 && $_[0] le 9
                                    }
                                    sub Perlito5::Grammar::Precedence::is_ident_middle {
                                        my $c = shift;
                                        ($c ge 'a' && $c le 'z') || ($c ge 0 && $c le 9) || ($c eq '_')
                                    }
                                    my @Parsed_op_chars = (2, 1);
                                    my %Parsed_op = ('?' => sub {
                                        Perlito5::Grammar::Expression::term_ternary($_[0], $_[1])
                                    }, '(' => sub {
                                        Perlito5::Grammar::Expression::term_paren($_[0], $_[1])
                                    }, '[' => sub {
                                        Perlito5::Grammar::Expression::term_square($_[0], $_[1])
                                    }, '{' => sub {
                                        Perlito5::Grammar::Expression::term_curly($_[0], $_[1])
                                    }, '->' => sub {
                                        Perlito5::Grammar::Expression::term_arrow($_[0], $_[1])
                                    });
                                    my @Term_chars;
                                    my %Term;
                                    sub Perlito5::Grammar::Precedence::add_term {
                                        my $name = shift;
                                        my $param = shift;
                                        $Term{$name} = $param;
                                        unshift(@Term_chars, scalar(@Term_chars) + 1)
                                            while @Term_chars < length($name)
                                    }
                                    my $End_token;
                                    my $End_token_chars;
                                    my %Op;
                                    my @Op_chars = (3, 2, 1);
                                    sub Perlito5::Grammar::Precedence::op_parse {
                                        my $str = shift;
                                        my $pos = shift;
                                        my $last_is_term = shift;
                                        for my $len (@{$End_token_chars}) {
                                            my $term = substr($str, $pos, $len);
                                            if (exists($End_token->{$term})) {
                                                my $c1 = substr($str, $pos + $len - 1, 1);
                                                my $c2 = substr($str, $pos + $len, 1);
                                                if (!(is_ident_middle($c1) && is_ident_middle($c2)) && !($c1 eq '<' && $c2 eq '<')) {
                                                    return {'str' => $str, 'from' => $pos, 'to' => $pos, 'capture' => ['end', $term]}
                                                }
                                            }
                                        }
                                        if (!$last_is_term) {
                                            for my $len (@Term_chars) {
                                                my $term = substr($str, $pos, $len);
                                                if (exists($Term{$term})) {
                                                    my $c1 = substr($str, $pos + $len - 1, 1);
                                                    my $c2 = substr($str, $pos + $len, 1);
                                                    if (is_num($c1) || !is_ident_middle($c1) || !is_ident_middle($c2)) {
                                                        my $m = $Term{$term}->($str, $pos);
                                                        $m && return $m
                                                    }
                                                }
                                            }
                                        }
                                        for my $len (@Parsed_op_chars) {
                                            my $op = substr($str, $pos, $len);
                                            if (exists($Parsed_op{$op})) {
                                                my $m = $Parsed_op{$op}->($str, $pos);
                                                $m && return $m
                                            }
                                        }
                                        for my $len (@Op_chars) {
                                            my $op = substr($str, $pos, $len);
                                            if (exists($Op{$op})) {
                                                my $c1 = substr($str, $pos + $len - 1, 1);
                                                my $c2 = substr($str, $pos + $len, 1);
                                                if ((!(is_ident_middle($c1) && is_ident_middle($c2)) && !($c1 eq '&' && $c2 eq '&')) || ($c1 eq 'x' && $c2 ge 0 && $c2 le 9)) {
                                                    if (exists($Operator->{'infix'}->{$op}) && !exists($Operator->{'prefix'}->{$op}) && !$last_is_term) {}
                                                    else {
                                                        return {'str' => $str, 'from' => $pos, 'to' => $pos + $len, 'capture' => ['op', $op]}
                                                    }
                                                }
                                            }
                                        }
                                        return Perlito5::Grammar::Bareword::term_bareword($str, $pos)
                                    }
                                    sub Perlito5::Grammar::Precedence::add_op {
                                        my($fixity, $names, $precedence, $param) = @_;
                                        $param //= {};
                                        my $assoc = $param->{'assoc'} || 'left';
                                        for my $name (@{$names}) {
                                            $Operator->{$fixity}->{$name} = 1;
                                            $Precedence->{$name} = $precedence;
                                            $fixity eq 'prefix' && ($PrefixPrecedence->{$name} = $precedence);
                                            $Assoc->{$assoc}->{$name} = 1;
                                            $Op{$name} = 1
                                        }
                                    }
                                    my $prec = 100;
                                    add_op('postfix', ['.( )', '.[ ]', '.{ }', '( )', '[ ]', 'funcall', 'funcall_no_params', 'methcall', 'methcall_no_params', 'block', 'hash'], $prec);
                                    $prec = $prec - 1;
                                    add_op('prefix', ['++', '--'], $prec);
                                    add_op('postfix', ['++', '--'], $prec);
                                    $prec = $prec - 1;
                                    add_op('infix', ['**'], $prec, {'assoc' => 'right'});
                                    $prec = $prec - 1;
                                    add_op('prefix', [chr(92), '+', '-', '~', '!'], $prec);
                                    $prec = $prec - 1;
                                    add_op('infix', ['=~', '!~'], $prec);
                                    $prec = $prec - 1;
                                    add_op('infix', ['*', '/', '%', 'x'], $prec);
                                    $prec = $prec - 1;
                                    add_op('infix', ['+', '-'], $prec);
                                    add_op('infix', ['.'], $prec, {'assoc' => 'list'});
                                    $prec = $prec - 1;
                                    add_op('infix', ['<<', '>>'], $prec);
                                    $prec = $prec - 1;
                                    add_op('prefix', ['-r', '-w', '-x', '-o', '-R', '-W', '-X', '-O', '-e', '-z', '-s', '-f', '-d', '-l', '-p', '-S', '-b', '-c', '-t', '-u', '-g', '-k', '-T', '-B', '-M', '-A', '-C'], $prec);
                                    $prec = $prec - 1;
                                    add_op('infix', ['lt', 'le', 'gt', 'ge', '<=', '>=', '<', '>'], $prec, {'assoc' => 'chain'});
                                    $prec = $prec - 1;
                                    add_op('infix', ['<=>', 'cmp', '==', '!=', 'ne', 'eq'], $prec, {'assoc' => 'chain'});
                                    $prec = $prec - 1;
                                    add_op('infix', ['&'], $prec);
                                    $prec = $prec - 1;
                                    add_op('infix', ['|', '^'], $prec);
                                    $prec = $prec - 1;
                                    add_op('infix', ['..', '...'], $prec);
                                    add_op('infix', ['~~'], $prec, {'assoc' => 'chain'});
                                    $prec = $prec - 1;
                                    add_op('infix', ['&&'], $prec, {'assoc' => 'right'});
                                    $prec = $prec - 1;
                                    add_op('infix', ['||'], $prec, {'assoc' => 'right'});
                                    add_op('infix', ['//'], $prec);
                                    $prec = $prec - 1;
                                    add_op('ternary', ['? :'], $prec, {'assoc' => 'right'});
                                    $prec = $prec - 1;
                                    add_op('infix', ['=', '**=', '+=', '-=', '*=', '/=', 'x=', '|=', '&=', '.=', '<<=', '>>=', '%=', '||=', '&&=', '^=', '//='], $prec, {'assoc' => 'right'});
                                    $prec = $prec - 1;
                                    add_op('infix', ['=>'], $prec);
                                    $prec = $prec - 1;
                                    add_op('list', [','], $prec, {'assoc' => 'list'});
                                    $prec = $prec - 1;
                                    add_op('prefix', ['not'], $prec);
                                    $prec = $prec - 1;
                                    add_op('infix', ['and'], $prec);
                                    $prec = $prec - 1;
                                    add_op('infix', ['or', 'xor'], $prec);
                                    $prec = $prec - 1;
                                    add_op('infix', ['*start*'], $prec);
                                    sub Perlito5::Grammar::Precedence::get_token_precedence {
                                        my $token = $_[0];
                                        if ($token->[0] eq 'prefix') {
                                            return $PrefixPrecedence->{$token->[1]}
                                        }
                                        return $Precedence->{$token->[1]}
                                    }
                                    sub Perlito5::Grammar::Precedence::precedence_parse {
                                        my $self = shift;
                                        my $get_token = $self->{'get_token'};
                                        my $reduce = $self->{'reduce'};
                                        my $last_end_token = $End_token;
                                        my $last_end_token_chars = $End_token_chars;
                                        $End_token = $self->{'end_token'};
                                        $End_token_chars = $self->{'end_token_chars'};
                                        my $op_stack = [];
                                        my $num_stack = [];
                                        my $last = ['op', '*start*'];
                                        my $last_is_term = 0;
                                        my $token = $get_token->($last_is_term);
                                        if ($token->[0] eq 'space') {
                                            $token = $get_token->($last_is_term)
                                        }
                                        while ((defined($token)) && ($token->[0] ne 'end')) {
                                            my $token_is_term = is_term($token);
                                            if (($token->[1] eq ',') && (($last->[1] eq '*start*') || ($last->[1] eq ','))) {
                                                push(@{$num_stack}, ['term', undef])
                                            }
                                            if ($Operator->{'prefix'}->{$token->[1]} && (($last->[1] eq '*start*') || !$last_is_term)) {
                                                $token->[0] = 'prefix';
                                                unshift(@{$op_stack}, $token)
                                            }
                                            elsif ($Operator->{'postfix'}->{$token->[1]} && $last_is_term) {
                                                my $pr = $Precedence->{$token->[1]};
                                                while (scalar(@{$op_stack}) && ($pr <= get_token_precedence($op_stack->[0]))) {
                                                    $reduce->($op_stack, $num_stack)
                                                }
                                                if ($token->[0] ne 'postfix_or_term') {
                                                    $token->[0] = 'postfix'
                                                }
                                                unshift(@{$op_stack}, $token);
                                                $token_is_term = 1
                                            }
                                            elsif ($token_is_term) {
                                                if ($last_is_term) {
                                                    Perlito5::Compiler::error('Value tokens must be separated by an operator (did you forget a comma?)')
                                                }
                                                $token->[0] = 'term';
                                                push(@{$num_stack}, $token)
                                            }
                                            elsif ($Precedence->{$token->[1]}) {
                                                my $pr = $Precedence->{$token->[1]};
                                                if ($Assoc->{'right'}->{$token->[1]}) {
                                                    while (scalar(@{$op_stack}) && ($pr < get_token_precedence($op_stack->[0]))) {
                                                        $reduce->($op_stack, $num_stack)
                                                    }
                                                }
                                                else {
                                                    while (scalar(@{$op_stack}) && ($pr <= get_token_precedence($op_stack->[0]))) {
                                                        $reduce->($op_stack, $num_stack)
                                                    }
                                                }
                                                if ($Operator->{'ternary'}->{$token->[1]}) {
                                                    $token->[0] = 'ternary'
                                                }
                                                else {
                                                    $token->[0] = 'infix'
                                                }
                                                unshift(@{$op_stack}, $token)
                                            }
                                            else {
                                                Perlito5::Compiler::error('Unknown token: ' . chr(39), $token->[1], chr(39))
                                            }
                                            $last = $token;
                                            $last_is_term = $token_is_term;
                                            $token = $get_token->($last_is_term);
                                            if ($token->[0] eq 'space') {
                                                $token = $get_token->($last_is_term)
                                            }
                                        }
                                        if (defined($token) && ($token->[0] ne 'end')) {
                                            Perlito5::Compiler::error('Unexpected end token: ', $token)
                                        }
                                        while (scalar(@{$op_stack})) {
                                            $reduce->($op_stack, $num_stack)
                                        }
                                        $End_token = $last_end_token;
                                        $End_token_chars = $last_end_token_chars;
                                        return $num_stack
                                    }
                                    1
                                }
                            }
                            {
                                {
                                    package main;
                                    package strict;
                                    sub strict::import {
                                        $Perlito5::STRICT = 1
                                    }
                                    sub strict::unimport {
                                        $Perlito5::STRICT = 0
                                    }
                                    1
                                }
                                {
                                    package main;
                                    package Perlito5::Grammar::Bareword;
                                    # use strict
                                    sub Perlito5::Grammar::Bareword::the_object {
                                        my $str = $_[0];
                                        my $pos = $_[1];
                                        my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
                                        my $tmp = ((do {
                                            my $pos1 = $MATCH->{'to'};
                                            (do {
                                                ((do {
                                                    my $tmp = $MATCH;
                                                    $MATCH = {'from' => $tmp->{'to'}, 'to' => $tmp->{'to'}};
                                                    my $res = ('$' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}));
                                                    $MATCH = $tmp;
                                                    $res ? 1 : 0
                                                }) && (do {
                                                    my $m2 = Perlito5::Grammar::Sigil::term_sigil($str, $MATCH->{'to'});
                                                    if ($m2) {
                                                        $MATCH->{'to'} = $m2->{'to'};
                                                        $MATCH->{'Perlito5::Grammar::Sigil::term_sigil'} = $m2;
                                                        1
                                                    }
                                                    else {
                                                        0
                                                    }
                                                }) && (do {
                                                    $MATCH->{'capture'} = Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::Sigil::term_sigil'})->[1];
                                                    1
                                                }))
                                            }) || (do {
                                                $MATCH->{'to'} = $pos1;
                                                (('{' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                                                    my $m2 = Perlito5::Grammar::Expression::curly_parse($str, $MATCH->{'to'});
                                                    if ($m2) {
                                                        $MATCH->{'to'} = $m2->{'to'};
                                                        $MATCH->{'Perlito5::Grammar::Expression::curly_parse'} = $m2;
                                                        1
                                                    }
                                                    else {
                                                        0
                                                    }
                                                }) && ('}' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                                                    $MATCH->{'capture'} = Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::Expression::curly_parse'});
                                                    1
                                                }))
                                            }) || (do {
                                                $MATCH->{'to'} = $pos1;
                                                ((do {
                                                    my $m2 = Perlito5::Grammar::Print::typeglob($str, $MATCH->{'to'});
                                                    if ($m2) {
                                                        $MATCH->{'to'} = $m2->{'to'};
                                                        $MATCH->{'Perlito5::Grammar::Print::typeglob'} = $m2;
                                                        1
                                                    }
                                                    else {
                                                        0
                                                    }
                                                }) && (do {
                                                    $MATCH->{'capture'} = Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::Print::typeglob'});
                                                    1
                                                }))
                                            })
                                        }));
                                        $tmp ? $MATCH : 0
                                    }
                                    sub Perlito5::Grammar::Bareword::term_bareword {
                                        my $str = $_[0];
                                        my $pos = $_[1];
                                        my $p = $pos;
                                        my $m_namespace = Perlito5::Grammar::optional_namespace_before_ident($str, $p);
                                        my $namespace = Perlito5::Match::flat($m_namespace);
                                        $p = $m_namespace->{'to'};
                                        my $m_name = Perlito5::Grammar::ident($str, $p);
                                        if (!$m_name) {
                                            if ($namespace) {
                                                $m_namespace->{'capture'} = ['term', Perlito5::AST::Var::->new('sigil' => '::', 'name' => '', 'namespace' => $namespace)];
                                                return $m_namespace
                                            }
                                            return 
                                        }
                                        my $name = Perlito5::Match::flat($m_name);
                                        $p = $m_name->{'to'};
                                        if (substr($str, $p, 2) eq '::') {
                                            $m_name->{'to'} = $p + 2;
                                            $m_name->{'capture'} = ['term', Perlito5::AST::Var::->new('sigil' => '::', 'name' => '', 'namespace' => $namespace . '::' . $name)];
                                            return $m_name
                                        }
                                        my $full_name = $name;
                                        $namespace && ($full_name = $namespace . '::' . $name);
                                        my $m = Perlito5::Grammar::Space::ws($str, $p);
                                        if ($m) {
                                            $p = $m->{'to'}
                                        }
                                        my $invocant;
                                        my $is_subroutine_name;
                                        my $effective_name = ($namespace || $Perlito5::PKG_NAME) . '::' . $name;
                                        {
                                            my $p = eval {
                                                prototype($effective_name)
                                            };
                                            $p && ($Perlito5::PROTO->{$effective_name} = $p)
                                        }
                                        if (exists($Perlito5::Grammar::Print::Print{$name})) {
                                            $invocant = undef
                                        }
                                        elsif (exists($Perlito5::PROTO->{$effective_name}) || ((!$namespace || $namespace eq 'CORE') && exists($Perlito5::CORE_PROTO->{'CORE::' . $name}))) {
                                            $is_subroutine_name = 1;
                                            $invocant = Perlito5::Grammar::full_ident($str, $p);
                                            my $package = Perlito5::Match::flat($invocant);
                                            if ($package) {
                                                $invocant->{'capture'} = Perlito5::AST::Var::->new('sigil' => '::', 'name' => '', 'namespace' => $package);
                                                if (substr($str, $invocant->{'to'}, 2) eq '::') {
                                                    $invocant->{'to'} = $invocant->{'to'} + 2
                                                }
                                                elsif (!$Perlito5::PACKAGES->{$package}) {
                                                    $invocant = undef
                                                }
                                            }
                                        }
                                        else {
                                            $invocant = Perlito5::Grammar::Bareword::the_object($str, $p)
                                        }
                                        if ($invocant) {
                                            $p = $invocant->{'to'};
                                            my $arg = [];
                                            $m = Perlito5::Grammar::Space::ws($str, $p);
                                            $m && ($p = $m->{'to'});
                                            if (substr($str, $p, 2) eq '->') {}
                                            elsif (substr($str, $p, 1) eq '(') {
                                                my $m = Perlito5::Grammar::Expression::term_paren($str, $p);
                                                if ($m) {
                                                    $arg = $m->{'capture'}->[2];
                                                    $p = $m->{'to'};
                                                    $arg = Perlito5::Grammar::Expression::expand_list($arg)
                                                }
                                            }
                                            else {
                                                my $m = Perlito5::Grammar::Expression::list_parse($str, $p);
                                                if ($m->{'capture'} ne '*undef*') {
                                                    $arg = Perlito5::Grammar::Expression::expand_list($m->{'capture'});
                                                    $p = $m->{'to'}
                                                }
                                            }
                                            $m_name->{'capture'} = ['term', Perlito5::AST::Call::->new('method' => $full_name, 'invocant' => Perlito5::Match::flat($invocant), 'arguments' => $arg)];
                                            $m_name->{'to'} = $p;
                                            return $m_name
                                        }
                                        if (substr($str, $p, 2) eq '=>') {
                                            $m_name->{'capture'} = ['term', Perlito5::AST::Apply::->new('code' => $name, 'namespace' => $namespace, 'arguments' => [], 'bareword' => 1)];
                                            $m_name->{'to'} = $p;
                                            return $m_name
                                        }
                                        if (substr($str, $p, 2) eq '->') {
                                            if ($is_subroutine_name) {
                                                $m_name->{'capture'} = ['term', Perlito5::AST::Apply::->new('arguments' => [], 'code' => $name, 'namespace' => $namespace)]
                                            }
                                            else {
                                                $m_name->{'capture'} = ['term', Perlito5::AST::Var::->new('name' => '', 'namespace' => $full_name, 'sigil' => '::')]
                                            }
                                            $m_name->{'to'} = $p;
                                            return $m_name
                                        }
                                        my $sig;
                                        if (exists($Perlito5::PROTO->{$effective_name})) {
                                            $sig = $Perlito5::PROTO->{$effective_name}
                                        }
                                        elsif ((!$namespace || $namespace eq 'CORE') && exists($Perlito5::CORE_PROTO->{'CORE::' . $name})) {
                                            $effective_name = 'CORE::' . $name;
                                            $sig = $Perlito5::CORE_PROTO->{$effective_name}
                                        }
                                        else {
                                            my $m = Perlito5::Grammar::Number::val_version($str, $pos);
                                            if ($m) {
                                                $m->{'capture'} = ['term', $m->{'capture'}];
                                                return $m
                                            }
                                            $sig = undef
                                        }
                                        my $has_paren = 0;
                                        if (defined($sig)) {
                                            my $arg_index = 1;
                                            my $optional = 0;
                                            my @args;
                                            my $sig_part = substr($sig, 0, 1);
                                            my $m;
                                            my $capture;
                                            if ($sig_part eq '&') {
                                                $m = Perlito5::Grammar::Space::ws($str, $p);
                                                $m && ($p = $m->{'to'});
                                                if (substr($str, $p, 1) ne '(') {
                                                    $sig = substr($sig, 1);
                                                    $m = Perlito5::Grammar::Bareword::prototype_is_ampersand($str, $p);
                                                    $m && ($capture = $m->{'capture'});
                                                    if (!$m) {
                                                        Perlito5::Compiler::error('Type of arg ' . $arg_index . ' to ' . $name . ' must be block or sub {}')
                                                    }
                                                    $p = $m->{'to'};
                                                    push(@args, $capture)
                                                }
                                            }
                                            if (substr($sig, 0, 1) eq ';' && substr($str, $p, 2) eq '//') {
                                                $m_name->{'capture'} = ['term', Perlito5::AST::Apply::->new('code' => $name, 'namespace' => $namespace, 'arguments' => [], 'bareword' => 1)];
                                                $m_name->{'to'} = $p;
                                                return $m_name
                                            }
                                            if ($sig eq '') {
                                                if (substr($str, $p, 1) eq '(') {
                                                    $p++;
                                                    $has_paren = 1;
                                                    my $m = Perlito5::Grammar::Space::ws($str, $p);
                                                    if ($m) {
                                                        $p = $m->{'to'}
                                                    }
                                                    if (substr($str, $p, 1) ne ')') {
                                                        Perlito5::Compiler::error('syntax error near ', substr($str, $pos, 10))
                                                    }
                                                    $p++
                                                }
                                                if ($name eq '__FILE__') {
                                                    $m_name->{'capture'} = ['term', Perlito5::AST::Buf::->new('buf' => $Perlito5::FILE_NAME)]
                                                }
                                                elsif ($name eq '__LINE__') {
                                                    $m_name->{'capture'} = ['term', Perlito5::AST::Int::->new('int' => $Perlito5::LINE_NUMBER)]
                                                }
                                                else {
                                                    $m_name->{'capture'} = ['term', Perlito5::AST::Apply::->new('code' => $name, 'namespace' => $namespace, 'arguments' => \@args, 'bareword' => ($has_paren == 0))]
                                                }
                                                $m_name->{'to'} = $p;
                                                return $m_name
                                            }
                                            if ($sig eq '_' || $sig eq '$' || $sig eq '+' || $sig eq ';$') {
                                                my $m;
                                                my $arg;
                                                if (substr($str, $p, 1) eq '(') {
                                                    $m = Perlito5::Grammar::Expression::term_paren($str, $p);
                                                    if (!$m) {
                                                        return $m
                                                    }
                                                    $p = $m->{'to'};
                                                    $has_paren = 1;
                                                    $arg = $m->{'capture'}->[2];
                                                    $arg = Perlito5::Grammar::Expression::expand_list($arg);
                                                    my $v = shift(@{$arg});
                                                    @{$arg} && Perlito5::Compiler::error('Too many arguments for ' . $name);
                                                    $arg = $v
                                                }
                                                else {
                                                    $m = Perlito5::Grammar::Expression::argument_parse($str, $p);
                                                    $arg = $m->{'capture'};
                                                    if ($arg eq '*undef*') {
                                                        $arg = undef
                                                    }
                                                    elsif (ref($arg) eq 'Perlito5::AST::Apply' && $arg->{'code'} eq 'circumfix:<( )>') {
                                                        my $v = shift(@{$arg->{'arguments'}});
                                                        @{$arg->{'arguments'}} && Perlito5::Compiler::error('Too many arguments for ' . $name);
                                                        $arg = $v
                                                    }
                                                }
                                                if (defined($arg)) {
                                                    push(@args, $arg);
                                                    $has_paren = 1
                                                }
                                                else {
                                                    $sig eq '$' && Perlito5::Compiler::error('Not enough arguments for ' . $name);
                                                    $sig eq '_' && push(@args, Perlito5::AST::Var::->new('namespace' => '', 'name' => '_', 'sigil' => '$'))
                                                }
                                                my $ast = Perlito5::AST::Apply::->new('code' => $name, 'namespace' => $namespace, 'arguments' => \@args, 'bareword' => ($has_paren == 0));
                                                if ($name eq 'eval' && !$namespace) {
                                                    $ast->{'_scope'} = Perlito5::Grammar::Scope::get_snapshot()
                                                }
                                                $m->{'capture'} = ['term', $ast];
                                                return $m
                                            }
                                            if ($sig eq ';@') {
                                                if (substr($str, $p, 1) eq '(') {
                                                    $m = Perlito5::Grammar::Expression::term_paren($str, $p);
                                                    $has_paren = 1;
                                                    my $arg = $m->{'capture'}->[2];
                                                    $arg = Perlito5::Grammar::Expression::expand_list($arg);
                                                    push(@args, @{$arg})
                                                }
                                                else {
                                                    $m = Perlito5::Grammar::Expression::list_parse($str, $p);
                                                    my $arg = $m->{'capture'};
                                                    if ($arg ne '*undef*') {
                                                        $arg = Perlito5::Grammar::Expression::expand_list($arg);
                                                        push(@args, @{$arg})
                                                    }
                                                }
                                                my $ast = Perlito5::AST::Apply::->new('code' => $name, 'namespace' => $namespace, 'arguments' => \@args, 'bareword' => ($has_paren == 0));
                                                $m->{'capture'} = ['term', $ast];
                                                return $m
                                            }
                                            if ($sig eq '*') {}
                                        }
                                        if (substr($str, $p, 1) eq '(') {
                                            $m = Perlito5::Grammar::Expression::term_paren($str, $p);
                                            if (!$m) {
                                                return $m
                                            }
                                            my $arg = $m->{'capture'}->[2];
                                            $arg = Perlito5::Grammar::Expression::expand_list($arg);
                                            if ($namespace eq '' || $namespace eq 'CORE') {
                                                if ($name eq 'local' || $name eq 'my' || $name eq 'state' || $name eq 'our') {
                                                    my $declarator = $name;
                                                    for my $var (@{$arg}) {
                                                        if (ref($var) eq 'Perlito5::AST::Apply' && $var->{'code'} eq 'undef') {}
                                                        else {
                                                            my $decl = Perlito5::AST::Decl::->new('decl' => $declarator, 'type' => '', 'var' => $var, 'attributes' => []);
                                                            $var->{'_decl'} = $name;
                                                            $var->{'_id'} = $Perlito5::ID++;
                                                            $declarator eq 'our' && ($var->{'_namespace'} = $Perlito5::PKG_NAME);
                                                            $declarator eq 'local' && !$var->{'namespace'} && !$var->{'_namespace'} && ($var->{'_namespace'} = $Perlito5::PKG_NAME)
                                                        }
                                                    }
                                                }
                                                if ($name eq 'print' || $name eq 'say') {
                                                    if (@{$arg} == 0) {
                                                        push(@{$arg}, Perlito5::AST::Var::->new('namespace' => '', 'name' => '_', 'sigil' => '$'))
                                                    }
                                                }
                                                if ($name eq 'split') {
                                                    if (@{$arg} == 0) {
                                                        push(@{$arg}, Perlito5::AST::Buf::->new('buf' => ' '))
                                                    }
                                                    if (@{$arg} == 1) {
                                                        push(@{$arg}, Perlito5::AST::Var::->new('namespace' => '', 'name' => '_', 'sigil' => '$'))
                                                    }
                                                }
                                            }
                                            $m->{'capture'} = ['term', Perlito5::AST::Apply::->new('code' => $name, 'namespace' => $namespace, 'arguments' => $arg, 'proto' => $sig)];
                                            return $m
                                        }
                                        my $m_list = Perlito5::Grammar::Expression::list_parse($str, $p);
                                        my $list = $m_list->{'capture'};
                                        if ($list ne '*undef*') {
                                            $m_name->{'capture'} = ['postfix_or_term', 'funcall', $namespace, $name, $list];
                                            $m_name->{'to'} = $m_list->{'to'};
                                            return $m_name
                                        }
                                        if ($namespace eq '' || $namespace eq 'CORE') {
                                            if ($name eq 'print' || $name eq 'say') {
                                                $m_name->{'capture'} = ['term', Perlito5::AST::Apply::->new('code' => $name, 'namespace' => $namespace, 'arguments' => [Perlito5::AST::Var::->new('namespace' => '', 'name' => '_', 'sigil' => '$')])];
                                                return $m_name
                                            }
                                            if ($name eq 'split' && ($namespace eq '' || $namespace eq 'CORE')) {
                                                $m_name->{'capture'} = ['term', Perlito5::AST::Apply::->new('code' => $name, 'namespace' => $namespace, 'arguments' => [Perlito5::AST::Buf::->new('buf' => ' '), Perlito5::AST::Var::->new('namespace' => '', 'name' => '_', 'sigil' => '$')])];
                                                return $m_name
                                            }
                                        }
                                        $m_name->{'capture'} = ['postfix_or_term', 'funcall_no_params', $namespace, $name];
                                        return $m_name
                                    }
                                    sub Perlito5::Grammar::Bareword::prototype_is_ampersand {
                                        my $str = $_[0];
                                        my $pos = $_[1];
                                        my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
                                        my $tmp = ((do {
                                            my $pos1 = $MATCH->{'to'};
                                            (do {
                                                (('sub' eq substr($str, $MATCH->{'to'}, 3) && ($MATCH->{'to'} = 3 + $MATCH->{'to'})) && (do {
                                                    my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{'to'});
                                                    if ($m2) {
                                                        $MATCH->{'to'} = $m2->{'to'};
                                                        1
                                                    }
                                                    else {
                                                        0
                                                    }
                                                }) && (do {
                                                    my $m2 = Perlito5::Grammar::Block::anon_sub_def($str, $MATCH->{'to'});
                                                    if ($m2) {
                                                        $MATCH->{'to'} = $m2->{'to'};
                                                        $MATCH->{'Perlito5::Grammar::Block::anon_sub_def'} = $m2;
                                                        1
                                                    }
                                                    else {
                                                        0
                                                    }
                                                }) && (do {
                                                    $MATCH->{'capture'} = Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::Block::anon_sub_def'});
                                                    1
                                                }))
                                            }) || (do {
                                                $MATCH->{'to'} = $pos1;
                                                ((do {
                                                    my $m2 = Perlito5::Grammar::block($str, $MATCH->{'to'});
                                                    if ($m2) {
                                                        $MATCH->{'to'} = $m2->{'to'};
                                                        $MATCH->{'Perlito5::Grammar::block'} = $m2;
                                                        1
                                                    }
                                                    else {
                                                        0
                                                    }
                                                }) && (do {
                                                    $MATCH->{'capture'} = Perlito5::AST::Sub::->new('attributes' => [], 'block' => Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::block'}), 'name' => undef, 'namespace' => undef, 'sig' => undef);
                                                    1
                                                }))
                                            }) || (do {
                                                $MATCH->{'to'} = $pos1;
                                                ((do {
                                                    my $tmp = $MATCH;
                                                    $MATCH = {'from' => $tmp->{'to'}, 'to' => $tmp->{'to'}};
                                                    my $res = ((chr(92) eq substr($str, $MATCH->{'to'}, 2) && ($MATCH->{'to'} = 2 + $MATCH->{'to'})) && (do {
                                                        my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{'to'});
                                                        if ($m2) {
                                                            $MATCH->{'to'} = $m2->{'to'};
                                                            1
                                                        }
                                                        else {
                                                            0
                                                        }
                                                    }) && ('&' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})));
                                                    $MATCH = $tmp;
                                                    $res ? 1 : 0
                                                }) && (do {
                                                    my $m2 = Perlito5::Grammar::Expression::argument_parse($str, $MATCH->{'to'});
                                                    if ($m2) {
                                                        $MATCH->{'to'} = $m2->{'to'};
                                                        $MATCH->{'Perlito5::Grammar::Expression::argument_parse'} = $m2;
                                                        1
                                                    }
                                                    else {
                                                        0
                                                    }
                                                }) && (do {
                                                    $MATCH->{'capture'} = Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::Expression::argument_parse'});
                                                    1
                                                }))
                                            })
                                        }));
                                        $tmp ? $MATCH : 0
                                    }
                                    1
                                }
                            }
                            {
                                {
                                    package main;
                                    undef();
                                    package Perlito5::Grammar::Attribute;
                                    sub Perlito5::Grammar::Attribute::opt_attribute {
                                        my $str = $_[0];
                                        my $pos = $_[1];
                                        my @attributes;
                                        my $ws = Perlito5::Grammar::Space::opt_ws($str, $pos);
                                        if (substr($str, $ws->{'to'}, 1) ne ':') {
                                            return {'to' => $pos, 'capture' => []}
                                        }
                                        $ws = Perlito5::Grammar::Space::opt_ws($str, $ws->{'to'} + 1);
                                        my $p = $ws->{'to'};
                                        my $m = Perlito5::Grammar::ident($str, $p);
                                        !$m && Perlito5::Compiler::error('syntax error');
                                        my $to;
                                        while (1) {
                                            my $attr = [Perlito5::Match::flat($m), undef];
                                            $to = $m->{'to'};
                                            my $delimiter = substr($str, $to, 1);
                                            if ($delimiter eq '(') {
                                                my $params = Perlito5::Grammar::String::string_interpolation_parse($str, $m->{'to'} + 1, '(', ')', 0);
                                                !$params && Perlito5::Compiler::error('syntax error');
                                                $attr->[1] = Perlito5::Match::flat($params)->{'buf'};
                                                $to = $params->{'to'}
                                            }
                                            push(@attributes, $attr);
                                            $ws = Perlito5::Grammar::Space::opt_ws($str, $to);
                                            if (substr($str, $ws->{'to'}, 1) eq ':') {
                                                $ws = Perlito5::Grammar::Space::opt_ws($str, $ws->{'to'} + 1)
                                            }
                                            $p = $ws->{'to'};
                                            $m = Perlito5::Grammar::ident($str, $p);
                                            !$m && return {'to' => $to, 'capture' => \@attributes}
                                        }
                                    }
                                    1
                                }
                            }
                            {
                                {
                                    package main;
                                    package Perlito5::Grammar::Statement;
                                    {
                                        {
                                            package main;
                                            undef();
                                            package Perlito5::Macro;
                                            # use strict
                                            {
                                                package Perlito5::AST::Apply;
                                                # use strict
                                                my %op = ('infix:<+=>' => 'infix:<+>', 'infix:<-=>' => 'infix:<->', 'infix:<*=>' => 'infix:<*>', 'infix:</=>' => 'infix:</>', 'infix:<||=>' => 'infix:<||>', 'infix:<&&=>' => 'infix:<&&>', 'infix:<|=>' => 'infix:<|>', 'infix:<&=>' => 'infix:<&>', 'infix:<//=>' => 'infix:<//>', 'infix:<.=>' => 'list:<.>', 'infix:<x=>' => 'infix:<x>');
                                                sub Perlito5::AST::Apply::op_assign {
                                                    my $self = $_[0];
                                                    my $code = $self->{'code'};
                                                    ref($code) && return 0;
                                                    if (exists($op{$code})) {
                                                        return Perlito5::AST::Apply::->new('code' => 'infix:<=>', 'arguments' => [$self->{'arguments'}->[0], Perlito5::AST::Apply::->new('code' => $op{$code}, 'arguments' => $self->{'arguments'})])
                                                    }
                                                    return 0
                                                }
                                                my %op_auto = ('prefix:<++>' => 1, 'prefix:<-->' => 1, 'postfix:<++>' => 1, 'postfix:<-->' => 1);
                                                sub Perlito5::AST::Apply::op_auto {
                                                    my $self = $_[0];
                                                    my $code = $self->{'code'};
                                                    ref($code) && return 0;
                                                    if (exists($op_auto{$code})) {
                                                        my $paren = $self->{'arguments'}->[0];
                                                        if ($paren->{'code'} eq 'circumfix:<( )>') {
                                                            my $arg = $paren->{'arguments'}->[-1];
                                                            if ($arg->{'code'} eq 'infix:<=>') {
                                                                my $var = $arg->{'arguments'}->[0];
                                                                return Perlito5::AST::Apply::->new('code' => 'do', 'arguments' => [Perlito5::AST::Block::->new('stmts' => [$paren, Perlito5::AST::Apply::->new('code' => $code, 'arguments' => [$var])])])
                                                            }
                                                        }
                                                    }
                                                    return 0
                                                }
                                            }
                                            sub Perlito5::Macro::while_file {
                                                my $self = $_[0];
                                                ref($self) ne 'Perlito5::AST::While' && return 0;
                                                my $cond = $self->{'cond'};
                                                if ($cond->isa('Perlito5::AST::Apply') && ($cond->{'code'} eq 'readline')) {
                                                    $self->{'cond'} = bless({'arguments' => [bless({'arguments' => [Perlito5::AST::Var::->new('name' => '_', 'namespace' => '', 'sigil' => '$'), $cond], 'code' => 'infix:<=>', 'namespace' => ''}, 'Perlito5::AST::Apply')], 'bareword' => '', 'code' => 'defined', 'namespace' => ''}, 'Perlito5::AST::Apply');
                                                    return $self
                                                }
                                                return 0
                                            }
                                        }
                                    }
                                    my @Statement_chars;
                                    my %Statement;
                                    sub Perlito5::Grammar::Statement::add_statement {
                                        my $name = shift;
                                        my $param = shift;
                                        $Statement{$name} = $param;
                                        unshift(@Statement_chars, scalar(@Statement_chars) + 1)
                                            while @Statement_chars < length($name)
                                    }
                                    sub Perlito5::Grammar::Statement::stmt_yadayada {
                                        my $str = $_[0];
                                        my $pos = $_[1];
                                        my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
                                        my $tmp = ((('...' eq substr($str, $MATCH->{'to'}, 3) && ($MATCH->{'to'} = 3 + $MATCH->{'to'})) && (do {
                                            $MATCH->{'capture'} = Perlito5::AST::Apply::->new('code' => 'die', 'namespace' => '', 'arguments' => [Perlito5::AST::Buf::->new('buf' => 'Unimplemented')]);
                                            1
                                        })));
                                        $tmp ? $MATCH : 0
                                    }
                                    sub Perlito5::Grammar::Statement::stmt_format {
                                        my $str = $_[0];
                                        my $pos = $_[1];
                                        my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
                                        my $tmp = ((('format' eq substr($str, $MATCH->{'to'}, 6) && ($MATCH->{'to'} = 6 + $MATCH->{'to'})) && (do {
                                            my $m2 = Perlito5::Grammar::Space::ws($str, $MATCH->{'to'});
                                            if ($m2) {
                                                $MATCH->{'to'} = $m2->{'to'};
                                                1
                                            }
                                            else {
                                                0
                                            }
                                        }) && (do {
                                            my $pos1 = $MATCH->{'to'};
                                            (do {
                                                (do {
                                                    my $m2 = Perlito5::Grammar::full_ident($str, $MATCH->{'to'});
                                                    if ($m2) {
                                                        $MATCH->{'to'} = $m2->{'to'};
                                                        $MATCH->{'Perlito5::Grammar::full_ident'} = $m2;
                                                        1
                                                    }
                                                    else {
                                                        0
                                                    }
                                                })
                                            }) || (do {
                                                $MATCH->{'to'} = $pos1;
                                                (do {
                                                    $MATCH->{'Perlito5::Grammar::full_ident'} = 'STDOUT';
                                                    1
                                                })
                                            })
                                        }) && (do {
                                            my $placeholder = Perlito5::AST::Apply::->new('code' => 'list:<.>', 'namespace' => '', 'arguments' => [Perlito5::AST::Apply::->new('code' => 'list:<.>', 'namespace' => '', 'arguments' => [])]);
                                            push(@Perlito5::Grammar::String::Here_doc, ['single_quote', $placeholder->{'arguments'}->[0]->{'arguments'}, '.']);
                                            $MATCH->{'capture'} = Perlito5::AST::Apply::->new('code' => 'p5:format', 'namespace' => '', 'arguments' => [Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::full_ident'}), $placeholder]);
                                            1
                                        }) && (do {
                                            my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{'to'});
                                            if ($m2) {
                                                $MATCH->{'to'} = $m2->{'to'};
                                                1
                                            }
                                            else {
                                                0
                                            }
                                        }) && ('=' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                                            my $m2 = Perlito5::Grammar::Space::ws($str, $MATCH->{'to'});
                                            if ($m2) {
                                                $MATCH->{'to'} = $m2->{'to'};
                                                1
                                            }
                                            else {
                                                0
                                            }
                                        })));
                                        $tmp ? $MATCH : 0
                                    }
                                    sub Perlito5::Grammar::Statement::stmt_package {
                                        my $str = $_[0];
                                        my $pos = $_[1];
                                        my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
                                        my $tmp = ((('package' eq substr($str, $MATCH->{'to'}, 7) && ($MATCH->{'to'} = 7 + $MATCH->{'to'})) && (do {
                                            my $m2 = Perlito5::Grammar::Space::ws($str, $MATCH->{'to'});
                                            if ($m2) {
                                                $MATCH->{'to'} = $m2->{'to'};
                                                1
                                            }
                                            else {
                                                0
                                            }
                                        }) && (do {
                                            my $m2 = Perlito5::Grammar::full_ident($str, $MATCH->{'to'});
                                            if ($m2) {
                                                $MATCH->{'to'} = $m2->{'to'};
                                                $MATCH->{'Perlito5::Grammar::full_ident'} = $m2;
                                                1
                                            }
                                            else {
                                                0
                                            }
                                        }) && (do {
                                            my $pos1 = $MATCH->{'to'};
                                            (do {
                                                ((do {
                                                    my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{'to'});
                                                    if ($m2) {
                                                        $MATCH->{'to'} = $m2->{'to'};
                                                        1
                                                    }
                                                    else {
                                                        0
                                                    }
                                                }) && (do {
                                                    my $name = Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::full_ident'});
                                                    $MATCH->{'_package'} = $Perlito5::PKG_NAME;
                                                    $Perlito5::PACKAGES->{$name} = 1;
                                                    $Perlito5::PKG_NAME = $name;
                                                    1
                                                }) && (do {
                                                    my $m2 = Perlito5::Grammar::block($str, $MATCH->{'to'});
                                                    if ($m2) {
                                                        $MATCH->{'to'} = $m2->{'to'};
                                                        $MATCH->{'Perlito5::Grammar::block'} = $m2;
                                                        1
                                                    }
                                                    else {
                                                        0
                                                    }
                                                }) && (do {
                                                    $MATCH->{'capture'} = Perlito5::AST::Block::->new('stmts' => [Perlito5::AST::Apply::->new('code' => 'package', 'arguments' => [], 'namespace' => Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::full_ident'})), @{$MATCH->{'Perlito5::Grammar::block'}->{'capture'}->{'stmts'}}]);
                                                    $Perlito5::PKG_NAME = $MATCH->{'_package'};
                                                    1
                                                }))
                                            }) || (do {
                                                $MATCH->{'to'} = $pos1;
                                                (do {
                                                    my $name = Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::full_ident'});
                                                    $Perlito5::PACKAGES->{$name} = 1;
                                                    $Perlito5::PKG_NAME = $name;
                                                    $MATCH->{'capture'} = Perlito5::AST::Apply::->new('code' => 'package', 'arguments' => [], 'namespace' => $name);
                                                    1
                                                })
                                            })
                                        })));
                                        $tmp ? $MATCH : 0
                                    }
                                    sub Perlito5::Grammar::Statement::exp_stmt {
                                        my $str = $_[0];
                                        my $pos = $_[1];
                                        for my $len (@Statement_chars) {
                                            my $term = substr($str, $pos, $len);
                                            if (exists($Statement{$term})) {
                                                my $m = $Statement{$term}->($str, $pos);
                                                $m && return $m
                                            }
                                        }
                                        return 0
                                    }
                                    my @Modifier_chars = (7, 6, 5, 4, 3, 2);
                                    my %Modifier = ('if' => 1, 'unless' => 1, 'when' => 1, 'for' => 1, 'foreach' => 1, 'while' => 1, 'until' => 1, 'given' => 1);
                                    sub Perlito5::Grammar::Statement::statement_modifier {
                                        my $str = $_[0];
                                        my $pos = $_[1];
                                        my $expression = $_[2];
                                        for my $len (@Modifier_chars) {
                                            my $term = substr($str, $pos, $len);
                                            if (exists($Modifier{$term})) {
                                                my $m = modifier($str, $pos + $len, $term, $expression);
                                                $m && return $m
                                            }
                                        }
                                        return 0
                                    }
                                    sub Perlito5::Grammar::Statement::modifier {
                                        my $str = $_[0];
                                        my $pos = $_[1];
                                        my $modifier = $_[2];
                                        my $expression = $_[3];
                                        my $modifier_exp = Perlito5::Grammar::Expression::exp_parse($str, $pos);
                                        if (!$modifier_exp) {
                                            Perlito5::Compiler::error('Expected expression after ' . chr(39), Perlito5::Match::flat($modifier), chr(39))
                                        }
                                        if ($modifier eq 'if') {
                                            return {'str' => $str, 'from' => $pos, 'to' => $modifier_exp->{'to'}, 'capture' => Perlito5::AST::Apply::->new('arguments' => [Perlito5::Match::flat($modifier_exp), $expression], 'code' => 'infix:<&&>', 'namespace' => '')}
                                        }
                                        if ($modifier eq 'unless') {
                                            return {'str' => $str, 'from' => $pos, 'to' => $modifier_exp->{'to'}, 'capture' => Perlito5::AST::Apply::->new('arguments' => [Perlito5::Match::flat($modifier_exp), $expression], 'code' => 'infix:<||>', 'namespace' => '')}
                                        }
                                        if ($modifier eq 'when') {
                                            return {'str' => $str, 'from' => $pos, 'to' => $modifier_exp->{'to'}, 'capture' => Perlito5::AST::When::->new('cond' => Perlito5::Match::flat($modifier_exp), 'body' => $expression)}
                                        }
                                        if ($modifier eq 'while') {
                                            my $stmt = Perlito5::AST::While::->new('cond' => Perlito5::Match::flat($modifier_exp), 'body' => $expression);
                                            my $out = Perlito5::Macro::while_file($stmt);
                                            $out && ($stmt = $out);
                                            return {'str' => $str, 'from' => $pos, 'to' => $modifier_exp->{'to'}, 'capture' => $stmt}
                                        }
                                        if ($modifier eq 'until') {
                                            my $stmt = Perlito5::AST::While::->new('cond' => Perlito5::AST::Apply::->new('arguments' => [Perlito5::Match::flat($modifier_exp)], 'code' => 'prefix:<!>', 'namespace' => ''), 'body' => $expression);
                                            return {'str' => $str, 'from' => $pos, 'to' => $modifier_exp->{'to'}, 'capture' => $stmt}
                                        }
                                        if ($modifier eq 'for' || $modifier eq 'foreach') {
                                            return {'str' => $str, 'from' => $pos, 'to' => $modifier_exp->{'to'}, 'capture' => Perlito5::AST::For::->new('cond' => Perlito5::Match::flat($modifier_exp), 'body' => $expression, 'topic' => Perlito5::AST::Var::->new('namespace' => '', 'name' => '_', 'sigil' => '$'))}
                                        }
                                        Perlito5::Compiler::error('Unexpected statement modifier ' . chr(39) . $modifier . chr(39))
                                    }
                                    sub Perlito5::Grammar::Statement::statement_parse {
                                        my $m = statement_parse_inner(@_);
                                        !@Perlito5::SCOPE_STMT && return $m;
                                        Perlito5::Grammar::Scope::check_variable_declarations();
                                        return $m
                                    }
                                    sub Perlito5::Grammar::Statement::statement_parse_inner {
                                        my $str = $_[0];
                                        my $pos = $_[1];
                                        my $res = exp_stmt($str, $pos);
                                        if ($res) {
                                            return $res
                                        }
                                        $res = Perlito5::Grammar::Expression::exp_parse($str, $pos);
                                        if (!$res) {
                                            return 
                                        }
                                        if (substr($str, $res->{'to'}, 1) eq ':' && $res->{'capture'}->isa('Perlito5::AST::Apply') && $res->{'capture'}->{'bareword'}) {
                                            my $label = $res->{'capture'}->{'code'};
                                            my $ws = Perlito5::Grammar::Space::opt_ws($str, $res->{'to'} + 1);
                                            my $stmt = statement_parse($str, $ws->{'to'});
                                            if ($stmt) {
                                                $stmt->{'capture'}->{'label'} = $label;
                                                return $stmt
                                            }
                                            $res->{'to'} = $ws->{'to'};
                                            $res->{'capture'} = Perlito5::AST::Apply::->new('arguments' => [], 'code' => 'undef', 'namespace' => '', 'label' => $label);
                                            return $res
                                        }
                                        my $modifier = statement_modifier($str, $res->{'to'}, Perlito5::Match::flat($res));
                                        my $p = $modifier ? $modifier->{'to'} : $res->{'to'};
                                        my $terminator = substr($str, $p, 1);
                                        if ($terminator ne ';' && $terminator ne '}' && $terminator ne '') {
                                            my $type = 'Number or Bareword';
                                            $terminator ge 0 && $terminator le 9 && ($type = 'Number');
                                            ($terminator eq '"' || $terminator eq chr(39)) && ($type = 'String');
                                            $terminator eq '$' && ($type = 'Scalar');
                                            $terminator eq '@' && ($type = 'Array');
                                            Perlito5::Compiler::error($type . ' found where operator expected')
                                        }
                                        if (!$modifier) {
                                            return $res
                                        }
                                        return $modifier
                                    }
                                    Perlito5::Grammar::Statement::add_statement('...' => \&stmt_yadayada);
                                    Perlito5::Grammar::Statement::add_statement('package' => \&stmt_package);
                                    Perlito5::Grammar::Statement::add_statement('format' => \&stmt_format);
                                    1
                                }
                            }
                            sub Perlito5::Grammar::Expression::expand_list {
                                my $param_list = shift;
                                if (ref($param_list) eq 'Perlito5::AST::Apply' && $param_list->code() eq 'list:<,>') {
                                    return [grep {
                                        defined($_)
                                    } @{$param_list->arguments()}]
                                }
                                elsif ($param_list eq '*undef*') {
                                    return []
                                }
                                else {
                                    return [$param_list]
                                }
                            }
                            sub Perlito5::Grammar::Expression::block_or_hash {
                                my $o = shift;
                                if (defined($o->sig())) {
                                    return $o
                                }
                                my $stmts = $o->stmts();
                                if (!(defined($stmts)) || scalar(@{$stmts}) == 0) {
                                    return Perlito5::AST::Apply::->new('code' => 'circumfix:<{ }>', 'namespace' => '', 'arguments' => [])
                                }
                                if (scalar(@{$stmts}) != 1) {
                                    return $o
                                }
                                my $stmt = $stmts->[0];
                                if (ref($stmt) eq 'Perlito5::AST::Var') {
                                    return Perlito5::AST::Apply::->new('code' => 'circumfix:<{ }>', 'namespace' => '', 'arguments' => [$stmt])
                                }
                                if (ref($stmt) ne 'Perlito5::AST::Apply') {
                                    return $o
                                }
                                if ($stmt->code() eq 'infix:<=>>' || $stmt->code() eq 'prefix:<%>' || $stmt->code() eq 'prefix:<@>') {
                                    return Perlito5::AST::Apply::->new('code' => 'circumfix:<{ }>', 'namespace' => '', 'arguments' => [$stmt])
                                }
                                if ($stmt->code() ne 'list:<,>') {}
                                return Perlito5::AST::Apply::->new('code' => 'circumfix:<{ }>', 'namespace' => '', 'arguments' => expand_list($stmt))
                            }
                            sub Perlito5::Grammar::Expression::pop_term {
                                my $num_stack = shift;
                                my $v = pop(@{$num_stack});
                                if (ref($v) eq 'ARRAY') {
                                    ref($v->[1]) && return $v->[1];
                                    if ($v->[1] eq 'methcall_no_params') {
                                        $v = Perlito5::AST::Call::->new('invocant' => undef, 'method' => $v->[2], 'arguments' => []);
                                        return $v
                                    }
                                    if ($v->[1] eq 'funcall_no_params') {
                                        $v = Perlito5::AST::Apply::->new('code' => $v->[3], 'namespace' => $v->[2], 'arguments' => [], 'bareword' => 1);
                                        return $v
                                    }
                                    if ($v->[1] eq 'methcall') {
                                        my $param_list = expand_list(($v->[3]));
                                        $v = Perlito5::AST::Call::->new('invocant' => undef, 'method' => $v->[2], 'arguments' => $param_list);
                                        return $v
                                    }
                                    if ($v->[1] eq 'funcall') {
                                        my $param_list = expand_list(($v->[4]));
                                        $v = Perlito5::AST::Apply::->new('code' => $v->[3], 'arguments' => $param_list, 'namespace' => $v->[2]);
                                        return $v
                                    }
                                    if ($v->[1] eq '( )') {
                                        my $param_list = expand_list($v->[2]);
                                        $v = Perlito5::AST::Apply::->new('code' => 'circumfix:<( )>', 'arguments' => $param_list, 'namespace' => '');
                                        return $v
                                    }
                                    if ($v->[1] eq '[ ]') {
                                        my $param_list = expand_list($v->[2]);
                                        $v = Perlito5::AST::Apply::->new('code' => 'circumfix:<[ ]>', 'arguments' => $param_list, 'namespace' => '');
                                        return $v
                                    }
                                    if ($v->[1] eq 'block') {
                                        $v = Perlito5::AST::Block::->new('stmts' => $v->[2], 'sig' => $v->[3]);
                                        $v = block_or_hash($v);
                                        return $v
                                    }
                                    if ($v->[1] eq '.( )') {
                                        $v = Perlito5::AST::Call::->new('invocant' => undef, 'method' => 'postcircumfix:<( )>', 'arguments' => $v->[2]);
                                        return $v
                                    }
                                    if ($v->[1] eq '.[ ]') {
                                        $v = Perlito5::AST::Index::->new('obj' => undef, 'index_exp' => $v->[2]);
                                        return $v
                                    }
                                    if ($v->[1] eq '.{ }') {
                                        $v = Perlito5::AST::Lookup::->new('obj' => undef, 'index_exp' => $v->[2]);
                                        return $v
                                    }
                                    return $v->[1]
                                }
                                return $v
                            }
                            sub Perlito5::Grammar::Expression::reduce_postfix {
                                my $op = shift;
                                my $value = shift;
                                my $v = $op;
                                if ($v->[1] eq 'methcall_no_params') {
                                    $v = Perlito5::AST::Call::->new('invocant' => $value, 'method' => $v->[2], 'arguments' => [], (ref($v->[2]) ? () : ('_no_params' => 1)));
                                    return $v
                                }
                                if ($v->[1] eq 'funcall_no_params') {
                                    Perlito5::Compiler::error('Bareword found where operator expected')
                                }
                                if ($v->[1] eq 'methcall') {
                                    my $param_list = expand_list($v->[3]);
                                    $v = Perlito5::AST::Call::->new('invocant' => $value, 'method' => $v->[2], 'arguments' => $param_list);
                                    return $v
                                }
                                if ($v->[1] eq 'funcall') {
                                    Perlito5::Compiler::error('unexpected function call')
                                }
                                if ($v->[1] eq '( )') {
                                    my $param_list = expand_list($v->[2]);
                                    if (ref($value) eq 'Perlito5::AST::Apply' && !(defined($value->arguments()))) {
                                        $value->{'arguments'} = $param_list;
                                        return $value
                                    }
                                    if (ref($value) eq 'Perlito5::AST::Call' && !(defined($value->arguments()))) {
                                        $value->{'arguments'} = $param_list;
                                        return $value
                                    }
                                    $v = Perlito5::AST::Call::->new('invocant' => $value, 'method' => 'postcircumfix:<( )>', 'arguments' => $param_list);
                                    return $v
                                }
                                if ($v->[1] eq '[ ]') {
                                    if (ref($value) eq 'Perlito5::AST::Var') {
                                        $value->{'_real_sigil'} = '@'
                                    }
                                    $v = Perlito5::AST::Index::->new('obj' => $value, 'index_exp' => $v->[2]);
                                    return $v
                                }
                                if ($v->[1] eq 'block') {
                                    if (ref($value) eq 'Perlito5::AST::Var') {
                                        $value->{'_real_sigil'} = '%'
                                    }
                                    $v = Perlito5::AST::Lookup::->new('obj' => $value, 'index_exp' => $v->[2]->[0]);
                                    return $v
                                }
                                if ($v->[1] eq '.( )') {
                                    my $param_list = expand_list($v->[2]);
                                    $v = Perlito5::AST::Call::->new('invocant' => $value, 'method' => 'postcircumfix:<( )>', 'arguments' => $param_list);
                                    return $v
                                }
                                if ($v->[1] eq '.[ ]') {
                                    $v = Perlito5::AST::Call::->new('invocant' => $value, 'method' => 'postcircumfix:<[ ]>', 'arguments' => $v->[2]);
                                    return $v
                                }
                                if ($v->[1] eq '.{ }') {
                                    $v = Perlito5::AST::Call::->new('invocant' => $value, 'method' => 'postcircumfix:<{ }>', 'arguments' => $v->[2]);
                                    return $v
                                }
                                push(@{$op}, $value);
                                return $op
                            }
                            my $reduce_to_ast = sub {
                                my $op_stack = shift;
                                my $num_stack = shift;
                                my $last_op = shift(@{$op_stack});
                                if ($last_op->[0] eq 'prefix') {
                                    push(@{$num_stack}, Perlito5::AST::Apply::->new('namespace' => '', 'code' => 'prefix:<' . $last_op->[1] . '>', 'arguments' => [pop_term($num_stack)]))
                                }
                                elsif ($last_op->[0] eq 'postfix') {
                                    push(@{$num_stack}, Perlito5::AST::Apply::->new('namespace' => '', 'code' => 'postfix:<' . $last_op->[1] . '>', 'arguments' => [pop_term($num_stack)]))
                                }
                                elsif ($last_op->[0] eq 'postfix_or_term') {
                                    push(@{$num_stack}, reduce_postfix($last_op, pop_term($num_stack)))
                                }
                                elsif (Perlito5::Grammar::Precedence::is_assoc_type('list', $last_op->[1])) {
                                    my $arg;
                                    if (scalar(@{$num_stack}) < 2) {
                                        my $v2 = pop_term($num_stack);
                                        if (ref($v2) eq 'Perlito5::AST::Apply' && $v2->code() eq ('list:<' . $last_op->[1] . '>')) {
                                            push(@{$num_stack}, Perlito5::AST::Apply::->new('namespace' => $v2->namespace(), 'code' => $v2->code(), 'arguments' => [@{$v2->arguments()}]))
                                        }
                                        else {
                                            push(@{$num_stack}, Perlito5::AST::Apply::->new('namespace' => '', 'code' => 'list:<' . $last_op->[1] . '>', 'arguments' => [$v2]))
                                        }
                                        return 
                                    }
                                    else {
                                        my $v2 = pop_term($num_stack);
                                        $arg = [pop_term($num_stack), $v2]
                                    }
                                    if (ref($arg->[0]) eq 'Perlito5::AST::Apply' && $last_op->[0] eq 'infix' && ($arg->[0]->code() eq 'list:<' . $last_op->[1] . '>')) {
                                        push(@{$num_stack}, Perlito5::AST::Apply::->new('namespace' => '', 'code' => ($arg->[0])->code(), 'arguments' => [@{($arg->[0])->arguments()}, $arg->[1]]));
                                        return 
                                    }
                                    push(@{$num_stack}, Perlito5::AST::Apply::->new('namespace' => '', 'code' => 'list:<' . $last_op->[1] . '>', 'arguments' => $arg))
                                }
                                elsif (Perlito5::Grammar::Precedence::is_assoc_type('chain', $last_op->[1])) {
                                    if (scalar(@{$num_stack}) < 2) {
                                        Perlito5::Compiler::error('Missing value after operator ' . $last_op->[1])
                                    }
                                    my $v2 = pop_term($num_stack);
                                    my $arg = [pop_term($num_stack), $v2];
                                    push(@{$num_stack}, Perlito5::AST::Apply::->new('namespace' => '', 'code' => 'infix:<' . $last_op->[1] . '>', 'arguments' => $arg))
                                }
                                elsif ($last_op->[0] eq 'ternary') {
                                    if (scalar(@{$num_stack}) < 2) {
                                        Perlito5::Compiler::error('Missing value after ternary operator')
                                    }
                                    my $v2 = pop_term($num_stack);
                                    push(@{$num_stack}, Perlito5::AST::Apply::->new('namespace' => '', 'code' => 'ternary:<' . $last_op->[1] . '>', 'arguments' => [pop_term($num_stack), $last_op->[2], $v2]))
                                }
                                else {
                                    if (scalar(@{$num_stack}) < 2) {
                                        Perlito5::Compiler::error('missing value after operator ' . chr(39) . $last_op->[1] . chr(39))
                                    }
                                    my $v2 = pop_term($num_stack);
                                    push(@{$num_stack}, Perlito5::AST::Apply::->new('namespace' => '', 'code' => 'infix:<' . $last_op->[1] . '>', 'arguments' => [pop_term($num_stack), $v2]))
                                }
                            };
                            sub Perlito5::Grammar::Expression::term_arrow {
                                my $str = $_[0];
                                my $pos = $_[1];
                                my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
                                my $tmp = ((('->' eq substr($str, $MATCH->{'to'}, 2) && ($MATCH->{'to'} = 2 + $MATCH->{'to'})) && (do {
                                    my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{'to'});
                                    if ($m2) {
                                        $MATCH->{'to'} = $m2->{'to'};
                                        1
                                    }
                                    else {
                                        0
                                    }
                                }) && (do {
                                    my $pos1 = $MATCH->{'to'};
                                    (do {
                                        (('(' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                                            my $m2 = paren_parse($str, $MATCH->{'to'});
                                            if ($m2) {
                                                $MATCH->{'to'} = $m2->{'to'};
                                                $MATCH->{'paren_parse'} = $m2;
                                                1
                                            }
                                            else {
                                                0
                                            }
                                        }) && (')' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                                            $MATCH->{'capture'} = ['postfix_or_term', '.( )', Perlito5::Match::flat($MATCH->{'paren_parse'})];
                                            1
                                        }))
                                    }) || (do {
                                        $MATCH->{'to'} = $pos1;
                                        (('[' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                                            my $m2 = square_parse($str, $MATCH->{'to'});
                                            if ($m2) {
                                                $MATCH->{'to'} = $m2->{'to'};
                                                $MATCH->{'square_parse'} = $m2;
                                                1
                                            }
                                            else {
                                                0
                                            }
                                        }) && (']' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                                            $MATCH->{'capture'} = ['postfix_or_term', '.[ ]', Perlito5::Match::flat($MATCH->{'square_parse'})];
                                            1
                                        }))
                                    }) || (do {
                                        $MATCH->{'to'} = $pos1;
                                        (('{' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                                            my $pos1 = $MATCH->{'to'};
                                            (do {
                                                ((do {
                                                    my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{'to'});
                                                    if ($m2) {
                                                        $MATCH->{'to'} = $m2->{'to'};
                                                        1
                                                    }
                                                    else {
                                                        0
                                                    }
                                                }) && (do {
                                                    my $m2 = Perlito5::Grammar::ident($str, $MATCH->{'to'});
                                                    if ($m2) {
                                                        $MATCH->{'to'} = $m2->{'to'};
                                                        $MATCH->{'Perlito5::Grammar::ident'} = $m2;
                                                        1
                                                    }
                                                    else {
                                                        0
                                                    }
                                                }) && (do {
                                                    my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{'to'});
                                                    if ($m2) {
                                                        $MATCH->{'to'} = $m2->{'to'};
                                                        1
                                                    }
                                                    else {
                                                        0
                                                    }
                                                }) && ('}' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                                                    $MATCH->{'capture'} = ['postfix_or_term', '.{ }', Perlito5::AST::Buf::->new('buf' => Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::ident'}))];
                                                    1
                                                }))
                                            }) || (do {
                                                $MATCH->{'to'} = $pos1;
                                                ((do {
                                                    my $m2 = curly_parse($str, $MATCH->{'to'});
                                                    if ($m2) {
                                                        $MATCH->{'to'} = $m2->{'to'};
                                                        $MATCH->{'curly_parse'} = $m2;
                                                        1
                                                    }
                                                    else {
                                                        0
                                                    }
                                                }) && (do {
                                                    my $pos1 = $MATCH->{'to'};
                                                    (do {
                                                        ('}' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}))
                                                    }) || (do {
                                                        $MATCH->{'to'} = $pos1;
                                                        (do {
                                                            Perlito5::Compiler::error('Missing right curly or square bracket');
                                                            1
                                                        })
                                                    })
                                                }) && (do {
                                                    $MATCH->{'capture'} = ['postfix_or_term', '.{ }', Perlito5::Match::flat($MATCH->{'curly_parse'})];
                                                    1
                                                }))
                                            })
                                        }))
                                    }) || (do {
                                        $MATCH->{'to'} = $pos1;
                                        (('$' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                                            my $m2 = Perlito5::Grammar::ident($str, $MATCH->{'to'});
                                            if ($m2) {
                                                $MATCH->{'to'} = $m2->{'to'};
                                                $MATCH->{'Perlito5::Grammar::ident'} = $m2;
                                                1
                                            }
                                            else {
                                                0
                                            }
                                        }) && (do {
                                            my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{'to'});
                                            if ($m2) {
                                                $MATCH->{'to'} = $m2->{'to'};
                                                1
                                            }
                                            else {
                                                0
                                            }
                                        }) && (do {
                                            my $pos1 = $MATCH->{'to'};
                                            (do {
                                                (('(' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                                                    my $m2 = paren_parse($str, $MATCH->{'to'});
                                                    if ($m2) {
                                                        $MATCH->{'to'} = $m2->{'to'};
                                                        $MATCH->{'paren_parse'} = $m2;
                                                        1
                                                    }
                                                    else {
                                                        0
                                                    }
                                                }) && (')' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                                                    $MATCH->{'capture'} = ['postfix_or_term', 'methcall', Perlito5::AST::Var::->new('sigil' => '$', 'namespace' => '', 'name' => Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::ident'})), Perlito5::Match::flat($MATCH->{'paren_parse'})];
                                                    1
                                                }))
                                            }) || (do {
                                                $MATCH->{'to'} = $pos1;
                                                (do {
                                                    $MATCH->{'capture'} = ['postfix_or_term', 'methcall_no_params', Perlito5::AST::Var::->new('sigil' => '$', 'namespace' => '', 'name' => Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::ident'}))];
                                                    1
                                                })
                                            })
                                        }))
                                    }) || (do {
                                        $MATCH->{'to'} = $pos1;
                                        ((do {
                                            my $m2 = Perlito5::Grammar::full_ident($str, $MATCH->{'to'});
                                            if ($m2) {
                                                $MATCH->{'to'} = $m2->{'to'};
                                                $MATCH->{'Perlito5::Grammar::full_ident'} = $m2;
                                                1
                                            }
                                            else {
                                                0
                                            }
                                        }) && (do {
                                            my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{'to'});
                                            if ($m2) {
                                                $MATCH->{'to'} = $m2->{'to'};
                                                1
                                            }
                                            else {
                                                0
                                            }
                                        }) && (do {
                                            my $pos1 = $MATCH->{'to'};
                                            (do {
                                                (('(' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                                                    my $m2 = paren_parse($str, $MATCH->{'to'});
                                                    if ($m2) {
                                                        $MATCH->{'to'} = $m2->{'to'};
                                                        $MATCH->{'paren_parse'} = $m2;
                                                        1
                                                    }
                                                    else {
                                                        0
                                                    }
                                                }) && (')' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                                                    $MATCH->{'capture'} = ['postfix_or_term', 'methcall', Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::full_ident'}), Perlito5::Match::flat($MATCH->{'paren_parse'})];
                                                    1
                                                }))
                                            }) || (do {
                                                $MATCH->{'to'} = $pos1;
                                                (do {
                                                    $MATCH->{'capture'} = ['postfix_or_term', 'methcall_no_params', Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::full_ident'})];
                                                    1
                                                })
                                            })
                                        }))
                                    })
                                })));
                                $tmp ? $MATCH : 0
                            }
                            sub Perlito5::Grammar::Expression::term_ternary {
                                my $str = $_[0];
                                my $pos = $_[1];
                                my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
                                my $tmp = ((('?' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                                    my $m2 = ternary5_parse($str, $MATCH->{'to'});
                                    if ($m2) {
                                        $MATCH->{'to'} = $m2->{'to'};
                                        $MATCH->{'ternary5_parse'} = $m2;
                                        1
                                    }
                                    else {
                                        0
                                    }
                                }) && (':' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                                    $MATCH->{'capture'} = ['op', '? :', Perlito5::Match::flat($MATCH->{'ternary5_parse'})];
                                    1
                                })));
                                $tmp ? $MATCH : 0
                            }
                            sub Perlito5::Grammar::Expression::term_paren {
                                my $str = $_[0];
                                my $pos = $_[1];
                                my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
                                my $tmp = ((('(' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                                    my $m2 = paren_parse($str, $MATCH->{'to'});
                                    if ($m2) {
                                        $MATCH->{'to'} = $m2->{'to'};
                                        $MATCH->{'paren_parse'} = $m2;
                                        1
                                    }
                                    else {
                                        0
                                    }
                                }) && (')' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                                    $MATCH->{'capture'} = ['postfix_or_term', '( )', Perlito5::Match::flat($MATCH->{'paren_parse'})];
                                    1
                                })));
                                $tmp ? $MATCH : 0
                            }
                            sub Perlito5::Grammar::Expression::term_square {
                                my $str = $_[0];
                                my $pos = $_[1];
                                my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
                                my $tmp = ((('[' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                                    my $m2 = square_parse($str, $MATCH->{'to'});
                                    if ($m2) {
                                        $MATCH->{'to'} = $m2->{'to'};
                                        $MATCH->{'square_parse'} = $m2;
                                        1
                                    }
                                    else {
                                        0
                                    }
                                }) && (']' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                                    $MATCH->{'capture'} = ['postfix_or_term', '[ ]', Perlito5::Match::flat($MATCH->{'square_parse'})];
                                    1
                                })));
                                $tmp ? $MATCH : 0
                            }
                            sub Perlito5::Grammar::Expression::term_curly {
                                my $str = $_[0];
                                my $pos = $_[1];
                                my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
                                my $tmp = ((('{' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                                    my $m = $MATCH;
                                    if (!(do {
                                        my $m2 = Perlito5::Grammar::Space::ws($str, $MATCH->{'to'});
                                        if ($m2) {
                                            $MATCH->{'to'} = $m2->{'to'};
                                            1
                                        }
                                        else {
                                            0
                                        }
                                    })) {
                                        $MATCH = $m
                                    }
                                    1
                                }) && (do {
                                    my $pos1 = $MATCH->{'to'};
                                    (do {
                                        ((do {
                                            my $m2 = Perlito5::Grammar::ident($str, $MATCH->{'to'});
                                            if ($m2) {
                                                $MATCH->{'to'} = $m2->{'to'};
                                                $MATCH->{'Perlito5::Grammar::ident'} = $m2;
                                                1
                                            }
                                            else {
                                                0
                                            }
                                        }) && (do {
                                            my $m = $MATCH;
                                            if (!(do {
                                                my $m2 = Perlito5::Grammar::Space::ws($str, $MATCH->{'to'});
                                                if ($m2) {
                                                    $MATCH->{'to'} = $m2->{'to'};
                                                    1
                                                }
                                                else {
                                                    0
                                                }
                                            })) {
                                                $MATCH = $m
                                            }
                                            1
                                        }) && ('}' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                                            $MATCH->{'capture'} = ['postfix_or_term', 'block', [Perlito5::AST::Apply::->new('arguments' => [], 'bareword' => 1, 'code' => Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::ident'}), 'namespace' => '')]];
                                            1
                                        }))
                                    }) || (do {
                                        $MATCH->{'to'} = $pos1;
                                        ((do {
                                            $MATCH->{'_save_scope'} = [@Perlito5::SCOPE_STMT];
                                            @Perlito5::SCOPE_STMT = ();
                                            1
                                        }) && (do {
                                            my $m2 = Perlito5::Grammar::exp_stmts($str, $MATCH->{'to'});
                                            if ($m2) {
                                                $MATCH->{'to'} = $m2->{'to'};
                                                $MATCH->{'Perlito5::Grammar::exp_stmts'} = $m2;
                                                1
                                            }
                                            else {
                                                0
                                            }
                                        }) && (do {
                                            @Perlito5::SCOPE_STMT = @{$MATCH->{'_save_scope'}};
                                            1
                                        }) && (do {
                                            my $m = $MATCH;
                                            if (!(do {
                                                my $m2 = Perlito5::Grammar::Space::ws($str, $MATCH->{'to'});
                                                if ($m2) {
                                                    $MATCH->{'to'} = $m2->{'to'};
                                                    1
                                                }
                                                else {
                                                    0
                                                }
                                            })) {
                                                $MATCH = $m
                                            }
                                            1
                                        }) && (do {
                                            my $pos1 = $MATCH->{'to'};
                                            (do {
                                                ('}' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}))
                                            }) || (do {
                                                $MATCH->{'to'} = $pos1;
                                                (do {
                                                    Perlito5::Compiler::error('Missing right curly or square bracket');
                                                    1
                                                })
                                            })
                                        }) && (do {
                                            $MATCH->{'capture'} = ['postfix_or_term', 'block', Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::exp_stmts'})];
                                            1
                                        }))
                                    })
                                })));
                                $tmp ? $MATCH : 0
                            }
                            sub Perlito5::Grammar::Expression::declarator {
                                my $str = $_[0];
                                my $pos = $_[1];
                                my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
                                my $tmp = ((do {
                                    my $pos1 = $MATCH->{'to'};
                                    (do {
                                        ('my' eq substr($str, $MATCH->{'to'}, 2) && ($MATCH->{'to'} = 2 + $MATCH->{'to'}))
                                    }) || (do {
                                        $MATCH->{'to'} = $pos1;
                                        ('state' eq substr($str, $MATCH->{'to'}, 5) && ($MATCH->{'to'} = 5 + $MATCH->{'to'}))
                                    }) || (do {
                                        $MATCH->{'to'} = $pos1;
                                        ('our' eq substr($str, $MATCH->{'to'}, 3) && ($MATCH->{'to'} = 3 + $MATCH->{'to'}))
                                    })
                                }));
                                $tmp ? $MATCH : 0
                            }
                            sub Perlito5::Grammar::Expression::term_declarator {
                                my $str = $_[0];
                                my $pos = $_[1];
                                my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
                                my $tmp = (((do {
                                    my $m2 = declarator($str, $MATCH->{'to'});
                                    if ($m2) {
                                        $MATCH->{'to'} = $m2->{'to'};
                                        $MATCH->{'declarator'} = $m2;
                                        1
                                    }
                                    else {
                                        0
                                    }
                                }) && (do {
                                    my $pos1 = $MATCH->{'to'};
                                    (do {
                                        ((do {
                                            my $m2 = Perlito5::Grammar::Space::ws($str, $MATCH->{'to'});
                                            if ($m2) {
                                                $MATCH->{'to'} = $m2->{'to'};
                                                1
                                            }
                                            else {
                                                0
                                            }
                                        }) && (do {
                                            my $pos1 = $MATCH->{'to'};
                                            (do {
                                                ((do {
                                                    my $m2 = Perlito5::Grammar::Block::named_sub($str, $MATCH->{'to'});
                                                    if ($m2) {
                                                        $MATCH->{'to'} = $m2->{'to'};
                                                        $MATCH->{'Perlito5::Grammar::Block::named_sub'} = $m2;
                                                        1
                                                    }
                                                    else {
                                                        0
                                                    }
                                                }) && (do {
                                                    my $sub = $MATCH->{'Perlito5::Grammar::Block::named_sub'}->{'capture'};
                                                    $sub->{'decl'} = Perlito5::Match::flat($MATCH->{'declarator'});
                                                    $MATCH->{'capture'} = ['term', $sub];
                                                    return $MATCH;
                                                    1
                                                }))
                                            }) || (do {
                                                $MATCH->{'to'} = $pos1;
                                                (do {
                                                    my $m2 = Perlito5::Grammar::opt_type($str, $MATCH->{'to'});
                                                    if ($m2) {
                                                        $MATCH->{'to'} = $m2->{'to'};
                                                        $MATCH->{'Perlito5::Grammar::opt_type'} = $m2;
                                                        1
                                                    }
                                                    else {
                                                        0
                                                    }
                                                })
                                            })
                                        }))
                                    }) || (do {
                                        $MATCH->{'to'} = $pos1;
                                        1
                                    })
                                }) && (do {
                                    my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{'to'});
                                    if ($m2) {
                                        $MATCH->{'to'} = $m2->{'to'};
                                        1
                                    }
                                    else {
                                        0
                                    }
                                }) && (do {
                                    my $m2 = Perlito5::Grammar::var_ident($str, $MATCH->{'to'});
                                    if ($m2) {
                                        $MATCH->{'to'} = $m2->{'to'};
                                        $MATCH->{'Perlito5::Grammar::var_ident'} = $m2;
                                        1
                                    }
                                    else {
                                        0
                                    }
                                }) && (do {
                                    my $m2 = Perlito5::Grammar::Attribute::opt_attribute($str, $MATCH->{'to'});
                                    if ($m2) {
                                        $MATCH->{'to'} = $m2->{'to'};
                                        $MATCH->{'Perlito5::Grammar::Attribute::opt_attribute'} = $m2;
                                        1
                                    }
                                    else {
                                        0
                                    }
                                }) && (do {
                                    my $declarator = Perlito5::Match::flat($MATCH->{'declarator'});
                                    my $type = Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::opt_type'});
                                    $type && !$Perlito5::PACKAGES->{$type} && Perlito5::Compiler::error('No such class ' . $type);
                                    my $var = $MATCH->{'Perlito5::Grammar::var_ident'}->{'capture'};
                                    $var->{'namespace'} && Perlito5::Compiler::error('No package name allowed for variable ' . $var->{'sigil'} . $var->{'name'} . ' in "' . $declarator . '"');
                                    $var->{'_decl'} = $declarator;
                                    $var->{'_id'} = $Perlito5::ID++;
                                    $declarator eq 'our' && ($var->{'_namespace'} = $Perlito5::PKG_NAME);
                                    my $decl = Perlito5::AST::Decl::->new('decl' => $declarator, 'type' => $type, 'var' => $var, 'attributes' => Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::Attribute::opt_attribute'}));
                                    $MATCH->{'capture'} = ['term', $decl];
                                    1
                                })));
                                $tmp ? $MATCH : 0
                            }
                            sub Perlito5::Grammar::Expression::term_not {
                                my $str = $_[0];
                                my $pos = $_[1];
                                my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
                                my $tmp = ((('not' eq substr($str, $MATCH->{'to'}, 3) && ($MATCH->{'to'} = 3 + $MATCH->{'to'})) && (do {
                                    my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{'to'});
                                    if ($m2) {
                                        $MATCH->{'to'} = $m2->{'to'};
                                        1
                                    }
                                    else {
                                        0
                                    }
                                }) && ('(' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                                    my $m2 = paren_parse($str, $MATCH->{'to'});
                                    if ($m2) {
                                        $MATCH->{'to'} = $m2->{'to'};
                                        $MATCH->{'paren_parse'} = $m2;
                                        1
                                    }
                                    else {
                                        0
                                    }
                                }) && (')' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                                    $MATCH->{'capture'} = ['term', Perlito5::AST::Apply::->new('code' => 'prefix:<not>', 'arguments' => expand_list(Perlito5::Match::flat($MATCH->{'paren_parse'})), 'namespace' => '')];
                                    1
                                })));
                                $tmp ? $MATCH : 0
                            }
                            sub Perlito5::Grammar::Expression::term_local {
                                my $str = $_[0];
                                my $pos = $_[1];
                                my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
                                my $tmp = ((('local' eq substr($str, $MATCH->{'to'}, 5) && ($MATCH->{'to'} = 5 + $MATCH->{'to'})) && (do {
                                    my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{'to'});
                                    if ($m2) {
                                        $MATCH->{'to'} = $m2->{'to'};
                                        1
                                    }
                                    else {
                                        0
                                    }
                                }) && (do {
                                    my $m2 = Perlito5::Grammar::Sigil::term_sigil($str, $MATCH->{'to'});
                                    if ($m2) {
                                        $MATCH->{'to'} = $m2->{'to'};
                                        $MATCH->{'Perlito5::Grammar::Sigil::term_sigil'} = $m2;
                                        1
                                    }
                                    else {
                                        0
                                    }
                                }) && (do {
                                    my $declarator = 'local';
                                    my $type = '';
                                    $MATCH->{'capture'} = Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::Sigil::term_sigil'})->[1];
                                    $MATCH = Perlito5::Grammar::String::double_quoted_var_with_subscript($MATCH);
                                    my $var = $MATCH->{'capture'};
                                    my $look = Perlito5::Grammar::Scope::lookup_variable($var);
                                    if ($look && ($look->{'_decl'} eq 'my' || $look->{'_decl'} eq 'state')) {
                                        Perlito5::Compiler::error('Can' . chr(39) . 't localize lexical variable ' . $var->{'sigil'} . $var->{'name'})
                                    }
                                    $var->{'_id'} = $Perlito5::ID++;
                                    $var->{'_decl'} = $declarator;
                                    !$var->{'namespace'} && !$var->{'_namespace'} && ($var->{'_namespace'} = $Perlito5::PKG_NAME);
                                    my $decl = Perlito5::AST::Decl::->new('decl' => $declarator, 'type' => $type, 'var' => $var);
                                    $MATCH->{'capture'} = ['term', $decl];
                                    1
                                })));
                                $tmp ? $MATCH : 0
                            }
                            sub Perlito5::Grammar::Expression::term_return {
                                my $str = $_[0];
                                my $pos = $_[1];
                                my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
                                my $tmp = ((('return' eq substr($str, $MATCH->{'to'}, 6) && ($MATCH->{'to'} = 6 + $MATCH->{'to'})) && (do {
                                    my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{'to'});
                                    if ($m2) {
                                        $MATCH->{'to'} = $m2->{'to'};
                                        1
                                    }
                                    else {
                                        0
                                    }
                                }) && (do {
                                    my $m2 = list_parse($str, $MATCH->{'to'});
                                    if ($m2) {
                                        $MATCH->{'to'} = $m2->{'to'};
                                        $MATCH->{'list_parse'} = $m2;
                                        1
                                    }
                                    else {
                                        0
                                    }
                                }) && (do {
                                    my $args = Perlito5::Match::flat($MATCH->{'list_parse'});
                                    $MATCH->{'capture'} = ['term', Perlito5::AST::Apply::->new('code' => 'return', 'arguments' => $args eq '*undef*' ? [] : [$args], 'namespace' => '')];
                                    1
                                })));
                                $tmp ? $MATCH : 0
                            }
                            sub Perlito5::Grammar::Expression::term_eval {
                                my $str = $_[0];
                                my $pos = $_[1];
                                my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
                                my $tmp = ((('eval' eq substr($str, $MATCH->{'to'}, 4) && ($MATCH->{'to'} = 4 + $MATCH->{'to'})) && (do {
                                    my $m2 = Perlito5::Grammar::block($str, $MATCH->{'to'});
                                    if ($m2) {
                                        $MATCH->{'to'} = $m2->{'to'};
                                        $MATCH->{'Perlito5::Grammar::block'} = $m2;
                                        1
                                    }
                                    else {
                                        0
                                    }
                                }) && (do {
                                    $MATCH->{'capture'} = ['term', Perlito5::AST::Apply::->new('code' => 'eval', 'arguments' => [Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::block'})], 'namespace' => '')];
                                    1
                                })));
                                $tmp ? $MATCH : 0
                            }
                            my $Expr_end_token_chars = [7, 6, 5, 4, 3, 2, 1];
                            my $Expr_end_token = {']' => 1, ')' => 1, '}' => 1, ';' => 1, 'if' => 1, 'for' => 1, 'else' => 1, 'when' => 1, 'while' => 1, 'until' => 1, 'elsif' => 1, 'unless' => 1, 'foreach' => 1};
                            my $List_end_token = {':' => 1, 'or' => 1, 'and' => 1, 'xor' => 1, %{$Expr_end_token}};
                            my $Argument_end_token = {',' => 1, '<' => 1, '>' => 1, '=' => 1, '|' => 1, '^' => 1, '?' => 1, '=>' => 1, 'lt' => 1, 'le' => 1, 'gt' => 1, 'ge' => 1, '<=' => 1, '>=' => 1, '==' => 1, '!=' => 1, 'ne' => 1, 'eq' => 1, '..' => 1, '~~' => 1, '&&' => 1, '||' => 1, '+=' => 1, '-=' => 1, '*=' => 1, '/=' => 1, 'x=' => 1, '|=' => 1, '&=' => 1, '.=' => 1, '^=' => 1, '%=' => 1, '//' => 1, '...' => 1, '<=>' => 1, 'cmp' => 1, '<<=' => 1, '>>=' => 1, '||=' => 1, '&&=' => 1, '//=' => 1, '**=' => 1, %{$List_end_token}};
                            sub Perlito5::Grammar::Expression::list_parser {
                                my($str, $pos, $end_token) = @_;
                                my $expr;
                                my $last_pos = $pos;
                                my $is_first_token = 1;
                                my $lexer_stack = [];
                                my $last_token_was_space = 1;
                                my $get_token = sub {
                                    my $last_is_term = $_[0];
                                    my $v;
                                    if (scalar(@{$lexer_stack})) {
                                        $v = pop(@{$lexer_stack});
                                        if ($is_first_token && ($v->[0] eq 'op') && !(Perlito5::Grammar::Precedence::is_fixity_type('prefix', $v->[1]))) {
                                            $v->[0] = 'end'
                                        }
                                    }
                                    else {
                                        my $m = Perlito5::Grammar::Precedence::op_parse($str, $last_pos, $last_is_term);
                                        if ($m) {
                                            my $spc = Perlito5::Grammar::Space::ws($str, $m->{'to'});
                                            if ($spc) {
                                                $m->{'to'} = $spc->{'to'}
                                            }
                                        }
                                        if (!$m) {
                                            return ['end', '*end*']
                                        }
                                        $v = $m->{'capture'};
                                        if ($is_first_token && ($v->[0] eq 'op') && !(Perlito5::Grammar::Precedence::is_fixity_type('prefix', $v->[1]))) {
                                            $v->[0] = 'end'
                                        }
                                        if ($v->[0] ne 'end') {
                                            $last_pos = $m->{'to'}
                                        }
                                    }
                                    $last_token_was_space = ($v->[0] eq 'space');
                                    $is_first_token = 0;
                                    return $v
                                };
                                my $prec = Perlito5::Grammar::Precedence::->new('get_token' => $get_token, 'reduce' => $reduce_to_ast, 'end_token' => $end_token, 'end_token_chars' => $Expr_end_token_chars);
                                my $res = $prec->precedence_parse();
                                if (scalar(@{$res}) == 0) {
                                    return {'str' => $str, 'from' => $pos, 'to' => $last_pos, 'capture' => '*undef*'}
                                }
                                my $result = pop_term($res);
                                return {'str' => $str, 'from' => $pos, 'to' => $last_pos, 'capture' => $result}
                            }
                            sub Perlito5::Grammar::Expression::argument_parse {
                                my($str, $pos) = @_;
                                return list_parser($str, $pos, $Argument_end_token)
                            }
                            sub Perlito5::Grammar::Expression::list_parse {
                                my($str, $pos) = @_;
                                return list_parser($str, $pos, $List_end_token)
                            }
                            sub Perlito5::Grammar::Expression::circumfix_parse {
                                my($str, $pos, $delimiter) = @_;
                                my $expr;
                                my $last_pos = $pos;
                                my $get_token = sub {
                                    my $last_is_term = $_[0];
                                    my $m = Perlito5::Grammar::Precedence::op_parse($str, $last_pos, $last_is_term);
                                    if ($m) {
                                        my $spc = Perlito5::Grammar::Space::ws($str, $m->{'to'});
                                        if ($spc) {
                                            $m->{'to'} = $spc->{'to'}
                                        }
                                    }
                                    if (!$m) {
                                        my $msg = 'Expected closing delimiter: ' . $delimiter;
                                        ($delimiter eq '}' || $delimiter eq ']') && ($msg = 'Missing right curly or square bracket');
                                        Perlito5::Compiler::error($msg . ' near ', $last_pos)
                                    }
                                    my $v = $m->{'capture'};
                                    if ($v->[0] ne 'end') {
                                        $last_pos = $m->{'to'}
                                    }
                                    return $v
                                };
                                my %delim_token;
                                $delim_token{$delimiter} = 1;
                                my $prec = Perlito5::Grammar::Precedence::->new('get_token' => $get_token, 'reduce' => $reduce_to_ast, 'end_token' => \%delim_token, 'end_token_chars' => [length($delimiter)]);
                                my $res = $prec->precedence_parse();
                                $res = pop_term($res);
                                if (!(defined($res))) {
                                    $res = '*undef*'
                                }
                                return {'str' => $str, 'from' => $pos, 'to' => $last_pos, 'capture' => $res}
                            }
                            sub Perlito5::Grammar::Expression::ternary5_parse {
                                return circumfix_parse(@_, ':')
                            }
                            sub Perlito5::Grammar::Expression::curly_parse {
                                return circumfix_parse(@_, '}')
                            }
                            sub Perlito5::Grammar::Expression::square_parse {
                                return circumfix_parse(@_, ']')
                            }
                            sub Perlito5::Grammar::Expression::paren_parse {
                                return circumfix_parse(@_, ')')
                            }
                            sub Perlito5::Grammar::Expression::exp_parse {
                                my($str, $pos) = @_;
                                my $expr;
                                my $last_pos = $pos;
                                my $lexer_stack = [];
                                my $get_token = sub {
                                    my $last_is_term = $_[0];
                                    my $v;
                                    if (scalar(@{$lexer_stack})) {
                                        $v = pop(@{$lexer_stack})
                                    }
                                    else {
                                        my $m = Perlito5::Grammar::Precedence::op_parse($str, $last_pos, $last_is_term);
                                        if ($m) {
                                            my $spc = Perlito5::Grammar::Space::ws($str, $m->{'to'});
                                            if ($spc) {
                                                $m->{'to'} = $spc->{'to'}
                                            }
                                        }
                                        if (!$m) {
                                            return ['end', '*end*']
                                        }
                                        $v = $m->{'capture'};
                                        if ($v->[0] ne 'end') {
                                            $last_pos = $m->{'to'}
                                        }
                                    }
                                    return $v
                                };
                                my $prec = Perlito5::Grammar::Precedence::->new('get_token' => $get_token, 'reduce' => $reduce_to_ast, 'end_token' => $Expr_end_token, 'end_token_chars' => $Expr_end_token_chars);
                                my $res = $prec->precedence_parse();
                                if (scalar(@{$res}) == 0) {
                                    return 0
                                }
                                my $result = pop_term($res);
                                return {'str' => $str, 'from' => $pos, 'to' => $last_pos, 'capture' => $result}
                            }
                            Perlito5::Grammar::Precedence::add_term('my' => \&term_declarator);
                            Perlito5::Grammar::Precedence::add_term('our' => \&term_declarator);
                            Perlito5::Grammar::Precedence::add_term('eval' => \&term_eval);
                            Perlito5::Grammar::Precedence::add_term('state' => \&term_declarator);
                            Perlito5::Grammar::Precedence::add_term('local' => \&term_local);
                            Perlito5::Grammar::Precedence::add_term('return' => \&term_return);
                            Perlito5::Grammar::Precedence::add_term('not' => \&term_not);
                            1
                        }
                    }
                    undef();
                    {
                        {
                            package main;
                            package Perlito5::Grammar;
                            # use strict
                            undef();
                            undef();
                            sub Perlito5::Grammar::unless {
                                my $str = $_[0];
                                my $pos = $_[1];
                                my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
                                my $tmp = ((('unless' eq substr($str, $MATCH->{'to'}, 6) && ($MATCH->{'to'} = 6 + $MATCH->{'to'})) && (do {
                                    my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{'to'});
                                    if ($m2) {
                                        $MATCH->{'to'} = $m2->{'to'};
                                        1
                                    }
                                    else {
                                        0
                                    }
                                }) && (do {
                                    Perlito5::Grammar::Scope::create_new_compile_time_scope();
                                    1
                                }) && (do {
                                    my $m2 = Perlito5::Grammar::Expression::term_paren($str, $MATCH->{'to'});
                                    if ($m2) {
                                        $MATCH->{'to'} = $m2->{'to'};
                                        $MATCH->{'Perlito5::Grammar::Expression::term_paren'} = $m2;
                                        1
                                    }
                                    else {
                                        0
                                    }
                                }) && (do {
                                    my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{'to'});
                                    if ($m2) {
                                        $MATCH->{'to'} = $m2->{'to'};
                                        1
                                    }
                                    else {
                                        0
                                    }
                                }) && (do {
                                    my $m2 = block($str, $MATCH->{'to'});
                                    if ($m2) {
                                        $MATCH->{'to'} = $m2->{'to'};
                                        $MATCH->{'block'} = $m2;
                                        1
                                    }
                                    else {
                                        0
                                    }
                                }) && (do {
                                    my $pos1 = $MATCH->{'to'};
                                    (do {
                                        ((do {
                                            my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{'to'});
                                            if ($m2) {
                                                $MATCH->{'to'} = $m2->{'to'};
                                                1
                                            }
                                            else {
                                                0
                                            }
                                        }) && ('else' eq substr($str, $MATCH->{'to'}, 4) && ($MATCH->{'to'} = 4 + $MATCH->{'to'})) && (do {
                                            my $m2 = block2($str, $MATCH->{'to'});
                                            if ($m2) {
                                                $MATCH->{'to'} = $m2->{'to'};
                                                $MATCH->{'block2'} = $m2;
                                                1
                                            }
                                            else {
                                                0
                                            }
                                        }) && (do {
                                            $MATCH->{'capture'} = Perlito5::AST::If::->new('cond' => Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::Expression::term_paren'})->[2], 'body' => Perlito5::Match::flat($MATCH->{'block2'}), 'otherwise' => Perlito5::Match::flat($MATCH->{'block'}));
                                            1
                                        }))
                                    }) || (do {
                                        $MATCH->{'to'} = $pos1;
                                        (do {
                                            $MATCH->{'capture'} = Perlito5::AST::If::->new('cond' => Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::Expression::term_paren'})->[2], 'body' => Perlito5::AST::Block::->new('stmts' => []), 'otherwise' => Perlito5::Match::flat($MATCH->{'block'}));
                                            1
                                        })
                                    })
                                }) && (do {
                                    Perlito5::Grammar::Scope::end_compile_time_scope();
                                    1
                                })));
                                $tmp ? $MATCH : 0
                            }
                            sub Perlito5::Grammar::if_ {
                                my $str = $_[0];
                                my $pos = $_[1];
                                my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
                                my $tmp = ((('if' eq substr($str, $MATCH->{'to'}, 2) && ($MATCH->{'to'} = 2 + $MATCH->{'to'})) && (do {
                                    my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{'to'});
                                    if ($m2) {
                                        $MATCH->{'to'} = $m2->{'to'};
                                        1
                                    }
                                    else {
                                        0
                                    }
                                }) && (do {
                                    Perlito5::Grammar::Scope::create_new_compile_time_scope();
                                    1
                                }) && (do {
                                    my $m2 = Perlito5::Grammar::Expression::term_paren($str, $MATCH->{'to'});
                                    if ($m2) {
                                        $MATCH->{'to'} = $m2->{'to'};
                                        $MATCH->{'Perlito5::Grammar::Expression::term_paren'} = $m2;
                                        1
                                    }
                                    else {
                                        0
                                    }
                                }) && (do {
                                    my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{'to'});
                                    if ($m2) {
                                        $MATCH->{'to'} = $m2->{'to'};
                                        1
                                    }
                                    else {
                                        0
                                    }
                                }) && (do {
                                    my $m2 = block($str, $MATCH->{'to'});
                                    if ($m2) {
                                        $MATCH->{'to'} = $m2->{'to'};
                                        $MATCH->{'block'} = $m2;
                                        1
                                    }
                                    else {
                                        0
                                    }
                                }) && (do {
                                    my $pos1 = $MATCH->{'to'};
                                    (do {
                                        ((do {
                                            my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{'to'});
                                            if ($m2) {
                                                $MATCH->{'to'} = $m2->{'to'};
                                                1
                                            }
                                            else {
                                                0
                                            }
                                        }) && ('else' eq substr($str, $MATCH->{'to'}, 4) && ($MATCH->{'to'} = 4 + $MATCH->{'to'})) && (do {
                                            my $m2 = block2($str, $MATCH->{'to'});
                                            if ($m2) {
                                                $MATCH->{'to'} = $m2->{'to'};
                                                $MATCH->{'block2'} = $m2;
                                                1
                                            }
                                            else {
                                                0
                                            }
                                        }) && (do {
                                            $MATCH->{'capture'} = Perlito5::AST::If::->new('cond' => Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::Expression::term_paren'})->[2], 'body' => Perlito5::Match::flat($MATCH->{'block'}), 'otherwise' => Perlito5::Match::flat($MATCH->{'block2'}));
                                            1
                                        }))
                                    }) || (do {
                                        $MATCH->{'to'} = $pos1;
                                        ((do {
                                            my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{'to'});
                                            if ($m2) {
                                                $MATCH->{'to'} = $m2->{'to'};
                                                1
                                            }
                                            else {
                                                0
                                            }
                                        }) && ('els' eq substr($str, $MATCH->{'to'}, 3) && ($MATCH->{'to'} = 3 + $MATCH->{'to'})) && (do {
                                            my $m2 = if_($str, $MATCH->{'to'});
                                            if ($m2) {
                                                $MATCH->{'to'} = $m2->{'to'};
                                                $MATCH->{'if_'} = $m2;
                                                1
                                            }
                                            else {
                                                0
                                            }
                                        }) && (do {
                                            $MATCH->{'capture'} = Perlito5::AST::If::->new('cond' => Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::Expression::term_paren'})->[2], 'body' => Perlito5::Match::flat($MATCH->{'block'}), 'otherwise' => Perlito5::AST::Block::->new('stmts' => [Perlito5::Match::flat($MATCH->{'if_'})]));
                                            1
                                        }))
                                    }) || (do {
                                        $MATCH->{'to'} = $pos1;
                                        (do {
                                            $MATCH->{'capture'} = Perlito5::AST::If::->new('cond' => Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::Expression::term_paren'})->[2], 'body' => Perlito5::Match::flat($MATCH->{'block'}), 'otherwise' => Perlito5::AST::Block::->new('stmts' => []));
                                            1
                                        })
                                    })
                                }) && (do {
                                    Perlito5::Grammar::Scope::end_compile_time_scope();
                                    1
                                })));
                                $tmp ? $MATCH : 0
                            }
                            sub Perlito5::Grammar::when {
                                my $str = $_[0];
                                my $pos = $_[1];
                                my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
                                my $tmp = ((('when' eq substr($str, $MATCH->{'to'}, 4) && ($MATCH->{'to'} = 4 + $MATCH->{'to'})) && (do {
                                    my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{'to'});
                                    if ($m2) {
                                        $MATCH->{'to'} = $m2->{'to'};
                                        1
                                    }
                                    else {
                                        0
                                    }
                                }) && (do {
                                    Perlito5::Grammar::Scope::create_new_compile_time_scope();
                                    1
                                }) && (do {
                                    my $m2 = Perlito5::Grammar::Expression::term_paren($str, $MATCH->{'to'});
                                    if ($m2) {
                                        $MATCH->{'to'} = $m2->{'to'};
                                        $MATCH->{'Perlito5::Grammar::Expression::term_paren'} = $m2;
                                        1
                                    }
                                    else {
                                        0
                                    }
                                }) && (do {
                                    my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{'to'});
                                    if ($m2) {
                                        $MATCH->{'to'} = $m2->{'to'};
                                        1
                                    }
                                    else {
                                        0
                                    }
                                }) && (do {
                                    my $m2 = block($str, $MATCH->{'to'});
                                    if ($m2) {
                                        $MATCH->{'to'} = $m2->{'to'};
                                        $MATCH->{'block'} = $m2;
                                        1
                                    }
                                    else {
                                        0
                                    }
                                }) && (do {
                                    $MATCH->{'capture'} = Perlito5::AST::When::->new('cond' => Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::Expression::term_paren'})->[2], 'body' => Perlito5::Match::flat($MATCH->{'block'}));
                                    1
                                }) && (do {
                                    Perlito5::Grammar::Scope::end_compile_time_scope();
                                    1
                                })));
                                $tmp ? $MATCH : 0
                            }
                            sub Perlito5::Grammar::for {
                                my $str = $_[0];
                                my $pos = $_[1];
                                my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
                                my $tmp = ((('for' eq substr($str, $MATCH->{'to'}, 3) && ($MATCH->{'to'} = 3 + $MATCH->{'to'})) && (do {
                                    my $m = $MATCH;
                                    if (!('each' eq substr($str, $MATCH->{'to'}, 4) && ($MATCH->{'to'} = 4 + $MATCH->{'to'}))) {
                                        $MATCH = $m
                                    }
                                    1
                                }) && (do {
                                    Perlito5::Grammar::Scope::create_new_compile_time_scope();
                                    1
                                }) && (do {
                                    my $pos1 = $MATCH->{'to'};
                                    (do {
                                        ((do {
                                            my $pos1 = $MATCH->{'to'};
                                            (do {
                                                ((do {
                                                    my $m2 = Perlito5::Grammar::Space::ws($str, $MATCH->{'to'});
                                                    if ($m2) {
                                                        $MATCH->{'to'} = $m2->{'to'};
                                                        1
                                                    }
                                                    else {
                                                        0
                                                    }
                                                }) && (do {
                                                    my $m2 = Perlito5::Grammar::Expression::term_declarator($str, $MATCH->{'to'});
                                                    if ($m2) {
                                                        $MATCH->{'to'} = $m2->{'to'};
                                                        $MATCH->{'Perlito5::Grammar::Expression::term_declarator'} = $m2;
                                                        1
                                                    }
                                                    else {
                                                        0
                                                    }
                                                }) && (do {
                                                    $MATCH->{'_tmp'} = Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::Expression::term_declarator'})->[1];
                                                    1
                                                }))
                                            }) || (do {
                                                $MATCH->{'to'} = $pos1;
                                                ((do {
                                                    my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{'to'});
                                                    if ($m2) {
                                                        $MATCH->{'to'} = $m2->{'to'};
                                                        1
                                                    }
                                                    else {
                                                        0
                                                    }
                                                }) && (do {
                                                    my $tmp = $MATCH;
                                                    $MATCH = {'from' => $tmp->{'to'}, 'to' => $tmp->{'to'}};
                                                    my $res = ('$' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}));
                                                    $MATCH = $tmp;
                                                    $res ? 1 : 0
                                                }) && (do {
                                                    my $m2 = Perlito5::Grammar::Sigil::term_sigil($str, $MATCH->{'to'});
                                                    if ($m2) {
                                                        $MATCH->{'to'} = $m2->{'to'};
                                                        $MATCH->{'Perlito5::Grammar::Sigil::term_sigil'} = $m2;
                                                        1
                                                    }
                                                    else {
                                                        0
                                                    }
                                                }) && (do {
                                                    $MATCH->{'_tmp'} = Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::Sigil::term_sigil'})->[1];
                                                    1
                                                }))
                                            })
                                        }) && (do {
                                            my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{'to'});
                                            if ($m2) {
                                                $MATCH->{'to'} = $m2->{'to'};
                                                1
                                            }
                                            else {
                                                0
                                            }
                                        }) && ('(' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                                            my $m2 = Perlito5::Grammar::Expression::paren_parse($str, $MATCH->{'to'});
                                            if ($m2) {
                                                $MATCH->{'to'} = $m2->{'to'};
                                                $MATCH->{'Perlito5::Grammar::Expression::paren_parse'} = $m2;
                                                1
                                            }
                                            else {
                                                0
                                            }
                                        }) && (')' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                                            my $m2 = block($str, $MATCH->{'to'});
                                            if ($m2) {
                                                $MATCH->{'to'} = $m2->{'to'};
                                                $MATCH->{'block'} = $m2;
                                                1
                                            }
                                            else {
                                                0
                                            }
                                        }) && (do {
                                            my $m2 = opt_continue_block($str, $MATCH->{'to'});
                                            if ($m2) {
                                                $MATCH->{'to'} = $m2->{'to'};
                                                $MATCH->{'opt_continue_block'} = $m2;
                                                1
                                            }
                                            else {
                                                0
                                            }
                                        }) && (do {
                                            my $body = Perlito5::Match::flat($MATCH->{'block'});
                                            $MATCH->{'capture'} = Perlito5::AST::For::->new('cond' => Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::Expression::paren_parse'}), 'body' => $body, 'continue' => $MATCH->{'opt_continue_block'}->{'capture'}, 'topic' => $MATCH->{'_tmp'});
                                            1
                                        }))
                                    }) || (do {
                                        $MATCH->{'to'} = $pos1;
                                        ((do {
                                            my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{'to'});
                                            if ($m2) {
                                                $MATCH->{'to'} = $m2->{'to'};
                                                1
                                            }
                                            else {
                                                0
                                            }
                                        }) && ('(' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                                            my $pos1 = $MATCH->{'to'};
                                            (do {
                                                ((do {
                                                    my $m2 = Perlito5::Grammar::Expression::exp_parse($str, $MATCH->{'to'});
                                                    if ($m2) {
                                                        $MATCH->{'to'} = $m2->{'to'};
                                                        $MATCH->{'Perlito5::Grammar::Expression::exp_parse'} = $m2;
                                                        1
                                                    }
                                                    else {
                                                        0
                                                    }
                                                }) && (do {
                                                    Perlito5::Grammar::Scope::check_variable_declarations();
                                                    1
                                                }))
                                            }) || (do {
                                                $MATCH->{'to'} = $pos1;
                                                ()
                                            }) || (do {
                                                $MATCH->{'to'} = $pos1;
                                                ((do {
                                                    my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{'to'});
                                                    if ($m2) {
                                                        $MATCH->{'to'} = $m2->{'to'};
                                                        1
                                                    }
                                                    else {
                                                        0
                                                    }
                                                }) && (do {
                                                    my $tmp = $MATCH;
                                                    $MATCH = {'from' => $tmp->{'to'}, 'to' => $tmp->{'to'}};
                                                    my $res = (';' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}));
                                                    $MATCH = $tmp;
                                                    $res ? 1 : 0
                                                }))
                                            })
                                        }) && (do {
                                            my $pos1 = $MATCH->{'to'};
                                            (do {
                                                ((';' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                                                    $MATCH->{'c_style_for'} = 1;
                                                    1
                                                }) && (do {
                                                    my $pos1 = $MATCH->{'to'};
                                                    (do {
                                                        ((do {
                                                            my $m2 = Perlito5::Grammar::exp($str, $MATCH->{'to'});
                                                            if ($m2) {
                                                                $MATCH->{'to'} = $m2->{'to'};
                                                                $MATCH->{'Perlito5::Grammar::exp'} = $m2;
                                                                1
                                                            }
                                                            else {
                                                                0
                                                            }
                                                        }) && (do {
                                                            Perlito5::Grammar::Scope::check_variable_declarations();
                                                            1
                                                        }))
                                                    }) || (do {
                                                        $MATCH->{'to'} = $pos1;
                                                        ()
                                                    }) || (do {
                                                        $MATCH->{'to'} = $pos1;
                                                        (do {
                                                            my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{'to'});
                                                            if ($m2) {
                                                                $MATCH->{'to'} = $m2->{'to'};
                                                                1
                                                            }
                                                            else {
                                                                0
                                                            }
                                                        })
                                                    })
                                                }) && (';' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                                                    my $pos1 = $MATCH->{'to'};
                                                    (do {
                                                        (do {
                                                            my $m2 = Perlito5::Grammar::exp2($str, $MATCH->{'to'});
                                                            if ($m2) {
                                                                $MATCH->{'to'} = $m2->{'to'};
                                                                $MATCH->{'Perlito5::Grammar::exp2'} = $m2;
                                                                1
                                                            }
                                                            else {
                                                                0
                                                            }
                                                        })
                                                    }) || (do {
                                                        $MATCH->{'to'} = $pos1;
                                                        ()
                                                    }) || (do {
                                                        $MATCH->{'to'} = $pos1;
                                                        (do {
                                                            my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{'to'});
                                                            if ($m2) {
                                                                $MATCH->{'to'} = $m2->{'to'};
                                                                1
                                                            }
                                                            else {
                                                                0
                                                            }
                                                        })
                                                    })
                                                }))
                                            }) || (do {
                                                $MATCH->{'to'} = $pos1;
                                                1
                                            })
                                        }) && (')' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                                            my $m2 = block($str, $MATCH->{'to'});
                                            if ($m2) {
                                                $MATCH->{'to'} = $m2->{'to'};
                                                $MATCH->{'block'} = $m2;
                                                1
                                            }
                                            else {
                                                0
                                            }
                                        }) && (do {
                                            my $m2 = opt_continue_block($str, $MATCH->{'to'});
                                            if ($m2) {
                                                $MATCH->{'to'} = $m2->{'to'};
                                                $MATCH->{'opt_continue_block'} = $m2;
                                                1
                                            }
                                            else {
                                                0
                                            }
                                        }) && (do {
                                            my $header;
                                            my $body = Perlito5::Match::flat($MATCH->{'block'});
                                            my $topic;
                                            if ($MATCH->{'c_style_for'}) {
                                                $header = [$MATCH->{'Perlito5::Grammar::Expression::exp_parse'}->{'capture'}, $MATCH->{'Perlito5::Grammar::exp'}->{'capture'}, $MATCH->{'Perlito5::Grammar::exp2'}->{'capture'}]
                                            }
                                            else {
                                                $header = $MATCH->{'Perlito5::Grammar::Expression::exp_parse'}->{'capture'};
                                                $topic = Perlito5::AST::Var::->new('namespace' => '', 'name' => '_', 'sigil' => '$')
                                            }
                                            $MATCH->{'capture'} = Perlito5::AST::For::->new('cond' => $header, 'body' => $body, 'continue' => $MATCH->{'opt_continue_block'}->{'capture'}, 'topic' => $topic);
                                            1
                                        }))
                                    })
                                }) && (do {
                                    Perlito5::Grammar::Scope::end_compile_time_scope();
                                    1
                                })));
                                $tmp ? $MATCH : 0
                            }
                            sub Perlito5::Grammar::while {
                                my $str = $_[0];
                                my $pos = $_[1];
                                my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
                                my $tmp = ((('while' eq substr($str, $MATCH->{'to'}, 5) && ($MATCH->{'to'} = 5 + $MATCH->{'to'})) && (do {
                                    my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{'to'});
                                    if ($m2) {
                                        $MATCH->{'to'} = $m2->{'to'};
                                        1
                                    }
                                    else {
                                        0
                                    }
                                }) && (do {
                                    Perlito5::Grammar::Scope::create_new_compile_time_scope();
                                    1
                                }) && ('(' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                                    my $m2 = Perlito5::Grammar::Expression::paren_parse($str, $MATCH->{'to'});
                                    if ($m2) {
                                        $MATCH->{'to'} = $m2->{'to'};
                                        $MATCH->{'Perlito5::Grammar::Expression::paren_parse'} = $m2;
                                        1
                                    }
                                    else {
                                        0
                                    }
                                }) && (')' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                                    my $m2 = block($str, $MATCH->{'to'});
                                    if ($m2) {
                                        $MATCH->{'to'} = $m2->{'to'};
                                        $MATCH->{'block'} = $m2;
                                        1
                                    }
                                    else {
                                        0
                                    }
                                }) && (do {
                                    my $m2 = opt_continue_block($str, $MATCH->{'to'});
                                    if ($m2) {
                                        $MATCH->{'to'} = $m2->{'to'};
                                        $MATCH->{'opt_continue_block'} = $m2;
                                        1
                                    }
                                    else {
                                        0
                                    }
                                }) && (do {
                                    my $cond = Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::Expression::paren_parse'});
                                    if ($cond eq '*undef*') {
                                        $cond = Perlito5::AST::Int::->new('int' => 1)
                                    }
                                    my $stmt = Perlito5::AST::While::->new('cond' => $cond, 'body' => Perlito5::Match::flat($MATCH->{'block'}), 'continue' => $MATCH->{'opt_continue_block'}->{'capture'});
                                    my $out = Perlito5::Macro::while_file($stmt);
                                    $out && ($stmt = $out);
                                    $MATCH->{'capture'} = $stmt;
                                    1
                                }) && (do {
                                    Perlito5::Grammar::Scope::end_compile_time_scope();
                                    1
                                })));
                                $tmp ? $MATCH : 0
                            }
                            sub Perlito5::Grammar::until {
                                my $str = $_[0];
                                my $pos = $_[1];
                                my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
                                my $tmp = ((('until' eq substr($str, $MATCH->{'to'}, 5) && ($MATCH->{'to'} = 5 + $MATCH->{'to'})) && (do {
                                    my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{'to'});
                                    if ($m2) {
                                        $MATCH->{'to'} = $m2->{'to'};
                                        1
                                    }
                                    else {
                                        0
                                    }
                                }) && (do {
                                    Perlito5::Grammar::Scope::create_new_compile_time_scope();
                                    1
                                }) && ('(' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                                    my $m2 = Perlito5::Grammar::Expression::paren_parse($str, $MATCH->{'to'});
                                    if ($m2) {
                                        $MATCH->{'to'} = $m2->{'to'};
                                        $MATCH->{'Perlito5::Grammar::Expression::paren_parse'} = $m2;
                                        1
                                    }
                                    else {
                                        0
                                    }
                                }) && (')' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                                    my $m2 = block($str, $MATCH->{'to'});
                                    if ($m2) {
                                        $MATCH->{'to'} = $m2->{'to'};
                                        $MATCH->{'block'} = $m2;
                                        1
                                    }
                                    else {
                                        0
                                    }
                                }) && (do {
                                    my $m2 = opt_continue_block($str, $MATCH->{'to'});
                                    if ($m2) {
                                        $MATCH->{'to'} = $m2->{'to'};
                                        $MATCH->{'opt_continue_block'} = $m2;
                                        1
                                    }
                                    else {
                                        0
                                    }
                                }) && (do {
                                    my $cond = Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::Expression::paren_parse'});
                                    if ($cond eq '*undef*') {
                                        $cond = Perlito5::AST::Int::->new('int' => 1)
                                    }
                                    $MATCH->{'capture'} = Perlito5::AST::While::->new('cond' => Perlito5::AST::Apply::->new('arguments' => [$cond], 'code' => 'prefix:<!>', 'namespace' => ''), 'body' => Perlito5::Match::flat($MATCH->{'block'}), 'continue' => $MATCH->{'opt_continue_block'}->{'capture'});
                                    1
                                }) && (do {
                                    Perlito5::Grammar::Scope::end_compile_time_scope();
                                    1
                                })));
                                $tmp ? $MATCH : 0
                            }
                            sub Perlito5::Grammar::given {
                                my $str = $_[0];
                                my $pos = $_[1];
                                my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
                                my $tmp = ((('given' eq substr($str, $MATCH->{'to'}, 5) && ($MATCH->{'to'} = 5 + $MATCH->{'to'})) && (do {
                                    my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{'to'});
                                    if ($m2) {
                                        $MATCH->{'to'} = $m2->{'to'};
                                        1
                                    }
                                    else {
                                        0
                                    }
                                }) && (do {
                                    Perlito5::Grammar::Scope::create_new_compile_time_scope();
                                    1
                                }) && ('(' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                                    my $m2 = Perlito5::Grammar::Expression::paren_parse($str, $MATCH->{'to'});
                                    if ($m2) {
                                        $MATCH->{'to'} = $m2->{'to'};
                                        $MATCH->{'Perlito5::Grammar::Expression::paren_parse'} = $m2;
                                        1
                                    }
                                    else {
                                        0
                                    }
                                }) && (')' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                                    my $m2 = block($str, $MATCH->{'to'});
                                    if ($m2) {
                                        $MATCH->{'to'} = $m2->{'to'};
                                        $MATCH->{'block'} = $m2;
                                        1
                                    }
                                    else {
                                        0
                                    }
                                }) && (do {
                                    my $body = Perlito5::Match::flat($MATCH->{'block'});
                                    $body->{'sig'} = Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::var_ident'});
                                    $MATCH->{'capture'} = Perlito5::AST::Given::->new('cond' => Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::Expression::paren_parse'}), 'body' => $body);
                                    1
                                }) && (do {
                                    Perlito5::Grammar::Scope::end_compile_time_scope();
                                    1
                                })));
                                $tmp ? $MATCH : 0
                            }
                            Perlito5::Grammar::Statement::add_statement('if' => \&if_);
                            Perlito5::Grammar::Statement::add_statement('for' => \&for);
                            Perlito5::Grammar::Statement::add_statement('foreach' => \&for);
                            Perlito5::Grammar::Statement::add_statement('when' => \&when);
                            Perlito5::Grammar::Statement::add_statement('while' => \&while);
                            Perlito5::Grammar::Statement::add_statement('until' => \&until);
                            Perlito5::Grammar::Statement::add_statement('given' => \&given);
                            Perlito5::Grammar::Statement::add_statement('unless' => \&unless)
                        }
                    }
                    {
                        {
                            package main;
                            undef();
                            package Perlito5::Grammar::String;
                            undef();
                            sub Perlito5::Grammar::String::term_q_quote {
                                my $str = $_[0];
                                my $pos = $_[1];
                                my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
                                my $tmp = (((do {
                                    my $pos1 = $MATCH->{'to'};
                                    (do {
                                        (('q' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                                            my $pos1 = $MATCH->{'to'};
                                            (do {
                                                ('#' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}))
                                            }) || (do {
                                                $MATCH->{'to'} = $pos1;
                                                ((do {
                                                    my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{'to'});
                                                    if ($m2) {
                                                        $MATCH->{'to'} = $m2->{'to'};
                                                        1
                                                    }
                                                    else {
                                                        0
                                                    }
                                                }) && (do {
                                                    my $tmp = $MATCH;
                                                    $MATCH = {'from' => $tmp->{'to'}, 'to' => $tmp->{'to'}};
                                                    my $res = ('=>' eq substr($str, $MATCH->{'to'}, 2) && ($MATCH->{'to'} = 2 + $MATCH->{'to'}));
                                                    $MATCH = $tmp;
                                                    $res ? 0 : 1
                                                }) && ('' ne substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})))
                                            })
                                        }))
                                    }) || (do {
                                        $MATCH->{'to'} = $pos1;
                                        (chr(39) eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}))
                                    })
                                }) && (do {
                                    my $m2 = q_quote_parse($str, $MATCH->{'to'});
                                    if ($m2) {
                                        $MATCH->{'to'} = $m2->{'to'};
                                        $MATCH->{'q_quote_parse'} = $m2;
                                        1
                                    }
                                    else {
                                        0
                                    }
                                }) && (do {
                                    $MATCH->{'capture'} = ['term', Perlito5::Match::flat($MATCH->{'q_quote_parse'})];
                                    1
                                })));
                                $tmp ? $MATCH : 0
                            }
                            sub Perlito5::Grammar::String::term_qq_quote {
                                my $str = $_[0];
                                my $pos = $_[1];
                                my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
                                my $tmp = (((do {
                                    my $pos1 = $MATCH->{'to'};
                                    (do {
                                        (('qq' eq substr($str, $MATCH->{'to'}, 2) && ($MATCH->{'to'} = 2 + $MATCH->{'to'})) && (do {
                                            my $pos1 = $MATCH->{'to'};
                                            (do {
                                                ('#' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}))
                                            }) || (do {
                                                $MATCH->{'to'} = $pos1;
                                                ((do {
                                                    my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{'to'});
                                                    if ($m2) {
                                                        $MATCH->{'to'} = $m2->{'to'};
                                                        1
                                                    }
                                                    else {
                                                        0
                                                    }
                                                }) && (do {
                                                    my $tmp = $MATCH;
                                                    $MATCH = {'from' => $tmp->{'to'}, 'to' => $tmp->{'to'}};
                                                    my $res = ('=>' eq substr($str, $MATCH->{'to'}, 2) && ($MATCH->{'to'} = 2 + $MATCH->{'to'}));
                                                    $MATCH = $tmp;
                                                    $res ? 0 : 1
                                                }) && ('' ne substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})))
                                            })
                                        }))
                                    }) || (do {
                                        $MATCH->{'to'} = $pos1;
                                        ('"' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}))
                                    })
                                }) && (do {
                                    my $m2 = qq_quote_parse($str, $MATCH->{'to'});
                                    if ($m2) {
                                        $MATCH->{'to'} = $m2->{'to'};
                                        $MATCH->{'qq_quote_parse'} = $m2;
                                        1
                                    }
                                    else {
                                        0
                                    }
                                }) && (do {
                                    $MATCH->{'capture'} = ['term', Perlito5::Match::flat($MATCH->{'qq_quote_parse'})];
                                    1
                                })));
                                $tmp ? $MATCH : 0
                            }
                            sub Perlito5::Grammar::String::term_qw_quote {
                                my $str = $_[0];
                                my $pos = $_[1];
                                my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
                                my $tmp = ((('qw' eq substr($str, $MATCH->{'to'}, 2) && ($MATCH->{'to'} = 2 + $MATCH->{'to'})) && (do {
                                    my $pos1 = $MATCH->{'to'};
                                    (do {
                                        ('#' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}))
                                    }) || (do {
                                        $MATCH->{'to'} = $pos1;
                                        ((do {
                                            my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{'to'});
                                            if ($m2) {
                                                $MATCH->{'to'} = $m2->{'to'};
                                                1
                                            }
                                            else {
                                                0
                                            }
                                        }) && (do {
                                            my $tmp = $MATCH;
                                            $MATCH = {'from' => $tmp->{'to'}, 'to' => $tmp->{'to'}};
                                            my $res = ('=>' eq substr($str, $MATCH->{'to'}, 2) && ($MATCH->{'to'} = 2 + $MATCH->{'to'}));
                                            $MATCH = $tmp;
                                            $res ? 0 : 1
                                        }) && ('' ne substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})))
                                    })
                                }) && (do {
                                    my $m2 = qw_quote_parse($str, $MATCH->{'to'});
                                    if ($m2) {
                                        $MATCH->{'to'} = $m2->{'to'};
                                        $MATCH->{'qw_quote_parse'} = $m2;
                                        1
                                    }
                                    else {
                                        0
                                    }
                                }) && (do {
                                    $MATCH->{'capture'} = ['term', Perlito5::Match::flat($MATCH->{'qw_quote_parse'})];
                                    1
                                })));
                                $tmp ? $MATCH : 0
                            }
                            sub Perlito5::Grammar::String::term_m_quote {
                                my $str = $_[0];
                                my $pos = $_[1];
                                my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
                                my $tmp = (((do {
                                    my $pos1 = $MATCH->{'to'};
                                    (do {
                                        (('m' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                                            my $pos1 = $MATCH->{'to'};
                                            (do {
                                                ('#' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}))
                                            }) || (do {
                                                $MATCH->{'to'} = $pos1;
                                                ((do {
                                                    my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{'to'});
                                                    if ($m2) {
                                                        $MATCH->{'to'} = $m2->{'to'};
                                                        1
                                                    }
                                                    else {
                                                        0
                                                    }
                                                }) && (do {
                                                    my $tmp = $MATCH;
                                                    $MATCH = {'from' => $tmp->{'to'}, 'to' => $tmp->{'to'}};
                                                    my $res = ('=>' eq substr($str, $MATCH->{'to'}, 2) && ($MATCH->{'to'} = 2 + $MATCH->{'to'}));
                                                    $MATCH = $tmp;
                                                    $res ? 0 : 1
                                                }) && ('' ne substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})))
                                            })
                                        }))
                                    }) || (do {
                                        $MATCH->{'to'} = $pos1;
                                        ('/' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}))
                                    })
                                }) && (do {
                                    my $m2 = m_quote_parse($str, $MATCH->{'to'});
                                    if ($m2) {
                                        $MATCH->{'to'} = $m2->{'to'};
                                        $MATCH->{'m_quote_parse'} = $m2;
                                        1
                                    }
                                    else {
                                        0
                                    }
                                }) && (do {
                                    $MATCH->{'capture'} = ['term', Perlito5::Match::flat($MATCH->{'m_quote_parse'})];
                                    1
                                })));
                                $tmp ? $MATCH : 0
                            }
                            sub Perlito5::Grammar::String::term_s_quote {
                                my $str = $_[0];
                                my $pos = $_[1];
                                my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
                                my $tmp = ((('s' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                                    my $pos1 = $MATCH->{'to'};
                                    (do {
                                        ('#' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}))
                                    }) || (do {
                                        $MATCH->{'to'} = $pos1;
                                        ((do {
                                            my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{'to'});
                                            if ($m2) {
                                                $MATCH->{'to'} = $m2->{'to'};
                                                1
                                            }
                                            else {
                                                0
                                            }
                                        }) && (do {
                                            my $tmp = $MATCH;
                                            $MATCH = {'from' => $tmp->{'to'}, 'to' => $tmp->{'to'}};
                                            my $res = ('=>' eq substr($str, $MATCH->{'to'}, 2) && ($MATCH->{'to'} = 2 + $MATCH->{'to'}));
                                            $MATCH = $tmp;
                                            $res ? 0 : 1
                                        }) && ('' ne substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})))
                                    })
                                }) && (do {
                                    my $m2 = s_quote_parse($str, $MATCH->{'to'});
                                    if ($m2) {
                                        $MATCH->{'to'} = $m2->{'to'};
                                        $MATCH->{'s_quote_parse'} = $m2;
                                        1
                                    }
                                    else {
                                        0
                                    }
                                }) && (do {
                                    $MATCH->{'capture'} = ['term', Perlito5::Match::flat($MATCH->{'s_quote_parse'})];
                                    1
                                })));
                                $tmp ? $MATCH : 0
                            }
                            sub Perlito5::Grammar::String::term_qx {
                                my $str = $_[0];
                                my $pos = $_[1];
                                my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
                                my $tmp = (((do {
                                    my $pos1 = $MATCH->{'to'};
                                    (do {
                                        (('qx' eq substr($str, $MATCH->{'to'}, 2) && ($MATCH->{'to'} = 2 + $MATCH->{'to'})) && (do {
                                            my $pos1 = $MATCH->{'to'};
                                            (do {
                                                ('#' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}))
                                            }) || (do {
                                                $MATCH->{'to'} = $pos1;
                                                ((do {
                                                    my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{'to'});
                                                    if ($m2) {
                                                        $MATCH->{'to'} = $m2->{'to'};
                                                        1
                                                    }
                                                    else {
                                                        0
                                                    }
                                                }) && (do {
                                                    my $tmp = $MATCH;
                                                    $MATCH = {'from' => $tmp->{'to'}, 'to' => $tmp->{'to'}};
                                                    my $res = ('=>' eq substr($str, $MATCH->{'to'}, 2) && ($MATCH->{'to'} = 2 + $MATCH->{'to'}));
                                                    $MATCH = $tmp;
                                                    $res ? 0 : 1
                                                }) && ('' ne substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})))
                                            })
                                        }))
                                    }) || (do {
                                        $MATCH->{'to'} = $pos1;
                                        ('`' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}))
                                    })
                                }) && (do {
                                    my $m2 = qx_quote_parse($str, $MATCH->{'to'});
                                    if ($m2) {
                                        $MATCH->{'to'} = $m2->{'to'};
                                        $MATCH->{'qx_quote_parse'} = $m2;
                                        1
                                    }
                                    else {
                                        0
                                    }
                                }) && (do {
                                    $MATCH->{'capture'} = ['term', Perlito5::Match::flat($MATCH->{'qx_quote_parse'})];
                                    1
                                })));
                                $tmp ? $MATCH : 0
                            }
                            sub Perlito5::Grammar::String::term_glob {
                                my $str = $_[0];
                                my $pos = $_[1];
                                my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
                                my $tmp = ((('<' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                                    my $m2 = glob_quote_parse($str, $MATCH->{'to'});
                                    if ($m2) {
                                        $MATCH->{'to'} = $m2->{'to'};
                                        $MATCH->{'glob_quote_parse'} = $m2;
                                        1
                                    }
                                    else {
                                        0
                                    }
                                }) && (do {
                                    $MATCH->{'capture'} = ['term', Perlito5::Match::flat($MATCH->{'glob_quote_parse'})];
                                    1
                                })));
                                $tmp ? $MATCH : 0
                            }
                            sub Perlito5::Grammar::String::term_tr_quote {
                                my $str = $_[0];
                                my $pos = $_[1];
                                my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
                                my $tmp = (((do {
                                    my $pos1 = $MATCH->{'to'};
                                    (do {
                                        ('tr' eq substr($str, $MATCH->{'to'}, 2) && ($MATCH->{'to'} = 2 + $MATCH->{'to'}))
                                    }) || (do {
                                        $MATCH->{'to'} = $pos1;
                                        ('y' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}))
                                    })
                                }) && (do {
                                    my $pos1 = $MATCH->{'to'};
                                    (do {
                                        ('#' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}))
                                    }) || (do {
                                        $MATCH->{'to'} = $pos1;
                                        ((do {
                                            my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{'to'});
                                            if ($m2) {
                                                $MATCH->{'to'} = $m2->{'to'};
                                                1
                                            }
                                            else {
                                                0
                                            }
                                        }) && (do {
                                            my $tmp = $MATCH;
                                            $MATCH = {'from' => $tmp->{'to'}, 'to' => $tmp->{'to'}};
                                            my $res = ('=>' eq substr($str, $MATCH->{'to'}, 2) && ($MATCH->{'to'} = 2 + $MATCH->{'to'}));
                                            $MATCH = $tmp;
                                            $res ? 0 : 1
                                        }) && ('' ne substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})))
                                    })
                                }) && (do {
                                    my $m2 = tr_quote_parse($str, $MATCH->{'to'});
                                    if ($m2) {
                                        $MATCH->{'to'} = $m2->{'to'};
                                        $MATCH->{'tr_quote_parse'} = $m2;
                                        1
                                    }
                                    else {
                                        0
                                    }
                                }) && (do {
                                    $MATCH->{'capture'} = ['term', Perlito5::Match::flat($MATCH->{'tr_quote_parse'})];
                                    1
                                })));
                                $tmp ? $MATCH : 0
                            }
                            sub Perlito5::Grammar::String::term_qr_quote {
                                my $str = $_[0];
                                my $pos = $_[1];
                                my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
                                my $tmp = ((('qr' eq substr($str, $MATCH->{'to'}, 2) && ($MATCH->{'to'} = 2 + $MATCH->{'to'})) && (do {
                                    my $pos1 = $MATCH->{'to'};
                                    (do {
                                        ('#' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}))
                                    }) || (do {
                                        $MATCH->{'to'} = $pos1;
                                        ((do {
                                            my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{'to'});
                                            if ($m2) {
                                                $MATCH->{'to'} = $m2->{'to'};
                                                1
                                            }
                                            else {
                                                0
                                            }
                                        }) && (do {
                                            my $tmp = $MATCH;
                                            $MATCH = {'from' => $tmp->{'to'}, 'to' => $tmp->{'to'}};
                                            my $res = ('=>' eq substr($str, $MATCH->{'to'}, 2) && ($MATCH->{'to'} = 2 + $MATCH->{'to'}));
                                            $MATCH = $tmp;
                                            $res ? 0 : 1
                                        }) && ('' ne substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})))
                                    })
                                }) && (do {
                                    my $m2 = qr_quote_parse($str, $MATCH->{'to'});
                                    if ($m2) {
                                        $MATCH->{'to'} = $m2->{'to'};
                                        $MATCH->{'qr_quote_parse'} = $m2;
                                        1
                                    }
                                    else {
                                        0
                                    }
                                }) && (do {
                                    $MATCH->{'capture'} = ['term', Perlito5::Match::flat($MATCH->{'qr_quote_parse'})];
                                    1
                                })));
                                $tmp ? $MATCH : 0
                            }
                            my %pair = ('{' => '}', '(' => ')', '[' => ']', '<' => '>');
                            my %escape_sequence = ('a', 7, 'b', 8, 'e', 27, 'f', 12, 'n', 10, 'r', 13, 't', 9);
                            my %hex = map(+($_ => 1), 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 'A', 'B', 'C', 'D', 'E', 'F');
                            my %octal = map(+($_ => 1), 0, 1, 2, 3, 4, 5, 6, 7);
                            sub Perlito5::Grammar::String::q_quote_parse {
                                my $str = $_[0];
                                my $pos = $_[1];
                                my $delimiter = substr($str, $pos - 1, 1);
                                my $open_delimiter = $delimiter;
                                exists($pair{$delimiter}) && ($delimiter = $pair{$delimiter});
                                return string_interpolation_parse($str, $pos, $open_delimiter, $delimiter, 0)
                            }
                            sub Perlito5::Grammar::String::qq_quote_parse {
                                my $str = $_[0];
                                my $pos = $_[1];
                                my $delimiter = substr($str, $pos - 1, 1);
                                my $open_delimiter = $delimiter;
                                exists($pair{$delimiter}) && ($delimiter = $pair{$delimiter});
                                return string_interpolation_parse($str, $pos, $open_delimiter, $delimiter, 1)
                            }
                            sub Perlito5::Grammar::String::qw_quote_parse {
                                my $str = $_[0];
                                my $pos = $_[1];
                                my $delimiter = substr($str, $pos - 1, 1);
                                my $open_delimiter = $delimiter;
                                exists($pair{$delimiter}) && ($delimiter = $pair{$delimiter});
                                my $m = string_interpolation_parse($str, $pos, $open_delimiter, $delimiter, 0);
                                if ($m) {
                                    $m->{'capture'} = Perlito5::AST::Apply::->new('code' => 'list:<,>', 'arguments' => [map(Perlito5::AST::Buf::->new('buf' => $_), split(' ', Perlito5::Match::flat($m)->{'buf'}))], 'namespace' => '')
                                }
                                return $m
                            }
                            sub Perlito5::Grammar::String::m_quote_parse {
                                my $str = $_[0];
                                my $pos = $_[1];
                                my $delimiter = substr($str, $pos - 1, 1);
                                my $open_delimiter = $delimiter;
                                my $closing_delimiter = $delimiter;
                                exists($pair{$delimiter}) && ($closing_delimiter = $pair{$delimiter});
                                my $interpolate = 2;
                                $delimiter eq chr(39) && ($interpolate = 3);
                                my $part1 = string_interpolation_parse($str, $pos, $open_delimiter, $closing_delimiter, $interpolate);
                                $part1 || return $part1;
                                my $str_regex = $part1->{'capture'};
                                my $p = $part1->{'to'};
                                my $modifiers = '';
                                my $m = Perlito5::Grammar::ident($str, $p);
                                if ($m) {
                                    $modifiers = Perlito5::Match::flat($m);
                                    $part1->{'to'} = $m->{'to'}
                                }
                                $part1->{'capture'} = Perlito5::AST::Apply::->new('code' => 'p5:m', 'arguments' => [$str_regex, Perlito5::AST::Buf::->new('buf' => $modifiers), Perlito5::AST::Var::->new('sigil' => '$', 'namespace' => '', 'name' => '_')], 'namespace' => '');
                                return $part1
                            }
                            sub Perlito5::Grammar::String::s_quote_parse {
                                my $str = $_[0];
                                my $pos = $_[1];
                                my $delimiter = substr($str, $pos - 1, 1);
                                my $open_delimiter = $delimiter;
                                my $closing_delimiter = $delimiter;
                                exists($pair{$delimiter}) && ($closing_delimiter = $pair{$delimiter});
                                my $part1 = string_interpolation_parse($str, $pos, $open_delimiter, $closing_delimiter, 1);
                                $part1 || return $part1;
                                my $str_regex = Perlito5::AST::Buf::->new('buf' => substr($str, $pos, $part1->{'to'} - $pos - 1));
                                my $part2;
                                my $m;
                                my $p = $part1->{'to'};
                                if (exists($pair{$delimiter})) {
                                    $m = Perlito5::Grammar::Space::opt_ws($str, $p);
                                    $p = $m->{'to'};
                                    $delimiter = substr($str, $p, 1);
                                    my $open_delimiter = $delimiter;
                                    $p++;
                                    $closing_delimiter = $delimiter;
                                    exists($pair{$delimiter}) && ($closing_delimiter = $pair{$delimiter});
                                    $part2 = string_interpolation_parse($str, $p, $open_delimiter, $closing_delimiter, 1);
                                    $part2 || return $part2
                                }
                                else {
                                    $part2 = string_interpolation_parse($str, $p, $open_delimiter, $closing_delimiter, 1);
                                    $part2 || return $part2
                                }
                                $p = $part2->{'to'};
                                my $modifiers = '';
                                $m = Perlito5::Grammar::ident($str, $p);
                                if ($m) {
                                    $modifiers = Perlito5::Match::flat($m)
                                }
                                my $replace;
                                if ($modifiers =~ m!e!) {
                                    delete($part2->{'capture'});
                                    $replace = Perlito5::Match::flat($part2);
                                    $replace = substr($replace, 0, -1);
                                    $replace = '{' . $replace . '}';
                                    my $m = Perlito5::Grammar::block($replace, 0);
                                    if (!$m) {
                                        Perlito5::Compiler::error('syntax error')
                                    }
                                    $replace = Perlito5::Match::flat($m);
                                    if ($modifiers =~ m!ee!) {
                                        $replace = Perlito5::AST::Block::->new('sig' => undef, 'stmts' => [Perlito5::AST::Apply::->new('code' => 'eval', 'arguments' => [Perlito5::AST::Apply::->new('code' => 'do', 'arguments' => [$replace])], 'bareword' => '', 'namespace' => '')])
                                    }
                                }
                                else {
                                    $replace = Perlito5::Match::flat($part2)
                                }
                                if ($m) {
                                    $part2->{'to'} = $m->{'to'}
                                }
                                $part2->{'capture'} = Perlito5::AST::Apply::->new('code' => 'p5:s', 'arguments' => [$str_regex, $replace, Perlito5::AST::Buf::->new('buf' => $modifiers), Perlito5::AST::Var::->new('sigil' => '$', 'namespace' => '', 'name' => '_')], 'namespace' => '');
                                return $part2
                            }
                            sub Perlito5::Grammar::String::qr_quote_parse {
                                my $str = $_[0];
                                my $pos = $_[1];
                                my $delimiter = substr($str, $pos - 1, 1);
                                my $open_delimiter = $delimiter;
                                my $closing_delimiter = $delimiter;
                                exists($pair{$delimiter}) && ($closing_delimiter = $pair{$delimiter});
                                my $interpolate = 2;
                                $delimiter eq chr(39) && ($interpolate = 3);
                                my $part1 = string_interpolation_parse($str, $pos, $open_delimiter, $closing_delimiter, $interpolate);
                                $part1 || return $part1;
                                my $str_regex = $part1->{'capture'};
                                my $p = $part1->{'to'};
                                my $modifiers = '';
                                my $m = Perlito5::Grammar::ident($str, $p);
                                if ($m) {
                                    $modifiers = Perlito5::Match::flat($m);
                                    $part1->{'to'} = $m->{'to'}
                                }
                                $part1->{'capture'} = Perlito5::AST::Apply::->new('code' => 'p5:qr', 'arguments' => [$str_regex, Perlito5::AST::Buf::->new('buf' => $modifiers)], 'namespace' => '');
                                return $part1
                            }
                            sub Perlito5::Grammar::String::qx_quote_parse {
                                my $str = $_[0];
                                my $pos = $_[1];
                                my $delimiter = substr($str, $pos - 1, 1);
                                my $open_delimiter = $delimiter;
                                exists($pair{$delimiter}) && ($delimiter = $pair{$delimiter});
                                my $m = string_interpolation_parse($str, $pos, $open_delimiter, $delimiter, 0);
                                if ($m) {
                                    $m->{'capture'} = Perlito5::AST::Apply::->new('code' => 'qx', 'arguments' => [Perlito5::Match::flat($m)], 'namespace' => '')
                                }
                                return $m
                            }
                            sub Perlito5::Grammar::String::glob_quote_parse {
                                my $str = $_[0];
                                my $pos = $_[1];
                                my $delimiter = substr($str, $pos - 1, 1);
                                my $open_delimiter = $delimiter;
                                exists($pair{$delimiter}) && ($delimiter = $pair{$delimiter});
                                if (substr($str, $pos, 3) eq '<>>') {
                                    return {'str' => $str, 'from' => $pos, 'to' => $pos + 3, 'capture' => Perlito5::AST::Apply::->new('code' => 'readline', 'arguments' => [Perlito5::AST::Apply::->new('code' => '<>', 'arguments' => [], 'namespace' => '', 'bareword' => 1)], 'namespace' => '')}
                                }
                                if (substr($str, $pos, 1) eq '>') {
                                    return {'str' => $str, 'from' => $pos, 'to' => $pos + 1, 'capture' => Perlito5::AST::Apply::->new('code' => 'readline', 'arguments' => [], 'namespace' => '')}
                                }
                                my $p = $pos;
                                my $sigil = '::';
                                if (substr($str, $p, 1) eq '$') {
                                    $sigil = '$';
                                    $p++
                                }
                                my $m_namespace = Perlito5::Grammar::optional_namespace_before_ident($str, $p);
                                my $namespace = Perlito5::Match::flat($m_namespace);
                                $p = $m_namespace->{'to'};
                                my $m_name = Perlito5::Grammar::ident($str, $p);
                                if ($m_name && substr($str, $m_name->{'to'}, 1) eq '>') {
                                    if ($sigil eq '::') {
                                        return {'str' => $str, 'from' => $pos, 'to' => $m_name->{'to'} + 1, 'capture' => Perlito5::AST::Apply::->new('code' => 'readline', 'arguments' => [Perlito5::AST::Apply::->new('code' => Perlito5::Match::flat($m_name), 'arguments' => [], 'namespace' => $namespace, 'bareword' => 1)], 'namespace' => '')}
                                    }
                                    return {'str' => $str, 'from' => $pos, 'to' => $m_name->{'to'} + 1, 'capture' => Perlito5::AST::Apply::->new('code' => 'readline', 'arguments' => [Perlito5::AST::Var::->new('sigil' => $sigil, 'name' => Perlito5::Match::flat($m_name), 'namespace' => $namespace)], 'namespace' => '')}
                                }
                                my $m = string_interpolation_parse($str, $pos, $open_delimiter, $delimiter, 1);
                                if ($m) {
                                    $m->{'capture'} = Perlito5::AST::Apply::->new('code' => 'glob', 'arguments' => [Perlito5::Match::flat($m)], 'namespace' => '')
                                }
                                return $m
                            }
                            sub Perlito5::Grammar::String::tr_quote_parse {
                                my $str = $_[0];
                                my $pos = $_[1];
                                my $delimiter = substr($str, $pos - 1, 1);
                                my $open_delimiter = $delimiter;
                                my $closing_delimiter = $delimiter;
                                exists($pair{$delimiter}) && ($closing_delimiter = $pair{$delimiter});
                                my $part1 = string_interpolation_parse($str, $pos, $open_delimiter, $closing_delimiter, 1);
                                $part1 || return $part1;
                                my $str_regex = Perlito5::AST::Buf::->new('buf' => substr($str, $pos, $part1->{'to'} - $pos - 1));
                                my $part2;
                                my $m;
                                my $p = $part1->{'to'};
                                if (exists($pair{$delimiter})) {
                                    $m = Perlito5::Grammar::Space::opt_ws($str, $p);
                                    $p = $m->{'to'};
                                    $delimiter = substr($str, $p, 1);
                                    my $open_delimiter = $delimiter;
                                    $p++;
                                    $closing_delimiter = $delimiter;
                                    exists($pair{$delimiter}) && ($closing_delimiter = $pair{$delimiter});
                                    $part2 = string_interpolation_parse($str, $p, $open_delimiter, $closing_delimiter, 1);
                                    $part2 || return $part2
                                }
                                else {
                                    $part2 = string_interpolation_parse($str, $p, $open_delimiter, $closing_delimiter, 1);
                                    $part2 || return $part2
                                }
                                $p = $part2->{'to'};
                                my $modifiers = '';
                                $m = Perlito5::Grammar::ident($str, $p);
                                if ($m) {
                                    $modifiers = Perlito5::Match::flat($m);
                                    $part2->{'to'} = $m->{'to'}
                                }
                                $part2->{'capture'} = Perlito5::AST::Apply::->new('code' => 'p5:tr', 'arguments' => [$str_regex, Perlito5::Match::flat($part2), Perlito5::AST::Buf::->new('buf' => $modifiers), Perlito5::AST::Var::->new('sigil' => '$', 'namespace' => '', 'name' => '_')], 'namespace' => '');
                                return $part2
                            }
                            sub Perlito5::Grammar::String::apply_quote_flags {
                                my($c, $quote_flags) = @_;
                                length($c) || return $c;
                                if ($quote_flags->{'l'}) {
                                    $c = lcfirst($c);
                                    delete($quote_flags->{'l'})
                                }
                                if ($quote_flags->{'u'}) {
                                    $c = ucfirst($c);
                                    delete($quote_flags->{'u'})
                                }
                                $quote_flags->{'L'} && ($c = lc($c));
                                $quote_flags->{'U'} && ($c = uc($c));
                                $quote_flags->{'Q'} && ($c = quotemeta($c));
                                return $c
                            }
                            sub Perlito5::Grammar::String::string_interpolation_parse {
                                my $str = $_[0];
                                my $pos = $_[1];
                                my $open_delimiter = $_[2];
                                my $delimiter = $_[3];
                                my $interpolate = $_[4];
                                my $quote_flags = $_[5] || {};
                                my $interpolate_vars = ($interpolate == 1 || $interpolate == 2);
                                my $p = $pos;
                                my $balanced = $open_delimiter && exists($pair{$open_delimiter});
                                my @args;
                                my $buf = '';
                                while ($p < length($str) && substr($str, $p, length($delimiter)) ne $delimiter) {
                                    my $c = substr($str, $p, 1);
                                    my $c2 = substr($str, $p + 1, 1);
                                    my $m;
                                    my $more = '';
                                    if ($balanced && $c eq chr(92) && ($c2 eq $open_delimiter || $c2 eq $delimiter)) {
                                        $p++;
                                        $c = $c2
                                    }
                                    elsif ($balanced && $c eq $open_delimiter) {
                                        $buf .= $c;
                                        $p++;
                                        $m = string_interpolation_parse($str, $p, $open_delimiter, $delimiter, $interpolate, $quote_flags);
                                        $more = $delimiter
                                    }
                                    elsif ($interpolate_vars && ($c eq '$' || $c eq '@')) {
                                        my $match = Perlito5::Grammar::String::double_quoted_var($str, $p, $delimiter, $interpolate);
                                        if ($match) {
                                            my $ast = $match->{'capture'};
                                            if ($quote_flags->{'l'}) {
                                                $ast = Perlito5::AST::Apply::->new('namespace' => '', 'code' => 'lcfirst', 'arguments' => [$ast]);
                                                delete($quote_flags->{'l'})
                                            }
                                            if ($quote_flags->{'u'}) {
                                                $ast = Perlito5::AST::Apply::->new('namespace' => '', 'code' => 'ucfirst', 'arguments' => [$ast]);
                                                delete($quote_flags->{'u'})
                                            }
                                            $quote_flags->{'L'} && ($ast = Perlito5::AST::Apply::->new('namespace' => '', 'code' => 'lc', 'arguments' => [$ast]));
                                            $quote_flags->{'U'} && ($ast = Perlito5::AST::Apply::->new('namespace' => '', 'code' => 'uc', 'arguments' => [$ast]));
                                            $quote_flags->{'Q'} && ($ast = Perlito5::AST::Apply::->new('namespace' => '', 'code' => 'quotemeta', 'arguments' => [$ast]));
                                            $match->{'capture'} = $ast
                                        }
                                        $m = $match
                                    }
                                    elsif ($c eq chr(92)) {
                                        if ($interpolate) {
                                            if ($c2 eq 'E') {
                                                my $flag_to_reset = $quote_flags->{'last_flag'};
                                                if ($flag_to_reset) {
                                                    delete($quote_flags->{$flag_to_reset});
                                                    delete($quote_flags->{'last_flag'})
                                                }
                                                else {
                                                    $quote_flags = {}
                                                }
                                                $p += 1;
                                                $c = ''
                                            }
                                            elsif ($c2 eq 'L') {
                                                $quote_flags->{$c2} = 1;
                                                delete($quote_flags->{'U'});
                                                $quote_flags->{'last_flag'} = $c2;
                                                $p += 1;
                                                $c = ''
                                            }
                                            elsif ($c2 eq 'U') {
                                                $quote_flags->{$c2} = 1;
                                                delete($quote_flags->{'L'});
                                                $quote_flags->{'last_flag'} = $c2;
                                                $p += 1;
                                                $c = ''
                                            }
                                            elsif ($c2 eq 'Q') {
                                                $quote_flags->{$c2} = 1;
                                                $quote_flags->{'last_flag'} = $c2;
                                                $p += 1;
                                                $c = ''
                                            }
                                            elsif ($c2 eq 'l') {
                                                $quote_flags->{'u'} || ($quote_flags->{$c2} = 1);
                                                $p += 1;
                                                $c = ''
                                            }
                                            elsif ($c2 eq 'u') {
                                                $quote_flags->{'l'} || ($quote_flags->{$c2} = 1);
                                                $p += 1;
                                                $c = ''
                                            }
                                        }
                                        if ($c) {
                                            if ($interpolate == 2) {
                                                $m = {'str' => $str, 'from' => $p, 'to' => $p + 2, 'capture' => Perlito5::AST::Buf::->new('buf' => substr($str, $p, 2))}
                                            }
                                            elsif ($interpolate == 1) {
                                                $m = Perlito5::Grammar::String::double_quoted_unescape($str, $p)
                                            }
                                            else {
                                                $m = $c2 eq chr(92) ? {'str' => $str, 'from' => $p, 'to' => $p + 2, 'capture' => Perlito5::AST::Buf::->new('buf' => chr(92))} : $c2 eq chr(39) ? {'str' => $str, 'from' => $p, 'to' => $p + 2, 'capture' => Perlito5::AST::Buf::->new('buf' => chr(39))} : 0
                                            }
                                        }
                                    }
                                    if ($m) {
                                        my $obj = Perlito5::Match::flat($m);
                                        if (ref($obj) eq 'Perlito5::AST::Buf') {
                                            $buf .= apply_quote_flags($obj->{'buf'}, $quote_flags);
                                            $obj = undef
                                        }
                                        if ($obj) {
                                            if (length($buf)) {
                                                push(@args, Perlito5::AST::Buf::->new('buf' => $buf));
                                                $buf = ''
                                            }
                                            push(@args, $obj)
                                        }
                                        $p = $m->{'to'};
                                        $buf .= $more
                                    }
                                    else {
                                        $p++;
                                        if ($c eq chr(10) || $c eq chr(13)) {
                                            my $m = here_doc($str, $p);
                                            if ($p != $m->{'to'}) {
                                                $p = $m->{'to'}
                                            }
                                            else {
                                                $buf .= apply_quote_flags($c, $quote_flags)
                                            }
                                        }
                                        else {
                                            $buf .= apply_quote_flags($c, $quote_flags)
                                        }
                                    }
                                }
                                if (length($buf)) {
                                    push(@args, Perlito5::AST::Buf::->new('buf' => $buf))
                                }
                                substr($str, $p, length($delimiter)) ne $delimiter && Perlito5::Compiler::error('Can' . chr(39) . 't find string terminator ' . chr(39) . $delimiter . chr(39) . ' anywhere before EOF');
                                $p += length($delimiter);
                                my $ast;
                                if (!@args) {
                                    $ast = Perlito5::AST::Buf::->new('buf' => '')
                                }
                                elsif (@args == 1) {
                                    $ast = $args[0]
                                }
                                else {
                                    $ast = Perlito5::AST::Apply::->new('namespace' => '', 'code' => 'list:<.>', 'arguments' => \@args)
                                }
                                return {'str' => $str, 'from' => $pos, 'to' => $p, 'capture' => $ast}
                            }
                            our @Here_doc;
                            sub Perlito5::Grammar::String::here_doc_wanted {
                                my $str = $_[0];
                                my $pos = $_[1];
                                my $delimiter;
                                my $type = 'double_quote';
                                my $p = $pos;
                                if (substr($str, $p, 2) eq '<<') {
                                    $p += 2;
                                    my $quote = substr($str, $p, 1);
                                    if ($quote eq chr(39) || $quote eq '"') {
                                        $p += 1;
                                        my $m = string_interpolation_parse($str, $p, $quote, $quote, 0);
                                        if ($m) {
                                            $p = $m->{'to'};
                                            $delimiter = Perlito5::Match::flat($m)->{'buf'};
                                            $type = $quote eq chr(39) ? 'single_quote' : 'double_quote'
                                        }
                                    }
                                    else {
                                        $quote eq chr(92) && ($p += 1);
                                        my $m = Perlito5::Grammar::ident($str, $p);
                                        if ($m) {
                                            $p = $m->{'to'};
                                            $delimiter = Perlito5::Match::flat($m);
                                            $type = $quote eq chr(92) ? 'single_quote' : 'double_quote'
                                        }
                                        else {
                                            $Perlito5::WARNINGS && warn('Use of bare << to mean <<"" is deprecated');
                                            $delimiter = '';
                                            $type = 'double_quote'
                                        }
                                    }
                                }
                                if (!defined($delimiter)) {
                                    return 0
                                }
                                my $placeholder = Perlito5::AST::Apply::->new('code' => 'list:<.>', 'namespace' => '', 'arguments' => [Perlito5::AST::Apply::->new('code' => 'list:<.>', 'namespace' => '', 'arguments' => [])]);
                                push(@Here_doc, [$type, $placeholder->{'arguments'}->[0]->{'arguments'}, $delimiter]);
                                return {'str' => $str, 'from' => $pos, 'to' => $p, 'capture' => ['term', $placeholder]}
                            }
                            sub Perlito5::Grammar::String::newline {
                                my $str = $_[0];
                                my $pos = $_[1];
                                my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
                                my $tmp = ((do {
                                    my $pos1 = $MATCH->{'to'};
                                    (do {
                                        ((chr(10) eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                                            my $m = $MATCH;
                                            if (!(chr(13) eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}))) {
                                                $MATCH = $m
                                            }
                                            1
                                        }))
                                    }) || (do {
                                        $MATCH->{'to'} = $pos1;
                                        ((chr(13) eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                                            my $m = $MATCH;
                                            if (!(chr(10) eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}))) {
                                                $MATCH = $m
                                            }
                                            1
                                        }))
                                    })
                                }));
                                $tmp ? $MATCH : 0
                            }
                            sub Perlito5::Grammar::String::here_doc {
                                my $str = $_[0];
                                my $pos = $_[1];
                                if (!@Here_doc) {
                                    return {'str' => $str, 'from' => $pos, 'to' => $pos}
                                }
                                my $p = $pos;
                                my $here = shift(@Here_doc);
                                my $type = $here->[0];
                                my $result = $here->[1];
                                my $delimiter = $here->[2];
                                if ($type eq 'single_quote') {
                                    while ($p < length($str)) {
                                        if (substr($str, $p, length($delimiter)) eq $delimiter) {
                                            push(@{$result}, Perlito5::AST::Buf::->new('buf' => substr($str, $pos, $p - $pos)));
                                            $p += length($delimiter);
                                            my $m = newline($str, $p);
                                            if ($p >= length($str) || $m) {
                                                $m && ($p = $m->{'to'});
                                                return {'str' => $str, 'from' => $pos, 'to' => $p - 1}
                                            }
                                        }
                                        while ($p < length($str) && (substr($str, $p, 1) ne chr(10) && substr($str, $p, 1) ne chr(13))) {
                                            $p++
                                        }
                                        while ($p < length($str) && (substr($str, $p, 1) eq chr(10) || substr($str, $p, 1) eq chr(13))) {
                                            $p++
                                        }
                                    }
                                }
                                else {
                                    my $m;
                                    if (substr($str, $p, length($delimiter)) eq $delimiter) {
                                        $p += length($delimiter);
                                        $m = newline($str, $p);
                                        if ($p >= length($str) || $m) {
                                            push(@{$result}, Perlito5::AST::Buf::->new('buf' => ''));
                                            $m && ($p = $m->{'to'});
                                            return {'str' => $str, 'from' => $pos, 'to' => $p}
                                        }
                                    }
                                    $m = string_interpolation_parse($str, $pos, '', chr(10) . $delimiter . chr(10), 1);
                                    if ($m) {
                                        push(@{$result}, Perlito5::Match::flat($m));
                                        push(@{$result}, Perlito5::AST::Buf::->new('buf' => chr(10)));
                                        $m->{'to'} = $m->{'to'} - 1;
                                        return $m
                                    }
                                }
                                Perlito5::Compiler::error('Can' . chr(39) . 't find string terminator "' . $delimiter . '" anywhere before EOF')
                            }
                            sub Perlito5::Grammar::String::double_quoted_unescape {
                                my $str = $_[0];
                                my $pos = $_[1];
                                my $c2 = substr($str, $pos + 1, 1);
                                my $m;
                                if (exists($escape_sequence{$c2})) {
                                    $m = {'str' => $str, 'from' => $pos, 'to' => $pos + 2, 'capture' => Perlito5::AST::Buf::->new('buf' => chr($escape_sequence{$c2}))}
                                }
                                elsif ($c2 eq 'c') {
                                    my $c3 = ord(uc(substr($str, $pos + 2, 1))) - ord('A') + 1;
                                    $c3 < 0 && ($c3 = 128 + $c3);
                                    $m = {'str' => $str, 'from' => $pos, 'to' => $pos + 3, 'capture' => Perlito5::AST::Buf::->new('buf' => chr($c3))}
                                }
                                elsif ($c2 eq 'x') {
                                    if (substr($str, $pos + 2, 1) eq '{') {
                                        my $p = $pos + 3;
                                        $p++
                                            while $p < length($str) && substr($str, $p, 1) ne '}';
                                        my $hex_code = substr($str, $pos + 3, $p - $pos - 3);
                                        $hex_code || ($hex_code = 0);
                                        my $tmp = oct('0x' . $hex_code);
                                        $m = {'str' => $str, 'from' => $pos, 'to' => $p + 1, 'capture' => Perlito5::AST::Buf::->new('buf' => chr($tmp))}
                                    }
                                    else {
                                        my $p = $pos + 2;
                                        $hex{uc(substr($str, $p, 1))} && $p++;
                                        $hex{uc(substr($str, $p, 1))} && $p++;
                                        my $hex_code = substr($str, $pos + 2, $p - $pos - 2);
                                        $hex_code || ($hex_code = 0);
                                        my $tmp = oct('0x' . $hex_code);
                                        $m = {'str' => $str, 'from' => $pos, 'to' => $p, 'capture' => Perlito5::AST::Buf::->new('buf' => chr($tmp))}
                                    }
                                }
                                elsif (exists($octal{$c2})) {
                                    my $p = $pos + 1;
                                    $octal{substr($str, $p, 1)} && $p++;
                                    $octal{substr($str, $p, 1)} && $p++;
                                    $octal{substr($str, $p, 1)} && $p++;
                                    my $oct_code = substr($str, $pos + 1, $p - $pos - 1);
                                    my $tmp = oct($oct_code);
                                    $m = {'str' => $str, 'from' => $pos, 'to' => $p, 'capture' => Perlito5::AST::Buf::->new('buf' => chr($tmp))}
                                }
                                elsif ($c2 eq 'N') {
                                    Perlito5::Compiler::error('TODO - ' . chr(92) . 'N{charname} not implemented; requires ' . chr(39) . 'use charnames' . chr(39))
                                }
                                else {
                                    $m = {'str' => $str, 'from' => $pos, 'to' => $pos + 2, 'capture' => Perlito5::AST::Buf::->new('buf' => $c2)}
                                }
                                return $m
                            }
                            sub Perlito5::Grammar::String::double_quoted_var_with_subscript {
                                my $m_var = $_[0];
                                my $interpolate = $_[1];
                                my $str = $m_var->{'str'};
                                my $pos = $m_var->{'to'};
                                my $p = $pos;
                                my $m_index;
                                if (substr($str, $p, 3) eq '->[') {
                                    $p += 3;
                                    $m_index = Perlito5::Grammar::Expression::list_parse($str, $p);
                                    $m_index || Perlito5::Compiler::error('syntax error');
                                    my $exp = $m_index->{'capture'};
                                    $p = $m_index->{'to'};
                                    ($exp eq '*undef*' || substr($str, $p, 1) ne ']') && Perlito5::Compiler::error('syntax error');
                                    $p++;
                                    $m_index->{'capture'} = Perlito5::AST::Call::->new('method' => 'postcircumfix:<[ ]>', 'invocant' => $m_var->{'capture'}, 'arguments' => $exp);
                                    $m_index->{'to'} = $p;
                                    return double_quoted_var_with_subscript($m_index, $interpolate)
                                }
                                if (substr($str, $p, 3) eq '->{') {
                                    $pos += 2;
                                    $m_index = Perlito5::Grammar::Expression::term_curly($str, $pos);
                                    $m_index || Perlito5::Compiler::error('syntax error');
                                    $m_index->{'capture'} = Perlito5::AST::Call::->new('method' => 'postcircumfix:<{ }>', 'invocant' => $m_var->{'capture'}, 'arguments' => Perlito5::Match::flat($m_index)->[2]->[0]);
                                    return double_quoted_var_with_subscript($m_index, $interpolate)
                                }
                                if (substr($str, $p, 1) eq '[') {
                                    if ($interpolate == 2) {
                                        my $m = Perlito5::Grammar::Number::term_digit($str, $p + 1) || (substr($str, $p + 1, 1) eq '-' && Perlito5::Grammar::Number::term_digit($str, $p + 2)) || Perlito5::Grammar::Sigil::term_sigil($str, $p + 1);
                                        $m || return $m_var;
                                        substr($str, $m->{'to'}, 1) eq ']' || return $m_var
                                    }
                                    $p++;
                                    $m_index = Perlito5::Grammar::Expression::list_parse($str, $p);
                                    if ($m_index) {
                                        my $exp = $m_index->{'capture'};
                                        $p = $m_index->{'to'};
                                        if ($exp ne '*undef*' && substr($str, $p, 1) eq ']') {
                                            $p++;
                                            my $value = $m_var->{'capture'};
                                            if (ref($value) eq 'Perlito5::AST::Var') {
                                                $value->{'_real_sigil'} = '@'
                                            }
                                            $m_index->{'capture'} = Perlito5::AST::Index::->new('obj' => $value, 'index_exp' => $exp);
                                            $m_index->{'to'} = $p;
                                            return double_quoted_var_with_subscript($m_index, $interpolate)
                                        }
                                    }
                                }
                                $m_index = Perlito5::Grammar::Expression::term_curly($str, $pos);
                                if ($m_index) {
                                    my $value = $m_var->{'capture'};
                                    if (ref($value) eq 'Perlito5::AST::Var') {
                                        $value->{'_real_sigil'} = '%'
                                    }
                                    $m_index->{'capture'} = Perlito5::AST::Lookup::->new('obj' => $value, 'index_exp' => Perlito5::Match::flat($m_index)->[2]->[0]);
                                    return double_quoted_var_with_subscript($m_index, $interpolate)
                                }
                                return $m_var
                            }
                            sub Perlito5::Grammar::String::double_quoted_var {
                                my $str = $_[0];
                                my $pos = $_[1];
                                my $delimiter = $_[2];
                                my $interpolate = $_[3];
                                my $c = substr($str, $pos, 1);
                                if ($c eq '$' && substr($str, $pos + 1, 1) eq '{') {
                                    my $m = Perlito5::Grammar::Sigil::term_sigil($str, $pos);
                                    $m || return $m;
                                    my $var = Perlito5::Match::flat($m)->[1];
                                    $m->{'capture'} = $var;
                                    return $m
                                }
                                elsif ($c eq '$' && substr($str, $pos + 1, 1) eq '$' && !Perlito5::Grammar::word($str, $pos + 2)) {
                                    return {'str' => $str, 'capture' => Perlito5::AST::Var::->new('name' => '$', 'sigil' => '$', 'namespace' => ''), 'from' => $pos, 'to' => $pos + 2}
                                }
                                elsif ($c eq '$' && substr($str, $pos + 1, length($delimiter)) ne $delimiter) {
                                    my $m = Perlito5::Grammar::Sigil::term_sigil($str, $pos);
                                    $m || return $m;
                                    $m->{'capture'} = $m->{'capture'}->[1];
                                    return double_quoted_var_with_subscript($m, $interpolate)
                                }
                                elsif ($c eq '@' && substr($str, $pos + 1, length($delimiter)) ne $delimiter) {
                                    my $m = Perlito5::Grammar::Sigil::term_sigil($str, $pos);
                                    $m || return $m;
                                    $m->{'capture'} = $m->{'capture'}->[1];
                                    $m = double_quoted_var_with_subscript($m, $interpolate);
                                    $m->{'capture'} = Perlito5::AST::Apply::->new('code' => 'join', 'arguments' => [Perlito5::AST::Var::->new('name' => '"', 'sigil' => '$', 'namespace' => ''), $m->{'capture'}], 'namespace' => '');
                                    return $m
                                }
                                return 0
                            }
                            Perlito5::Grammar::Precedence::add_term(chr(39) => \&term_q_quote);
                            Perlito5::Grammar::Precedence::add_term('"' => \&term_qq_quote);
                            Perlito5::Grammar::Precedence::add_term('/' => \&term_m_quote);
                            Perlito5::Grammar::Precedence::add_term('<' => \&term_glob);
                            Perlito5::Grammar::Precedence::add_term('<<>>' => \&term_glob);
                            Perlito5::Grammar::Precedence::add_term('<<' => \&here_doc_wanted);
                            Perlito5::Grammar::Precedence::add_term('`' => \&term_qx);
                            Perlito5::Grammar::Precedence::add_term('m' => \&term_m_quote);
                            Perlito5::Grammar::Precedence::add_term('q' => \&term_q_quote);
                            Perlito5::Grammar::Precedence::add_term('qq' => \&term_qq_quote);
                            Perlito5::Grammar::Precedence::add_term('qw' => \&term_qw_quote);
                            Perlito5::Grammar::Precedence::add_term('qx' => \&term_qx);
                            Perlito5::Grammar::Precedence::add_term('qr' => \&term_qr_quote);
                            Perlito5::Grammar::Precedence::add_term('s' => \&term_s_quote);
                            Perlito5::Grammar::Precedence::add_term('tr' => \&term_tr_quote);
                            Perlito5::Grammar::Precedence::add_term('y' => \&term_tr_quote);
                            1
                        }
                    }
                    {
                        {
                            package main;
                            undef();
                            package Perlito5::Grammar::Sigil;
                            undef();
                            my %special_var = ('$_' => '', '$&' => '', '$`' => '', '$' . chr(39) => '', '$+' => '', '@+' => '', '%+' => '', '$.' => '', '$/' => '', '$|' => '', '$,' => '', '$' . chr(92) => '', '$"' => '', '$;' => '', '$%' => '', '$=' => '', '$-' => '', '@-' => '', '%-' => '', '$~' => '', '$^' => '', '$:' => '', '$?' => '', '$!' => '', '%!' => '', '$@' => '', '$$' => '', '$<' => '', '$>' => '', '$(' => '', '$)' => '', '$[' => '', '$]' => '', '$}' => '', '@_' => '', '*_' => '', '*&' => '', '*`' => '', '*' . chr(39) => '', '*+' => '', '*.' => '', '*/' => '', '*|' => '', '*,' => '', '*' . chr(92) => '', '*"' => '', '*;' => '', '*%' => '', '*=' => '', '*-' => '', '*~' => '', '*^' => '', '*:' => '', '*?' => '', '*!' => '', '*@' => '', '*$' => '', '*<' => '', '*>' => '', '*(' => '', '*)' => '', '*[' => '', '*]' => '', '*_' => '', '**' => '', '*#' => '', '$#+' => '', '$#-' => '', '$#_' => '');
                            sub Perlito5::Grammar::Sigil::term_special_var {
                                my $str = $_[0];
                                my $pos = $_[1];
                                my $len = 0;
                                my $s = substr($str, $pos, 3);
                                if ($s eq '$#[') {
                                    $len = 2
                                }
                                elsif (exists($special_var{$s})) {
                                    $len = length($s)
                                }
                                else {
                                    $s = substr($str, $pos, 2);
                                    if (exists($special_var{$s})) {
                                        $len = 2
                                    }
                                }
                                if ($len) {
                                    my $c0 = substr($str, $pos + $len - 1, 1);
                                    my $c1 = substr($str, $pos + $len, 1);
                                    if (($c0 eq '$' || $c0 eq '@' || $c0 eq '%' || $c0 eq '*' || $c0 eq '&') && ($c1 eq '$' || $c1 eq '@' || $c1 eq '%' || $c1 eq '*' || $c1 eq '&' || ($c1 ge 'a' && $c1 le 'z') || ($c1 ge 'A' && $c1 le 'Z') || ($c1 ge 0 && $c1 le 9))) {}
                                    else {
                                        return {'str' => $str, 'from' => $pos, 'to' => $pos + $len, 'capture' => ['term', Perlito5::AST::Var::->new('sigil' => substr($s, 0, $len - 1), 'namespace' => $special_var{$s}, 'name' => substr($s, $len - 1, 1), '_namespace' => 'main')]}
                                    }
                                }
                                return 0
                            }
                            my %sigil = ('$' => 1, '%' => 1, '@' => 1, '&' => 1, '*' => 1);
                            sub Perlito5::Grammar::Sigil::term_sigil {
                                my $str = $_[0];
                                my $pos = $_[1];
                                my $c1 = substr($str, $pos, 1);
                                exists($sigil{$c1}) || return ;
                                my $p = $pos + 1;
                                my $sigil = $c1;
                                if (substr($str, $pos, 2) eq '$#') {
                                    $sigil = '$#';
                                    $p++
                                }
                                my $m = Perlito5::Grammar::Space::opt_ws($str, $p);
                                $p = $m->{'to'};
                                my $p0 = $p;
                                $c1 = substr($str, $p, 1);
                                my $q = $p + 1;
                                if ($c1 eq '{') {
                                    my $p = $q;
                                    $m = Perlito5::Grammar::Space::opt_ws($str, $p);
                                    $p = $m->{'to'};
                                    $m = Perlito5::Grammar::optional_namespace_before_ident($str, $p);
                                    if ($m) {
                                        my $namespace = Perlito5::Match::flat($m);
                                        my $pos = $m->{'to'};
                                        my $n = Perlito5::Grammar::var_name($str, $m->{'to'});
                                        my $name;
                                        if ($n) {
                                            $name = Perlito5::Match::flat($n);
                                            $pos = $n->{'to'}
                                        }
                                        if ($namespace || $name) {
                                            my $spc = Perlito5::Grammar::Space::opt_ws($str, $pos);
                                            if (substr($str, $pos, 1) eq '{' || substr($str, $pos, 1) eq '[' || substr($str, $pos, 1) eq '}') {
                                                $m->{'capture'} = Perlito5::AST::Var::->new('sigil' => $sigil, 'namespace' => $namespace, 'name' => $name);
                                                $m->{'to'} = $spc->{'to'};
                                                $m = Perlito5::Grammar::String::double_quoted_var_with_subscript($m);
                                                $m->{'capture'} = ['term', $m->{'capture'}];
                                                $spc = Perlito5::Grammar::Space::opt_ws($str, $m->{'to'});
                                                my $p = $spc->{'to'};
                                                if (substr($str, $p, 1) eq '}') {
                                                    $m->{'to'} = $p + 1;
                                                    return $m
                                                }
                                            }
                                        }
                                    }
                                    my $caret = Perlito5::Grammar::caret_char($str, $p);
                                    if ($caret) {
                                        my $p = $caret->{'to'};
                                        my $name = Perlito5::Match::flat($caret);
                                        $m = Perlito5::Grammar::var_name($str, $p);
                                        if ($m) {
                                            $name = $name . Perlito5::Match::flat($m);
                                            $p = $m->{'to'}
                                        }
                                        if (substr($str, $p, 1) eq '}') {
                                            $caret->{'capture'} = ['term', Perlito5::AST::Var::->new('name' => $name, 'namespace' => '', 'sigil' => $sigil)];
                                            $caret->{'to'} = $p + 1;
                                            return $caret
                                        }
                                    }
                                    my $special = $sigil . substr($str, $p, 1);
                                    if (exists($special_var{$special})) {
                                        my $m = Perlito5::Grammar::Space::opt_ws($str, $p + 1);
                                        my $p2 = $m->{'to'};
                                        my $c2 = substr($str, $p2, 1);
                                        if ($c2 eq '}') {
                                            $m->{'to'} = $p2 + 1;
                                            $m->{'capture'} = ['term', Perlito5::AST::Var::->new('sigil' => $sigil, 'namespace' => '', 'name' => substr($str, $p, 1), ($sigil eq '$#' ? ('_real_sigil' => '@') : ()), '_namespace' => 'main')];
                                            return $m
                                        }
                                    }
                                    if (substr($str, $p, 1) eq '}') {
                                        Perlito5::Compiler::error('syntax error')
                                    }
                                    $m = Perlito5::Grammar::block($str, $p0);
                                    if ($m) {
                                        my $ast = Perlito5::Match::flat($m);
                                        if (@{$ast->{'stmts'}} == 1 && (ref($ast->{'stmts'}->[0]) eq 'Perlito5::AST::Apply' || ref($ast->{'stmts'}->[0]) eq 'Perlito5::AST::Call' || ref($ast->{'stmts'}->[0]) eq 'Perlito5::AST::Var' || ref($ast->{'stmts'}->[0]) eq 'Perlito5::AST::Index' || ref($ast->{'stmts'}->[0]) eq 'Perlito5::AST::Lookup')) {
                                            $m->{'capture'} = ['term', Perlito5::AST::Apply::->new('code' => 'prefix:<' . $sigil . '>', 'namespace' => '', 'arguments' => [$ast->{'stmts'}->[0]])];
                                            return $m
                                        }
                                        $m->{'capture'} = ['term', Perlito5::AST::Apply::->new('code' => 'prefix:<' . $sigil . '>', 'arguments' => [Perlito5::AST::Apply::->new('code' => 'do', 'namespace' => '', 'arguments' => [$ast])])];
                                        return $m
                                    }
                                }
                                my $caret = Perlito5::Grammar::caret_char($str, $p);
                                if ($caret) {
                                    my $name = Perlito5::Match::flat($caret);
                                    $caret->{'capture'} = ['term', Perlito5::AST::Var::->new('name' => $name, 'namespace' => '', 'sigil' => $sigil)];
                                    return $caret
                                }
                                if ($c1 eq '$') {
                                    my $m2 = Perlito5::Grammar::Space::opt_ws($str, $p + 1);
                                    my $p2 = $m2->{'to'};
                                    my $c2 = substr($str, $p2, 1);
                                    if ($c2 ne ',' && $c2 ne ';') {
                                        $m = term_sigil($str, $p);
                                        if ($m) {
                                            $m->{'capture'} = ['term', Perlito5::AST::Apply::->new('arguments' => [$m->{'capture'}->[1]], 'code' => 'prefix:<' . $sigil . '>', 'namespace' => '')];
                                            return $m
                                        }
                                    }
                                }
                                $m = Perlito5::Grammar::optional_namespace_before_ident($str, $p);
                                if ($m) {
                                    my $namespace = Perlito5::Match::flat($m);
                                    my $n = Perlito5::Grammar::var_name($str, $m->{'to'});
                                    if ($n) {
                                        $n->{'capture'} = ['term', Perlito5::AST::Var::->new('sigil' => $sigil, 'namespace' => $namespace, 'name' => Perlito5::Match::flat($n), ($sigil eq '$#' ? ('_real_sigil' => '@') : ()))];
                                        return $n
                                    }
                                    if ($namespace) {
                                        $m->{'capture'} = ['term', Perlito5::AST::Var::->new('sigil' => $sigil, 'namespace' => $namespace, 'name' => undef, ($sigil eq '$#' ? ('_real_sigil' => '@') : ()))];
                                        return $m
                                    }
                                }
                                return term_special_var($str, $pos)
                            }
                            Perlito5::Grammar::Precedence::add_term('$' => \&term_sigil);
                            Perlito5::Grammar::Precedence::add_term('@' => \&term_sigil);
                            Perlito5::Grammar::Precedence::add_term('%' => \&term_sigil);
                            Perlito5::Grammar::Precedence::add_term('&' => \&term_sigil);
                            Perlito5::Grammar::Precedence::add_term('*' => \&term_sigil);
                            1
                        }
                    }
                    {
                        {
                            package main;
                            package Perlito5::Grammar::Use;
                            undef();
                            undef();
                            # use strict
                            my %Perlito_internal_module = ('strict' => 'Perlito5X::strict', 'warnings' => 'Perlito5X::warnings', 'feature' => 'Perlito5X::feature', 'utf8' => 'Perlito5X::utf8', 'bytes' => 'Perlito5X::bytes', 'encoding' => 'Perlito5X::encoding', 'Carp' => 'Perlito5X::Carp', 'Exporter' => 'Perlito5X::Exporter', 'Data::Dumper' => 'Perlito5X::Dumper');
                            sub Perlito5::Grammar::Use::use_decl {
                                my $str = $_[0];
                                my $pos = $_[1];
                                my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
                                my $tmp = ((do {
                                    my $pos1 = $MATCH->{'to'};
                                    (do {
                                        ('use' eq substr($str, $MATCH->{'to'}, 3) && ($MATCH->{'to'} = 3 + $MATCH->{'to'}))
                                    }) || (do {
                                        $MATCH->{'to'} = $pos1;
                                        ('no' eq substr($str, $MATCH->{'to'}, 2) && ($MATCH->{'to'} = 2 + $MATCH->{'to'}))
                                    })
                                }));
                                $tmp ? $MATCH : 0
                            }
                            sub Perlito5::Grammar::Use::version_string {
                                my $str = $_[0];
                                my $pos = $_[1];
                                my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
                                my $tmp = ((do {
                                    my $pos1 = $MATCH->{'to'};
                                    (do {
                                        ((do {
                                            my $m2 = Perlito5::Grammar::Number::val_version($str, $MATCH->{'to'});
                                            if ($m2) {
                                                $MATCH->{'to'} = $m2->{'to'};
                                                $MATCH->{'Perlito5::Grammar::Number::val_version'} = $m2;
                                                1
                                            }
                                            else {
                                                0
                                            }
                                        }) && (do {
                                            $MATCH->{'capture'} = $MATCH->{'Perlito5::Grammar::Number::val_version'}->{'capture'};
                                            1
                                        }))
                                    }) || (do {
                                        $MATCH->{'to'} = $pos1;
                                        ((do {
                                            my $m2 = Perlito5::Grammar::Number::term_digit($str, $MATCH->{'to'});
                                            if ($m2) {
                                                $MATCH->{'to'} = $m2->{'to'};
                                                $MATCH->{'Perlito5::Grammar::Number::term_digit'} = $m2;
                                                1
                                            }
                                            else {
                                                0
                                            }
                                        }) && (do {
                                            my $version = $MATCH->{'Perlito5::Grammar::Number::term_digit'}->{'capture'}->[1]->{'buf'} || $MATCH->{'Perlito5::Grammar::Number::term_digit'}->{'capture'}->[1]->{'int'} || $MATCH->{'Perlito5::Grammar::Number::term_digit'}->{'capture'}->[1]->{'num'};
                                            $MATCH->{'capture'} = Perlito5::AST::Buf::->new('buf' => $version);
                                            1
                                        }))
                                    })
                                }));
                                $tmp ? $MATCH : 0
                            }
                            sub Perlito5::Grammar::Use::term_require {
                                my $str = $_[0];
                                my $pos = $_[1];
                                my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
                                my $tmp = ((('require' eq substr($str, $MATCH->{'to'}, 7) && ($MATCH->{'to'} = 7 + $MATCH->{'to'})) && (do {
                                    my $m2 = Perlito5::Grammar::Space::ws($str, $MATCH->{'to'});
                                    if ($m2) {
                                        $MATCH->{'to'} = $m2->{'to'};
                                        1
                                    }
                                    else {
                                        0
                                    }
                                }) && (do {
                                    my $pos1 = $MATCH->{'to'};
                                    (do {
                                        ((do {
                                            my $m2 = version_string($str, $MATCH->{'to'});
                                            if ($m2) {
                                                $MATCH->{'to'} = $m2->{'to'};
                                                $MATCH->{'version_string'} = $m2;
                                                1
                                            }
                                            else {
                                                0
                                            }
                                        }) && (do {
                                            my $version = $MATCH->{'version_string'}->{'capture'};
                                            $version->{'is_version_string'} = 1;
                                            $MATCH->{'capture'} = ['term', Perlito5::AST::Apply::->new('code' => 'require', 'namespace' => '', 'arguments' => [$version])];
                                            1
                                        }))
                                    }) || (do {
                                        $MATCH->{'to'} = $pos1;
                                        ((do {
                                            my $m2 = Perlito5::Grammar::full_ident($str, $MATCH->{'to'});
                                            if ($m2) {
                                                $MATCH->{'to'} = $m2->{'to'};
                                                $MATCH->{'Perlito5::Grammar::full_ident'} = $m2;
                                                1
                                            }
                                            else {
                                                0
                                            }
                                        }) && (do {
                                            my $module_name = Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::full_ident'});
                                            my $filename = modulename_to_filename($module_name);
                                            $MATCH->{'capture'} = ['term', Perlito5::AST::Apply::->new('code' => 'require', 'namespace' => '', 'arguments' => [Perlito5::AST::Buf::->new('buf' => $filename)])];
                                            1
                                        }))
                                    })
                                })));
                                $tmp ? $MATCH : 0
                            }
                            sub Perlito5::Grammar::Use::stmt_use {
                                my $str = $_[0];
                                my $pos = $_[1];
                                my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
                                my $tmp = (((do {
                                    my $m2 = use_decl($str, $MATCH->{'to'});
                                    if ($m2) {
                                        $MATCH->{'to'} = $m2->{'to'};
                                        $MATCH->{'use_decl'} = $m2;
                                        1
                                    }
                                    else {
                                        0
                                    }
                                }) && (do {
                                    my $m2 = Perlito5::Grammar::Space::ws($str, $MATCH->{'to'});
                                    if ($m2) {
                                        $MATCH->{'to'} = $m2->{'to'};
                                        1
                                    }
                                    else {
                                        0
                                    }
                                }) && (do {
                                    my $pos1 = $MATCH->{'to'};
                                    (do {
                                        ((do {
                                            my $m2 = version_string($str, $MATCH->{'to'});
                                            if ($m2) {
                                                $MATCH->{'to'} = $m2->{'to'};
                                                $MATCH->{'version_string'} = $m2;
                                                1
                                            }
                                            else {
                                                0
                                            }
                                        }) && (do {
                                            my $version = $MATCH->{'version_string'}->{'capture'}->{'buf'};
                                            Perlito5::test_perl_version($version);
                                            $MATCH->{'capture'} = Perlito5::AST::Apply::->new('code' => 'undef', 'namespace' => '', 'arguments' => []);
                                            1
                                        }))
                                    }) || (do {
                                        $MATCH->{'to'} = $pos1;
                                        ((do {
                                            my $m2 = Perlito5::Grammar::full_ident($str, $MATCH->{'to'});
                                            if ($m2) {
                                                $MATCH->{'to'} = $m2->{'to'};
                                                $MATCH->{'Perlito5::Grammar::full_ident'} = $m2;
                                                1
                                            }
                                            else {
                                                0
                                            }
                                        }) && (do {
                                            my $m = $MATCH;
                                            if (!(('-' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                                                my $m2 = Perlito5::Grammar::ident($str, $MATCH->{'to'});
                                                if ($m2) {
                                                    $MATCH->{'to'} = $m2->{'to'};
                                                    if (exists($MATCH->{'Perlito5::Grammar::ident'})) {
                                                        push(@{$MATCH->{'Perlito5::Grammar::ident'}}, $m2)
                                                    }
                                                    else {
                                                        $MATCH->{'Perlito5::Grammar::ident'} = [$m2]
                                                    }
                                                    1
                                                }
                                                else {
                                                    0
                                                }
                                            }))) {
                                                $MATCH = $m
                                            }
                                            1
                                        }) && (do {
                                            my $m = $MATCH;
                                            if (!((do {
                                                my $m2 = Perlito5::Grammar::Space::ws($str, $MATCH->{'to'});
                                                if ($m2) {
                                                    $MATCH->{'to'} = $m2->{'to'};
                                                    1
                                                }
                                                else {
                                                    0
                                                }
                                            }) && (do {
                                                my $m2 = version_string($str, $MATCH->{'to'});
                                                if ($m2) {
                                                    $MATCH->{'to'} = $m2->{'to'};
                                                    if (exists($MATCH->{'version_string'})) {
                                                        push(@{$MATCH->{'version_string'}}, $m2)
                                                    }
                                                    else {
                                                        $MATCH->{'version_string'} = [$m2]
                                                    }
                                                    1
                                                }
                                                else {
                                                    0
                                                }
                                            }) && (do {
                                                my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{'to'});
                                                if ($m2) {
                                                    $MATCH->{'to'} = $m2->{'to'};
                                                    1
                                                }
                                                else {
                                                    0
                                                }
                                            }))) {
                                                $MATCH = $m
                                            }
                                            1
                                        }) && (do {
                                            my $m2 = Perlito5::Grammar::Expression::list_parse($str, $MATCH->{'to'});
                                            if ($m2) {
                                                $MATCH->{'to'} = $m2->{'to'};
                                                $MATCH->{'Perlito5::Grammar::Expression::list_parse'} = $m2;
                                                1
                                            }
                                            else {
                                                0
                                            }
                                        }) && (do {
                                            my $version = $MATCH->{'version_string'}->[0]->{'capture'}->{'buf'};
                                            my $list = Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::Expression::list_parse'});
                                            if ($list eq '*undef*') {
                                                $list = undef
                                            }
                                            else {
                                                my $m = $MATCH->{'Perlito5::Grammar::Expression::list_parse'};
                                                my $list_code = substr($str, $m->{'from'}, $m->{'to'} - $m->{'from'});
                                                my @list = eval($list_code);
                                                $list = \@list
                                            }
                                            my $full_ident = Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::full_ident'});
                                            $Perlito5::PACKAGES->{$full_ident} = 1;
                                            my $use_decl = Perlito5::Match::flat($MATCH->{'use_decl'});
                                            if ($use_decl eq 'use' && $full_ident eq 'vars' && $list) {
                                                my $code = 'our (' . join(', ', @{$list}) . ')';
                                                my $m = Perlito5::Grammar::Statement::statement_parse($code, 0);
                                                !$m && Perlito5::Compiler::error('not a valid variable name: ' . join(${'"'}, @{$list}));
                                                $MATCH->{'capture'} = $m->{'capture'}
                                            }
                                            elsif ($full_ident eq 'strict') {
                                                $Perlito5::STRICT = ($use_decl eq 'no' ? 0 : 1);
                                                my $ast = Perlito5::AST::Use::->new('code' => $use_decl, 'mod' => $full_ident, 'arguments' => $list);
                                                $MATCH->{'capture'} = $ast
                                            }
                                            elsif ($use_decl eq 'use' && $full_ident eq 'constant' && $list) {
                                                my @ast;
                                                my $name = shift(@{$list});
                                                if (ref($name) eq 'HASH') {
                                                    for my $key (sort {
                                                        $a cmp $b
                                                    } keys(%{$name})) {
                                                        my $code = 'sub ' . $key . ' () { ' . Perlito5::Dumper::_dumper($name->{$key}) . ' }';
                                                        my $m = Perlito5::Grammar::Statement::statement_parse($code, 0);
                                                        !$m && Perlito5::Compiler::error('not a valid constant: ' . join(${'"'}, @{$list}));
                                                        push(@ast, $m->{'capture'})
                                                    }
                                                }
                                                else {
                                                    my $code = 'sub ' . $name . ' () { (' . join(', ', map {
                                                        Perlito5::Dumper::_dumper($_)
                                                    } @{$list}) . ') }';
                                                    my $m = Perlito5::Grammar::Statement::statement_parse($code, 0);
                                                    !$m && Perlito5::Compiler::error('not a valid constant: ' . join(${'"'}, @{$list}));
                                                    push(@ast, $m->{'capture'})
                                                }
                                                $MATCH->{'capture'} = Perlito5::AST::Block::->new('stmts' => \@ast)
                                            }
                                            else {
                                                my $ast = Perlito5::AST::Use::->new('code' => $use_decl, 'mod' => $full_ident, 'arguments' => $list);
                                                if ($Perlito5::EMIT_USE) {
                                                    $MATCH->{'capture'} = $ast
                                                }
                                                else {
                                                    $MATCH->{'capture'} = parse_time_eval($ast)
                                                }
                                            }
                                            1
                                        }))
                                    }) || (do {
                                        $MATCH->{'to'} = $pos1;
                                        (do {
                                            Perlito5::Compiler::error('Syntax error');
                                            1
                                        })
                                    })
                                })));
                                $tmp ? $MATCH : 0
                            }
                            sub Perlito5::Grammar::Use::parse_time_eval {
                                my $ast = shift;
                                my $module_name = $ast->mod();
                                my $use_or_not = $ast->code();
                                my $arguments = $ast->{'arguments'};
                                my $skip_import = defined($arguments) && @{$arguments} == 0;
                                defined($arguments) || ($arguments = []);
                                my $comp_units = [];
                                if (!$Perlito5::EXPAND_USE) {
                                    expand_use($comp_units, $ast)
                                }
                                if ($Perlito5::EXPAND_USE) {
                                    my $current_module_name = $Perlito5::PKG_NAME;
                                    my $filename = modulename_to_filename($module_name);
                                    require($filename);
                                    if (!$skip_import) {
                                        if ($use_or_not eq 'use') {
                                            if (defined(&{$module_name . '::import'})) {
                                                unshift(@{$Perlito5::CALLER}, [$current_module_name]);
                                                eval('package ' . $current_module_name . ';' . chr(10) . '$module_name->import(@$arguments); 1') or ${'@'}->Perlito5::Compiler::error();
                                                shift(@{$Perlito5::CALLER})
                                            }
                                        }
                                        elsif ($use_or_not eq 'no') {
                                            if (defined(&{$module_name . '::unimport'})) {
                                                unshift(@{$Perlito5::CALLER}, [$current_module_name]);
                                                eval('package ' . $current_module_name . ';' . chr(10) . '$module_name->unimport(@$arguments); 1') or ${'@'}->Perlito5::Compiler::error();
                                                shift(@{$Perlito5::CALLER})
                                            }
                                        }
                                    }
                                }
                                if (@{$comp_units}) {
                                    return Perlito5::AST::Block::->new('stmts' => $comp_units)
                                }
                                else {
                                    return Perlito5::AST::Apply::->new('code' => 'undef', 'namespace' => '', 'arguments' => [])
                                }
                            }
                            sub Perlito5::Grammar::Use::emit_time_eval {
                                my $ast = shift;
                                if ($ast->mod() eq 'strict') {
                                    if ($ast->code() eq 'use') {
                                        strict::->import()
                                    }
                                    elsif ($ast->code() eq 'no') {
                                        strict::->unimport()
                                    }
                                }
                            }
                            sub Perlito5::Grammar::Use::modulename_to_filename {
                                my $s = shift;
                                exists($Perlito_internal_module{$s}) && ($s = $Perlito_internal_module{$s});
                                $s =~ s!::!/!g;
                                return $s . '.pm'
                            }
                            sub Perlito5::Grammar::Use::filename_lookup {
                                my $filename = shift;
                                if (exists($INC{$filename})) {
                                    $INC{$filename} && return 'done';
                                    Perlito5::Compiler::error('Compilation failed in require')
                                }
                                for my $prefix (@INC, '.') {
                                    my $realfilename = $prefix . '/' . $filename;
                                    if (-f $realfilename) {
                                        $INC{$filename} = $realfilename;
                                        return 'todo'
                                    }
                                }
                                Perlito5::Compiler::error('Can' . chr(39) . 't locate ' . $filename . ' in @INC ' . '(@INC contains ' . join(' ', @INC) . ').')
                            }
                            sub Perlito5::Grammar::Use::expand_use {
                                my $comp_units = shift;
                                my $stmt = shift;
                                my $module_name = $stmt->mod();
                                my $filename = modulename_to_filename($module_name);
                                filename_lookup($filename) eq 'done' && return ;
                                local $Perlito5::FILE_NAME = $filename;
                                local $Perlito5::LINE_NUMBER = 1;
                                my $realfilename = $INC{$filename};
                                open(FILE, '<', $realfilename) or Perlito5::Compiler::error('Cannot read ' . $realfilename . ': ' . ${'!'} . chr(10));
                                local $/ = undef;
                                my $source = <FILE>;
                                close(FILE);
                                my $m = Perlito5::Grammar::exp_stmts($source, 0);
                                $m->{'to'} != length($source) && Perlito5::Compiler::error('Syntax Error near ', $m->{'to'});
                                if ($m->{'to'} != length($source)) {
                                    my $pos = $m->{'to'} - 10;
                                    $pos < 0 && ($pos = 0);
                                    print('* near: ', substr($source, $pos, 20), chr(10));
                                    print('* filename: ' . $realfilename . chr(10));
                                    Perlito5::Compiler::error('Syntax Error')
                                }
                                if ($ENV{'PERLITO5DEV'}) {
                                    push(@{$comp_units}, Perlito5::AST::CompUnit::->new('name' => 'main', 'body' => Perlito5::Match::flat($m)));
                                    return 
                                }
                                push(@{$comp_units}, @{add_comp_unit([Perlito5::AST::CompUnit::->new('name' => 'main', 'body' => Perlito5::Match::flat($m))])});
                                return 
                            }
                            sub Perlito5::Grammar::Use::add_comp_unit {
                                my $parse = shift;
                                my $comp_units = [];
                                for my $comp_unit (@{$parse}) {
                                    if (defined($comp_unit)) {
                                        if ($comp_unit->isa('Perlito5::AST::Use')) {
                                            expand_use($comp_units, $comp_unit)
                                        }
                                        elsif ($comp_unit->isa('Perlito5::AST::CompUnit')) {
                                            for my $stmt (@{$comp_unit->body()}) {
                                                if ($stmt->isa('Perlito5::AST::Use')) {
                                                    expand_use($comp_units, $stmt)
                                                }
                                            }
                                        }
                                        push(@{$comp_units}, $comp_unit)
                                    }
                                }
                                return $comp_units
                            }
                            sub Perlito5::Grammar::Use::require {
                                my $filename = shift;
                                filename_lookup($filename) eq 'done' && return ;
                                my $result = do($filename);
                                if (${'@'}) {
                                    $INC{$filename} = undef;
                                    ${'@'}->Perlito5::Compiler::error()
                                }
                                elsif (!$result) {
                                    delete($INC{$filename});
                                    ${'@'} && warn(${'@'});
                                    Perlito5::Compiler::error($filename . ' did not return true value')
                                }
                                else {
                                    return $result
                                }
                            }
                            sub Perlito5::Grammar::Use::do_file {
                                my $filename = shift;
                                eval {
                                    filename_lookup($filename);
                                    1
                                } or do {
                                    $INC{$filename} = undef;
                                    ${'@'} = '';
                                    ${'!'} = 'No such file or directory';
                                    return 'undef'
                                };
                                my $realfilename = $INC{$filename};
                                open(FILE, '<', $realfilename) or Perlito5::Compiler::error('Cannot read ' . $realfilename . ': ' . ${'!'} . chr(10));
                                local $/ = undef;
                                my $source = <FILE>;
                                close(FILE);
                                return $source
                            }
                            Perlito5::Grammar::Statement::add_statement('no' => \&stmt_use);
                            Perlito5::Grammar::Statement::add_statement('use' => \&stmt_use);
                            Perlito5::Grammar::Precedence::add_term('require' => \&term_require);
                            1
                        }
                    }
                    {
                        {
                            package main;
                            package Perlito5::Grammar::Block;
                            undef();
                            {
                                {
                                    package main;
                                    package Perlito5::Grammar::Scope;
                                    # use strict
                                    our %Special_var = ('ARGV' => 1, 'INC' => 1, 'ENV' => 1, 'SIG' => 1, '_' => 1);
                                    sub Perlito5::Grammar::Scope::new {
                                        return {'block' => []}
                                    }
                                    sub Perlito5::Grammar::Scope::new_base_scope {
                                        return {'block' => []}
                                    }
                                    sub Perlito5::Grammar::Scope::create_new_compile_time_scope {
                                        my $new_scope = {'block' => []};
                                        push(@{$Perlito5::SCOPE->{'block'}}, $new_scope);
                                        $Perlito5::SCOPE_DEPTH++;
                                        $Perlito5::SCOPE = $new_scope
                                    }
                                    sub Perlito5::Grammar::Scope::end_compile_time_scope {
                                        my $pos = 0;
                                        $Perlito5::SCOPE_DEPTH--;
                                        $Perlito5::SCOPE = $Perlito5::BASE_SCOPE;
                                        while ($Perlito5::SCOPE_DEPTH > $pos) {
                                            $pos++;
                                            $Perlito5::SCOPE = $Perlito5::SCOPE->{'block'}->[-1]
                                        }
                                    }
                                    sub Perlito5::Grammar::Scope::lookup_variable {
                                        my $var = shift;
                                        my $scope = shift() // $Perlito5::BASE_SCOPE;
                                        $var->{'namespace'} && return $var;
                                        $var->{'_decl'} && return $var;
                                        my $look = lookup_variable_inner($var, $scope, 0);
                                        $look && return $look;
                                        my $c = substr($var->{'name'}, 0, 1);
                                        if ($Special_var{$var->{'name'}} || $c lt 'A' || ($c gt 'Z' && $c lt 'a') || $c gt 'z') {
                                            $var->{'_decl'} = 'global';
                                            $var->{'_namespace'} = 'main';
                                            return $var
                                        }
                                        if ($var->{'sigil'} eq '$' && ($var->{'name'} eq 'a' || $var->{'name'} eq 'b')) {
                                            if (!$var->{'_real_sigil'}) {
                                                $var->{'_decl'} = 'global';
                                                $var->{'_namespace'} = $Perlito5::PKG_NAME;
                                                return $var
                                            }
                                        }
                                        return 
                                    }
                                    sub Perlito5::Grammar::Scope::lookup_variable_inner {
                                        my($var, $scope, $depth) = @_;
                                        $depth > $Perlito5::SCOPE_DEPTH && return ;
                                        my $block = $scope->{'block'};
                                        if (@{$block} && ref($block->[-1]) eq 'HASH' && $block->[-1]->{'block'}) {
                                            my $look = lookup_variable_inner($var, $block->[-1], $depth + 1);
                                            $look && return $look
                                        }
                                        for my $item (reverse(@{$block})) {
                                            if (ref($item) eq 'Perlito5::AST::Var' && $item->{'_decl'} && $item->{'_decl'} ne 'global' && $item->{'name'} eq $var->{'name'}) {
                                                my $sigil = $var->{'_real_sigil'} || $var->{'sigil'};
                                                my $item_sigil = $item->{'_real_sigil'} || $item->{'sigil'};
                                                if ($sigil eq $item_sigil) {
                                                    return $item
                                                }
                                            }
                                        }
                                        return 
                                    }
                                    sub Perlito5::Grammar::Scope::check_variable_declarations {
                                        for my $item (@Perlito5::SCOPE_STMT) {
                                            if (ref($item) eq 'Perlito5::AST::Var') {
                                                my $var = $item;
                                                my $look = lookup_variable($var);
                                                if ($look) {
                                                    $look->{'_id'} && ($var->{'_id'} = $look->{'_id'});
                                                    $look->{'_decl'} && ($var->{'_decl'} = $look->{'_decl'});
                                                    $look->{'_namespace'} && ($var->{'_namespace'} = $look->{'_namespace'})
                                                }
                                                else {
                                                    if ($Perlito5::STRICT) {
                                                        my $sigil = $var->{'_real_sigil'} || $var->{'sigil'};
                                                        if ($sigil ne '*' && $sigil ne '&') {
                                                            Perlito5::Compiler::error('Global symbol "' . $sigil . $var->{'name'} . '"' . ' requires explicit package name')
                                                        }
                                                    }
                                                    $var->{'_decl'} = 'global';
                                                    $var->{'_namespace'} = $Perlito5::PKG_NAME
                                                }
                                                if ($ENV{'PERLITO5DEV'}) {
                                                    my $compiletime_name = ($var->{'_real_sigil'} || $var->{'sigil'}) . ($var->{'namespace'} || $var->{'_namespace'} || 'C_') . '::' . $var->{'name'} . ($var->{'_decl'} eq 'global' ? '' : '_' . $var->{'_id'});
                                                    $Perlito5::GLOBAL->{$compiletime_name} = {'value' => undef, 'ast' => $var}
                                                }
                                            }
                                        }
                                        push(@{$Perlito5::SCOPE->{'block'}}, @Perlito5::SCOPE_STMT);
                                        @Perlito5::SCOPE_STMT = ()
                                    }
                                    sub Perlito5::Grammar::Scope::get_snapshot {
                                        my @result;
                                        my $scope = shift() // $Perlito5::BASE_SCOPE;
                                        my $block = $scope->{'block'};
                                        if (@{$block} && ref($block->[-1]) eq 'HASH' && $block->[-1]->{'block'}) {
                                            my $look = get_snapshot($block->[-1]);
                                            unshift(@result, @{$look->{'block'}})
                                        }
                                        for my $item (@{$block}) {
                                            if (ref($item) eq 'Perlito5::AST::Var' && $item->{'_decl'}) {
                                                unshift(@result, $item)
                                            }
                                        }
                                        return {'block' => \@result}
                                    }
                                    1
                                }
                            }
                            # use strict
                            our %Named_block = ('BEGIN' => 1, 'UNITCHECK' => 1, 'CHECK' => 1, 'INIT' => 1, 'END' => 1, 'AUTOLOAD' => 1, 'DESTROY' => 1);
                            sub Perlito5::Grammar::Block::block {
                                my $str = $_[0];
                                my $pos = $_[1];
                                my $m = Perlito5::Grammar::Space::opt_ws($str, $pos);
                                $pos = $m->{'to'};
                                if (substr($str, $pos, 1) ne '{') {
                                    return 
                                }
                                $pos++;
                                Perlito5::Grammar::Scope::check_variable_declarations();
                                Perlito5::Grammar::Scope::create_new_compile_time_scope();
                                $m = Perlito5::Grammar::exp_stmts($str, $pos);
                                if (!$m) {
                                    Perlito5::Compiler::error('syntax error')
                                }
                                $pos = $m->{'to'};
                                my $capture = Perlito5::Match::flat($m);
                                $m = Perlito5::Grammar::Space::opt_ws($str, $pos);
                                $pos = $m->{'to'};
                                if (substr($str, $pos, 1) ne '}') {
                                    Perlito5::Compiler::error('syntax error')
                                }
                                $m->{'to'} = $pos + 1;
                                $m->{'capture'} = Perlito5::AST::Block::->new('stmts' => $capture, 'sig' => undef);
                                Perlito5::Grammar::Scope::end_compile_time_scope();
                                return $m
                            }
                            sub Perlito5::Grammar::Block::eval_end_block {
                                my($block, $phase) = @_;
                                local ${'@'};
                                my @data = $block->emit_perl5();
                                my $out = [];
                                Perlito5::Perl5::PrettyPrinter::pretty_print(\@data, 0, $out);
                                my $code = 'package ' . $Perlito5::PKG_NAME . ';' . chr(10) . 'sub ' . join('', @{$out}) . chr(10);
                                eval(Perlito5::CompileTime::Dumper::generate_eval_string($code)) or Perlito5::Compiler::error('Error in ' . $phase . ' block: ' . ${'@'})
                            }
                            sub Perlito5::Grammar::Block::eval_begin_block {
                                my $block = shift;
                                local ${'@'};
                                my @data = $block->emit_perl5();
                                my $out = [];
                                Perlito5::Perl5::PrettyPrinter::pretty_print(\@data, 0, $out);
                                my $code = 'package ' . $Perlito5::PKG_NAME . ';' . chr(10) . join('', @{$out}) . '; 1' . chr(10);
                                local ${chr(7) . 'LOBAL_PHASE'};
                                Perlito5::set_global_phase('BEGIN');
                                eval(Perlito5::CompileTime::Dumper::generate_eval_string($code)) or Perlito5::Compiler::error('Error in BEGIN block: ' . ${'@'})
                            }
                            sub Perlito5::Grammar::Block::opt_continue_block {
                                my $str = $_[0];
                                my $pos = $_[1];
                                my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
                                my $tmp = ((do {
                                    my $pos1 = $MATCH->{'to'};
                                    (do {
                                        ((do {
                                            my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{'to'});
                                            if ($m2) {
                                                $MATCH->{'to'} = $m2->{'to'};
                                                1
                                            }
                                            else {
                                                0
                                            }
                                        }) && ('continue' eq substr($str, $MATCH->{'to'}, 8) && ($MATCH->{'to'} = 8 + $MATCH->{'to'})) && (do {
                                            my $m2 = block($str, $MATCH->{'to'});
                                            if ($m2) {
                                                $MATCH->{'to'} = $m2->{'to'};
                                                $MATCH->{'block'} = $m2;
                                                1
                                            }
                                            else {
                                                0
                                            }
                                        }) && (do {
                                            $MATCH->{'capture'} = Perlito5::Match::flat($MATCH->{'block'});
                                            $MATCH->{'capture'}->{'is_continue'} = 1;
                                            1
                                        }))
                                    }) || (do {
                                        $MATCH->{'to'} = $pos1;
                                        (do {
                                            $MATCH->{'capture'} = Perlito5::AST::Block::->new('stmts' => [], 'sig' => undef);
                                            1
                                        })
                                    })
                                }));
                                $tmp ? $MATCH : 0
                            }
                            sub Perlito5::Grammar::Block::anon_block {
                                my $str = $_[0];
                                my $pos = $_[1];
                                my $p = $pos;
                                local $Perlito5::BLOCK_HAS_SEMICOLON;
                                my $m = Perlito5::Grammar::block($str, $p);
                                !$m && return ;
                                $p = $m->{'to'};
                                my $block = Perlito5::Match::flat($m);
                                $m = Perlito5::Grammar::opt_continue_block($str, $p);
                                $p = $m->{'to'};
                                my $continue = Perlito5::Match::flat($m);
                                my $v = $block;
                                !$continue->{'is_continue'} && !$Perlito5::BLOCK_HAS_SEMICOLON && ($v = Perlito5::Grammar::Expression::block_or_hash($v));
                                $m->{'capture'} = $v;
                                if ($continue->{'is_continue'}) {
                                    $m->{'capture'}->{'continue'} = $continue
                                }
                                return $m
                            }
                            sub Perlito5::Grammar::Block::ast_undef {
                                Perlito5::AST::Apply::->new('code' => 'undef', 'namespace' => '', 'arguments' => [])
                            }
                            sub Perlito5::Grammar::Block::special_named_block {
                                my $str = $_[0];
                                my $pos = $_[1];
                                my $p = $pos;
                                my $block_name;
                                my $m_name = Perlito5::Grammar::ident($str, $p);
                                !$m_name && return ;
                                $p = $m_name->{'to'};
                                $block_name = Perlito5::Match::flat($m_name);
                                my $ws = Perlito5::Grammar::Space::opt_ws($str, $p);
                                $p = $ws->{'to'};
                                my $block_start = $p;
                                my $m = Perlito5::Grammar::block($str, $p);
                                !$m && return ;
                                $p = $m->{'to'};
                                my $block = Perlito5::Match::flat($m);
                                my $compile_block = $Perlito5::SCOPE->{'block'}->[-1];
                                $compile_block->{'type'} = 'sub';
                                $compile_block->{'name'} = $block_name;
                                if ($block_name eq 'INIT') {
                                    push(@Perlito5::INIT_BLOCK, eval_end_block($block, 'INIT'));
                                    $m->{'capture'} = ast_undef()
                                }
                                elsif ($block_name eq 'END') {
                                    unshift(@Perlito5::END_BLOCK, eval_end_block($block, 'END'));
                                    $m->{'capture'} = ast_undef()
                                }
                                elsif ($block_name eq 'CHECK') {
                                    unshift(@Perlito5::CHECK_BLOCK, eval_end_block($block, 'CHECK'));
                                    $m->{'capture'} = ast_undef()
                                }
                                elsif ($block_name eq 'UNITCHECK') {
                                    unshift(@Perlito5::UNITCHECK_BLOCK, eval_end_block($block, 'UNITCHECK'));
                                    $m->{'capture'} = ast_undef()
                                }
                                elsif ($block_name eq 'BEGIN') {
                                    local $Perlito5::PHASE = 'BEGIN';
                                    eval_begin_block($block);
                                    $m->{'capture'} = ast_undef()
                                }
                                elsif ($block_name eq 'AUTOLOAD' || $block_name eq 'DESTROY') {
                                    $m->{'capture'} = Perlito5::AST::Sub::->new('attributes' => [], 'block' => $block, 'name' => $block_name, 'namespace' => $Perlito5::PKG_NAME, 'sig' => undef)
                                }
                                else {
                                    $m->{'capture'} = $block;
                                    $m->{'capture'}->{'name'} = $block_name
                                }
                                return $m
                            }
                            sub Perlito5::Grammar::Block::named_sub_def {
                                my $str = $_[0];
                                my $pos = $_[1];
                                my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
                                my $tmp = (((do {
                                    my $m2 = Perlito5::Grammar::optional_namespace_before_ident($str, $MATCH->{'to'});
                                    if ($m2) {
                                        $MATCH->{'to'} = $m2->{'to'};
                                        $MATCH->{'Perlito5::Grammar::optional_namespace_before_ident'} = $m2;
                                        1
                                    }
                                    else {
                                        0
                                    }
                                }) && (do {
                                    my $m2 = Perlito5::Grammar::ident($str, $MATCH->{'to'});
                                    if ($m2) {
                                        $MATCH->{'to'} = $m2->{'to'};
                                        $MATCH->{'Perlito5::Grammar::ident'} = $m2;
                                        1
                                    }
                                    else {
                                        0
                                    }
                                }) && (do {
                                    my $m2 = Perlito5::Grammar::Block::prototype_($str, $MATCH->{'to'});
                                    if ($m2) {
                                        $MATCH->{'to'} = $m2->{'to'};
                                        $MATCH->{'Perlito5::Grammar::Block::prototype_'} = $m2;
                                        1
                                    }
                                    else {
                                        0
                                    }
                                }) && (do {
                                    my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{'to'});
                                    if ($m2) {
                                        $MATCH->{'to'} = $m2->{'to'};
                                        1
                                    }
                                    else {
                                        0
                                    }
                                }) && (do {
                                    my $m2 = Perlito5::Grammar::Attribute::opt_attribute($str, $MATCH->{'to'});
                                    if ($m2) {
                                        $MATCH->{'to'} = $m2->{'to'};
                                        $MATCH->{'Perlito5::Grammar::Attribute::opt_attribute'} = $m2;
                                        1
                                    }
                                    else {
                                        0
                                    }
                                }) && (do {
                                    my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{'to'});
                                    if ($m2) {
                                        $MATCH->{'to'} = $m2->{'to'};
                                        1
                                    }
                                    else {
                                        0
                                    }
                                }) && (do {
                                    my $pos1 = $MATCH->{'to'};
                                    (do {
                                        ((do {
                                            my $m2 = Perlito5::Grammar::block($str, $MATCH->{'to'});
                                            if ($m2) {
                                                $MATCH->{'to'} = $m2->{'to'};
                                                $MATCH->{'Perlito5::Grammar::block'} = $m2;
                                                1
                                            }
                                            else {
                                                0
                                            }
                                        }) && (do {
                                            $MATCH->{'_tmp'} = Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::block'});
                                            1
                                        }))
                                    }) || (do {
                                        $MATCH->{'to'} = $pos1;
                                        ((do {
                                            my $m2 = Perlito5::Grammar::Statement::statement_parse($str, $MATCH->{'to'});
                                            if ($m2) {
                                                $MATCH->{'to'} = $m2->{'to'};
                                                1
                                            }
                                            else {
                                                0
                                            }
                                        }) && (do {
                                            Perlito5::Compiler::error('Illegal declaration of subroutine ' . chr(39), Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::ident'}), chr(39));
                                            1
                                        }))
                                    }) || (do {
                                        $MATCH->{'to'} = $pos1;
                                        (do {
                                            $MATCH->{'_tmp'} = undef;
                                            1
                                        })
                                    })
                                }) && (do {
                                    my $name = Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::ident'});
                                    my $sig = Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::Block::prototype_'});
                                    $sig eq '*undef*' && ($sig = undef);
                                    my $attributes = Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::Attribute::opt_attribute'});
                                    my($proto) = grep {
                                        $_->[0] eq 'prototype'
                                    } @{$attributes};
                                    if ($proto) {
                                        $attributes = [grep {
                                            $_->[0] ne 'prototype'
                                        } @{$attributes}];
                                        $sig = $proto->[1]
                                    }
                                    my $namespace = Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::optional_namespace_before_ident'});
                                    if ($name) {
                                        if (!$namespace) {
                                            $namespace = $name eq '_' ? 'main' : $Perlito5::PKG_NAME
                                        }
                                        my $full_name = $namespace . '::' . $name;
                                        $Perlito5::PROTO->{$full_name} = $sig;
                                        if ($MATCH->{'_tmp'}) {
                                            my $block = $Perlito5::SCOPE->{'block'}->[-1];
                                            $block->{'type'} = 'sub';
                                            $block->{'name'} = $full_name
                                        }
                                    }
                                    my $sub = Perlito5::AST::Sub::->new('name' => $name, 'namespace' => $namespace, 'sig' => $sig, 'block' => $MATCH->{'_tmp'}, 'attributes' => $attributes);
                                    if ($ENV{'PERLITO5DEV'}) {
                                        if ($name) {
                                            my $full_name = $namespace . '::' . $name;
                                            $Perlito5::GLOBAL->{$full_name} = $sub;
                                            $sub = Perlito5::AST::Apply::->new('code' => 'undef', 'namespace' => '', 'arguments' => [])
                                        }
                                    }
                                    $MATCH->{'capture'} = $sub;
                                    1
                                })));
                                $tmp ? $MATCH : 0
                            }
                            sub Perlito5::Grammar::Block::named_sub {
                                my $str = $_[0];
                                my $pos = $_[1];
                                substr($str, $pos, 3) eq 'sub' || return ;
                                my $ws = Perlito5::Grammar::Space::ws($str, $pos + 3);
                                $ws || return ;
                                my $p = $ws->{'to'};
                                my $m_name = Perlito5::Grammar::ident($str, $p);
                                $m_name || return ;
                                my $block_name = Perlito5::Match::flat($m_name);
                                if (exists($Named_block{$block_name})) {
                                    return Perlito5::Grammar::Block::special_named_block($str, $p)
                                }
                                return Perlito5::Grammar::Block::named_sub_def($str, $p)
                            }
                            sub Perlito5::Grammar::Block::term_anon_sub {
                                my $str = $_[0];
                                my $pos = $_[1];
                                my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
                                my $tmp = ((('sub' eq substr($str, $MATCH->{'to'}, 3) && ($MATCH->{'to'} = 3 + $MATCH->{'to'})) && (do {
                                    my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{'to'});
                                    if ($m2) {
                                        $MATCH->{'to'} = $m2->{'to'};
                                        1
                                    }
                                    else {
                                        0
                                    }
                                }) && (do {
                                    my $m2 = Perlito5::Grammar::Block::anon_sub_def($str, $MATCH->{'to'});
                                    if ($m2) {
                                        $MATCH->{'to'} = $m2->{'to'};
                                        $MATCH->{'Perlito5::Grammar::Block::anon_sub_def'} = $m2;
                                        1
                                    }
                                    else {
                                        0
                                    }
                                }) && (do {
                                    $MATCH->{'capture'} = ['term', Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::Block::anon_sub_def'})];
                                    1
                                })));
                                $tmp ? $MATCH : 0
                            }
                            sub Perlito5::Grammar::Block::term_do {
                                my $str = $_[0];
                                my $pos = $_[1];
                                my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
                                my $tmp = ((('do' eq substr($str, $MATCH->{'to'}, 2) && ($MATCH->{'to'} = 2 + $MATCH->{'to'})) && (do {
                                    my $m2 = Perlito5::Grammar::block($str, $MATCH->{'to'});
                                    if ($m2) {
                                        $MATCH->{'to'} = $m2->{'to'};
                                        $MATCH->{'Perlito5::Grammar::block'} = $m2;
                                        1
                                    }
                                    else {
                                        0
                                    }
                                }) && (do {
                                    $MATCH->{'capture'} = ['term', Perlito5::AST::Apply::->new('code' => 'do', 'arguments' => [Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::block'})])];
                                    1
                                })));
                                $tmp ? $MATCH : 0
                            }
                            sub Perlito5::Grammar::Block::args_sig {
                                my $str = $_[0];
                                my $pos = $_[1];
                                my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
                                my $tmp = ((do {
                                    my $last_match_null = 0;
                                    my $m = $MATCH;
                                    my $to = $MATCH->{'to'};
                                    while ((do {
                                        my $pos1 = $MATCH->{'to'};
                                        (do {
                                            (';' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}))
                                        }) || (do {
                                            $MATCH->{'to'} = $pos1;
                                            (chr(92) eq substr($str, $MATCH->{'to'}, 2) && ($MATCH->{'to'} = 2 + $MATCH->{'to'}))
                                        }) || (do {
                                            $MATCH->{'to'} = $pos1;
                                            ('[' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}))
                                        }) || (do {
                                            $MATCH->{'to'} = $pos1;
                                            (']' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}))
                                        }) || (do {
                                            $MATCH->{'to'} = $pos1;
                                            ('*' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}))
                                        }) || (do {
                                            $MATCH->{'to'} = $pos1;
                                            ('+' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}))
                                        }) || (do {
                                            $MATCH->{'to'} = $pos1;
                                            ('@' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}))
                                        }) || (do {
                                            $MATCH->{'to'} = $pos1;
                                            ('%' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}))
                                        }) || (do {
                                            $MATCH->{'to'} = $pos1;
                                            ('$' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}))
                                        }) || (do {
                                            $MATCH->{'to'} = $pos1;
                                            ('&' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}))
                                        })
                                    }) && ($last_match_null < 2)) {
                                        if ($to == $MATCH->{'to'}) {
                                            $last_match_null = $last_match_null + 1
                                        }
                                        else {
                                            $last_match_null = 0
                                        }
                                        $m = $MATCH;
                                        $to = $MATCH->{'to'}
                                    }
                                    $MATCH = $m;
                                    $MATCH->{'to'} = $to;
                                    1
                                }));
                                $tmp ? $MATCH : 0
                            }
                            sub Perlito5::Grammar::Block::prototype_ {
                                my $str = $_[0];
                                my $pos = $_[1];
                                my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
                                my $tmp = ((do {
                                    my $pos1 = $MATCH->{'to'};
                                    (do {
                                        ((do {
                                            my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{'to'});
                                            if ($m2) {
                                                $MATCH->{'to'} = $m2->{'to'};
                                                1
                                            }
                                            else {
                                                0
                                            }
                                        }) && ('(' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                                            my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{'to'});
                                            if ($m2) {
                                                $MATCH->{'to'} = $m2->{'to'};
                                                1
                                            }
                                            else {
                                                0
                                            }
                                        }) && ('_' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                                            my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{'to'});
                                            if ($m2) {
                                                $MATCH->{'to'} = $m2->{'to'};
                                                1
                                            }
                                            else {
                                                0
                                            }
                                        }) && (')' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                                            $MATCH->{'capture'} = '_';
                                            1
                                        }))
                                    }) || (do {
                                        $MATCH->{'to'} = $pos1;
                                        ((do {
                                            my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{'to'});
                                            if ($m2) {
                                                $MATCH->{'to'} = $m2->{'to'};
                                                1
                                            }
                                            else {
                                                0
                                            }
                                        }) && ('(' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                                            my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{'to'});
                                            if ($m2) {
                                                $MATCH->{'to'} = $m2->{'to'};
                                                1
                                            }
                                            else {
                                                0
                                            }
                                        }) && (do {
                                            my $m2 = args_sig($str, $MATCH->{'to'});
                                            if ($m2) {
                                                $MATCH->{'to'} = $m2->{'to'};
                                                $MATCH->{'args_sig'} = $m2;
                                                1
                                            }
                                            else {
                                                0
                                            }
                                        }) && (do {
                                            my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{'to'});
                                            if ($m2) {
                                                $MATCH->{'to'} = $m2->{'to'};
                                                1
                                            }
                                            else {
                                                0
                                            }
                                        }) && (')' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                                            $MATCH->{'capture'} = '' . Perlito5::Match::flat($MATCH->{'args_sig'});
                                            1
                                        }))
                                    }) || (do {
                                        $MATCH->{'to'} = $pos1;
                                        (do {
                                            $MATCH->{'capture'} = '*undef*';
                                            1
                                        })
                                    })
                                }));
                                $tmp ? $MATCH : 0
                            }
                            sub Perlito5::Grammar::Block::anon_sub_def {
                                my $str = $_[0];
                                my $pos = $_[1];
                                my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
                                my $tmp = (((do {
                                    my $m2 = prototype_($str, $MATCH->{'to'});
                                    if ($m2) {
                                        $MATCH->{'to'} = $m2->{'to'};
                                        $MATCH->{'prototype_'} = $m2;
                                        1
                                    }
                                    else {
                                        0
                                    }
                                }) && (do {
                                    my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{'to'});
                                    if ($m2) {
                                        $MATCH->{'to'} = $m2->{'to'};
                                        1
                                    }
                                    else {
                                        0
                                    }
                                }) && (do {
                                    my $m2 = Perlito5::Grammar::Attribute::opt_attribute($str, $MATCH->{'to'});
                                    if ($m2) {
                                        $MATCH->{'to'} = $m2->{'to'};
                                        $MATCH->{'Perlito5::Grammar::Attribute::opt_attribute'} = $m2;
                                        1
                                    }
                                    else {
                                        0
                                    }
                                }) && (do {
                                    my $m2 = Perlito5::Grammar::block($str, $MATCH->{'to'});
                                    if ($m2) {
                                        $MATCH->{'to'} = $m2->{'to'};
                                        $MATCH->{'Perlito5::Grammar::block'} = $m2;
                                        1
                                    }
                                    else {
                                        0
                                    }
                                }) && (do {
                                    my $sig = Perlito5::Match::flat($MATCH->{'prototype_'});
                                    $sig eq '*undef*' && ($sig = undef);
                                    my $attributes = Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::Attribute::opt_attribute'});
                                    my($proto) = grep {
                                        $_->[0] eq 'prototype'
                                    } @{$attributes};
                                    if ($proto) {
                                        $attributes = [grep {
                                            $_->[0] ne 'prototype'
                                        } @{$attributes}];
                                        $sig = $proto->[1]
                                    }
                                    $MATCH->{'capture'} = Perlito5::AST::Sub::->new('name' => undef, 'namespace' => undef, 'sig' => $sig, 'block' => Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::block'}), 'attributes' => $attributes);
                                    1
                                })));
                                $tmp ? $MATCH : 0
                            }
                            Perlito5::Grammar::Precedence::add_term('do' => \&term_do);
                            Perlito5::Grammar::Precedence::add_term('sub' => \&term_anon_sub);
                            Perlito5::Grammar::Statement::add_statement('{' => \&anon_block);
                            Perlito5::Grammar::Statement::add_statement('sub' => \&named_sub);
                            Perlito5::Grammar::Statement::add_statement($_ => \&special_named_block)
                                for keys(%Named_block);
                            1
                        }
                    }
                    {
                        {
                            package main;
                            package Perlito5::Grammar::Space;
                            undef();
                            my %line_index;
                            sub Perlito5::Grammar::Space::count_line {
                                my $pos = $_[0];
                                $pos < $line_index{$Perlito5::FILE_NAME} && return ;
                                $line_index{$Perlito5::FILE_NAME} = $pos + 1;
                                $Perlito5::LINE_NUMBER++
                            }
                            my %space = ('#' => sub {
                                my $m = Perlito5::Grammar::Space::to_eol($_[0], $_[1]);
                                $m->{'to'}
                            }, chr(9) => sub {
                                $_[1]
                            }, chr(10) => sub {
                                my $str = $_[0];
                                my $pos = $_[1];
                                count_line($pos);
                                substr($str, $pos, 1) eq chr(13) && $pos++;
                                my $m = Perlito5::Grammar::Space::start_of_line($_[0], $pos);
                                $m->{'to'}
                            }, chr(12) => sub {
                                $_[1]
                            }, chr(13) => sub {
                                my $str = $_[0];
                                my $pos = $_[1];
                                if (substr($str, $pos, 1) eq chr(10)) {
                                    count_line($pos);
                                    $pos++
                                }
                                my $m = Perlito5::Grammar::Space::start_of_line($_[0], $pos);
                                $m->{'to'}
                            }, chr(32) => sub {
                                $_[1]
                            });
                            sub Perlito5::Grammar::Space::term_space {
                                my $str = $_[0];
                                my $pos = $_[1];
                                my $p = $pos;
                                while (exists($space{substr($str, $p, 1)})) {
                                    $p = $space{substr($str, $p, 1)}->($str, $p + 1)
                                }
                                (substr($str, $p, 7) eq '__END__' || substr($str, $p, 8) eq '__DATA__') && return term_end($str, $p);
                                return {'str' => $str, 'from' => $pos, 'to' => $p, 'capture' => ['space', ' ']}
                            }
                            sub Perlito5::Grammar::Space::term_end {
                                my $str = $_[0];
                                my $p = $_[1];
                                my $is_data = 0;
                                if (substr($str, $_[1], 7) eq '__END__' && $Perlito5::PKG_NAME eq 'main') {
                                    $p = $p + 7;
                                    $is_data = 1
                                }
                                elsif (substr($str, $_[1], 8) eq '__DATA__') {
                                    $p = $p + 8;
                                    $is_data = 1
                                }
                                my $m = Perlito5::Grammar::Space::to_eol($str, $p);
                                $p = $m->{'to'};
                                if (substr($str, $p, 1) eq chr(10)) {
                                    count_line($p);
                                    $p++;
                                    substr($str, $p, 1) eq chr(13) && $p++
                                }
                                elsif (substr($str, $p, 1) eq chr(13)) {
                                    $p++;
                                    if (substr($str, $p, 1) eq chr(10)) {
                                        count_line($p);
                                        $p++
                                    }
                                }
                                if ($is_data) {
                                    $Perlito5::DATA_SECTION{$Perlito5::PKG_NAME} = substr($_[0], $p)
                                }
                                return {'str' => $str, 'from' => $_[1], 'to' => length($_[0]), 'capture' => ['space', ' ']}
                            }
                            Perlito5::Grammar::Precedence::add_term('#' => \&term_space);
                            Perlito5::Grammar::Precedence::add_term(chr(9) => \&term_space);
                            Perlito5::Grammar::Precedence::add_term(chr(10) => \&term_space);
                            Perlito5::Grammar::Precedence::add_term(chr(12) => \&term_space);
                            Perlito5::Grammar::Precedence::add_term(chr(13) => \&term_space);
                            Perlito5::Grammar::Precedence::add_term(chr(32) => \&term_space);
                            Perlito5::Grammar::Precedence::add_term('__END__' => \&term_end);
                            Perlito5::Grammar::Precedence::add_term('__DATA__' => \&term_end);
                            sub Perlito5::Grammar::Space::to_eol {
                                my $str = $_[0];
                                my $pos = $_[1];
                                my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
                                my $tmp = ((do {
                                    my $last_match_null = 0;
                                    my $m = $MATCH;
                                    my $to = $MATCH->{'to'};
                                    while (((do {
                                        my $tmp = $MATCH;
                                        $MATCH = {'from' => $tmp->{'to'}, 'to' => $tmp->{'to'}};
                                        my $res = (do {
                                            my $pos1 = $MATCH->{'to'};
                                            (do {
                                                (chr(10) eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}))
                                            }) || (do {
                                                $MATCH->{'to'} = $pos1;
                                                (chr(13) eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}))
                                            })
                                        });
                                        $MATCH = $tmp;
                                        $res ? 0 : 1
                                    }) && ('' ne substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}))) && ($last_match_null < 2)) {
                                        if ($to == $MATCH->{'to'}) {
                                            $last_match_null = $last_match_null + 1
                                        }
                                        else {
                                            $last_match_null = 0
                                        }
                                        $m = $MATCH;
                                        $to = $MATCH->{'to'}
                                    }
                                    $MATCH = $m;
                                    $MATCH->{'to'} = $to;
                                    1
                                }));
                                $tmp ? $MATCH : 0
                            }
                            sub Perlito5::Grammar::Space::pod_pod_begin {
                                my $str = $_[0];
                                my $pos = $_[1];
                                my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
                                my $tmp = ((do {
                                    my $pos1 = $MATCH->{'to'};
                                    (do {
                                        ((do {
                                            my $pos1 = $MATCH->{'to'};
                                            (do {
                                                (chr(10) eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}))
                                            }) || (do {
                                                $MATCH->{'to'} = $pos1;
                                                (chr(13) eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}))
                                            })
                                        }) && ('=cut' eq substr($str, $MATCH->{'to'}, 4) && ($MATCH->{'to'} = 4 + $MATCH->{'to'})) && (do {
                                            my $m2 = to_eol($str, $MATCH->{'to'});
                                            if ($m2) {
                                                $MATCH->{'to'} = $m2->{'to'};
                                                1
                                            }
                                            else {
                                                0
                                            }
                                        }))
                                    }) || (do {
                                        $MATCH->{'to'} = $pos1;
                                        (('' ne substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                                            my $m2 = to_eol($str, $MATCH->{'to'});
                                            if ($m2) {
                                                $MATCH->{'to'} = $m2->{'to'};
                                                1
                                            }
                                            else {
                                                0
                                            }
                                        }) && (do {
                                            my $m2 = pod_pod_begin($str, $MATCH->{'to'});
                                            if ($m2) {
                                                $MATCH->{'to'} = $m2->{'to'};
                                                1
                                            }
                                            else {
                                                0
                                            }
                                        }))
                                    })
                                }));
                                $tmp ? $MATCH : 0
                            }
                            sub Perlito5::Grammar::Space::pod_begin {
                                my $str = $_[0];
                                my $pos = $_[1];
                                my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
                                my $tmp = ((do {
                                    my $pos1 = $MATCH->{'to'};
                                    (do {
                                        ((do {
                                            my $pos1 = $MATCH->{'to'};
                                            (do {
                                                (chr(10) eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}))
                                            }) || (do {
                                                $MATCH->{'to'} = $pos1;
                                                (chr(13) eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}))
                                            })
                                        }) && ('=end' eq substr($str, $MATCH->{'to'}, 4) && ($MATCH->{'to'} = 4 + $MATCH->{'to'})) && (do {
                                            my $m2 = to_eol($str, $MATCH->{'to'});
                                            if ($m2) {
                                                $MATCH->{'to'} = $m2->{'to'};
                                                1
                                            }
                                            else {
                                                0
                                            }
                                        }))
                                    }) || (do {
                                        $MATCH->{'to'} = $pos1;
                                        (('' ne substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                                            my $m2 = to_eol($str, $MATCH->{'to'});
                                            if ($m2) {
                                                $MATCH->{'to'} = $m2->{'to'};
                                                1
                                            }
                                            else {
                                                0
                                            }
                                        }) && (do {
                                            my $m2 = pod_begin($str, $MATCH->{'to'});
                                            if ($m2) {
                                                $MATCH->{'to'} = $m2->{'to'};
                                                1
                                            }
                                            else {
                                                0
                                            }
                                        }))
                                    })
                                }));
                                $tmp ? $MATCH : 0
                            }
                            sub Perlito5::Grammar::Space::start_of_line {
                                my $str = $_[0];
                                my $pos = $_[1];
                                my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
                                my $tmp = (((do {
                                    my $m2 = Perlito5::Grammar::String::here_doc($str, $MATCH->{'to'});
                                    if ($m2) {
                                        $MATCH->{'to'} = $m2->{'to'};
                                        1
                                    }
                                    else {
                                        0
                                    }
                                }) && (do {
                                    my $pos1 = $MATCH->{'to'};
                                    (do {
                                        (('=' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                                            my $pos1 = $MATCH->{'to'};
                                            (do {
                                                (('pod' eq substr($str, $MATCH->{'to'}, 3) && ($MATCH->{'to'} = 3 + $MATCH->{'to'})) && (do {
                                                    my $m2 = pod_pod_begin($str, $MATCH->{'to'});
                                                    if ($m2) {
                                                        $MATCH->{'to'} = $m2->{'to'};
                                                        1
                                                    }
                                                    else {
                                                        0
                                                    }
                                                }))
                                            }) || (do {
                                                $MATCH->{'to'} = $pos1;
                                                (('head' eq substr($str, $MATCH->{'to'}, 4) && ($MATCH->{'to'} = 4 + $MATCH->{'to'})) && (do {
                                                    my $m2 = pod_pod_begin($str, $MATCH->{'to'});
                                                    if ($m2) {
                                                        $MATCH->{'to'} = $m2->{'to'};
                                                        1
                                                    }
                                                    else {
                                                        0
                                                    }
                                                }))
                                            }) || (do {
                                                $MATCH->{'to'} = $pos1;
                                                (('begin' eq substr($str, $MATCH->{'to'}, 5) && ($MATCH->{'to'} = 5 + $MATCH->{'to'})) && (do {
                                                    my $m2 = pod_begin($str, $MATCH->{'to'});
                                                    if ($m2) {
                                                        $MATCH->{'to'} = $m2->{'to'};
                                                        1
                                                    }
                                                    else {
                                                        0
                                                    }
                                                }))
                                            }) || (do {
                                                $MATCH->{'to'} = $pos1;
                                                (('for' eq substr($str, $MATCH->{'to'}, 3) && ($MATCH->{'to'} = 3 + $MATCH->{'to'})) && (do {
                                                    my $m2 = pod_begin($str, $MATCH->{'to'});
                                                    if ($m2) {
                                                        $MATCH->{'to'} = $m2->{'to'};
                                                        1
                                                    }
                                                    else {
                                                        0
                                                    }
                                                }))
                                            }) || (do {
                                                $MATCH->{'to'} = $pos1;
                                                (('encoding' eq substr($str, $MATCH->{'to'}, 8) && ($MATCH->{'to'} = 8 + $MATCH->{'to'})) && (do {
                                                    my $m2 = to_eol($str, $MATCH->{'to'});
                                                    if ($m2) {
                                                        $MATCH->{'to'} = $m2->{'to'};
                                                        1
                                                    }
                                                    else {
                                                        0
                                                    }
                                                }))
                                            }) || (do {
                                                $MATCH->{'to'} = $pos1;
                                                (('cut' eq substr($str, $MATCH->{'to'}, 3) && ($MATCH->{'to'} = 3 + $MATCH->{'to'})) && (do {
                                                    my $m2 = to_eol($str, $MATCH->{'to'});
                                                    if ($m2) {
                                                        $MATCH->{'to'} = $m2->{'to'};
                                                        1
                                                    }
                                                    else {
                                                        0
                                                    }
                                                }))
                                            })
                                        }))
                                    }) || (do {
                                        $MATCH->{'to'} = $pos1;
                                        (('#' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                                            my $last_match_null = 0;
                                            my $m = $MATCH;
                                            my $to = $MATCH->{'to'};
                                            while ((do {
                                                my $pos1 = $MATCH->{'to'};
                                                (do {
                                                    (' ' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}))
                                                }) || (do {
                                                    $MATCH->{'to'} = $pos1;
                                                    (chr(9) eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}))
                                                })
                                            }) && ($last_match_null < 2)) {
                                                if ($to == $MATCH->{'to'}) {
                                                    $last_match_null = $last_match_null + 1
                                                }
                                                else {
                                                    $last_match_null = 0
                                                }
                                                $m = $MATCH;
                                                $to = $MATCH->{'to'}
                                            }
                                            $MATCH = $m;
                                            $MATCH->{'to'} = $to;
                                            1
                                        }) && ('line' eq substr($str, $MATCH->{'to'}, 4) && ($MATCH->{'to'} = 4 + $MATCH->{'to'})) && (do {
                                            my $last_match_null = 0;
                                            my $m = $MATCH;
                                            my $to = $MATCH->{'to'};
                                            my $count = 0;
                                            while ((do {
                                                my $pos1 = $MATCH->{'to'};
                                                (do {
                                                    (' ' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}))
                                                }) || (do {
                                                    $MATCH->{'to'} = $pos1;
                                                    (chr(9) eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}))
                                                })
                                            }) && ($last_match_null < 2)) {
                                                if ($to == $MATCH->{'to'}) {
                                                    $last_match_null = $last_match_null + 1
                                                }
                                                else {
                                                    $last_match_null = 0
                                                }
                                                $m = $MATCH;
                                                $to = $MATCH->{'to'};
                                                $count = $count + 1
                                            }
                                            $MATCH = $m;
                                            $MATCH->{'to'} = $to;
                                            $count > 0
                                        }) && (do {
                                            my $m2 = Perlito5::Grammar::Number::digits($str, $MATCH->{'to'});
                                            if ($m2) {
                                                $MATCH->{'to'} = $m2->{'to'};
                                                $MATCH->{'Perlito5::Grammar::Number::digits'} = $m2;
                                                1
                                            }
                                            else {
                                                0
                                            }
                                        }) && (do {
                                            my $last_match_null = 0;
                                            my $m = $MATCH;
                                            my $to = $MATCH->{'to'};
                                            while ((do {
                                                my $pos1 = $MATCH->{'to'};
                                                (do {
                                                    (' ' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}))
                                                }) || (do {
                                                    $MATCH->{'to'} = $pos1;
                                                    (chr(9) eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}))
                                                })
                                            }) && ($last_match_null < 2)) {
                                                if ($to == $MATCH->{'to'}) {
                                                    $last_match_null = $last_match_null + 1
                                                }
                                                else {
                                                    $last_match_null = 0
                                                }
                                                $m = $MATCH;
                                                $to = $MATCH->{'to'}
                                            }
                                            $MATCH = $m;
                                            $MATCH->{'to'} = $to;
                                            1
                                        }) && (do {
                                            my $m2 = to_eol($str, $MATCH->{'to'});
                                            if ($m2) {
                                                $MATCH->{'to'} = $m2->{'to'};
                                                1
                                            }
                                            else {
                                                0
                                            }
                                        }) && (do {
                                            $Perlito5::LINE_NUMBER = 0 + Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::Number::digits'});
                                            1
                                        }))
                                    }) || (do {
                                        $MATCH->{'to'} = $pos1;
                                        1
                                    })
                                })));
                                $tmp ? $MATCH : 0
                            }
                            sub Perlito5::Grammar::Space::ws {
                                my $str = shift;
                                my $pos = shift;
                                my $p = $pos;
                                while (exists($space{substr($str, $p, 1)})) {
                                    $p = $space{substr($str, $p, 1)}->($str, $p + 1)
                                }
                                (substr($str, $p, 7) eq '__END__' || substr($str, $p, 8) eq '__DATA__') && return term_end($str, $p);
                                if ($p == $pos) {
                                    return 0
                                }
                                return {'str' => $str, 'from' => $pos, 'to' => $p}
                            }
                            sub Perlito5::Grammar::Space::opt_ws {
                                my $str = shift;
                                my $pos = shift;
                                my $p = $pos;
                                while (exists($space{substr($str, $p, 1)})) {
                                    $p = $space{substr($str, $p, 1)}->($str, $p + 1)
                                }
                                (substr($str, $p, 7) eq '__END__' || substr($str, $p, 8) eq '__DATA__') && return term_end($str, $p);
                                return {'str' => $str, 'from' => $pos, 'to' => $p}
                            }
                            1
                        }
                    }
                    {
                        {
                            package main;
                            package Perlito5::Grammar::Print;
                            # use strict
                            our %Print = ('print' => 1, 'printf' => 1, 'say' => 1, 'exec' => 1, 'system' => 1);
                            sub Perlito5::Grammar::Print::print_decl {
                                my $str = $_[0];
                                my $pos = $_[1];
                                my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
                                my $tmp = ((do {
                                    my $pos1 = $MATCH->{'to'};
                                    (do {
                                        ('printf' eq substr($str, $MATCH->{'to'}, 6) && ($MATCH->{'to'} = 6 + $MATCH->{'to'}))
                                    }) || (do {
                                        $MATCH->{'to'} = $pos1;
                                        ('print' eq substr($str, $MATCH->{'to'}, 5) && ($MATCH->{'to'} = 5 + $MATCH->{'to'}))
                                    }) || (do {
                                        $MATCH->{'to'} = $pos1;
                                        ('say' eq substr($str, $MATCH->{'to'}, 3) && ($MATCH->{'to'} = 3 + $MATCH->{'to'}))
                                    }) || (do {
                                        $MATCH->{'to'} = $pos1;
                                        ('exec' eq substr($str, $MATCH->{'to'}, 4) && ($MATCH->{'to'} = 4 + $MATCH->{'to'}))
                                    }) || (do {
                                        $MATCH->{'to'} = $pos1;
                                        ('system' eq substr($str, $MATCH->{'to'}, 6) && ($MATCH->{'to'} = 6 + $MATCH->{'to'}))
                                    })
                                }));
                                $tmp ? $MATCH : 0
                            }
                            sub Perlito5::Grammar::Print::the_object {
                                my $str = $_[0];
                                my $pos = $_[1];
                                my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
                                my $tmp = (((do {
                                    my $pos1 = $MATCH->{'to'};
                                    (do {
                                        ((do {
                                            my $tmp = $MATCH;
                                            $MATCH = {'from' => $tmp->{'to'}, 'to' => $tmp->{'to'}};
                                            my $res = ('$' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}));
                                            $MATCH = $tmp;
                                            $res ? 1 : 0
                                        }) && (do {
                                            my $m2 = Perlito5::Grammar::Sigil::term_sigil($str, $MATCH->{'to'});
                                            if ($m2) {
                                                $MATCH->{'to'} = $m2->{'to'};
                                                $MATCH->{'Perlito5::Grammar::Sigil::term_sigil'} = $m2;
                                                1
                                            }
                                            else {
                                                0
                                            }
                                        }) && (do {
                                            my $tmp = $MATCH;
                                            $MATCH = {'from' => $tmp->{'to'}, 'to' => $tmp->{'to'}};
                                            my $res = ('+' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}));
                                            $MATCH = $tmp;
                                            $res ? 0 : 1
                                        }) && (do {
                                            $MATCH->{'capture'} = Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::Sigil::term_sigil'})->[1];
                                            1
                                        }))
                                    }) || (do {
                                        $MATCH->{'to'} = $pos1;
                                        ((do {
                                            my $tmp = $MATCH;
                                            $MATCH = {'from' => $tmp->{'to'}, 'to' => $tmp->{'to'}};
                                            my $res = ('{' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}));
                                            $MATCH = $tmp;
                                            $res ? 1 : 0
                                        }) && (do {
                                            my $m2 = Perlito5::Grammar::Block::block($str, $MATCH->{'to'});
                                            if ($m2) {
                                                $MATCH->{'to'} = $m2->{'to'};
                                                $MATCH->{'Perlito5::Grammar::Block::block'} = $m2;
                                                1
                                            }
                                            else {
                                                0
                                            }
                                        }) && (do {
                                            $MATCH->{'capture'} = Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::Block::block'});
                                            1
                                        }))
                                    }) || (do {
                                        $MATCH->{'to'} = $pos1;
                                        ((do {
                                            my $m2 = typeglob($str, $MATCH->{'to'});
                                            if ($m2) {
                                                $MATCH->{'to'} = $m2->{'to'};
                                                $MATCH->{'typeglob'} = $m2;
                                                1
                                            }
                                            else {
                                                0
                                            }
                                        }) && (do {
                                            my $tmp = $MATCH;
                                            $MATCH = {'from' => $tmp->{'to'}, 'to' => $tmp->{'to'}};
                                            my $res = ('(' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}));
                                            $MATCH = $tmp;
                                            $res ? 0 : 1
                                        }) && (do {
                                            $MATCH->{'capture'} = Perlito5::Match::flat($MATCH->{'typeglob'});
                                            1
                                        }))
                                    })
                                }) && (do {
                                    my $pos = $MATCH->{'to'};
                                    my $m = Perlito5::Grammar::Space::ws($MATCH->{'str'}, $pos);
                                    $m && ($pos = $m->{'to'});
                                    my $s = substr($MATCH->{'str'}, $pos, 1);
                                    my $s2 = substr($MATCH->{'str'}, $pos, 2);
                                    if ($s eq ',' || $s eq '?' || $s2 eq '->' || $s eq '[' || $s eq '{') {
                                        return 
                                    }
                                    if ($s eq '+') {
                                        my $m = Perlito5::Grammar::Space::ws($MATCH->{'str'}, $pos + 1);
                                        if ($m) {
                                            return 
                                        }
                                    }
                                    else {
                                        my $m = Perlito5::Grammar::Precedence::op_parse($MATCH->{'str'}, $pos, 1);
                                        my $next_op = $m ? Perlito5::Match::flat($m)->[1] : '';
                                        my $is_infix = Perlito5::Grammar::Precedence::is_fixity_type('infix', $next_op);
                                        $is_infix && return 
                                    }
                                    1
                                })));
                                $tmp ? $MATCH : 0
                            }
                            sub Perlito5::Grammar::Print::typeglob {
                                my $str = $_[0];
                                my $pos = $_[1];
                                my $p = $pos;
                                my $m_namespace = Perlito5::Grammar::optional_namespace_before_ident($str, $p);
                                my $namespace = Perlito5::Match::flat($m_namespace);
                                $p = $m_namespace->{'to'};
                                my $m_name = Perlito5::Grammar::ident($str, $p);
                                if (!$m_name) {
                                    if ($namespace) {
                                        $m_namespace->{'capture'} = Perlito5::AST::Var::->new('sigil' => '::', 'name' => '', 'namespace' => $namespace);
                                        return $m_namespace
                                    }
                                    return 
                                }
                                my $name = Perlito5::Match::flat($m_name);
                                $p = $m_name->{'to'};
                                if (substr($str, $p, 2) eq '::') {
                                    $m_name->{'to'} = $p + 2;
                                    $m_name->{'capture'} = Perlito5::AST::Var::->new('sigil' => '::', 'name' => '', 'namespace' => $namespace . '::' . $name);
                                    return $m_name
                                }
                                my $effective_name = ($namespace || $Perlito5::PKG_NAME) . '::' . $name;
                                if (exists($Perlito5::PROTO->{$effective_name}) || exists(&{$effective_name})) {
                                    return 
                                }
                                if ((!$namespace || $namespace eq 'CORE') && exists($Perlito5::CORE_PROTO->{'CORE::' . $name})) {
                                    return 
                                }
                                my $full_name = $name;
                                $namespace && ($full_name = $namespace . '::' . $name);
                                $m_name->{'capture'} = Perlito5::AST::Var::->new('sigil' => '::', 'name' => '', 'namespace' => $full_name);
                                return $m_name
                            }
                            sub Perlito5::Grammar::Print::print_ast {
                                my($decl, $the_object, $expr) = @_;
                                Perlito5::AST::Apply::->new('namespace' => '', 'code' => $decl, 'special_arg' => $the_object, 'arguments' => $expr)
                            }
                            sub Perlito5::Grammar::Print::term_print {
                                my $str = $_[0];
                                my $pos = $_[1];
                                my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
                                my $tmp = (((do {
                                    my $m2 = print_decl($str, $MATCH->{'to'});
                                    if ($m2) {
                                        $MATCH->{'to'} = $m2->{'to'};
                                        $MATCH->{'print_decl'} = $m2;
                                        1
                                    }
                                    else {
                                        0
                                    }
                                }) && (do {
                                    my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{'to'});
                                    if ($m2) {
                                        $MATCH->{'to'} = $m2->{'to'};
                                        1
                                    }
                                    else {
                                        0
                                    }
                                }) && (do {
                                    my $pos1 = $MATCH->{'to'};
                                    (do {
                                        (('(' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                                            my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{'to'});
                                            if ($m2) {
                                                $MATCH->{'to'} = $m2->{'to'};
                                                1
                                            }
                                            else {
                                                0
                                            }
                                        }) && (do {
                                            $MATCH->{'_scope'} = $#Perlito5::SCOPE_STMT;
                                            1
                                        }) && (do {
                                            my $pos1 = $MATCH->{'to'};
                                            (do {
                                                ((do {
                                                    my $m2 = the_object($str, $MATCH->{'to'});
                                                    if ($m2) {
                                                        $MATCH->{'to'} = $m2->{'to'};
                                                        $MATCH->{'the_object'} = $m2;
                                                        1
                                                    }
                                                    else {
                                                        0
                                                    }
                                                }) && (do {
                                                    my $m2 = Perlito5::Grammar::Expression::list_parse($str, $MATCH->{'to'});
                                                    if ($m2) {
                                                        $MATCH->{'to'} = $m2->{'to'};
                                                        $MATCH->{'Perlito5::Grammar::Expression::list_parse'} = $m2;
                                                        1
                                                    }
                                                    else {
                                                        0
                                                    }
                                                }))
                                            }) || (do {
                                                $MATCH->{'to'} = $pos1;
                                                (do {
                                                    $#Perlito5::SCOPE_STMT = $MATCH->{'_scope'};
                                                    return ;
                                                    1
                                                })
                                            })
                                        }) && (')' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                                            my $list = Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::Expression::list_parse'});
                                            !ref($list) && return ;
                                            $MATCH->{'capture'} = ['term', print_ast(Perlito5::Match::flat($MATCH->{'print_decl'}), Perlito5::Match::flat($MATCH->{'the_object'}), Perlito5::Grammar::Expression::expand_list($list))];
                                            1
                                        }))
                                    }) || (do {
                                        $MATCH->{'to'} = $pos1;
                                        ((do {
                                            $MATCH->{'_scope'} = $#Perlito5::SCOPE_STMT;
                                            1
                                        }) && (do {
                                            my $pos1 = $MATCH->{'to'};
                                            (do {
                                                ((do {
                                                    my $m2 = the_object($str, $MATCH->{'to'});
                                                    if ($m2) {
                                                        $MATCH->{'to'} = $m2->{'to'};
                                                        $MATCH->{'the_object'} = $m2;
                                                        1
                                                    }
                                                    else {
                                                        0
                                                    }
                                                }) && (do {
                                                    my $m2 = Perlito5::Grammar::Expression::list_parse($str, $MATCH->{'to'});
                                                    if ($m2) {
                                                        $MATCH->{'to'} = $m2->{'to'};
                                                        $MATCH->{'Perlito5::Grammar::Expression::list_parse'} = $m2;
                                                        1
                                                    }
                                                    else {
                                                        0
                                                    }
                                                }))
                                            }) || (do {
                                                $MATCH->{'to'} = $pos1;
                                                (do {
                                                    $#Perlito5::SCOPE_STMT = $MATCH->{'_scope'};
                                                    return ;
                                                    1
                                                })
                                            })
                                        }) && (do {
                                            my $list = Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::Expression::list_parse'});
                                            !ref($list) && return ;
                                            $MATCH->{'capture'} = ['term', print_ast(Perlito5::Match::flat($MATCH->{'print_decl'}), Perlito5::Match::flat($MATCH->{'the_object'}), Perlito5::Grammar::Expression::expand_list($list))];
                                            1
                                        }))
                                    })
                                })));
                                $tmp ? $MATCH : 0
                            }
                            Perlito5::Grammar::Precedence::add_term('print' => \&term_print);
                            Perlito5::Grammar::Precedence::add_term('printf' => \&term_print);
                            Perlito5::Grammar::Precedence::add_term('say' => \&term_print);
                            Perlito5::Grammar::Precedence::add_term('exec' => \&term_print);
                            Perlito5::Grammar::Precedence::add_term('system' => \&term_print);
                            1
                        }
                    }
                    {
                        {
                            package main;
                            package Perlito5::Grammar::Map;
                            # use strict
                            sub Perlito5::Grammar::Map::map_or_grep {
                                my $str = $_[0];
                                my $pos = $_[1];
                                my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
                                my $tmp = ((do {
                                    my $pos1 = $MATCH->{'to'};
                                    (do {
                                        ('map' eq substr($str, $MATCH->{'to'}, 3) && ($MATCH->{'to'} = 3 + $MATCH->{'to'}))
                                    }) || (do {
                                        $MATCH->{'to'} = $pos1;
                                        ('grep' eq substr($str, $MATCH->{'to'}, 4) && ($MATCH->{'to'} = 4 + $MATCH->{'to'}))
                                    })
                                }));
                                $tmp ? $MATCH : 0
                            }
                            sub Perlito5::Grammar::Map::term_map_or_grep {
                                my $str = $_[0];
                                my $pos = $_[1];
                                my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
                                my $tmp = (((do {
                                    my $m2 = map_or_grep($str, $MATCH->{'to'});
                                    if ($m2) {
                                        $MATCH->{'to'} = $m2->{'to'};
                                        $MATCH->{'map_or_grep'} = $m2;
                                        1
                                    }
                                    else {
                                        0
                                    }
                                }) && (do {
                                    my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{'to'});
                                    if ($m2) {
                                        $MATCH->{'to'} = $m2->{'to'};
                                        1
                                    }
                                    else {
                                        0
                                    }
                                }) && (do {
                                    my $pos1 = $MATCH->{'to'};
                                    (do {
                                        ((do {
                                            my $m2 = Perlito5::Grammar::block($str, $MATCH->{'to'});
                                            if ($m2) {
                                                $MATCH->{'to'} = $m2->{'to'};
                                                $MATCH->{'Perlito5::Grammar::block'} = $m2;
                                                1
                                            }
                                            else {
                                                0
                                            }
                                        }) && (do {
                                            my $m2 = Perlito5::Grammar::Expression::list_parse($str, $MATCH->{'to'});
                                            if ($m2) {
                                                $MATCH->{'to'} = $m2->{'to'};
                                                $MATCH->{'Perlito5::Grammar::Expression::list_parse'} = $m2;
                                                1
                                            }
                                            else {
                                                0
                                            }
                                        }) && (do {
                                            $MATCH->{'capture'} = ['term', Perlito5::AST::Apply::->new('code' => Perlito5::Match::flat($MATCH->{'map_or_grep'}), 'special_arg' => $MATCH->{'Perlito5::Grammar::block'}->{'capture'}, 'arguments' => Perlito5::Grammar::Expression::expand_list($MATCH->{'Perlito5::Grammar::Expression::list_parse'}->{'capture'}), 'namespace' => '')];
                                            1
                                        }))
                                    }) || (do {
                                        $MATCH->{'to'} = $pos1;
                                        (('(' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                                            my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{'to'});
                                            if ($m2) {
                                                $MATCH->{'to'} = $m2->{'to'};
                                                1
                                            }
                                            else {
                                                0
                                            }
                                        }) && (do {
                                            my $m2 = Perlito5::Grammar::block($str, $MATCH->{'to'});
                                            if ($m2) {
                                                $MATCH->{'to'} = $m2->{'to'};
                                                $MATCH->{'Perlito5::Grammar::block'} = $m2;
                                                1
                                            }
                                            else {
                                                0
                                            }
                                        }) && (do {
                                            my $m2 = Perlito5::Grammar::Expression::list_parse($str, $MATCH->{'to'});
                                            if ($m2) {
                                                $MATCH->{'to'} = $m2->{'to'};
                                                $MATCH->{'Perlito5::Grammar::Expression::list_parse'} = $m2;
                                                1
                                            }
                                            else {
                                                0
                                            }
                                        }) && (')' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                                            $MATCH->{'capture'} = ['term', Perlito5::AST::Apply::->new('code' => Perlito5::Match::flat($MATCH->{'map_or_grep'}), 'special_arg' => $MATCH->{'Perlito5::Grammar::block'}->{'capture'}, 'arguments' => Perlito5::Grammar::Expression::expand_list($MATCH->{'Perlito5::Grammar::Expression::list_parse'}->{'capture'}), 'namespace' => '')];
                                            1
                                        }))
                                    })
                                })));
                                $tmp ? $MATCH : 0
                            }
                            sub Perlito5::Grammar::Map::non_core_ident {
                                my $str = $_[0];
                                my $pos = $_[1];
                                my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
                                my $tmp = (((do {
                                    my $m2 = Perlito5::Grammar::full_ident($str, $MATCH->{'to'});
                                    if ($m2) {
                                        $MATCH->{'to'} = $m2->{'to'};
                                        $MATCH->{'Perlito5::Grammar::full_ident'} = $m2;
                                        1
                                    }
                                    else {
                                        0
                                    }
                                }) && (do {
                                    my $name = Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::full_ident'});
                                    ($Perlito5::CORE_PROTO->{$name} || $Perlito5::CORE_PROTO->{'CORE::' . $name}) && return ;
                                    1
                                })));
                                $tmp ? $MATCH : 0
                            }
                            sub Perlito5::Grammar::Map::term_sort {
                                my $str = $_[0];
                                my $pos = $_[1];
                                my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
                                my $tmp = ((('sort' eq substr($str, $MATCH->{'to'}, 4) && ($MATCH->{'to'} = 4 + $MATCH->{'to'})) && (do {
                                    my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{'to'});
                                    if ($m2) {
                                        $MATCH->{'to'} = $m2->{'to'};
                                        1
                                    }
                                    else {
                                        0
                                    }
                                }) && (do {
                                    my $pos1 = $MATCH->{'to'};
                                    (do {
                                        (('(' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                                            my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{'to'});
                                            if ($m2) {
                                                $MATCH->{'to'} = $m2->{'to'};
                                                1
                                            }
                                            else {
                                                0
                                            }
                                        }) && (do {
                                            my $pos1 = $MATCH->{'to'};
                                            (do {
                                                ((do {
                                                    my $m2 = Perlito5::Grammar::Map::non_core_ident($str, $MATCH->{'to'});
                                                    if ($m2) {
                                                        $MATCH->{'to'} = $m2->{'to'};
                                                        $MATCH->{'Perlito5::Grammar::Map::non_core_ident'} = $m2;
                                                        1
                                                    }
                                                    else {
                                                        0
                                                    }
                                                }) && (do {
                                                    my $m2 = Perlito5::Grammar::Space::ws($str, $MATCH->{'to'});
                                                    if ($m2) {
                                                        $MATCH->{'to'} = $m2->{'to'};
                                                        1
                                                    }
                                                    else {
                                                        0
                                                    }
                                                }) && (do {
                                                    my $name = Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::Map::non_core_ident'});
                                                    $MATCH->{'_tmp'} = $name;
                                                    1
                                                }))
                                            }) || (do {
                                                $MATCH->{'to'} = $pos1;
                                                ((do {
                                                    my $m2 = Perlito5::Grammar::block($str, $MATCH->{'to'});
                                                    if ($m2) {
                                                        $MATCH->{'to'} = $m2->{'to'};
                                                        $MATCH->{'Perlito5::Grammar::block'} = $m2;
                                                        1
                                                    }
                                                    else {
                                                        0
                                                    }
                                                }) && (do {
                                                    $MATCH->{'_tmp'} = $MATCH->{'Perlito5::Grammar::block'}->{'capture'};
                                                    1
                                                }))
                                            }) || (do {
                                                $MATCH->{'to'} = $pos1;
                                                ((do {
                                                    my $tmp = $MATCH;
                                                    $MATCH = {'from' => $tmp->{'to'}, 'to' => $tmp->{'to'}};
                                                    my $res = ('$' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}));
                                                    $MATCH = $tmp;
                                                    $res ? 1 : 0
                                                }) && (do {
                                                    my $m2 = Perlito5::Grammar::Sigil::term_sigil($str, $MATCH->{'to'});
                                                    if ($m2) {
                                                        $MATCH->{'to'} = $m2->{'to'};
                                                        $MATCH->{'Perlito5::Grammar::Sigil::term_sigil'} = $m2;
                                                        1
                                                    }
                                                    else {
                                                        0
                                                    }
                                                }) && (do {
                                                    my $var = Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::Sigil::term_sigil'})->[1];
                                                    ref($var) ne 'Perlito5::AST::Var' && return ;
                                                    $MATCH->{'_tmp'} = $var;
                                                    1
                                                }))
                                            })
                                        }) && (do {
                                            my $m2 = Perlito5::Grammar::Expression::list_parse($str, $MATCH->{'to'});
                                            if ($m2) {
                                                $MATCH->{'to'} = $m2->{'to'};
                                                $MATCH->{'Perlito5::Grammar::Expression::list_parse'} = $m2;
                                                1
                                            }
                                            else {
                                                0
                                            }
                                        }) && (')' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                                            $MATCH->{'capture'} = ['term', Perlito5::AST::Apply::->new('code' => 'sort', 'special_arg' => $MATCH->{'_tmp'}, 'arguments' => Perlito5::Grammar::Expression::expand_list($MATCH->{'Perlito5::Grammar::Expression::list_parse'}->{'capture'}), 'namespace' => '')];
                                            1
                                        }))
                                    }) || (do {
                                        $MATCH->{'to'} = $pos1;
                                        ((do {
                                            my $pos1 = $MATCH->{'to'};
                                            (do {
                                                ((do {
                                                    my $m2 = Perlito5::Grammar::block($str, $MATCH->{'to'});
                                                    if ($m2) {
                                                        $MATCH->{'to'} = $m2->{'to'};
                                                        $MATCH->{'Perlito5::Grammar::block'} = $m2;
                                                        1
                                                    }
                                                    else {
                                                        0
                                                    }
                                                }) && (do {
                                                    $MATCH->{'_tmp'} = $MATCH->{'Perlito5::Grammar::block'}->{'capture'};
                                                    1
                                                }))
                                            }) || (do {
                                                $MATCH->{'to'} = $pos1;
                                                ((do {
                                                    my $m2 = Perlito5::Grammar::Map::non_core_ident($str, $MATCH->{'to'});
                                                    if ($m2) {
                                                        $MATCH->{'to'} = $m2->{'to'};
                                                        $MATCH->{'Perlito5::Grammar::Map::non_core_ident'} = $m2;
                                                        1
                                                    }
                                                    else {
                                                        0
                                                    }
                                                }) && (do {
                                                    my $name = Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::Map::non_core_ident'});
                                                    $MATCH->{'_tmp'} = $name;
                                                    1
                                                }))
                                            }) || (do {
                                                $MATCH->{'to'} = $pos1;
                                                ((do {
                                                    my $tmp = $MATCH;
                                                    $MATCH = {'from' => $tmp->{'to'}, 'to' => $tmp->{'to'}};
                                                    my $res = ('$' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}));
                                                    $MATCH = $tmp;
                                                    $res ? 1 : 0
                                                }) && (do {
                                                    my $m2 = Perlito5::Grammar::Sigil::term_sigil($str, $MATCH->{'to'});
                                                    if ($m2) {
                                                        $MATCH->{'to'} = $m2->{'to'};
                                                        $MATCH->{'Perlito5::Grammar::Sigil::term_sigil'} = $m2;
                                                        1
                                                    }
                                                    else {
                                                        0
                                                    }
                                                }) && (do {
                                                    my $var = Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::Sigil::term_sigil'})->[1];
                                                    ref($var) ne 'Perlito5::AST::Var' && return ;
                                                    $MATCH->{'_tmp'} = $var;
                                                    1
                                                }))
                                            }) || (do {
                                                $MATCH->{'to'} = $pos1;
                                                (do {
                                                    $MATCH->{'_tmp'} = Perlito5::AST::Block::->new('stmts' => [Perlito5::AST::Apply::->new('code' => 'infix:<cmp>', 'arguments' => [Perlito5::AST::Var::->new('name' => 'a', 'namespace' => $Perlito5::PKG, 'sigil' => '$'), Perlito5::AST::Var::->new('name' => 'b', 'namespace' => $Perlito5::PKG, 'sigil' => '$')])]);
                                                    1
                                                })
                                            })
                                        }) && (do {
                                            my $m2 = Perlito5::Grammar::Expression::list_parse($str, $MATCH->{'to'});
                                            if ($m2) {
                                                $MATCH->{'to'} = $m2->{'to'};
                                                $MATCH->{'Perlito5::Grammar::Expression::list_parse'} = $m2;
                                                1
                                            }
                                            else {
                                                0
                                            }
                                        }) && (do {
                                            $MATCH->{'capture'} = ['term', Perlito5::AST::Apply::->new('code' => 'sort', 'special_arg' => $MATCH->{'_tmp'}, 'arguments' => Perlito5::Grammar::Expression::expand_list($MATCH->{'Perlito5::Grammar::Expression::list_parse'}->{'capture'}), 'namespace' => '')];
                                            1
                                        }))
                                    })
                                })));
                                $tmp ? $MATCH : 0
                            }
                            Perlito5::Grammar::Precedence::add_term('map' => \&term_map_or_grep);
                            Perlito5::Grammar::Precedence::add_term('grep' => \&term_map_or_grep);
                            Perlito5::Grammar::Precedence::add_term('sort' => \&term_sort);
                            1
                        }
                    }
                    undef();
                    {
                        {
                            package main;
                            package Perlito5::Grammar::Number;
                            # use strict
                            undef();
                            sub Perlito5::Grammar::Number::term_digit {
                                my $str = $_[0];
                                my $pos = $_[1];
                                my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
                                my $tmp = ((do {
                                    my $pos1 = $MATCH->{'to'};
                                    (do {
                                        ((do {
                                            my $m2 = Perlito5::Grammar::Number::val_octal($str, $MATCH->{'to'});
                                            if ($m2) {
                                                $MATCH->{'to'} = $m2->{'to'};
                                                $MATCH->{'Perlito5::Grammar::Number::val_octal'} = $m2;
                                                1
                                            }
                                            else {
                                                0
                                            }
                                        }) && (do {
                                            $MATCH->{'capture'} = ['term', Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::Number::val_octal'})];
                                            1
                                        }))
                                    }) || (do {
                                        $MATCH->{'to'} = $pos1;
                                        ((do {
                                            my $m2 = Perlito5::Grammar::Number::val_vstring($str, $MATCH->{'to'});
                                            if ($m2) {
                                                $MATCH->{'to'} = $m2->{'to'};
                                                $MATCH->{'Perlito5::Grammar::Number::val_vstring'} = $m2;
                                                1
                                            }
                                            else {
                                                0
                                            }
                                        }) && (do {
                                            $MATCH->{'capture'} = ['term', Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::Number::val_vstring'})];
                                            1
                                        }))
                                    }) || (do {
                                        $MATCH->{'to'} = $pos1;
                                        ((do {
                                            my $m2 = Perlito5::Grammar::Number::val_num($str, $MATCH->{'to'});
                                            if ($m2) {
                                                $MATCH->{'to'} = $m2->{'to'};
                                                $MATCH->{'Perlito5::Grammar::Number::val_num'} = $m2;
                                                1
                                            }
                                            else {
                                                0
                                            }
                                        }) && (do {
                                            $MATCH->{'capture'} = ['term', Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::Number::val_num'})];
                                            1
                                        }))
                                    }) || (do {
                                        $MATCH->{'to'} = $pos1;
                                        ((do {
                                            my $m2 = Perlito5::Grammar::Number::val_int($str, $MATCH->{'to'});
                                            if ($m2) {
                                                $MATCH->{'to'} = $m2->{'to'};
                                                $MATCH->{'Perlito5::Grammar::Number::val_int'} = $m2;
                                                1
                                            }
                                            else {
                                                0
                                            }
                                        }) && (do {
                                            $MATCH->{'capture'} = ['term', Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::Number::val_int'})];
                                            1
                                        }))
                                    })
                                }));
                                $tmp ? $MATCH : 0
                            }
                            Perlito5::Grammar::Precedence::add_term($_ => \&term_digit)
                                for '.', 0 .. 9;
                            sub Perlito5::Grammar::Number::digit {
                                substr($_[0], $_[1], 1) =~ m!\d! ? {'str' => $_[0], 'from' => $_[1], 'to' => $_[1] + 1} : 0
                            }
                            sub Perlito5::Grammar::Number::exponent {
                                my $str = $_[0];
                                my $pos = $_[1];
                                my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
                                my $tmp = (((do {
                                    my $pos1 = $MATCH->{'to'};
                                    (do {
                                        ('e' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}))
                                    }) || (do {
                                        $MATCH->{'to'} = $pos1;
                                        ('E' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}))
                                    })
                                }) && (do {
                                    my $pos1 = $MATCH->{'to'};
                                    (do {
                                        ('+' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}))
                                    }) || (do {
                                        $MATCH->{'to'} = $pos1;
                                        ('-' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}))
                                    }) || (do {
                                        $MATCH->{'to'} = $pos1;
                                        1
                                    })
                                }) && (do {
                                    my $last_match_null = 0;
                                    my $m = $MATCH;
                                    my $to = $MATCH->{'to'};
                                    my $count = 0;
                                    while ((do {
                                        my $pos1 = $MATCH->{'to'};
                                        (do {
                                            ('_' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}))
                                        }) || (do {
                                            $MATCH->{'to'} = $pos1;
                                            (do {
                                                my $m2 = digit($str, $MATCH->{'to'});
                                                if ($m2) {
                                                    $MATCH->{'to'} = $m2->{'to'};
                                                    1
                                                }
                                                else {
                                                    0
                                                }
                                            })
                                        })
                                    }) && ($last_match_null < 2)) {
                                        if ($to == $MATCH->{'to'}) {
                                            $last_match_null = $last_match_null + 1
                                        }
                                        else {
                                            $last_match_null = 0
                                        }
                                        $m = $MATCH;
                                        $to = $MATCH->{'to'};
                                        $count = $count + 1
                                    }
                                    $MATCH = $m;
                                    $MATCH->{'to'} = $to;
                                    $count > 0
                                })));
                                $tmp ? $MATCH : 0
                            }
                            sub Perlito5::Grammar::Number::val_num {
                                my $str = $_[0];
                                my $pos = $_[1];
                                my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
                                my $tmp = (((do {
                                    my $pos1 = $MATCH->{'to'};
                                    (do {
                                        (('.' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                                            my $m2 = digit($str, $MATCH->{'to'});
                                            if ($m2) {
                                                $MATCH->{'to'} = $m2->{'to'};
                                                1
                                            }
                                            else {
                                                0
                                            }
                                        }) && (do {
                                            my $last_match_null = 0;
                                            my $m = $MATCH;
                                            my $to = $MATCH->{'to'};
                                            while ((do {
                                                my $pos1 = $MATCH->{'to'};
                                                (do {
                                                    ('_' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}))
                                                }) || (do {
                                                    $MATCH->{'to'} = $pos1;
                                                    (do {
                                                        my $m2 = digit($str, $MATCH->{'to'});
                                                        if ($m2) {
                                                            $MATCH->{'to'} = $m2->{'to'};
                                                            1
                                                        }
                                                        else {
                                                            0
                                                        }
                                                    })
                                                })
                                            }) && ($last_match_null < 2)) {
                                                if ($to == $MATCH->{'to'}) {
                                                    $last_match_null = $last_match_null + 1
                                                }
                                                else {
                                                    $last_match_null = 0
                                                }
                                                $m = $MATCH;
                                                $to = $MATCH->{'to'}
                                            }
                                            $MATCH = $m;
                                            $MATCH->{'to'} = $to;
                                            1
                                        }) && (do {
                                            my $m = $MATCH;
                                            if (!(do {
                                                my $m2 = exponent($str, $MATCH->{'to'});
                                                if ($m2) {
                                                    $MATCH->{'to'} = $m2->{'to'};
                                                    1
                                                }
                                                else {
                                                    0
                                                }
                                            })) {
                                                $MATCH = $m
                                            }
                                            1
                                        }))
                                    }) || (do {
                                        $MATCH->{'to'} = $pos1;
                                        ((do {
                                            my $m2 = digit($str, $MATCH->{'to'});
                                            if ($m2) {
                                                $MATCH->{'to'} = $m2->{'to'};
                                                1
                                            }
                                            else {
                                                0
                                            }
                                        }) && (do {
                                            my $last_match_null = 0;
                                            my $m = $MATCH;
                                            my $to = $MATCH->{'to'};
                                            while ((do {
                                                my $pos1 = $MATCH->{'to'};
                                                (do {
                                                    ('_' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}))
                                                }) || (do {
                                                    $MATCH->{'to'} = $pos1;
                                                    (do {
                                                        my $m2 = digit($str, $MATCH->{'to'});
                                                        if ($m2) {
                                                            $MATCH->{'to'} = $m2->{'to'};
                                                            1
                                                        }
                                                        else {
                                                            0
                                                        }
                                                    })
                                                })
                                            }) && ($last_match_null < 2)) {
                                                if ($to == $MATCH->{'to'}) {
                                                    $last_match_null = $last_match_null + 1
                                                }
                                                else {
                                                    $last_match_null = 0
                                                }
                                                $m = $MATCH;
                                                $to = $MATCH->{'to'}
                                            }
                                            $MATCH = $m;
                                            $MATCH->{'to'} = $to;
                                            1
                                        }) && (do {
                                            my $pos1 = $MATCH->{'to'};
                                            (do {
                                                (do {
                                                    my $m2 = exponent($str, $MATCH->{'to'});
                                                    if ($m2) {
                                                        $MATCH->{'to'} = $m2->{'to'};
                                                        1
                                                    }
                                                    else {
                                                        0
                                                    }
                                                })
                                            }) || (do {
                                                $MATCH->{'to'} = $pos1;
                                                (('.' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                                                    my $tmp = $MATCH;
                                                    $MATCH = {'from' => $tmp->{'to'}, 'to' => $tmp->{'to'}};
                                                    my $res = ('.' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}));
                                                    $MATCH = $tmp;
                                                    $res ? 0 : 1
                                                }) && (do {
                                                    my $last_match_null = 0;
                                                    my $m = $MATCH;
                                                    my $to = $MATCH->{'to'};
                                                    while ((do {
                                                        my $pos1 = $MATCH->{'to'};
                                                        (do {
                                                            ('_' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}))
                                                        }) || (do {
                                                            $MATCH->{'to'} = $pos1;
                                                            (do {
                                                                my $m2 = digit($str, $MATCH->{'to'});
                                                                if ($m2) {
                                                                    $MATCH->{'to'} = $m2->{'to'};
                                                                    1
                                                                }
                                                                else {
                                                                    0
                                                                }
                                                            })
                                                        })
                                                    }) && ($last_match_null < 2)) {
                                                        if ($to == $MATCH->{'to'}) {
                                                            $last_match_null = $last_match_null + 1
                                                        }
                                                        else {
                                                            $last_match_null = 0
                                                        }
                                                        $m = $MATCH;
                                                        $to = $MATCH->{'to'}
                                                    }
                                                    $MATCH = $m;
                                                    $MATCH->{'to'} = $to;
                                                    1
                                                }) && (do {
                                                    my $m = $MATCH;
                                                    if (!(do {
                                                        my $m2 = exponent($str, $MATCH->{'to'});
                                                        if ($m2) {
                                                            $MATCH->{'to'} = $m2->{'to'};
                                                            1
                                                        }
                                                        else {
                                                            0
                                                        }
                                                    })) {
                                                        $MATCH = $m
                                                    }
                                                    1
                                                }))
                                            })
                                        }))
                                    })
                                }) && (do {
                                    my $s = Perlito5::Match::flat($MATCH);
                                    $s =~ s!_!!g;
                                    $MATCH->{'capture'} = Perlito5::AST::Num::->new('num' => $s);
                                    1
                                })));
                                $tmp ? $MATCH : 0
                            }
                            sub Perlito5::Grammar::Number::digits {
                                my $str = $_[0];
                                my $pos = $_[1];
                                my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
                                my $tmp = ((do {
                                    my $last_match_null = 0;
                                    my $m = $MATCH;
                                    my $to = $MATCH->{'to'};
                                    my $count = 0;
                                    while ((do {
                                        my $m2 = digit($str, $MATCH->{'to'});
                                        if ($m2) {
                                            $MATCH->{'to'} = $m2->{'to'};
                                            1
                                        }
                                        else {
                                            0
                                        }
                                    }) && ($last_match_null < 2)) {
                                        if ($to == $MATCH->{'to'}) {
                                            $last_match_null = $last_match_null + 1
                                        }
                                        else {
                                            $last_match_null = 0
                                        }
                                        $m = $MATCH;
                                        $to = $MATCH->{'to'};
                                        $count = $count + 1
                                    }
                                    $MATCH = $m;
                                    $MATCH->{'to'} = $to;
                                    $count > 0
                                }));
                                $tmp ? $MATCH : 0
                            }
                            sub Perlito5::Grammar::Number::digits_underscore {
                                my $str = $_[0];
                                my $pos = $_[1];
                                my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
                                my $tmp = (((do {
                                    my $m2 = digit($str, $MATCH->{'to'});
                                    if ($m2) {
                                        $MATCH->{'to'} = $m2->{'to'};
                                        1
                                    }
                                    else {
                                        0
                                    }
                                }) && (do {
                                    my $last_match_null = 0;
                                    my $m = $MATCH;
                                    my $to = $MATCH->{'to'};
                                    while ((do {
                                        my $pos1 = $MATCH->{'to'};
                                        (do {
                                            ('_' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}))
                                        }) || (do {
                                            $MATCH->{'to'} = $pos1;
                                            (do {
                                                my $m2 = digit($str, $MATCH->{'to'});
                                                if ($m2) {
                                                    $MATCH->{'to'} = $m2->{'to'};
                                                    1
                                                }
                                                else {
                                                    0
                                                }
                                            })
                                        })
                                    }) && ($last_match_null < 2)) {
                                        if ($to == $MATCH->{'to'}) {
                                            $last_match_null = $last_match_null + 1
                                        }
                                        else {
                                            $last_match_null = 0
                                        }
                                        $m = $MATCH;
                                        $to = $MATCH->{'to'}
                                    }
                                    $MATCH = $m;
                                    $MATCH->{'to'} = $to;
                                    1
                                })));
                                $tmp ? $MATCH : 0
                            }
                            sub Perlito5::Grammar::Number::val_octal {
                                my $str = $_[0];
                                my $pos = $_[1];
                                my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
                                my $tmp = (((0 eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                                    my $pos1 = $MATCH->{'to'};
                                    (do {
                                        ((do {
                                            my $pos1 = $MATCH->{'to'};
                                            (do {
                                                ('x' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}))
                                            }) || (do {
                                                $MATCH->{'to'} = $pos1;
                                                ('X' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}))
                                            })
                                        }) && (do {
                                            my $last_match_null = 0;
                                            my $m = $MATCH;
                                            my $to = $MATCH->{'to'};
                                            my $count = 0;
                                            while ((do {
                                                my $m2 = Perlito5::Grammar::word($str, $MATCH->{'to'});
                                                if ($m2) {
                                                    $MATCH->{'to'} = $m2->{'to'};
                                                    1
                                                }
                                                else {
                                                    0
                                                }
                                            }) && ($last_match_null < 2)) {
                                                if ($to == $MATCH->{'to'}) {
                                                    $last_match_null = $last_match_null + 1
                                                }
                                                else {
                                                    $last_match_null = 0
                                                }
                                                $m = $MATCH;
                                                $to = $MATCH->{'to'};
                                                $count = $count + 1
                                            }
                                            $MATCH = $m;
                                            $MATCH->{'to'} = $to;
                                            $count > 0
                                        }))
                                    }) || (do {
                                        $MATCH->{'to'} = $pos1;
                                        ((do {
                                            my $pos1 = $MATCH->{'to'};
                                            (do {
                                                ('b' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}))
                                            }) || (do {
                                                $MATCH->{'to'} = $pos1;
                                                ('B' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}))
                                            })
                                        }) && (do {
                                            my $last_match_null = 0;
                                            my $m = $MATCH;
                                            my $to = $MATCH->{'to'};
                                            my $count = 0;
                                            while ((do {
                                                my $pos1 = $MATCH->{'to'};
                                                (do {
                                                    ('_' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}))
                                                }) || (do {
                                                    $MATCH->{'to'} = $pos1;
                                                    (0 eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}))
                                                }) || (do {
                                                    $MATCH->{'to'} = $pos1;
                                                    (1 eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}))
                                                })
                                            }) && ($last_match_null < 2)) {
                                                if ($to == $MATCH->{'to'}) {
                                                    $last_match_null = $last_match_null + 1
                                                }
                                                else {
                                                    $last_match_null = 0
                                                }
                                                $m = $MATCH;
                                                $to = $MATCH->{'to'};
                                                $count = $count + 1
                                            }
                                            $MATCH = $m;
                                            $MATCH->{'to'} = $to;
                                            $count > 0
                                        }))
                                    }) || (do {
                                        $MATCH->{'to'} = $pos1;
                                        (do {
                                            my $last_match_null = 0;
                                            my $m = $MATCH;
                                            my $to = $MATCH->{'to'};
                                            my $count = 0;
                                            while ((do {
                                                my $pos1 = $MATCH->{'to'};
                                                (do {
                                                    ('_' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}))
                                                }) || (do {
                                                    $MATCH->{'to'} = $pos1;
                                                    (do {
                                                        my $m2 = digit($str, $MATCH->{'to'});
                                                        if ($m2) {
                                                            $MATCH->{'to'} = $m2->{'to'};
                                                            1
                                                        }
                                                        else {
                                                            0
                                                        }
                                                    })
                                                })
                                            }) && ($last_match_null < 2)) {
                                                if ($to == $MATCH->{'to'}) {
                                                    $last_match_null = $last_match_null + 1
                                                }
                                                else {
                                                    $last_match_null = 0
                                                }
                                                $m = $MATCH;
                                                $to = $MATCH->{'to'};
                                                $count = $count + 1
                                            }
                                            $MATCH = $m;
                                            $MATCH->{'to'} = $to;
                                            $count > 0
                                        })
                                    })
                                }) && (do {
                                    $MATCH->{'capture'} = Perlito5::AST::Int::->new('int' => oct(lc(Perlito5::Match::flat($MATCH))));
                                    1
                                })));
                                $tmp ? $MATCH : 0
                            }
                            sub Perlito5::Grammar::Number::val_int {
                                my $str = $_[0];
                                my $pos = $_[1];
                                my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
                                my $tmp = (((do {
                                    my $m2 = digits_underscore($str, $MATCH->{'to'});
                                    if ($m2) {
                                        $MATCH->{'to'} = $m2->{'to'};
                                        1
                                    }
                                    else {
                                        0
                                    }
                                }) && (do {
                                    my $s = Perlito5::Match::flat($MATCH);
                                    $s =~ s!_!!g;
                                    $MATCH->{'capture'} = Perlito5::AST::Int::->new('int' => $s);
                                    1
                                })));
                                $tmp ? $MATCH : 0
                            }
                            sub Perlito5::Grammar::Number::val_vstring {
                                my $str = $_[0];
                                my $pos = $_[1];
                                my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
                                my $tmp = (((do {
                                    my $m2 = val_int($str, $MATCH->{'to'});
                                    if ($m2) {
                                        $MATCH->{'to'} = $m2->{'to'};
                                        $MATCH->{'val_int'} = $m2;
                                        1
                                    }
                                    else {
                                        0
                                    }
                                }) && (do {
                                    my $last_match_null = 0;
                                    my $m = $MATCH;
                                    my $to = $MATCH->{'to'};
                                    my $count = 0;
                                    while ((('.' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                                        my $m2 = digits_underscore($str, $MATCH->{'to'});
                                        if ($m2) {
                                            $MATCH->{'to'} = $m2->{'to'};
                                            if (exists($MATCH->{'digits_underscore'})) {
                                                push(@{$MATCH->{'digits_underscore'}}, $m2)
                                            }
                                            else {
                                                $MATCH->{'digits_underscore'} = [$m2]
                                            }
                                            1
                                        }
                                        else {
                                            0
                                        }
                                    })) && ($last_match_null < 2)) {
                                        if ($to == $MATCH->{'to'}) {
                                            $last_match_null = $last_match_null + 1
                                        }
                                        else {
                                            $last_match_null = 0
                                        }
                                        $m = $MATCH;
                                        $to = $MATCH->{'to'};
                                        $count = $count + 1
                                    }
                                    $MATCH = $m;
                                    $MATCH->{'to'} = $to;
                                    $count > 0
                                }) && (do {
                                    my @parts = map {
                                        Perlito5::Match::flat($_)
                                    } @{$MATCH->{'digits_underscore'}};
                                    @parts < 2 && return ;
                                    $MATCH->{'capture'} = Perlito5::AST::Buf::->new('buf' => join('', map {
                                        chr($_)
                                    } $MATCH->{'val_int'}->{'capture'}->{'int'}, @parts));
                                    1
                                })));
                                $tmp ? $MATCH : 0
                            }
                            sub Perlito5::Grammar::Number::val_version {
                                my $str = $_[0];
                                my $pos = $_[1];
                                my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
                                my $tmp = ((('v' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                                    my $m2 = val_int($str, $MATCH->{'to'});
                                    if ($m2) {
                                        $MATCH->{'to'} = $m2->{'to'};
                                        $MATCH->{'val_int'} = $m2;
                                        1
                                    }
                                    else {
                                        0
                                    }
                                }) && (do {
                                    my $last_match_null = 0;
                                    my $m = $MATCH;
                                    my $to = $MATCH->{'to'};
                                    while ((('.' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                                        my $m2 = digits_underscore($str, $MATCH->{'to'});
                                        if ($m2) {
                                            $MATCH->{'to'} = $m2->{'to'};
                                            if (exists($MATCH->{'digits_underscore'})) {
                                                push(@{$MATCH->{'digits_underscore'}}, $m2)
                                            }
                                            else {
                                                $MATCH->{'digits_underscore'} = [$m2]
                                            }
                                            1
                                        }
                                        else {
                                            0
                                        }
                                    })) && ($last_match_null < 2)) {
                                        if ($to == $MATCH->{'to'}) {
                                            $last_match_null = $last_match_null + 1
                                        }
                                        else {
                                            $last_match_null = 0
                                        }
                                        $m = $MATCH;
                                        $to = $MATCH->{'to'}
                                    }
                                    $MATCH = $m;
                                    $MATCH->{'to'} = $to;
                                    1
                                }) && (do {
                                    my @parts = map {
                                        Perlito5::Match::flat($_)
                                    } @{$MATCH->{'digits_underscore'}};
                                    $MATCH->{'capture'} = Perlito5::AST::Buf::->new('buf' => join('', map {
                                        chr($_)
                                    } $MATCH->{'val_int'}->{'capture'}->{'int'}, @parts));
                                    1
                                })));
                                $tmp ? $MATCH : 0
                            }
                            1
                        }
                    }
                    sub Perlito5::Grammar::word {
                        substr($_[0], $_[1], 1) =~ m!\w! ? {'str' => $_[0], 'from' => $_[1], 'to' => $_[1] + 1} : 0
                    }
                    sub Perlito5::Grammar::ident {
                        substr($_[0], $_[1], 256) !~ m!^([a-zA-Z_]\w*)! && return ;
                        length(${1}) > 251 && die('Identifier too long');
                        return {'str' => $_[0], 'from' => $_[1], 'to' => $_[1] + length(${1})}
                    }
                    sub Perlito5::Grammar::caret_char {
                        my $c = substr($_[0], $_[1], 1);
                        my $pos = $_[1];
                        if ($c eq '^') {
                            $pos++;
                            $c = substr($_[0], $pos, 1);
                            ($c lt 'A' || $c gt 'Z') && return 0;
                            $c = chr(ord($c) - ord('A') + 1)
                        }
                        elsif (Perlito5::Grammar::Space::ws($_[0], $pos)) {
                            return 0
                        }
                        ($c lt chr(1) || $c gt chr(26)) && return 0;
                        return {'str' => $_[0], 'from' => $_[1], 'to' => $pos + 1, 'capture' => $c}
                    }
                    sub Perlito5::Grammar::full_ident {
                        my $str = $_[0];
                        my $pos = $_[1];
                        my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
                        my $tmp = (((do {
                            my $m2 = ident($str, $MATCH->{'to'});
                            if ($m2) {
                                $MATCH->{'to'} = $m2->{'to'};
                                1
                            }
                            else {
                                0
                            }
                        }) && (do {
                            my $last_match_null = 0;
                            my $m = $MATCH;
                            my $to = $MATCH->{'to'};
                            while ((('::' eq substr($str, $MATCH->{'to'}, 2) && ($MATCH->{'to'} = 2 + $MATCH->{'to'})) && (do {
                                my $m2 = ident($str, $MATCH->{'to'});
                                if ($m2) {
                                    $MATCH->{'to'} = $m2->{'to'};
                                    1
                                }
                                else {
                                    0
                                }
                            })) && ($last_match_null < 2)) {
                                if ($to == $MATCH->{'to'}) {
                                    $last_match_null = $last_match_null + 1
                                }
                                else {
                                    $last_match_null = 0
                                }
                                $m = $MATCH;
                                $to = $MATCH->{'to'}
                            }
                            $MATCH = $m;
                            $MATCH->{'to'} = $to;
                            1
                        })));
                        $tmp ? $MATCH : 0
                    }
                    sub Perlito5::Grammar::namespace_before_ident {
                        my $str = $_[0];
                        my $pos = $_[1];
                        my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
                        my $tmp = (((do {
                            my $m2 = ident($str, $MATCH->{'to'});
                            if ($m2) {
                                $MATCH->{'to'} = $m2->{'to'};
                                1
                            }
                            else {
                                0
                            }
                        }) && (do {
                            my $tmp = $MATCH;
                            $MATCH = {'from' => $tmp->{'to'}, 'to' => $tmp->{'to'}};
                            my $res = ('::' eq substr($str, $MATCH->{'to'}, 2) && ($MATCH->{'to'} = 2 + $MATCH->{'to'}));
                            $MATCH = $tmp;
                            $res ? 1 : 0
                        }) && (do {
                            my $last_match_null = 0;
                            my $m = $MATCH;
                            my $to = $MATCH->{'to'};
                            while ((('::' eq substr($str, $MATCH->{'to'}, 2) && ($MATCH->{'to'} = 2 + $MATCH->{'to'})) && (do {
                                my $m2 = ident($str, $MATCH->{'to'});
                                if ($m2) {
                                    $MATCH->{'to'} = $m2->{'to'};
                                    1
                                }
                                else {
                                    0
                                }
                            }) && (do {
                                my $tmp = $MATCH;
                                $MATCH = {'from' => $tmp->{'to'}, 'to' => $tmp->{'to'}};
                                my $res = ('::' eq substr($str, $MATCH->{'to'}, 2) && ($MATCH->{'to'} = 2 + $MATCH->{'to'}));
                                $MATCH = $tmp;
                                $res ? 1 : 0
                            })) && ($last_match_null < 2)) {
                                if ($to == $MATCH->{'to'}) {
                                    $last_match_null = $last_match_null + 1
                                }
                                else {
                                    $last_match_null = 0
                                }
                                $m = $MATCH;
                                $to = $MATCH->{'to'}
                            }
                            $MATCH = $m;
                            $MATCH->{'to'} = $to;
                            1
                        })));
                        $tmp ? $MATCH : 0
                    }
                    sub Perlito5::Grammar::optional_namespace_before_ident {
                        my $str = $_[0];
                        my $pos = $_[1];
                        my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
                        my $tmp = ((do {
                            my $pos1 = $MATCH->{'to'};
                            (do {
                                ((do {
                                    my $m2 = namespace_before_ident($str, $MATCH->{'to'});
                                    if ($m2) {
                                        $MATCH->{'to'} = $m2->{'to'};
                                        $MATCH->{'namespace_before_ident'} = $m2;
                                        1
                                    }
                                    else {
                                        0
                                    }
                                }) && (do {
                                    my $last_match_null = 0;
                                    my $m = $MATCH;
                                    my $to = $MATCH->{'to'};
                                    while (('::' eq substr($str, $MATCH->{'to'}, 2) && ($MATCH->{'to'} = 2 + $MATCH->{'to'})) && ($last_match_null < 2)) {
                                        if ($to == $MATCH->{'to'}) {
                                            $last_match_null = $last_match_null + 1
                                        }
                                        else {
                                            $last_match_null = 0
                                        }
                                        $m = $MATCH;
                                        $to = $MATCH->{'to'}
                                    }
                                    $MATCH = $m;
                                    $MATCH->{'to'} = $to;
                                    1
                                }) && (do {
                                    $MATCH->{'capture'} = Perlito5::Match::flat($MATCH->{'namespace_before_ident'});
                                    1
                                }))
                            }) || (do {
                                $MATCH->{'to'} = $pos1;
                                (('::' eq substr($str, $MATCH->{'to'}, 2) && ($MATCH->{'to'} = 2 + $MATCH->{'to'})) && (do {
                                    my $m2 = optional_namespace_before_ident($str, $MATCH->{'to'});
                                    if ($m2) {
                                        $MATCH->{'to'} = $m2->{'to'};
                                        $MATCH->{'optional_namespace_before_ident'} = $m2;
                                        1
                                    }
                                    else {
                                        0
                                    }
                                }) && (do {
                                    my $name = Perlito5::Match::flat($MATCH->{'optional_namespace_before_ident'});
                                    $MATCH->{'capture'} = 'main';
                                    $name ne '' && ($MATCH->{'capture'} .= '::' . $name);
                                    1
                                }))
                            }) || (do {
                                $MATCH->{'to'} = $pos1;
                                (1 && (do {
                                    $MATCH->{'capture'} = '';
                                    1
                                }))
                            })
                        }));
                        $tmp ? $MATCH : 0
                    }
                    sub Perlito5::Grammar::exp_stmts2 {
                        my $str = $_[0];
                        my $pos = $_[1];
                        my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
                        my $tmp = (((do {
                            my $m2 = exp_stmts($str, $MATCH->{'to'});
                            if ($m2) {
                                $MATCH->{'to'} = $m2->{'to'};
                                $MATCH->{'exp_stmts'} = $m2;
                                1
                            }
                            else {
                                0
                            }
                        }) && (do {
                            $MATCH->{'capture'} = Perlito5::Match::flat($MATCH->{'exp_stmts'});
                            1
                        })));
                        $tmp ? $MATCH : 0
                    }
                    sub Perlito5::Grammar::exp {
                        my $str = $_[0];
                        my $pos = $_[1];
                        my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
                        my $tmp = (((do {
                            my $m2 = Perlito5::Grammar::Expression::exp_parse($str, $MATCH->{'to'});
                            if ($m2) {
                                $MATCH->{'to'} = $m2->{'to'};
                                $MATCH->{'Perlito5::Grammar::Expression::exp_parse'} = $m2;
                                1
                            }
                            else {
                                0
                            }
                        }) && (do {
                            $MATCH->{'capture'} = Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::Expression::exp_parse'});
                            1
                        })));
                        $tmp ? $MATCH : 0
                    }
                    sub Perlito5::Grammar::exp2 {
                        my $str = $_[0];
                        my $pos = $_[1];
                        my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
                        my $tmp = (((do {
                            my $m2 = Perlito5::Grammar::Expression::exp_parse($str, $MATCH->{'to'});
                            if ($m2) {
                                $MATCH->{'to'} = $m2->{'to'};
                                $MATCH->{'Perlito5::Grammar::Expression::exp_parse'} = $m2;
                                1
                            }
                            else {
                                0
                            }
                        }) && (do {
                            $MATCH->{'capture'} = Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::Expression::exp_parse'});
                            1
                        })));
                        $tmp ? $MATCH : 0
                    }
                    sub Perlito5::Grammar::opt_type {
                        my $str = $_[0];
                        my $pos = $_[1];
                        my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
                        my $tmp = ((do {
                            my $pos1 = $MATCH->{'to'};
                            (do {
                                ((do {
                                    my $m = $MATCH;
                                    if (!('::' eq substr($str, $MATCH->{'to'}, 2) && ($MATCH->{'to'} = 2 + $MATCH->{'to'}))) {
                                        $MATCH = $m
                                    }
                                    1
                                }) && (do {
                                    my $m2 = full_ident($str, $MATCH->{'to'});
                                    if ($m2) {
                                        $MATCH->{'to'} = $m2->{'to'};
                                        $MATCH->{'full_ident'} = $m2;
                                        1
                                    }
                                    else {
                                        0
                                    }
                                }) && (do {
                                    $MATCH->{'capture'} = Perlito5::Match::flat($MATCH->{'full_ident'});
                                    1
                                }))
                            }) || (do {
                                $MATCH->{'to'} = $pos1;
                                (1 && (do {
                                    $MATCH->{'capture'} = '';
                                    1
                                }))
                            })
                        }));
                        $tmp ? $MATCH : 0
                    }
                    sub Perlito5::Grammar::var_sigil {
                        my $str = $_[0];
                        my $pos = $_[1];
                        my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
                        my $tmp = ((do {
                            my $pos1 = $MATCH->{'to'};
                            (do {
                                ('$' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}))
                            }) || (do {
                                $MATCH->{'to'} = $pos1;
                                ('%' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}))
                            }) || (do {
                                $MATCH->{'to'} = $pos1;
                                ('@' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}))
                            }) || (do {
                                $MATCH->{'to'} = $pos1;
                                ('&' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}))
                            }) || (do {
                                $MATCH->{'to'} = $pos1;
                                ('*' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}))
                            })
                        }));
                        $tmp ? $MATCH : 0
                    }
                    sub Perlito5::Grammar::var_name {
                        my $str = $_[0];
                        my $pos = $_[1];
                        my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
                        my $tmp = ((do {
                            my $pos1 = $MATCH->{'to'};
                            (do {
                                (do {
                                    my $m2 = full_ident($str, $MATCH->{'to'});
                                    if ($m2) {
                                        $MATCH->{'to'} = $m2->{'to'};
                                        $MATCH->{'full_ident'} = $m2;
                                        1
                                    }
                                    else {
                                        0
                                    }
                                })
                            }) || (do {
                                $MATCH->{'to'} = $pos1;
                                (do {
                                    my $m2 = Perlito5::Grammar::Number::digits($str, $MATCH->{'to'});
                                    if ($m2) {
                                        $MATCH->{'to'} = $m2->{'to'};
                                        $MATCH->{'Perlito5::Grammar::Number::digits'} = $m2;
                                        1
                                    }
                                    else {
                                        0
                                    }
                                })
                            })
                        }));
                        $tmp ? $MATCH : 0
                    }
                    sub Perlito5::Grammar::var_ident {
                        my $str = $_[0];
                        my $pos = $_[1];
                        my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
                        my $tmp = (((do {
                            my $m2 = var_sigil($str, $MATCH->{'to'});
                            if ($m2) {
                                $MATCH->{'to'} = $m2->{'to'};
                                $MATCH->{'var_sigil'} = $m2;
                                1
                            }
                            else {
                                0
                            }
                        }) && (do {
                            my $m2 = optional_namespace_before_ident($str, $MATCH->{'to'});
                            if ($m2) {
                                $MATCH->{'to'} = $m2->{'to'};
                                $MATCH->{'optional_namespace_before_ident'} = $m2;
                                1
                            }
                            else {
                                0
                            }
                        }) && (do {
                            my $m2 = var_name($str, $MATCH->{'to'});
                            if ($m2) {
                                $MATCH->{'to'} = $m2->{'to'};
                                $MATCH->{'var_name'} = $m2;
                                1
                            }
                            else {
                                0
                            }
                        }) && (do {
                            $MATCH->{'capture'} = Perlito5::AST::Var::->new('sigil' => Perlito5::Match::flat($MATCH->{'var_sigil'}), 'namespace' => Perlito5::Match::flat($MATCH->{'optional_namespace_before_ident'}), 'name' => Perlito5::Match::flat($MATCH->{'var_name'}));
                            1
                        })));
                        $tmp ? $MATCH : 0
                    }
                    sub Perlito5::Grammar::block {
                        Perlito5::Grammar::Block::block(@_)
                    }
                    sub Perlito5::Grammar::block2 {
                        Perlito5::Grammar::Block::block(@_)
                    }
                    sub Perlito5::Grammar::opt_continue_block {
                        Perlito5::Grammar::Block::opt_continue_block(@_)
                    }
                    my @PKG;
                    sub Perlito5::Grammar::exp_stmts {
                        my $str = $_[0];
                        my $pos = $_[1];
                        push(@PKG, $Perlito5::PKG_NAME);
                        my $has_semicolon;
                        my @stmts;
                        my $m = Perlito5::Grammar::Space::opt_ws($str, $pos);
                        $pos = $m->{'to'};
                        while ($m) {
                            if (substr($str, $pos, 1) eq ';') {
                                $has_semicolon = 1;
                                $m = Perlito5::Grammar::Space::opt_ws($str, $pos + 1);
                                $pos = $m->{'to'}
                            }
                            else {
                                $m = Perlito5::Grammar::Statement::statement_parse($str, $pos);
                                if ($m) {
                                    push(@stmts, $m->{'capture'});
                                    $pos = $m->{'to'};
                                    if (substr($str, $pos, 1) eq ';') {
                                        $has_semicolon = 1;
                                        $pos = $pos + 1
                                    }
                                    $m = Perlito5::Grammar::Space::opt_ws($str, $pos);
                                    $pos = $m->{'to'}
                                }
                            }
                        }
                        $Perlito5::PKG_NAME = pop(@PKG);
                        $Perlito5::BLOCK_HAS_SEMICOLON ||= $has_semicolon;
                        return {'str' => $str, 'to' => $pos, 'capture' => \@stmts}
                    }
                }
            }
            undef();
            undef();
            undef();
            undef();
            {
                {
                    package main;
                    package Perlito5;
                    undef();
                    # use strict
                    defined(${chr(15)}) || (${chr(15)} = 'perlito5');
                    defined($/) || ($/ = chr(10));
                    defined(${'"'}) || (${'"'} = ' ');
                    defined(${','}) || (${','} = undef);
                    defined(${'!'}) || (${'!'} = '');
                    defined(${';'}) || (${';'} = chr(28));
                    defined(${'?'}) || (${'?'} = 0);
                    ${']'} || (${']'} = '5.020000');
                    defined(${chr(22)}) || (${chr(22)} = bless({'original' => 'v5.20.0', 'qv' => 1, 'version' => [5, 20, 0]}, 'version'));
                    our $EXPAND_USE = 1;
                    our $EMIT_USE = 0;
                    our $STRICT = 0;
                    our $WARNINGS = 0;
                    our $UTF8 = 0;
                    our $BYTES = 0;
                    our $CALLER = [];
                    our %DATA_SECTION = ();
                    our $PKG_NAME = '';
                    our $LINE_NUMBER = 0;
                    our $FILE_NAME = '';
                    our $GLOBAL = {};
                    our $BASE_SCOPE = Perlito5::Grammar::Scope::->new_base_scope();
                    our $SCOPE = $BASE_SCOPE;
                    our $SCOPE_DEPTH = 0;
                    our @SCOPE_STMT = ();
                    our @END_BLOCK = ();
                    our @INIT_BLOCK = ();
                    our @CHECK_BLOCK = ();
                    our @UNITCHECK_BLOCK = ();
                    our $PROTO = {};
                    sub Perlito5::set_global_phase {
                        my $phase = shift;
                        local ${'@'};
                        eval {
                            ${chr(7) . 'LOBAL_PHASE'} = $phase
                        }
                    }
                    our $ID = 100;
                    our $PACKAGES = {'STDERR' => 1, 'STDOUT' => 1, 'STDIN' => 1, 'main' => 1, 'strict' => 1, 'warnings' => 1, 'utf8' => 1, 'bytes' => 1, 'encoding' => 1, 'UNIVERSAL' => 1, 'CORE' => 1, 'CORE::GLOBAL' => 1, 'Perlito5::IO' => 1};
                    push(@INC, $_)
                        for split(':', ($ENV{'PERL5LIB'} || ''));
                    our $SPECIAL_VAR = {'$_' => 'ARG', '$&' => '$MATCH', '$`' => '$PREMATCH', '$' . chr(39) => '$POSTMATCH', '$+' => '$LAST_PAREN_MATCH', '@+' => '@LAST_MATCH_END', '%+' => '%LAST_PAREN_MATCH', '@-' => '@LAST_MATCH_START', '$|' => 'autoflush', '$/' => '$RS', '@_' => '@ARG', '< $' => '$EUID', '$.' => '$NR', '< $< ' => '$UID', '$(' => '$GID', '$#' => undef, '$@' => '$EVAL_ERROR', '$=' => '$FORMAT_LINES_PER_PAGE', '$,' => '$OFS', '$?' => '$CHILD_ERROR', '$*' => undef, '$[' => undef, '$$' => '$PID', '%-' => undef, '$~' => '$FORMAT_NAME', '$-' => '$FORMAT_LINES_LEFT', '$&' => '$MATCH', '$%' => '$FORMAT_PAGE_NUMBER', '$)' => '$EGID', '$]' => undef, '$!' => '$ERRNO', '$;' => '$SUBSEP', '$' . chr(92) => '$ORS', '%!' => undef, '$"' => '$LIST_SEPARATOR', '$_' => '$ARG', '$:' => 'FORMAT_LINE_BREAK_CHARACTERS'};
                    our $CORE_OVERRIDABLE = {'say' => 1, 'break' => 1, 'given' => 1, 'when' => 1, 'default' => 1, 'state' => 1, 'lock' => 1};
                    our $CORE_PROTO = {'CORE::shutdown' => '*$', 'CORE::chop' => '_', 'CORE::lstat' => '*', 'CORE::rename' => '$$', 'CORE::lock' => chr(92) . '$', 'CORE::rand' => ';$', 'CORE::gmtime' => ';$', 'CORE::gethostbyname' => '$', 'CORE::each' => '+', 'CORE::ref' => '_', 'CORE::syswrite' => '*$;$$', 'CORE::msgctl' => '$$$', 'CORE::getnetbyname' => '$', 'CORE::write' => ';*', 'CORE::alarm' => '_', 'CORE::print' => undef, 'CORE::getnetent' => '', 'CORE::semget' => '$$$', 'CORE::use' => undef, 'CORE::abs' => '_', 'CORE::break' => '', 'CORE::undef' => ';$', 'CORE::no' => undef, 'CORE::eval' => '_', 'CORE::split' => undef, 'CORE::localtime' => ';$', 'CORE::sort' => undef, 'CORE::chown' => '@', 'CORE::endpwent' => '', 'CORE::getpwent' => '', 'CORE::pos' => undef, 'CORE::lcfirst' => '_', 'CORE::kill' => '@', 'CORE::send' => '*$$;$', 'CORE::endprotoent' => '', 'CORE::semctl' => '$$$$', 'CORE::waitpid' => '$$', 'CORE::utime' => '@', 'CORE::dbmclose' => chr(92) . '%', 'CORE::getpwnam' => '$', 'CORE::substr' => '$$;$$', 'CORE::listen' => '*$', 'CORE::getprotoent' => '', 'CORE::shmget' => '$$$', 'CORE::our' => undef, 'CORE::readlink' => '_', 'CORE::shmwrite' => '$$$$', 'CORE::times' => '', 'CORE::package' => undef, 'CORE::map' => undef, 'CORE::join' => '$@', 'CORE::rmdir' => '_', 'CORE::shmread' => '$$$$', 'CORE::uc' => '_', 'CORE::bless' => '$;$', 'CORE::closedir' => '*', 'CORE::getppid' => '', 'CORE::tie' => chr(92) . '[$@%]$;@', 'CORE::readdir' => '*', 'CORE::gethostent' => '', 'CORE::getlogin' => '', 'CORE::last' => undef, 'CORE::gethostbyaddr' => '$$', 'CORE::accept' => '**', 'CORE::log' => '_', 'CORE::tell' => ';*', 'CORE::readline' => ';*', 'CORE::tied' => undef, 'CORE::socket' => '*$$$', 'CORE::umask' => ';$', 'CORE::sysread' => '*' . chr(92) . '$$;$', 'CORE::syscall' => '$@', 'CORE::quotemeta' => '_', 'CORE::dump' => '', 'CORE::opendir' => '*$', 'CORE::untie' => undef, 'CORE::truncate' => '$$', 'CORE::select' => ';*', 'CORE::sleep' => ';$', 'CORE::seek' => '*$$', 'CORE::read' => '*' . chr(92) . '$$;$', 'CORE::rewinddir' => '*', 'CORE::scalar' => undef, 'CORE::wantarray' => '', 'CORE::oct' => '_', 'CORE::bind' => '*$', 'CORE::stat' => '*', 'CORE::sqrt' => '_', 'CORE::getc' => ';*', 'CORE::fileno' => '*', 'CORE::getpeername' => '*', 'CORE::sin' => '_', 'CORE::getnetbyaddr' => '$$', 'CORE::grep' => undef, 'CORE::setservent' => '$', 'CORE::sub' => undef, 'CORE::shmctl' => '$$$', 'CORE::study' => undef, 'CORE::msgrcv' => '$$$$$', 'CORE::setsockopt' => '*$$$', 'CORE::int' => '_', 'CORE::pop' => ';+', 'CORE::link' => '$$', 'CORE::exec' => undef, 'CORE::setpwent' => '', 'CORE::mkdir' => '_;$', 'CORE::sysseek' => '*$$', 'CORE::endservent' => '', 'CORE::chr' => '_', 'CORE::when' => undef, 'CORE::getpwuid' => '$', 'CORE::setprotoent' => '$', 'CORE::reverse' => '@', 'CORE::say' => undef, 'CORE::goto' => undef, 'CORE::getgrent' => '', 'CORE::endnetent' => '', 'CORE::hex' => '_', 'CORE::binmode' => '*;$', 'CORE::formline' => '$@', 'CORE::getgrnam' => '$', 'CORE::ucfirst' => '_', 'CORE::chdir' => ';$', 'CORE::setnetent' => '$', 'CORE::splice' => '+;$$@', 'CORE::unlink' => '@', 'CORE::time' => '', 'CORE::push' => '+@', 'CORE::exit' => ';$', 'CORE::endgrent' => '', 'CORE::unshift' => '+@', 'CORE::local' => undef, 'CORE::my' => undef, 'CORE::cos' => '_', 'CORE::redo' => undef, 'CORE::warn' => '@', 'CORE::getsockname' => '*', 'CORE::pipe' => '**', 'CORE::sprintf' => '$@', 'CORE::open' => '*;$@', 'CORE::setpgrp' => ';$$', 'CORE::exp' => '_', 'CORE::seekdir' => '*$', 'CORE::getservbyport' => '$$', 'CORE::given' => undef, 'CORE::pack' => '$@', 'CORE::msgget' => '$$', 'CORE::rindex' => '$$;$', 'CORE::srand' => ';$', 'CORE::telldir' => '*', 'CORE::connect' => '*$', 'CORE::getprotobyname' => '$', 'CORE::msgsnd' => '$$$', 'CORE::length' => '_', 'CORE::state' => undef, 'CORE::die' => '@', 'CORE::delete' => undef, 'CORE::getservent' => '', 'CORE::getservbyname' => '$$', 'CORE::setpriority' => '$$$', 'CORE::lc' => '_', 'CORE::fcntl' => '*$$', 'CORE::chroot' => '_', 'CORE::recv' => '*' . chr(92) . '$$$', 'CORE::dbmopen' => chr(92) . '%$$', 'CORE::socketpair' => '**$$$', 'CORE::vec' => '$$$', 'CORE::system' => undef, 'CORE::defined' => '_', 'CORE::index' => '$$;$', 'CORE::caller' => ';$', 'CORE::close' => ';*', 'CORE::atan2' => '$$', 'CORE::semop' => '$$', 'CORE::unpack' => '$;$', 'CORE::ord' => '_', 'CORE::chmod' => '@', 'CORE::prototype' => undef, 'CORE::getprotobynumber' => '$', 'CORE::values' => '+', 'CORE::chomp' => '_', 'CORE::ioctl' => '*$$', 'CORE::eof' => ';*', 'CORE::crypt' => '$$', 'CORE::do' => undef, 'CORE::flock' => '*$', 'CORE::wait' => '', 'CORE::sethostent' => '$', 'CORE::return' => undef, 'CORE::getsockopt' => '*$$', 'CORE::fork' => '', 'CORE::require' => undef, 'CORE::format' => undef, 'CORE::readpipe' => '_', 'CORE::endhostent' => '', 'CORE::getpgrp' => ';$', 'CORE::setgrent' => '', 'CORE::keys' => '+', 'CORE::glob' => undef, 'CORE::getpriority' => '$$', 'CORE::reset' => ';$', 'CORE::sysopen' => '*$$;$', 'CORE::continue' => '', 'CORE::next' => undef, 'CORE::getgrgid' => '$', 'CORE::default' => undef, 'CORE::shift' => ';+', 'CORE::symlink' => '$$', 'CORE::exists' => '$', 'CORE::printf' => '$@', 'CORE::m' => undef, 'CORE::q' => undef, 'CORE::qq' => undef, 'CORE::qw' => undef, 'CORE::qx' => undef, 'CORE::qr' => undef, 'CORE::s' => undef, 'CORE::tr' => undef, 'CORE::y' => undef, 'CORE::if' => undef, 'CORE::unless' => undef, 'CORE::when' => undef, 'CORE::for' => undef, 'CORE::foreach' => undef, 'CORE::while' => undef, 'CORE::given' => undef, 'CORE::and' => undef, 'CORE::or' => undef, 'CORE::xor' => undef, 'CORE::not' => undef, 'CORE::cmp' => undef, 'CORE::__FILE__' => '', 'CORE::__LINE__' => ''};
                    sub Perlito5::test_perl_version {
                        my $version = shift;
                        $version =~ s!^v!!;
                        if ($version && ord(substr($version, 0, 1)) < 10) {
                            my @v = split(m!!, $version);
                            push(@v, chr(0))
                                while @v < 3;
                            $version = sprintf('%d.%03d%03d', map {
                                ord($_)
                            } @v)
                        }
                        else {
                            my @v = split(m!\.!, $version);
                            $v[1] = $v[1] . 0
                                while length($v[1]) < 3;
                            $version = join('.', @v)
                        }
                        if ($version gt ${']'}) {
                            die('Perl v' . $version . ' required--this is only v' . ${']'})
                        }
                    }
                    1
                }
            }
            sub Perlito5::Compiler::compiler_name {
                'Perlito5'
            }
            sub Perlito5::Compiler::do_not_edit {
                my $prefix = shift;
                return $prefix . ' Do not edit this file - Generated by ' . compiler_name() . ' ' . $Perlito5::VERSION . chr(10)
            }
            sub Perlito5::Compiler::error {
                die(join('', @_) . ' at ' . $Perlito5::FILE_NAME . ' line ' . $Perlito5::LINE_NUMBER)
            }
            1
        }
    }
    {
        {
            package main;
            undef();
            {
                {
                    package main;
                    undef();
                    package Perlito5::AST::CompUnit;
                    sub Perlito5::AST::CompUnit::new {
                        my $class = shift;
                        bless({@_}, $class)
                    }
                    sub Perlito5::AST::CompUnit::name {
                        $_[0]->{'name'}
                    }
                    sub Perlito5::AST::CompUnit::body {
                        $_[0]->{'body'}
                    }
                    package Perlito5::AST::Int;
                    sub Perlito5::AST::Int::new {
                        my $class = shift;
                        bless({@_}, $class)
                    }
                    sub Perlito5::AST::Int::int {
                        $_[0]->{'int'}
                    }
                    package Perlito5::AST::Num;
                    sub Perlito5::AST::Num::new {
                        my $class = shift;
                        bless({@_}, $class)
                    }
                    sub Perlito5::AST::Num::num {
                        $_[0]->{'num'}
                    }
                    package Perlito5::AST::Buf;
                    sub Perlito5::AST::Buf::new {
                        my $class = shift;
                        bless({@_}, $class)
                    }
                    sub Perlito5::AST::Buf::buf {
                        $_[0]->{'buf'}
                    }
                    package Perlito5::AST::Block;
                    sub Perlito5::AST::Block::new {
                        my $class = shift;
                        bless({@_}, $class)
                    }
                    sub Perlito5::AST::Block::sig {
                        $_[0]->{'sig'}
                    }
                    sub Perlito5::AST::Block::stmts {
                        $_[0]->{'stmts'}
                    }
                    package Perlito5::AST::Index;
                    sub Perlito5::AST::Index::new {
                        my $class = shift;
                        bless({@_}, $class)
                    }
                    sub Perlito5::AST::Index::obj {
                        $_[0]->{'obj'}
                    }
                    sub Perlito5::AST::Index::index_exp {
                        $_[0]->{'index_exp'}
                    }
                    package Perlito5::AST::Lookup;
                    sub Perlito5::AST::Lookup::new {
                        my $class = shift;
                        bless({@_}, $class)
                    }
                    sub Perlito5::AST::Lookup::obj {
                        $_[0]->{'obj'}
                    }
                    sub Perlito5::AST::Lookup::index_exp {
                        $_[0]->{'index_exp'}
                    }
                    sub Perlito5::AST::Lookup::autoquote {
                        my $self = shift;
                        my $index = shift;
                        if ($index->isa('Perlito5::AST::Apply') && $index->{'bareword'}) {
                            my $full_name = ($index->{'namespace'} ? $index->{'namespace'} . '::' : '') . $index->{'code'};
                            if (!exists($Perlito5::PROTO->{$full_name})) {
                                return Perlito5::AST::Buf::->new('buf' => $full_name)
                            }
                        }
                        elsif ($index->isa('Perlito5::AST::Apply') && ($index->code() eq 'prefix:<->' || $index->code() eq 'prefix:<+>')) {
                            my $arg = $index->arguments()->[0];
                            $arg && return Perlito5::AST::Apply::->new('code' => $index->code(), 'namespace' => $index->namespace(), 'arguments' => [$self->autoquote($arg)])
                        }
                        elsif ($index->isa('Perlito5::AST::Apply') && ($index->code() eq 'list:<,>')) {
                            my $obj = $self->obj();
                            if ($obj->sigil() eq '@') {
                                return $index
                            }
                            my $args = $index->arguments();
                            return Perlito5::AST::Apply::->new('code' => 'join', 'namespace' => '', 'arguments' => [Perlito5::AST::Var::->new('name' => ';', 'namespace' => '', 'sigil' => '$'), map {
                                defined($_) ? $_ : Perlito5::AST::Buf::->new('buf' => '')
                            } @{$args}])
                        }
                        $index
                    }
                    package Perlito5::AST::Var;
                    sub Perlito5::AST::Var::new {
                        my($class, %args) = @_;
                        my $var = bless(\%args, $class);
                        push(@Perlito5::SCOPE_STMT, $var);
                        return $var
                    }
                    sub Perlito5::AST::Var::sigil {
                        $_[0]->{'sigil'}
                    }
                    sub Perlito5::AST::Var::namespace {
                        $_[0]->{'namespace'}
                    }
                    sub Perlito5::AST::Var::name {
                        $_[0]->{'name'}
                    }
                    sub Perlito5::AST::Var::plain_name {
                        my $self = shift;
                        if ($self->namespace()) {
                            return $self->namespace() . '::' . $self->name()
                        }
                        return $self->name()
                    }
                    package Perlito5::AST::Call;
                    sub Perlito5::AST::Call::new {
                        my $class = shift;
                        bless({@_}, $class)
                    }
                    sub Perlito5::AST::Call::invocant {
                        $_[0]->{'invocant'}
                    }
                    sub Perlito5::AST::Call::method {
                        $_[0]->{'method'}
                    }
                    sub Perlito5::AST::Call::arguments {
                        $_[0]->{'arguments'}
                    }
                    package Perlito5::AST::Apply;
                    sub Perlito5::AST::Apply::new {
                        my $class = shift;
                        bless({@_}, $class)
                    }
                    sub Perlito5::AST::Apply::code {
                        $_[0]->{'code'}
                    }
                    sub Perlito5::AST::Apply::special_arg {
                        $_[0]->{'special_arg'}
                    }
                    sub Perlito5::AST::Apply::arguments {
                        $_[0]->{'arguments'}
                    }
                    sub Perlito5::AST::Apply::namespace {
                        $_[0]->{'namespace'}
                    }
                    package Perlito5::AST::If;
                    sub Perlito5::AST::If::new {
                        my $class = shift;
                        bless({@_}, $class)
                    }
                    sub Perlito5::AST::If::cond {
                        $_[0]->{'cond'}
                    }
                    sub Perlito5::AST::If::body {
                        $_[0]->{'body'}
                    }
                    sub Perlito5::AST::If::otherwise {
                        $_[0]->{'otherwise'}
                    }
                    package Perlito5::AST::When;
                    sub Perlito5::AST::When::new {
                        my $class = shift;
                        bless({@_}, $class)
                    }
                    sub Perlito5::AST::When::cond {
                        $_[0]->{'cond'}
                    }
                    sub Perlito5::AST::When::body {
                        $_[0]->{'body'}
                    }
                    package Perlito5::AST::While;
                    sub Perlito5::AST::While::new {
                        my $class = shift;
                        bless({@_}, $class)
                    }
                    sub Perlito5::AST::While::init {
                        $_[0]->{'init'}
                    }
                    sub Perlito5::AST::While::cond {
                        $_[0]->{'cond'}
                    }
                    sub Perlito5::AST::While::continue {
                        $_[0]->{'continue'}
                    }
                    sub Perlito5::AST::While::body {
                        $_[0]->{'body'}
                    }
                    package Perlito5::AST::For;
                    sub Perlito5::AST::For::new {
                        my $class = shift;
                        bless({@_}, $class)
                    }
                    sub Perlito5::AST::For::cond {
                        $_[0]->{'cond'}
                    }
                    sub Perlito5::AST::For::continue {
                        $_[0]->{'continue'}
                    }
                    sub Perlito5::AST::For::body {
                        $_[0]->{'body'}
                    }
                    sub Perlito5::AST::For::topic {
                        $_[0]->{'topic'}
                    }
                    package Perlito5::AST::Given;
                    sub Perlito5::AST::Given::new {
                        my $class = shift;
                        bless({@_}, $class)
                    }
                    sub Perlito5::AST::Given::cond {
                        $_[0]->{'cond'}
                    }
                    sub Perlito5::AST::Given::body {
                        $_[0]->{'body'}
                    }
                    package Perlito5::AST::Decl;
                    sub Perlito5::AST::Decl::new {
                        my $class = shift;
                        bless({@_}, $class)
                    }
                    sub Perlito5::AST::Decl::decl {
                        $_[0]->{'decl'}
                    }
                    sub Perlito5::AST::Decl::type {
                        $_[0]->{'type'}
                    }
                    sub Perlito5::AST::Decl::var {
                        $_[0]->{'var'}
                    }
                    sub Perlito5::AST::Decl::attributes {
                        $_[0]->{'attributes'}
                    }
                    package Perlito5::AST::Sub;
                    sub Perlito5::AST::Sub::new {
                        my $class = shift;
                        bless({@_}, $class)
                    }
                    sub Perlito5::AST::Sub::name {
                        $_[0]->{'name'}
                    }
                    sub Perlito5::AST::Sub::sig {
                        $_[0]->{'sig'}
                    }
                    sub Perlito5::AST::Sub::block {
                        $_[0]->{'block'}
                    }
                    sub Perlito5::AST::Sub::attributes {
                        $_[0]->{'attributes'}
                    }
                    package Perlito5::AST::Use;
                    sub Perlito5::AST::Use::new {
                        my $class = shift;
                        bless({@_}, $class)
                    }
                    sub Perlito5::AST::Use::mod {
                        $_[0]->{'mod'}
                    }
                    sub Perlito5::AST::Use::code {
                        $_[0]->{'code'}
                    }
                    1
                }
            }
            # use strict
            package Perlito5::CompileTime;
            {
                sub Perlito5::CompileTime::emit_compile_time_block {
                    my $block = $_[0];
                    return ['block', map {
                        defined($_) && $_->emit_compile_time()
                    } @{$block}]
                }
            }
            package Perlito5::AST::CompUnit;
            {
                sub Perlito5::AST::CompUnit::emit_compile_time {
                    my $self;
                    $self->{'body'} = Perlito5::CompileTime::emit_compile_time_block($self->{'body'});
                    return $self
                }
                sub Perlito5::AST::CompUnit::emit_compile_time_program {
                    my $comp_units = $_[0];
                    return map {
                        $_->emit_compile_time()
                    } @{$comp_units}
                }
            }
            package Perlito5::AST::Int;
            {
                sub Perlito5::AST::Int::emit_compile_time {
                    return $_[0]->emit_perl5()
                }
            }
            package Perlito5::AST::Num;
            {
                sub Perlito5::AST::Num::emit_compile_time {
                    return $_[0]->emit_perl5()
                }
            }
            package Perlito5::AST::Buf;
            {
                sub Perlito5::AST::Buf::emit_compile_time {
                    return $_[0]->emit_perl5()
                }
            }
            package Perlito5::AST::Block;
            {
                sub Perlito5::AST::Block::emit_compile_time {
                    my $self = $_[0];
                    my @out;
                    $self->{'label'} && push(@out, ['label' => $self->{'label'}]);
                    if ($self->{'name'}) {
                        push(@out, ['stmt' => ['keyword' => $self->{'name'}], Perlito5::CompileTime::emit_compile_time_block($self->{'stmts'})])
                    }
                    else {
                        push(@out, Perlito5::CompileTime::emit_compile_time_block($self->{'stmts'}))
                    }
                    if ($self->{'continue'} && @{$self->{'continue'}->{'stmts'}}) {
                        push(@out, ['stmt' => ['keyword' => 'continue'], Perlito5::CompileTime::emit_compile_time_block($self->{'continue'}->{'stmts'})])
                    }
                    return @out
                }
            }
            package Perlito5::AST::Index;
            {
                sub Perlito5::AST::Index::emit_compile_time {
                    my $self = $_[0];
                    if (($self->{'obj'}->isa('Perlito5::AST::Apply') && $self->{'obj'}->{'code'} eq 'prefix:<@>') || ($self->{'obj'}->isa('Perlito5::AST::Var') && ($self->{'obj'}->sigil() eq '$' || $self->{'obj'}->sigil() eq '@'))) {
                        return ['apply' => '[', $self->{'obj'}->emit_compile_time(), $self->{'index_exp'}->emit_compile_time()]
                    }
                    if (($self->{'obj'}->isa('Perlito5::AST::Apply') && $self->{'obj'}->{'code'} eq 'prefix:<%>') || ($self->{'obj'}->isa('Perlito5::AST::Var') && ($self->{'obj'}->sigil() eq '%'))) {
                        return ['apply' => '[', $self->{'obj'}->emit_compile_time(), $self->{'index_exp'}->emit_compile_time()]
                    }
                    if ($self->{'obj'}->isa('Perlito5::AST::Apply') && $self->{'obj'}->{'code'} eq 'prefix:<$>') {
                        return ['op' => 'infix:<->>', $self->{'obj'}->{'arguments'}->[0]->emit_compile_time(), ['op' => 'circumfix:<[ ]>', $self->{'index_exp'}->emit_compile_time()]]
                    }
                    return ['op' => 'infix:<->>', $self->{'obj'}->emit_compile_time(), ['op' => 'circumfix:<[ ]>', $self->{'index_exp'}->emit_compile_time()]]
                }
            }
            package Perlito5::AST::Lookup;
            {
                sub Perlito5::AST::Lookup::emit_compile_time {
                    my $self = $_[0];
                    if (($self->{'obj'}->isa('Perlito5::AST::Apply') && $self->{'obj'}->{'code'} eq 'prefix:<@>') || ($self->{'obj'}->isa('Perlito5::AST::Var') && ($self->{'obj'}->sigil() eq '$' || $self->{'obj'}->sigil() eq '@'))) {
                        return ['apply' => '{', $self->{'obj'}->emit_compile_time(), $self->autoquote($self->{'index_exp'})->emit_compile_time()]
                    }
                    if (($self->{'obj'}->isa('Perlito5::AST::Apply') && $self->{'obj'}->{'code'} eq 'prefix:<%>') || ($self->{'obj'}->isa('Perlito5::AST::Var') && ($self->{'obj'}->sigil() eq '%'))) {
                        return ['apply' => '{', $self->{'obj'}->emit_compile_time(), $self->autoquote($self->{'index_exp'})->emit_compile_time()]
                    }
                    if ($self->{'obj'}->isa('Perlito5::AST::Apply') && $self->{'obj'}->{'code'} eq 'prefix:<$>') {
                        return ['op' => 'infix:<->>', $self->{'obj'}->{'arguments'}->[0]->emit_compile_time(), ['op' => 'circumfix:<{ }>', $self->autoquote($self->{'index_exp'})->emit_compile_time()]]
                    }
                    return ['op' => 'infix:<->>', $self->{'obj'}->emit_compile_time(), ['op' => 'circumfix:<{ }>', $self->autoquote($self->{'index_exp'})->emit_compile_time()]]
                }
            }
            package Perlito5::AST::Var;
            {
                sub Perlito5::AST::Var::emit_compile_time {
                    my $self;
                    if ($self->{'_decl'} eq 'my') {
                        $self->{'_decl'} = 'global';
                        $self->{'namespace'} = 'MY'
                    }
                    return $self
                }
            }
            package Perlito5::AST::Call;
            {
                sub Perlito5::AST::Call::emit_compile_time {
                    my $self = $_[0];
                    my $invocant = $self->{'invocant'}->emit_compile_time();
                    if ($self->{'method'} eq 'postcircumfix:<[ ]>') {
                        return ['op' => 'infix:<->>', $invocant, ['op' => 'circumfix:<[ ]>', $self->{'arguments'}->emit_compile_time()]]
                    }
                    if ($self->{'method'} eq 'postcircumfix:<{ }>') {
                        return ['op' => 'infix:<->>', $invocant, ['op' => 'circumfix:<{ }>', Perlito5::AST::Lookup::->autoquote($self->{'arguments'})->emit_compile_time()]]
                    }
                    my $meth = $self->{'method'};
                    if ($meth eq 'postcircumfix:<( )>') {
                        if ((ref($self->{'invocant'}) eq 'Perlito5::AST::Var' && $self->{'invocant'}->{'sigil'} eq '&') || (ref($self->{'invocant'}) eq 'Perlito5::AST::Apply' && $self->{'invocant'}->{'code'} eq 'prefix:<&>')) {
                            return ['apply' => '(', $invocant, map {
                                $_->emit_compile_time()
                            } @{$self->{'arguments'}}]
                        }
                        $meth = ''
                    }
                    if (ref($meth) eq 'Perlito5::AST::Var') {
                        $meth = $meth->emit_compile_time()
                    }
                    if ($meth) {
                        return ['call' => $invocant, $meth, map {
                            $_->emit_compile_time()
                        } @{$self->{'arguments'}}]
                    }
                    return ['op' => 'infix:<->>', $invocant, ['op' => 'list:<,>', map {
                        $_->emit_compile_time()
                    } @{$self->{'arguments'}}]]
                }
            }
            package Perlito5::AST::Apply;
            {
                sub Perlito5::AST::Apply::emit_compile_time_args {
                    my $self = $_[0];
                    !$self->{'arguments'} && return ();
                    return map {
                        $_->emit_compile_time()
                    } @{$self->{'arguments'}}
                }
                sub Perlito5::AST::Apply::emit_compile_time {
                    my $self = $_[0];
                    if (ref($self->{'code'})) {
                        return ['op' => 'infix:<->>', $self->{'code'}->emit_compile_time(), $self->emit_compile_time_args()]
                    }
                    if ($self->{'code'} eq 'infix:<=>>') {
                        return ['op' => $self->{'code'}, Perlito5::AST::Lookup::->autoquote($self->{'arguments'}->[0])->emit_compile_time(), $self->{'arguments'}->[1]->emit_compile_time()]
                    }
                    if ($Perlito5::Perl5::PrettyPrinter::op{$self->{'code'}}) {
                        return ['op' => $self->{'code'}, $self->emit_compile_time_args()]
                    }
                    my $ns = '';
                    if ($self->{'namespace'}) {
                        $ns = $self->{'namespace'} . '::'
                    }
                    my $code = $ns . $self->{'code'};
                    if ($self->{'code'} eq 'p5:s') {
                        return 's!' . $self->{'arguments'}->[0]->{'buf'} . '!' . $self->{'arguments'}->[1]->{'buf'} . '!' . $self->{'arguments'}->[2]->{'buf'}
                    }
                    if ($self->{'code'} eq 'p5:m') {
                        my $s;
                        if ($self->{'arguments'}->[0]->isa('Perlito5::AST::Buf')) {
                            $s = $self->{'arguments'}->[0]->{'buf'}
                        }
                        else {
                            for my $ast (@{$self->{'arguments'}->[0]->{'arguments'}}) {
                                if ($ast->isa('Perlito5::AST::Buf')) {
                                    $s .= $ast->{'buf'}
                                }
                                else {
                                    $s .= $ast->emit_compile_time()
                                }
                            }
                        }
                        return 'm!' . $s . '!' . $self->{'arguments'}->[1]->{'buf'}
                    }
                    if ($self->{'code'} eq 'p5:tr') {
                        return 'tr!' . $self->{'arguments'}->[0]->{'buf'} . '!' . $self->{'arguments'}->[1]->{'buf'} . '!'
                    }
                    if ($self->{'code'} eq 'package') {
                        return ['stmt' => 'package', ['bareword' => $self->{'namespace'}]]
                    }
                    if ($code eq 'map' || $code eq 'grep' || $code eq 'sort') {
                        if ($self->{'special_arg'}) {
                            return ['op' => 'prefix:<' . $code . '>', ['block', map {
                                $_->emit_compile_time()
                            } @{$self->{'special_arg'}->{'stmts'}}], ['op' => 'list:<,>', $self->emit_compile_time_args()]]
                        }
                        return ['apply' => '(', $code, $self->emit_compile_time_args()]
                    }
                    if (($code eq 'eval' || $code eq 'do') && ref($self->{'arguments'}->[0]) eq 'Perlito5::AST::Block') {
                        return ['op' => 'prefix:<' . $code . '>', $self->{'arguments'}->[0]->emit_compile_time()]
                    }
                    if ($code eq 'readline') {
                        return ['paren' => '<', $self->emit_compile_time_args()]
                    }
                    if ($self->{'bareword'} && !@{$self->{'arguments'}}) {
                        return ['bareword' => $code]
                    }
                    return ['apply' => '(', $code, $self->emit_compile_time_args()]
                }
            }
            package Perlito5::AST::If;
            {
                sub Perlito5::AST::If::emit_compile_time {
                    my $self = $_[0];
                    if ($self->{'body'} && ref($self->{'body'}) ne 'Perlito5::AST::Block') {
                        return ['stmt_modifier' => $self->{'body'}->emit_compile_time(), ['stmt' => 'if', $self->{'cond'}->emit_compile_time()]]
                    }
                    if ($self->{'otherwise'} && ref($self->{'otherwise'}) ne 'Perlito5::AST::Block') {
                        return ['stmt_modifier' => $self->{'otherwise'}->emit_compile_time(), ['stmt' => 'unless', $self->{'cond'}->emit_compile_time()]]
                    }
                    my @out = (['stmt' => ['keyword' => 'if'], ['paren' => '(', $self->{'cond'}->emit_compile_time()], Perlito5::CompileTime::emit_compile_time_block($self->{'body'}->stmts())]);
                    my $otherwise = $self->{'otherwise'};
                    while ($otherwise && @{$otherwise->{'stmts'}} == 1 && ref($otherwise->{'stmts'}->[0]) eq 'Perlito5::AST::If' && ($otherwise->{'stmts'}->[0]->{'body'} && ref($otherwise->{'stmts'}->[0]->{'body'}) eq 'Perlito5::AST::Block')) {
                        push(@out, ['stmt' => ['keyword' => 'elsif'], ['paren' => '(', $otherwise->{'stmts'}->[0]->{'cond'}->emit_compile_time()], Perlito5::CompileTime::emit_compile_time_block($otherwise->{'stmts'}->[0]->{'body'}->{'stmts'})]);
                        $otherwise = $otherwise->{'stmts'}->[0]->{'otherwise'}
                    }
                    !($otherwise && scalar(@{$otherwise->stmts()})) && return @out;
                    push(@out, ['stmt' => ['keyword' => 'else'], Perlito5::CompileTime::emit_compile_time_block($otherwise->stmts())]);
                    return @out
                }
            }
            package Perlito5::AST::When;
            {
                sub Perlito5::AST::When::emit_compile_time {
                    my $self = $_[0];
                    return ['stmt' => ['keyword' => 'when'], ['paren' => '(', $self->{'cond'}->emit_compile_time()], Perlito5::CompileTime::emit_compile_time_block($self->{'body'}->stmts())]
                }
            }
            package Perlito5::AST::While;
            {
                sub Perlito5::AST::While::emit_compile_time {
                    my $self = $_[0];
                    my @out;
                    $self->{'label'} && push(@out, ['label' => $self->{'label'}]);
                    if ($self->{'body'} && ref($self->{'body'}) ne 'Perlito5::AST::Block') {
                        return @out, ['stmt_modifier' => $self->{'body'}->emit_compile_time(), ['stmt' => ['keyword' => 'while'], $self->{'cond'}->emit_compile_time()]]
                    }
                    push(@out, ['stmt' => ['keyword' => 'while'], ['paren' => '(', $self->{'cond'}->emit_compile_time()], Perlito5::CompileTime::emit_compile_time_block($self->{'body'}->stmts())]);
                    if ($self->{'continue'} && @{$self->{'continue'}->{'stmts'}}) {
                        push(@out, ['stmt' => ['keyword' => 'continue'], Perlito5::CompileTime::emit_compile_time_block($self->{'continue'}->{'stmts'})])
                    }
                    return @out
                }
            }
            package Perlito5::AST::For;
            {
                sub Perlito5::AST::For::emit_compile_time {
                    my $self = $_[0];
                    my @out;
                    $self->{'label'} && push(@out, ['label' => $self->{'label'}]);
                    if ($self->{'body'} && ref($self->{'body'}) ne 'Perlito5::AST::Block') {
                        return @out, ['stmt_modifier' => $self->{'body'}->emit_compile_time(), ['stmt' => 'for', $self->{'cond'}->emit_compile_time()]]
                    }
                    my $cond;
                    if (ref($self->{'cond'}) eq 'ARRAY') {
                        $cond = ['paren_semicolon' => '(', ($self->{'cond'}->[0] ? $self->{'cond'}->[0]->emit_compile_time() : []), ($self->{'cond'}->[1] ? $self->{'cond'}->[1]->emit_compile_time() : []), ($self->{'cond'}->[2] ? $self->{'cond'}->[2]->emit_compile_time() : [])]
                    }
                    else {
                        $cond = ['paren' => '(', $self->{'cond'}->emit_compile_time()]
                    }
                    my @sig;
                    my $sig_ast = $self->{'topic'};
                    if (!$sig_ast) {}
                    else {
                        @sig = $sig_ast->emit_compile_time()
                    }
                    push(@out, ['stmt' => ['keyword' => 'for'], @sig, $cond, Perlito5::CompileTime::emit_compile_time_block($self->{'body'}->stmts())]);
                    if ($self->{'continue'} && @{$self->{'continue'}->{'stmts'}}) {
                        push(@out, ['stmt' => ['keyword' => 'continue'], Perlito5::CompileTime::emit_compile_time_block($self->{'continue'}->{'stmts'})])
                    }
                    return @out
                }
            }
            package Perlito5::AST::Decl;
            {
                sub Perlito5::AST::Decl::emit_compile_time {
                    my $self = $_[0];
                    return $self->{'var'}->emit_compile_time()
                }
            }
            package Perlito5::AST::Sub;
            {
                sub Perlito5::AST::Sub::emit_compile_time {
                    my $self = $_[0];
                    my @parts;
                    defined($self->{'sig'}) && push(@parts, ['paren' => '(', ['bareword' => $self->{'sig'}]]);
                    defined($self->{'block'}) && push(@parts, Perlito5::CompileTime::emit_compile_time_block($self->{'block'}->{'stmts'}));
                    !$self->{'name'} && return ['op' => 'prefix:<sub>', @parts];
                    return ['stmt' => ['keyword' => 'sub'], ['bareword' => $self->{'namespace'} . '::' . $self->{'name'}], @parts]
                }
            }
            package Perlito5::AST::Use;
            {
                sub Perlito5::AST::Use::emit_compile_time {
                    my $self = shift;
                    Perlito5::Grammar::Use::emit_time_eval($self);
                    if ($Perlito5::EMIT_USE) {
                        return ['stmt' => ['keyword' => 'use'], ['bareword' => $self->{'mod'}]]
                    }
                    else {
                        return ['comment' => '# ' . $self->{'code'} . ' ' . $self->{'mod'}]
                    }
                }
            }
            1
        }
    }
    {
        {
            package main;
            package Perlito5::CompileTime::Dumper;
            # use strict
            sub Perlito5::CompileTime::Dumper::generate_eval_string {
                my($source) = @_;
                my $m = Perlito5::Grammar::exp_stmts($source, 0);
                my $block = Perlito5::AST::Block::->new('stmts' => Perlito5::Match::flat($m));
                my @data = $block->emit_perl5();
                my $out = [];
                Perlito5::Perl5::PrettyPrinter::pretty_print(\@data, 0, $out);
                my $source_new = join('', @{$out}), ';1' . chr(10);
                return $source_new
            }
            sub Perlito5::CompileTime::Dumper::_dumper {
                my($obj, $tab, $seen, $pos) = @_;
                !defined($obj) && return 'undef';
                my $ref = ref($obj);
                !$ref && return Perlito5::Dumper::escape_string($obj);
                my $as_string = $obj;
                $seen->{$as_string} && return $seen->{$as_string};
                $seen->{$as_string} = $pos;
                my $tab1 = $tab . '    ';
                if ($ref eq 'ARRAY') {
                    @{$obj} || return '[]';
                    my @out;
                    for my $i (0 .. $#{$obj}) {
                        my $here = $pos . '->[' . $i . ']';
                        push(@out, $tab1, _dumper($obj->[$i], $tab1, $seen, $here), ',' . chr(10))
                    }
                    return join('', '[' . chr(10), @out, $tab, ']')
                }
                elsif ($ref eq 'HASH') {
                    keys(%{$obj}) || return '{}';
                    my @out;
                    for my $i (sort {
                        $a cmp $b
                    } keys(%{$obj})) {
                        my $here = $pos . '->{' . $i . '}';
                        push(@out, $tab1, chr(39) . $i . chr(39) . ' => ', _dumper($obj->{$i}, $tab1, $seen, $here), ',' . chr(10))
                    }
                    return join('', '{' . chr(10), @out, $tab, '}')
                }
                elsif ($ref eq 'SCALAR' || $ref eq 'REF') {
                    return chr(92) . _dumper(${$obj}, $tab1, $seen, $pos)
                }
                elsif ($ref eq 'CODE') {
                    my $closure_flag = bless({}, 'Perlito5::dump');
                    my $captures = $obj->($closure_flag) // {};
                    my @vars;
                    for my $var (keys(%{$captures})) {
                        push(@vars, 'my ' . $var . ' = ' . _dumper($captures->{$var}, $tab1, $seen, $pos) . '; ')
                    }
                    return join('', 'do { ', @vars, 'sub { "DUMMY" } ', '}')
                }
                my @out;
                for my $i (sort {
                    $a cmp $b
                } keys(%{$obj})) {
                    my $here = $pos . '->{' . $i . '}';
                    push(@out, $tab1, chr(39) . $i . chr(39) . ' => ', _dumper($obj->{$i}, $tab1, $seen, $here), ',' . chr(10))
                }
                return join('', 'bless({' . chr(10), @out, $tab, '}, ' . chr(39) . $ref . chr(39) . ')')
            }
            sub Perlito5::CompileTime::Dumper::_dump_global {
                my($item, $seen, $dumper_seen, $vars, $tab) = @_;
                if (ref($item) eq 'Perlito5::AST::Sub') {
                    my $n = $item->{'namespace'} . '::' . $item->{'name'};
                    if (!$seen->{$n}) {
                        push(@{$vars}, $tab . 'sub ' . $n . ' = ' . _dumper($item, '  ', $dumper_seen, $n) . ';' . chr(10));
                        $seen->{$n} = 1
                    }
                }
                elsif (ref($item) eq 'Perlito5::AST::Var') {
                    my $n = $item->{'sigil'} . $item->{'namespace'} . '::' . $item->{'name'};
                    if (!$seen->{$n}) {
                        if ($item->{'sigil'} eq '$') {
                            push(@{$vars}, $tab . $n . ' = ' . _dumper(eval($n), '  ', $dumper_seen, $n) . ';' . chr(10))
                        }
                        elsif ($item->{'sigil'} eq '@' || $item->{'sigil'} eq '%') {
                            my $ref = chr(92) . $n;
                            my $d = _dumper(eval($ref), $tab . '  ', $dumper_seen, $ref);
                            if ($d eq '[]' || $d eq '{}') {
                                push(@{$vars}, $tab . $n . ' = ();' . chr(10))
                            }
                            else {
                                push(@{$vars}, $tab . $n . ' = ' . $item->{'sigil'} . '{' . $d . '};' . chr(10))
                            }
                        }
                        elsif ($item->{'sigil'} eq '*') {
                            push(@{$vars}, $tab . '# ' . $n . chr(10));
                            for $_ ('$', '@', '%') {
                                local $item->{'sigil'} = $_;
                                _dump_global($item, $seen, $dumper_seen, $vars, $tab)
                            }
                        }
                        $seen->{$n} = 1
                    }
                }
            }
            sub Perlito5::CompileTime::Dumper::_emit_globals {
                my($scope, $seen, $dumper_seen, $vars, $tab) = @_;
                my $block = $scope->{'block'};
                for my $item (@{$block}) {
                    if (ref($item) eq 'Perlito5::AST::Var' && !$item->{'_decl'}) {
                        $item->{'_decl'} = 'global'
                    }
                    if (ref($item) eq 'Perlito5::AST::Var' && $item->{'_decl'} eq 'global') {
                        $item->{'namespace'} ||= $item->{'_namespace'};
                        ($item->{'name'} eq 0 || $item->{'name'} > 0) && next;
                        _dump_global($item, $seen, $dumper_seen, $vars, $tab)
                    }
                    if (ref($item) eq 'Perlito5::AST::Var' && $item->{'_decl'} eq 'my') {
                        my $id = $item->{'_id'};
                        if (!$seen->{$id}) {
                            push(@{$vars}, $tab . emit_compiletime_lexical($item) . '  # my ' . $item->{'sigil'} . $item->{'name'} . chr(10))
                        }
                        $seen->{$id} = 1
                    }
                    if (ref($item) eq 'HASH' && $item->{'block'}) {
                        push(@{$vars}, $tab . '{' . chr(10));
                        _emit_globals($item, $seen, $dumper_seen, $vars, $tab . '  ');
                        push(@{$vars}, $tab . '}' . chr(10))
                    }
                }
            }
            sub Perlito5::CompileTime::Dumper::emit_compiletime_lexical {
                my $item = shift;
                return $item->{'sigil'} . 'C_::' . $item->{'name'} . '_' . $item->{'_id'}
            }
            sub Perlito5::CompileTime::Dumper::emit_globals_scope {
                my $scope = shift() // $Perlito5::BASE_SCOPE;
                my @vars;
                my %seen;
                my $dumper_seen = {};
                my $tab = '';
                _emit_globals($scope, \%seen, $dumper_seen, \@vars, $tab);
                return join('', @vars)
            }
            sub Perlito5::CompileTime::Dumper::emit_globals {
                my $scope = shift() // $Perlito5::GLOBAL;
                my $vars = [];
                my $seen = {};
                my $dumper_seen = {};
                my $tab = '';
                for my $name (keys(%{$scope})) {
                    my $item = $scope->{$name};
                    if (ref($item) eq 'Perlito5::AST::Sub' && $item->{'name'}) {
                        _dump_global($item, $seen, $dumper_seen, $vars, $tab)
                    }
                    else {
                        $item->{'value'} = eval($name);
                        push(@{$vars}, $name . ' = ' . _dumper($item, '  ', $dumper_seen, $name . '->{value}') . ';' . chr(10))
                    }
                }
                return join('', @{$vars})
            }
            1
        }
    }
    {
        {
            package main;
            package Perlito5::Grammar::Regex6;
            undef();
            sub Perlito5::Grammar::Regex6::term_token {
                my $str = $_[0];
                my $pos = $_[1];
                my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
                my $tmp = ((('token' eq substr($str, $MATCH->{'to'}, 5) && ($MATCH->{'to'} = 5 + $MATCH->{'to'})) && (do {
                    my $m2 = Perlito5::Grammar::Space::ws($str, $MATCH->{'to'});
                    if ($m2) {
                        $MATCH->{'to'} = $m2->{'to'};
                        1
                    }
                    else {
                        0
                    }
                }) && (do {
                    my $m2 = Perlito5::Grammar::ident($str, $MATCH->{'to'});
                    if ($m2) {
                        $MATCH->{'to'} = $m2->{'to'};
                        $MATCH->{'Perlito5::Grammar::ident'} = $m2;
                        1
                    }
                    else {
                        0
                    }
                }) && (do {
                    my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{'to'});
                    if ($m2) {
                        $MATCH->{'to'} = $m2->{'to'};
                        1
                    }
                    else {
                        0
                    }
                }) && ('{' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                    my $m2 = Perlito5::Grammar::Regex6::rule($str, $MATCH->{'to'});
                    if ($m2) {
                        $MATCH->{'to'} = $m2->{'to'};
                        $MATCH->{'Perlito5::Grammar::Regex6::rule'} = $m2;
                        1
                    }
                    else {
                        0
                    }
                }) && ('}' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                    my $source = Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::ident'}) . '{ ' . 'my $str     = $_[0]; ' . 'my $pos     = $_[1]; ' . 'my $MATCH = { str => $str, from => $pos, to => $pos }; ' . 'my $tmp = ( ' . Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::Regex6::rule'})->emit_perl5() . '); ' . '$tmp ? $MATCH : 0; ' . '}';
                    my $ast = Perlito5::Grammar::Block::named_sub_def($source, 0);
                    $MATCH->{'capture'} = ['term', Perlito5::Match::flat($ast)];
                    1
                })));
                $tmp ? $MATCH : 0
            }
            Perlito5::Grammar::Precedence::add_term('token', \&term_token);
            sub Perlito5::Grammar::Regex6::any {
                my $str = $_[0];
                my $pos = $_[1];
                my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
                my $tmp = (('' ne substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})));
                $tmp ? $MATCH : 0
            }
            sub Perlito5::Grammar::Regex6::literal {
                my $str = $_[0];
                my $pos = $_[1];
                my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
                my $tmp = ((do {
                    my $last_match_null = 0;
                    my $m = $MATCH;
                    my $to = $MATCH->{'to'};
                    while ((do {
                        my $pos1 = $MATCH->{'to'};
                        (do {
                            ((chr(92) eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && ('' ne substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})))
                        }) || (do {
                            $MATCH->{'to'} = $pos1;
                            ((do {
                                my $tmp = $MATCH;
                                $MATCH = {'from' => $tmp->{'to'}, 'to' => $tmp->{'to'}};
                                my $res = (chr(39) eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}));
                                $MATCH = $tmp;
                                $res ? 0 : 1
                            }) && ('' ne substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})))
                        })
                    }) && ($last_match_null < 2)) {
                        if ($to == $MATCH->{'to'}) {
                            $last_match_null = $last_match_null + 1
                        }
                        else {
                            $last_match_null = 0
                        }
                        $m = $MATCH;
                        $to = $MATCH->{'to'}
                    }
                    $MATCH = $m;
                    $MATCH->{'to'} = $to;
                    1
                }));
                $tmp ? $MATCH : 0
            }
            sub Perlito5::Grammar::Regex6::metasyntax_exp {
                my $str = $_[0];
                my $pos = $_[1];
                my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
                my $tmp = ((do {
                    my $last_match_null = 0;
                    my $m = $MATCH;
                    my $to = $MATCH->{'to'};
                    my $count = 0;
                    while (((do {
                        my $tmp = $MATCH;
                        $MATCH = {'from' => $tmp->{'to'}, 'to' => $tmp->{'to'}};
                        my $res = ('>' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}));
                        $MATCH = $tmp;
                        $res ? 0 : 1
                    }) && ('' ne substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}))) && ($last_match_null < 2)) {
                        if ($to == $MATCH->{'to'}) {
                            $last_match_null = $last_match_null + 1
                        }
                        else {
                            $last_match_null = 0
                        }
                        $m = $MATCH;
                        $to = $MATCH->{'to'};
                        $count = $count + 1
                    }
                    $MATCH = $m;
                    $MATCH->{'to'} = $to;
                    $count > 0
                }));
                $tmp ? $MATCH : 0
            }
            sub Perlito5::Grammar::Regex6::string_code {
                my $str = $_[0];
                my $pos = $_[1];
                my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
                my $tmp = ((do {
                    my $last_match_null = 0;
                    my $m = $MATCH;
                    my $to = $MATCH->{'to'};
                    my $count = 0;
                    while ((do {
                        my $pos1 = $MATCH->{'to'};
                        (do {
                            ((chr(92) eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && ('' ne substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})))
                        }) || (do {
                            $MATCH->{'to'} = $pos1;
                            ((chr(39) eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                                my $m2 = literal($str, $MATCH->{'to'});
                                if ($m2) {
                                    $MATCH->{'to'} = $m2->{'to'};
                                    1
                                }
                                else {
                                    0
                                }
                            }) && (chr(39) eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})))
                        }) || (do {
                            $MATCH->{'to'} = $pos1;
                            (('{' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                                my $m2 = string_code($str, $MATCH->{'to'});
                                if ($m2) {
                                    $MATCH->{'to'} = $m2->{'to'};
                                    1
                                }
                                else {
                                    0
                                }
                            }) && ('}' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})))
                        }) || (do {
                            $MATCH->{'to'} = $pos1;
                            ((do {
                                my $tmp = $MATCH;
                                $MATCH = {'from' => $tmp->{'to'}, 'to' => $tmp->{'to'}};
                                my $res = ('}' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}));
                                $MATCH = $tmp;
                                $res ? 0 : 1
                            }) && ('' ne substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})))
                        })
                    }) && ($last_match_null < 2)) {
                        if ($to == $MATCH->{'to'}) {
                            $last_match_null = $last_match_null + 1
                        }
                        else {
                            $last_match_null = 0
                        }
                        $m = $MATCH;
                        $to = $MATCH->{'to'};
                        $count = $count + 1
                    }
                    $MATCH = $m;
                    $MATCH->{'to'} = $to;
                    $count > 0
                }));
                $tmp ? $MATCH : 0
            }
            sub Perlito5::Grammar::Regex6::parsed_code {
                my $str = $_[0];
                my $pos = $_[1];
                my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
                my $tmp = (((do {
                    my $m2 = string_code($str, $MATCH->{'to'});
                    if ($m2) {
                        $MATCH->{'to'} = $m2->{'to'};
                        1
                    }
                    else {
                        0
                    }
                }) && (do {
                    $MATCH->{'capture'} = Perlito5::Match::flat($MATCH);
                    1
                })));
                $tmp ? $MATCH : 0
            }
            sub Perlito5::Grammar::Regex6::rule_term {
                my $str = $_[0];
                my $pos = $_[1];
                my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
                my $tmp = ((do {
                    my $pos1 = $MATCH->{'to'};
                    (do {
                        (('<before' eq substr($str, $MATCH->{'to'}, 7) && ($MATCH->{'to'} = 7 + $MATCH->{'to'})) && (do {
                            my $m2 = Perlito5::Grammar::Space::ws($str, $MATCH->{'to'});
                            if ($m2) {
                                $MATCH->{'to'} = $m2->{'to'};
                                1
                            }
                            else {
                                0
                            }
                        }) && (do {
                            my $m2 = rule($str, $MATCH->{'to'});
                            if ($m2) {
                                $MATCH->{'to'} = $m2->{'to'};
                                $MATCH->{'rule'} = $m2;
                                1
                            }
                            else {
                                0
                            }
                        }) && ('>' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                            $MATCH->{'capture'} = Perlito5::Rul::Before::->new('rule_exp' => Perlito5::Match::flat($MATCH->{'rule'}));
                            1
                        }))
                    }) || (do {
                        $MATCH->{'to'} = $pos1;
                        (('<!before' eq substr($str, $MATCH->{'to'}, 8) && ($MATCH->{'to'} = 8 + $MATCH->{'to'})) && (do {
                            my $m2 = Perlito5::Grammar::Space::ws($str, $MATCH->{'to'});
                            if ($m2) {
                                $MATCH->{'to'} = $m2->{'to'};
                                1
                            }
                            else {
                                0
                            }
                        }) && (do {
                            my $m2 = rule($str, $MATCH->{'to'});
                            if ($m2) {
                                $MATCH->{'to'} = $m2->{'to'};
                                $MATCH->{'rule'} = $m2;
                                1
                            }
                            else {
                                0
                            }
                        }) && ('>' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                            $MATCH->{'capture'} = Perlito5::Rul::NotBefore::->new('rule_exp' => Perlito5::Match::flat($MATCH->{'rule'}));
                            1
                        }))
                    }) || (do {
                        $MATCH->{'to'} = $pos1;
                        ((chr(39) eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                            my $m2 = literal($str, $MATCH->{'to'});
                            if ($m2) {
                                $MATCH->{'to'} = $m2->{'to'};
                                $MATCH->{'literal'} = $m2;
                                1
                            }
                            else {
                                0
                            }
                        }) && (chr(39) eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                            $MATCH->{'capture'} = Perlito5::Rul::Constant::->new('constant' => Perlito5::Match::flat($MATCH->{'literal'}));
                            1
                        }))
                    }) || (do {
                        $MATCH->{'to'} = $pos1;
                        (('<' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                            my $pos1 = $MATCH->{'to'};
                            (do {
                                (('.' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                                    my $m2 = metasyntax_exp($str, $MATCH->{'to'});
                                    if ($m2) {
                                        $MATCH->{'to'} = $m2->{'to'};
                                        $MATCH->{'metasyntax_exp'} = $m2;
                                        1
                                    }
                                    else {
                                        0
                                    }
                                }) && ('>' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                                    $MATCH->{'capture'} = Perlito5::Rul::Subrule::->new('metasyntax' => Perlito5::Match::flat($MATCH->{'metasyntax_exp'}), 'captures' => 0);
                                    1
                                }))
                            }) || (do {
                                $MATCH->{'to'} = $pos1;
                                ((do {
                                    my $m2 = metasyntax_exp($str, $MATCH->{'to'});
                                    if ($m2) {
                                        $MATCH->{'to'} = $m2->{'to'};
                                        $MATCH->{'metasyntax_exp'} = $m2;
                                        1
                                    }
                                    else {
                                        0
                                    }
                                }) && ('>' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                                    $MATCH->{'capture'} = Perlito5::Rul::Subrule::->new('metasyntax' => Perlito5::Match::flat($MATCH->{'metasyntax_exp'}), 'captures' => 1);
                                    1
                                }))
                            })
                        }))
                    }) || (do {
                        $MATCH->{'to'} = $pos1;
                        (('{' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                            my $m2 = parsed_code($str, $MATCH->{'to'});
                            if ($m2) {
                                $MATCH->{'to'} = $m2->{'to'};
                                $MATCH->{'parsed_code'} = $m2;
                                1
                            }
                            else {
                                0
                            }
                        }) && ('}' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                            $MATCH->{'capture'} = Perlito5::Rul::Block::->new('closure' => Perlito5::Match::flat($MATCH->{'parsed_code'}));
                            1
                        }))
                    }) || (do {
                        $MATCH->{'to'} = $pos1;
                        ((chr(92) eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                            my $pos1 = $MATCH->{'to'};
                            (do {
                                (('c' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                                    my $m2 = Perlito5::Grammar::Number::digits($str, $MATCH->{'to'});
                                    if ($m2) {
                                        $MATCH->{'to'} = $m2->{'to'};
                                        $MATCH->{'Perlito5::Grammar::Number::digits'} = $m2;
                                        1
                                    }
                                    else {
                                        0
                                    }
                                }) && (do {
                                    $MATCH->{'capture'} = Perlito5::Rul::Constant::->new('constant' => chr(Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::Number::digits'})));
                                    1
                                }))
                            }) || (do {
                                $MATCH->{'to'} = $pos1;
                                ((do {
                                    my $m2 = any($str, $MATCH->{'to'});
                                    if ($m2) {
                                        $MATCH->{'to'} = $m2->{'to'};
                                        $MATCH->{'any'} = $m2;
                                        1
                                    }
                                    else {
                                        0
                                    }
                                }) && (do {
                                    $MATCH->{'capture'} = Perlito5::Rul::SpecialChar::->new('char' => Perlito5::Match::flat($MATCH->{'any'}));
                                    1
                                }))
                            })
                        }))
                    }) || (do {
                        $MATCH->{'to'} = $pos1;
                        (('.' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                            $MATCH->{'capture'} = Perlito5::Rul::Dot::->new();
                            1
                        }))
                    }) || (do {
                        $MATCH->{'to'} = $pos1;
                        (('[' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                            my $m2 = rule($str, $MATCH->{'to'});
                            if ($m2) {
                                $MATCH->{'to'} = $m2->{'to'};
                                $MATCH->{'rule'} = $m2;
                                1
                            }
                            else {
                                0
                            }
                        }) && (']' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                            $MATCH->{'capture'} = Perlito5::Match::flat($MATCH->{'rule'});
                            1
                        }))
                    })
                }));
                $tmp ? $MATCH : 0
            }
            sub Perlito5::Grammar::Regex6::quant_exp {
                my $str = $_[0];
                my $pos = $_[1];
                my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
                my $tmp = ((do {
                    my $pos1 = $MATCH->{'to'};
                    (do {
                        ('?' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}))
                    }) || (do {
                        $MATCH->{'to'} = $pos1;
                        ('*' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}))
                    }) || (do {
                        $MATCH->{'to'} = $pos1;
                        ('+' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}))
                    })
                }));
                $tmp ? $MATCH : 0
            }
            sub Perlito5::Grammar::Regex6::quantifier {
                my $str = $_[0];
                my $pos = $_[1];
                my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
                my $tmp = (((do {
                    my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{'to'});
                    if ($m2) {
                        $MATCH->{'to'} = $m2->{'to'};
                        $MATCH->{'Perlito5::Grammar::Space::opt_ws'} = $m2;
                        1
                    }
                    else {
                        0
                    }
                }) && (do {
                    my $m2 = rule_term($str, $MATCH->{'to'});
                    if ($m2) {
                        $MATCH->{'to'} = $m2->{'to'};
                        $MATCH->{'rule_term'} = $m2;
                        1
                    }
                    else {
                        0
                    }
                }) && (do {
                    my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{'to'});
                    if ($m2) {
                        $MATCH->{'to'} = $m2->{'to'};
                        $MATCH->{'Perlito5::Grammar::Space::opt_ws'} = $m2;
                        1
                    }
                    else {
                        0
                    }
                }) && (do {
                    my $pos1 = $MATCH->{'to'};
                    (do {
                        ((do {
                            my $m2 = quant_exp($str, $MATCH->{'to'});
                            if ($m2) {
                                $MATCH->{'to'} = $m2->{'to'};
                                $MATCH->{'quant_exp'} = $m2;
                                1
                            }
                            else {
                                0
                            }
                        }) && (do {
                            my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{'to'});
                            if ($m2) {
                                $MATCH->{'to'} = $m2->{'to'};
                                $MATCH->{'Perlito5::Grammar::Space::opt_ws'} = $m2;
                                1
                            }
                            else {
                                0
                            }
                        }) && (do {
                            $MATCH->{'capture'} = Perlito5::Rul::Quantifier::->new('term' => Perlito5::Match::flat($MATCH->{'rule_term'}), 'quant' => Perlito5::Match::flat($MATCH->{'quant_exp'}));
                            1
                        }))
                    }) || (do {
                        $MATCH->{'to'} = $pos1;
                        (do {
                            $MATCH->{'capture'} = Perlito5::Match::flat($MATCH->{'rule_term'});
                            1
                        })
                    })
                })));
                $tmp ? $MATCH : 0
            }
            sub Perlito5::Grammar::Regex6::concat_list {
                my $str = $_[0];
                my $pos = $_[1];
                my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
                my $tmp = ((do {
                    my $pos1 = $MATCH->{'to'};
                    (do {
                        ((do {
                            my $m2 = quantifier($str, $MATCH->{'to'});
                            if ($m2) {
                                $MATCH->{'to'} = $m2->{'to'};
                                $MATCH->{'quantifier'} = $m2;
                                1
                            }
                            else {
                                0
                            }
                        }) && (do {
                            my $pos1 = $MATCH->{'to'};
                            (do {
                                ((do {
                                    my $m2 = concat_list($str, $MATCH->{'to'});
                                    if ($m2) {
                                        $MATCH->{'to'} = $m2->{'to'};
                                        $MATCH->{'concat_list'} = $m2;
                                        1
                                    }
                                    else {
                                        0
                                    }
                                }) && (do {
                                    $MATCH->{'capture'} = [Perlito5::Match::flat($MATCH->{'quantifier'}), @{Perlito5::Match::flat($MATCH->{'concat_list'})}];
                                    1
                                }))
                            }) || (do {
                                $MATCH->{'to'} = $pos1;
                                (do {
                                    $MATCH->{'capture'} = [Perlito5::Match::flat($MATCH->{'quantifier'})];
                                    1
                                })
                            })
                        }))
                    }) || (do {
                        $MATCH->{'to'} = $pos1;
                        (do {
                            $MATCH->{'capture'} = [];
                            1
                        })
                    })
                }));
                $tmp ? $MATCH : 0
            }
            sub Perlito5::Grammar::Regex6::concat_exp {
                my $str = $_[0];
                my $pos = $_[1];
                my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
                my $tmp = (((do {
                    my $m2 = concat_list($str, $MATCH->{'to'});
                    if ($m2) {
                        $MATCH->{'to'} = $m2->{'to'};
                        $MATCH->{'concat_list'} = $m2;
                        1
                    }
                    else {
                        0
                    }
                }) && (do {
                    $MATCH->{'capture'} = Perlito5::Rul::Concat::->new('concat' => Perlito5::Match::flat($MATCH->{'concat_list'}));
                    1
                })));
                $tmp ? $MATCH : 0
            }
            sub Perlito5::Grammar::Regex6::or_list_exp {
                my $str = $_[0];
                my $pos = $_[1];
                my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
                my $tmp = ((do {
                    my $pos1 = $MATCH->{'to'};
                    (do {
                        ((do {
                            my $m2 = concat_exp($str, $MATCH->{'to'});
                            if ($m2) {
                                $MATCH->{'to'} = $m2->{'to'};
                                $MATCH->{'concat_exp'} = $m2;
                                1
                            }
                            else {
                                0
                            }
                        }) && (do {
                            my $pos1 = $MATCH->{'to'};
                            (do {
                                (('|' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                                    my $m2 = or_list_exp($str, $MATCH->{'to'});
                                    if ($m2) {
                                        $MATCH->{'to'} = $m2->{'to'};
                                        $MATCH->{'or_list_exp'} = $m2;
                                        1
                                    }
                                    else {
                                        0
                                    }
                                }) && (do {
                                    $MATCH->{'capture'} = [Perlito5::Match::flat($MATCH->{'concat_exp'}), @{Perlito5::Match::flat($MATCH->{'or_list_exp'})}];
                                    1
                                }))
                            }) || (do {
                                $MATCH->{'to'} = $pos1;
                                (do {
                                    $MATCH->{'capture'} = [Perlito5::Match::flat($MATCH->{'concat_exp'})];
                                    1
                                })
                            })
                        }))
                    }) || (do {
                        $MATCH->{'to'} = $pos1;
                        (do {
                            $MATCH->{'capture'} = [];
                            1
                        })
                    })
                }));
                $tmp ? $MATCH : 0
            }
            sub Perlito5::Grammar::Regex6::rule {
                my $str = $_[0];
                my $pos = $_[1];
                my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
                my $tmp = (((do {
                    my $pos1 = $MATCH->{'to'};
                    (do {
                        ((do {
                            my $m = $MATCH;
                            if (!(do {
                                my $m2 = Perlito5::Grammar::Space::ws($str, $MATCH->{'to'});
                                if ($m2) {
                                    $MATCH->{'to'} = $m2->{'to'};
                                    1
                                }
                                else {
                                    0
                                }
                            })) {
                                $MATCH = $m
                            }
                            1
                        }) && ('|' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})))
                    }) || (do {
                        $MATCH->{'to'} = $pos1;
                        1
                    })
                }) && (do {
                    my $m2 = or_list_exp($str, $MATCH->{'to'});
                    if ($m2) {
                        $MATCH->{'to'} = $m2->{'to'};
                        $MATCH->{'or_list_exp'} = $m2;
                        1
                    }
                    else {
                        0
                    }
                }) && (do {
                    $MATCH->{'capture'} = Perlito5::Rul::Or::->new('or_list' => Perlito5::Match::flat($MATCH->{'or_list_exp'}));
                    1
                })));
                $tmp ? $MATCH : 0
            }
        }
    }
    {
        {
            package main;
            undef();
            package Perlito5::Rul;
            sub Perlito5::Rul::new {
                my $class = shift;
                bless({@_}, $class)
            }
            sub Perlito5::Rul::constant {
                my $str = shift;
                my $len = length($str);
                if ($str eq chr(92)) {
                    $str = chr(92) . chr(92)
                }
                if ($str eq chr(39)) {
                    $str = chr(92) . chr(39)
                }
                if ($len) {
                    '( ' . chr(39) . $str . chr(39) . ' eq substr( $str, $MATCH->{to}, ' . $len . ') ' . '&& ( $MATCH->{to} = ' . $len . ' + $MATCH->{to} )' . ')'
                }
                else {
                    return 1
                }
            }
            package Perlito5::Rul::Quantifier;
            sub Perlito5::Rul::Quantifier::new {
                my $class = shift;
                bless({@_}, $class)
            }
            sub Perlito5::Rul::Quantifier::term {
                $_[0]->{'term'}
            }
            sub Perlito5::Rul::Quantifier::quant {
                $_[0]->{'quant'}
            }
            sub Perlito5::Rul::Quantifier::emit_perl5 {
                my $self = $_[0];
                if ($self->{'quant'} eq '') {
                    return $self->{'term'}->emit_perl5()
                }
                if ($self->{'quant'} eq '+') {
                    $self->{'term'}->set_captures_to_array();
                    return '(do { ' . 'my $last_match_null = 0; ' . 'my $m = $MATCH; ' . 'my $to = $MATCH->{to}; ' . 'my $count = 0; ' . 'while (' . $self->{'term'}->emit_perl5() . ' && ($last_match_null < 2)) ' . '{ ' . 'if ($to == $MATCH->{to}) { ' . '$last_match_null = $last_match_null + 1; ' . '} ' . 'else { ' . '$last_match_null = 0; ' . '}; ' . '$m = $MATCH; ' . '$to = $MATCH->{to}; ' . '$count = $count + 1; ' . '}; ' . '$MATCH = $m; ' . '$MATCH->{to} = $to; ' . '$count > 0; ' . '})'
                }
                if ($self->{'quant'} eq '*') {
                    $self->{'term'}->set_captures_to_array();
                    return '(do { ' . 'my $last_match_null = 0; ' . 'my $m = $MATCH; ' . 'my $to = $MATCH->{to}; ' . 'while (' . $self->{'term'}->emit_perl5() . ' && ($last_match_null < 2)) ' . '{ ' . 'if ($to == $MATCH->{to}) { ' . '$last_match_null = $last_match_null + 1; ' . '} ' . 'else { ' . '$last_match_null = 0; ' . '}; ' . '$m = $MATCH; ' . '$to = $MATCH->{to}; ' . '}; ' . '$MATCH = $m; ' . '$MATCH->{to} = $to; ' . '1 ' . '})'
                }
                if ($self->{'quant'} eq '?') {
                    $self->{'term'}->set_captures_to_array();
                    return '(do { ' . 'my $m = $MATCH; ' . 'if (!' . $self->{'term'}->emit_perl5() . ') ' . '{ ' . '$MATCH = $m; ' . '}; ' . '1 ' . '})'
                }
                die('Perlito5::Rul::Quantifier:  not implemented')
            }
            sub Perlito5::Rul::Quantifier::set_captures_to_array {
                my $self = $_[0];
                $self->{'term'}->set_captures_to_array()
            }
            package Perlito5::Rul::Or;
            sub Perlito5::Rul::Or::new {
                my $class = shift;
                bless({@_}, $class)
            }
            sub Perlito5::Rul::Or::or_list {
                $_[0]->{'or_list'}
            }
            sub Perlito5::Rul::Or::emit_perl5 {
                my $self = $_[0];
                if (scalar(@{$self->{'or_list'}}) == 1) {
                    return $self->{'or_list'}->[0]->emit_perl5()
                }
                '(do { ' . 'my $pos1 = $MATCH->{to}; (do { ' . join('}) || (do { $MATCH->{to} = $pos1; ', map($_->emit_perl5(), @{$self->{'or_list'}})) . '}) })'
            }
            sub Perlito5::Rul::Or::set_captures_to_array {
                my $self = $_[0];
                map($_->set_captures_to_array(), @{$self->{'or_list'}})
            }
            package Perlito5::Rul::Concat;
            sub Perlito5::Rul::Concat::new {
                my $class = shift;
                bless({@_}, $class)
            }
            sub Perlito5::Rul::Concat::concat {
                $_[0]->{'concat'}
            }
            sub Perlito5::Rul::Concat::emit_perl5 {
                my $self = $_[0];
                if (scalar(@{$self->{'concat'}}) == 1) {
                    return $self->{'concat'}->[0]->emit_perl5()
                }
                '(' . join(' && ', map($_->emit_perl5(), @{$self->{'concat'}})) . ')'
            }
            sub Perlito5::Rul::Concat::set_captures_to_array {
                my $self = $_[0];
                map($_->set_captures_to_array(), @{$self->{'concat'}})
            }
            package Perlito5::Rul::Subrule;
            sub Perlito5::Rul::Subrule::new {
                my $class = shift;
                bless({@_}, $class)
            }
            sub Perlito5::Rul::Subrule::metasyntax {
                $_[0]->{'metasyntax'}
            }
            sub Perlito5::Rul::Subrule::captures {
                $_[0]->{'captures'}
            }
            sub Perlito5::Rul::Subrule::emit_perl5 {
                my $self = $_[0];
                my $meth = $self->{'metasyntax'};
                my $code;
                if ($self->{'captures'} == 1) {
                    $code = 'if ($m2) { $MATCH->{to} = $m2->{to}; $MATCH->{' . chr(39) . $self->{'metasyntax'} . chr(39) . '} = $m2; 1 } else { 0 }; '
                }
                elsif ($self->{'captures'} > 1) {
                    $code = 'if ($m2) { ' . '$MATCH->{to} = $m2->{to}; ' . 'if (exists $MATCH->{' . chr(39) . $self->{'metasyntax'} . chr(39) . '}) { ' . 'push @{ $MATCH->{' . chr(39) . $self->{'metasyntax'} . chr(39) . '} }, $m2; ' . '} ' . 'else { ' . '$MATCH->{' . chr(39) . $self->{'metasyntax'} . chr(39) . '} = [ $m2 ]; ' . '}; ' . '1 ' . '} else { 0 }; '
                }
                else {
                    $code = 'if ($m2) { $MATCH->{to} = $m2->{to}; 1 } else { 0 }; '
                }
                '(do { ' . 'my $m2 = ' . $meth . '($str, $MATCH->{to}); ' . $code . '})'
            }
            sub Perlito5::Rul::Subrule::set_captures_to_array {
                my $self = $_[0];
                if ($self->{'captures'} > 0) {
                    $self->{'captures'} = $self->{'captures'} + 1
                }
            }
            package Perlito5::Rul::Constant;
            sub Perlito5::Rul::Constant::new {
                my $class = shift;
                bless({@_}, $class)
            }
            sub Perlito5::Rul::Constant::constant {
                $_[0]->{'constant'}
            }
            sub Perlito5::Rul::Constant::emit_perl5 {
                my $self = $_[0];
                my $str = $self->{'constant'};
                Perlito5::Rul::constant($str)
            }
            sub Perlito5::Rul::Constant::set_captures_to_array {
                my $self = $_[0]
            }
            package Perlito5::Rul::Dot;
            sub Perlito5::Rul::Dot::new {
                my $class = shift;
                bless({@_}, $class)
            }
            sub Perlito5::Rul::Dot::emit_perl5 {
                my $self = $_[0];
                '( ' . chr(39) . chr(39) . ' ne substr( $str, $MATCH->{to}, 1 ) ' . '&& ($MATCH->{to} = 1 + $MATCH->{to})' . ')'
            }
            sub Perlito5::Rul::Dot::set_captures_to_array {
                my $self = $_[0]
            }
            package Perlito5::Rul::SpecialChar;
            sub Perlito5::Rul::SpecialChar::new {
                my $class = shift;
                bless({@_}, $class)
            }
            sub Perlito5::Rul::SpecialChar::char {
                $_[0]->{'char'}
            }
            sub Perlito5::Rul::SpecialChar::emit_perl5 {
                my $self = $_[0];
                my $char = $self->{'char'};
                if ($char eq 'n') {
                    return Perlito5::Rul::Subrule::->new('metasyntax' => 'is_newline', 'captures' => 0)->emit_perl5()
                }
                if ($char eq 'N') {
                    return Perlito5::Rul::Subrule::->new('metasyntax' => 'not_newline', 'captures' => 0)->emit_perl5()
                }
                if ($char eq 'd') {
                    return Perlito5::Rul::Subrule::->new('metasyntax' => 'digit', 'captures' => 0)->emit_perl5()
                }
                if ($char eq 's') {
                    return Perlito5::Rul::Subrule::->new('metasyntax' => 'space', 'captures' => 0)->emit_perl5()
                }
                if ($char eq 't') {
                    return Perlito5::Rul::constant(chr(9))
                }
                return Perlito5::Rul::constant($char)
            }
            sub Perlito5::Rul::SpecialChar::set_captures_to_array {
                my $self = $_[0]
            }
            package Perlito5::Rul::Block;
            sub Perlito5::Rul::Block::new {
                my $class = shift;
                bless({@_}, $class)
            }
            sub Perlito5::Rul::Block::closure {
                $_[0]->{'closure'}
            }
            sub Perlito5::Rul::Block::emit_perl5 {
                my $self = $_[0];
                '(do { ' . $self->{'closure'} . '; 1 })'
            }
            sub Perlito5::Rul::Block::set_captures_to_array {
                my $self = $_[0]
            }
            package Perlito5::Rul::Before;
            sub Perlito5::Rul::Before::new {
                my $class = shift;
                bless({@_}, $class)
            }
            sub Perlito5::Rul::Before::rule_exp {
                $_[0]->{'rule_exp'}
            }
            sub Perlito5::Rul::Before::emit_perl5 {
                my $self = $_[0];
                '(do { ' . 'my $tmp = $MATCH; ' . '$MATCH = { ' . chr(39) . 'from' . chr(39) . ' => $tmp->{to}, ' . chr(39) . 'to' . chr(39) . ' => $tmp->{to} }; ' . 'my $res = ' . $self->{'rule_exp'}->emit_perl5() . '; ' . '$MATCH = $tmp; ' . '$res ? 1 : 0 ' . '})'
            }
            sub Perlito5::Rul::Before::set_captures_to_array {
                my $self = $_[0]
            }
            package Perlito5::Rul::NotBefore;
            sub Perlito5::Rul::NotBefore::new {
                my $class = shift;
                bless({@_}, $class)
            }
            sub Perlito5::Rul::NotBefore::rule_exp {
                $_[0]->{'rule_exp'}
            }
            sub Perlito5::Rul::NotBefore::emit_perl5 {
                my $self = $_[0];
                '(do { ' . 'my $tmp = $MATCH; ' . '$MATCH = { ' . chr(39) . 'from' . chr(39) . ' => $tmp->{to}, ' . chr(39) . 'to' . chr(39) . ' => $tmp->{to} }; ' . 'my $res = ' . $self->{'rule_exp'}->emit_perl5() . '; ' . '$MATCH = $tmp; ' . '$res ? 0 : 1 ' . '})'
            }
            sub Perlito5::Rul::NotBefore::set_captures_to_array {
                my $self = $_[0]
            }
            1
        }
    }
    {
        {
            package main;
            package Perlito5::Dumper;
            sub Perlito5::Dumper::ast_dumper {
                my $seen = {};
                my $level = '';
                my $pos = '[TODO - recursive structure in AST is not supported]';
                return _dumper($_[0], $level, $seen, $pos)
            }
            sub Perlito5::Dumper::_dumper {
                my($obj, $tab, $seen, $pos) = @_;
                !defined($obj) && return 'undef';
                my $ref = ref($obj);
                !$ref && return escape_string($obj);
                my $as_string = $obj;
                $seen->{$as_string} && return $seen->{$as_string};
                $seen->{$as_string} = $pos;
                my $tab1 = $tab . '    ';
                if ($ref eq 'ARRAY') {
                    @{$obj} || return '[]';
                    my @out;
                    for my $i (0 .. $#{$obj}) {
                        my $here = $pos . '->[' . $i . ']';
                        push(@out, $tab1, _dumper($obj->[$i], $tab1, $seen, $here), ',' . chr(10))
                    }
                    return join('', '[' . chr(10), @out, $tab, ']')
                }
                elsif ($ref eq 'HASH') {
                    keys(%{$obj}) || return '{}';
                    my @out;
                    for my $i (sort {
                        $a cmp $b
                    } keys(%{$obj})) {
                        my $here = $pos . '->{' . $i . '}';
                        push(@out, $tab1, chr(39) . $i . chr(39) . ' => ', _dumper($obj->{$i}, $tab1, $seen, $here), ',' . chr(10))
                    }
                    return join('', '{' . chr(10), @out, $tab, '}')
                }
                elsif ($ref eq 'SCALAR' || $ref eq 'REF') {
                    return chr(92) . _dumper(${$obj}, $tab1, $seen, $pos)
                }
                elsif ($ref eq 'CODE') {
                    return 'sub { "DUMMY" }'
                }
                my @out;
                for my $i (sort {
                    $a cmp $b
                } keys(%{$obj})) {
                    my $here = $pos . '->{' . $i . '}';
                    push(@out, $tab1, chr(39) . $i . chr(39) . ' => ', _dumper($obj->{$i}, $tab1, $seen, $here), ',' . chr(10))
                }
                return join('', 'bless({' . chr(10), @out, $tab, '}, ' . chr(39) . $ref . chr(39) . ')')
            }
            my %safe_char = (' ' => 1, '!' => 1, '"' => 1, '#' => 1, '$' => 1, '%' => 1, '&' => 1, '(' => 1, ')' => 1, '*' => 1, '+' => 1, ',' => 1, '-' => 1, '.' => 1, '/' => 1, ':' => 1, ';' => 1, '<' => 1, '=' => 1, '>' => 1, '?' => 1, '@' => 1, '[' => 1, ']' => 1, '^' => 1, '_' => 1, '`' => 1, '{' => 1, '|' => 1, '}' => 1, '~' => 1);
            sub Perlito5::Dumper::escape_string {
                my $s = shift;
                my @out;
                my $tmp = '';
                $s eq '' && return chr(39) . chr(39);
                (0 + $s) eq $s && $s =~ m![0-9]! && return 0 + $s;
                for my $i (0 .. length($s) - 1) {
                    my $c = substr($s, $i, 1);
                    if (($c ge 'a' && $c le 'z') || ($c ge 'A' && $c le 'Z') || ($c ge 0 && $c le 9) || exists($safe_char{$c})) {
                        $tmp = $tmp . $c
                    }
                    else {
                        $tmp ne '' && push(@out, chr(39) . $tmp . chr(39));
                        push(@out, 'chr(' . ord($c) . ')');
                        $tmp = ''
                    }
                }
                $tmp ne '' && push(@out, chr(39) . $tmp . chr(39));
                return join(' . ', @out)
            }
            sub Perlito5::Dumper::_identity {
                $_[0] eq $_[1]
            }
            1
        }
    }
    {
        {
            package main;
            package Perlito5::JSON;
            sub Perlito5::JSON::ast_dumper {
                my $seen = {};
                my $level = '';
                my $pos = '[TODO - recursive structure in AST is not supported]';
                return _dumper($_[0], $level, $seen, $pos)
            }
            sub Perlito5::JSON::_dumper {
                my($obj, $tab, $seen, $pos) = @_;
                !defined($obj) && return 'null';
                my $ref = ref($obj);
                !$ref && return escape_string($obj);
                my $as_string = $obj;
                $seen->{$as_string} && return $seen->{$as_string};
                $seen->{$as_string} = $pos;
                my $tab1 = $tab . '  ';
                if ($ref eq 'ARRAY') {
                    @{$obj} || return '[]';
                    my @out;
                    for my $i (0 .. $#{$obj}) {
                        my $here = $pos . '[' . $i . ']';
                        push(@out, $tab1 . _dumper($obj->[$i], $tab1, $seen, $here))
                    }
                    return '[' . chr(10) . join(',' . chr(10), @out) . chr(10) . $tab . ']'
                }
                elsif ($ref eq 'SCALAR') {
                    return '{ "_type": "SCALAR", "value": ' . _dumper(${$obj}, $tab1, $seen, $pos) . ' }'
                }
                elsif ($ref eq 'CODE') {
                    return '{ "_type": "CODE", "value": "DUMMY" }'
                }
                $ref =~ s!^Perlito5::AST::!!;
                my @out;
                $ref ne 'HASH' && push(@out, '"_type": "' . $ref . '"');
                for my $i (sort {
                    $a cmp $b
                } keys(%{$obj})) {
                    my $here = $pos . '{' . $i . '}';
                    push(@out, $tab1 . '"' . $i . '": ' . _dumper($obj->{$i}, $tab1, $seen, $here))
                }
                return '{ ' . join(',' . chr(10), @out) . chr(10) . $tab . '}'
            }
            sub Perlito5::JSON::escape_string {
                my $s = shift;
                my @out;
                $s eq '' && return '""';
                (0 + $s) eq $s && $s =~ m![0-9]! && return 0 + $s;
                for my $i (0 .. length($s) - 1) {
                    my $c = substr($s, $i, 1);
                    if ($c eq chr(92) || $c eq '"') {
                        push(@out, chr(92) . $c)
                    }
                    elsif ($c eq chr(10)) {
                        push(@out, chr(92) . 'n')
                    }
                    elsif ($c eq chr(13)) {
                        push(@out, chr(92) . 'r')
                    }
                    elsif ($c eq chr(9)) {
                        push(@out, chr(92) . 't')
                    }
                    elsif ($c eq chr(8)) {
                        push(@out, chr(92) . 'b')
                    }
                    elsif ($c eq chr(12)) {
                        push(@out, chr(92) . 'f')
                    }
                    elsif ($c le chr(31)) {
                        push(@out, sprintf(chr(92) . 'u%04x', ord($c)))
                    }
                    else {
                        push(@out, $c)
                    }
                }
                return join('', '"', @out, '"')
            }
            1
        }
    }
    {
        {
            package main;
            undef();
            undef();
            undef();
            # use strict
            package Perlito5::Javascript2;
            {
                my %label;
                sub Perlito5::Javascript2::pkg {
                    'p5pkg[' . Perlito5::Javascript2::escape_string($Perlito5::PKG_NAME) . ']'
                }
                sub Perlito5::Javascript2::get_label {
                    'tmp' . $Perlito5::ID++
                }
                sub Perlito5::Javascript2::tab {
                    my $level = shift;
                    chr(9) x $level
                }
                our %op_prefix_js_str = ('prefix:<-A>' => 'p5atime', 'prefix:<-C>' => 'p5ctime', 'prefix:<-M>' => 'p5mtime', 'prefix:<-d>' => 'p5is_directory', 'prefix:<-e>' => 'p5file_exists', 'prefix:<-f>' => 'p5is_file', 'prefix:<-s>' => 'p5size', 'prefix:<-p>' => 'p5is_pipe');
                our %op_infix_js_str = ('infix:<eq>' => ' == ', 'infix:<ne>' => ' != ', 'infix:<le>' => ' <= ', 'infix:<ge>' => ' >= ', 'infix:<lt>' => ' < ', 'infix:<gt>' => ' > ');
                our %op_infix_js_num = ('infix:<==>' => ' == ', 'infix:<!=>' => ' != ', 'infix:<+>' => ' + ', 'infix:<->' => ' - ', 'infix:<*>' => ' * ', 'infix:</>' => ' / ', 'infix:<>>' => ' > ', 'infix:<<>' => ' < ', 'infix:<>=>' => ' >= ', 'infix:<<=>' => ' <= ', 'infix:<&>' => ' & ', 'infix:<|>' => ' | ', 'infix:<^>' => ' ^ ', 'infix:<>>>' => ' >>> ');
                our %op_to_bool = map(+($_ => 1), 'prefix:<!>', 'infix:<!=>', 'infix:<==>', 'infix:<<=>', 'infix:<>=>', 'infix:<>>', 'infix:<<>', 'infix:<eq>', 'infix:<ne>', 'infix:<ge>', 'infix:<le>', 'infix:<gt>', 'infix:<lt>', 'infix:<~~>', 'prefix:<not>', 'exists', 'defined');
                our %op_to_str = map(+($_ => 1), 'substr', 'join', 'list:<.>', 'chr', 'lc', 'uc', 'lcfirst', 'ucfirst', 'ref');
                our %op_to_num = map(+($_ => 1), 'length', 'index', 'ord', 'oct', 'infix:<->', 'infix:<+>', 'infix:<*>', 'infix:</>', 'infix:<%>', 'infix:<**>');
                my %safe_char = (' ' => 1, '!' => 1, '"' => 1, '#' => 1, '$' => 1, '%' => 1, '&' => 1, '(' => 1, ')' => 1, '*' => 1, '+' => 1, ',' => 1, '-' => 1, '.' => 1, '/' => 1, ':' => 1, ';' => 1, '<' => 1, '=' => 1, '>' => 1, '?' => 1, '@' => 1, '[' => 1, ']' => 1, '^' => 1, '_' => 1, '`' => 1, '{' => 1, '|' => 1, '}' => 1, '~' => 1);
                sub Perlito5::Javascript2::escape_string {
                    my $s = shift;
                    my @out;
                    my $tmp = '';
                    $s eq '' && return chr(39) . chr(39);
                    for my $i (0 .. length($s) - 1) {
                        my $c = substr($s, $i, 1);
                        if (($c ge 'a' && $c le 'z') || ($c ge 'A' && $c le 'Z') || ($c ge 0 && $c le 9) || exists($safe_char{$c})) {
                            $tmp = $tmp . $c
                        }
                        else {
                            $tmp ne '' && push(@out, chr(39) . $tmp . chr(39));
                            push(@out, 'String.fromCharCode(' . ord($c) . ')');
                            $tmp = ''
                        }
                    }
                    $tmp ne '' && push(@out, chr(39) . $tmp . chr(39));
                    return join(' + ', @out)
                }
                sub Perlito5::Javascript2::to_str {
                    my $cond = shift;
                    my $level = shift;
                    my $wantarray = 'scalar';
                    if ($cond->isa('Perlito5::AST::Apply') && $cond->code() eq 'circumfix:<( )>' && $cond->{'arguments'} && @{$cond->{'arguments'}}) {
                        return to_str($cond->{'arguments'}->[0], $level)
                    }
                    if (($cond->isa('Perlito5::AST::Buf')) || ($cond->isa('Perlito5::AST::Apply') && exists($op_to_str{$cond->code()}))) {
                        return $cond->emit_javascript2($level, $wantarray)
                    }
                    else {
                        return 'p5str(' . $cond->emit_javascript2($level, $wantarray) . ')'
                    }
                }
                sub Perlito5::Javascript2::is_num {
                    my $cond = shift;
                    ($cond->isa('Perlito5::AST::Int') || $cond->isa('Perlito5::AST::Num') || ($cond->isa('Perlito5::AST::Apply') && exists($op_to_num{$cond->code()}))) && return 1;
                    return 0
                }
                sub Perlito5::Javascript2::to_num {
                    my $cond = shift;
                    my $level = shift;
                    my $wantarray = 'scalar';
                    if (is_num($cond)) {
                        return $cond->emit_javascript2($level, $wantarray)
                    }
                    else {
                        return 'p5num(' . $cond->emit_javascript2($level, $wantarray) . ')'
                    }
                }
                sub Perlito5::Javascript2::to_bool {
                    my $cond = shift;
                    my $level = shift;
                    my $wantarray = 'scalar';
                    if ($cond->isa('Perlito5::AST::Apply') && $cond->code() eq 'circumfix:<( )>' && $cond->{'arguments'} && @{$cond->{'arguments'}}) {
                        return to_bool($cond->{'arguments'}->[0], $level)
                    }
                    if ($cond->isa('Perlito5::AST::Apply') && ($cond->code() eq 'infix:<&&>' || $cond->code() eq 'infix:<and>')) {
                        return '(' . to_bool($cond->{'arguments'}->[0], $level) . ' && ' . to_bool($cond->{'arguments'}->[1], $level) . ')'
                    }
                    if ($cond->isa('Perlito5::AST::Apply') && ($cond->code() eq 'infix:<||>' || $cond->code() eq 'infix:<or>')) {
                        return '(' . to_bool($cond->{'arguments'}->[0], $level) . ' || ' . to_bool($cond->{'arguments'}->[1], $level) . ')'
                    }
                    if (($cond->isa('Perlito5::AST::Int')) || ($cond->isa('Perlito5::AST::Num')) || ($cond->isa('Perlito5::AST::Apply') && exists($op_to_bool{$cond->code()}))) {
                        return $cond->emit_javascript2($level, $wantarray)
                    }
                    else {
                        return 'p5bool(' . $cond->emit_javascript2($level, $wantarray) . ')'
                    }
                }
                sub Perlito5::Javascript2::is_scalar {
                    !$_[0]->isa('Perlito5::AST::Int') && !$_[0]->isa('Perlito5::AST::Num') && !$_[0]->isa('Perlito5::AST::Buf') && !$_[0]->isa('Perlito5::AST::Sub') && !($_[0]->isa('Perlito5::AST::Var') && $_[0]->{'sigil'} eq '$') && !($_[0]->isa('Perlito5::AST::Apply') && (exists($op_to_str{$_[0]->{'code'}}) || exists($op_to_num{$_[0]->{'code'}}) || exists($op_to_bool{$_[0]->{'code'}})))
                }
                sub Perlito5::Javascript2::to_list {
                    my $items = to_list_preprocess($_[0]);
                    my $level = $_[1];
                    my $literal_type = $_[2] || 'array';
                    my $wantarray = 'list';
                    my $interpolate = 0;
                    for $_ (@{$items}) {
                        is_scalar($_) && ($interpolate = 1)
                    }
                    if ($literal_type eq 'hash') {
                        if (!$interpolate) {
                            my @out;
                            my $printable = 1;
                            my @in = @{$items};
                            while (@in) {
                                my $k = shift(@in);
                                my $v = shift(@in);
                                $k = $k->emit_javascript2($level, 0);
                                $k =~ m![ \[]! && ($printable = 0);
                                $v = $v ? $v->emit_javascript2($level, 0) : 'null';
                                push(@out, $k . ' : ' . $v)
                            }
                            $printable && return '{' . join(', ', @out) . '}'
                        }
                        return 'p5a_to_h(' . to_list($items, $level, 'array') . ')'
                    }
                    $interpolate ? ('p5list_to_a([' . join(', ', map($_->emit_javascript2($level, $wantarray), @{$items})) . '])') : ('[' . join(', ', map($_->emit_javascript2($level, $wantarray), @{$items})) . ']')
                }
                sub Perlito5::Javascript2::to_list_preprocess {
                    my @items;
                    for my $item (@{$_[0]}) {
                        if ($item->isa('Perlito5::AST::Apply') && ($item->code() eq 'circumfix:<( )>' || $item->code() eq 'list:<,>' || $item->code() eq 'infix:<=>>')) {
                            if ($item->isa('Perlito5::AST::Apply') && $item->code() eq 'infix:<=>>') {
                                $item->{'arguments'}->[0] = Perlito5::AST::Lookup::->autoquote($item->{'arguments'}->[0])
                            }
                            for my $arg (@{to_list_preprocess($item->arguments())}) {
                                push(@items, $arg)
                            }
                        }
                        else {
                            push(@items, $item)
                        }
                    }
                    return \@items
                }
                sub Perlito5::Javascript2::to_scalar {
                    my $items = to_scalar_preprocess($_[0]);
                    my $level = $_[1];
                    my $wantarray = 'scalar';
                    @{$items} ? '(' . join(', ', map($_->emit_javascript2($level, $wantarray), @{$items})) . ')' : 'null'
                }
                sub Perlito5::Javascript2::to_scalar_preprocess {
                    my @items;
                    for my $item (@{$_[0]}) {
                        if ($item->isa('Perlito5::AST::Apply') && ($item->code() eq 'list:<,>' || $item->code() eq 'infix:<=>>')) {
                            if ($item->isa('Perlito5::AST::Apply') && $item->code() eq 'infix:<=>>') {
                                $item->{'arguments'}->[0] = Perlito5::AST::Lookup::->autoquote($item->{'arguments'}->[0])
                            }
                            for my $arg (@{to_scalar_preprocess($item->arguments())}) {
                                push(@items, $arg)
                            }
                        }
                        else {
                            push(@items, $item)
                        }
                    }
                    return \@items
                }
                sub Perlito5::Javascript2::to_runtime_context {
                    my $items = to_scalar_preprocess($_[0]);
                    my $level = $_[1];
                    my $wantarray = 'runtime';
                    @{$items} == 1 && is_scalar($items->[0]) && return $items->[0]->emit_javascript2($level, $wantarray);
                    'p5context(' . '[' . join(', ', map($_->emit_javascript2($level, $wantarray), @{$items})) . ']' . ', p5want)'
                }
                sub Perlito5::Javascript2::to_context {
                    my $wantarray = shift;
                    $wantarray eq 'list' ? 1 : $wantarray eq 'scalar' ? 0 : $wantarray eq 'void' ? 'null' : 'p5want'
                }
                sub Perlito5::Javascript2::autoquote {
                    my $index = shift;
                    my $level = shift;
                    $index = Perlito5::AST::Lookup::->autoquote($index);
                    return to_str($index, $level)
                }
                sub Perlito5::Javascript2::emit_javascript2_autovivify {
                    my $obj = shift;
                    my $level = shift;
                    my $type = shift;
                    if ($obj->isa('Perlito5::AST::Index') || $obj->isa('Perlito5::AST::Lookup') || $obj->isa('Perlito5::AST::Call')) {
                        return $obj->emit_javascript2($level, 0, $type)
                    }
                    if ($obj->isa('Perlito5::AST::Apply') && $obj->code() eq 'prefix:<$>') {
                        my $arg = $obj->{'arguments'}->[0];
                        return 'p5scalar_deref(' . $arg->emit_javascript2($level) . ', ' . Perlito5::Javascript2::escape_string($Perlito5::PKG_NAME) . ', ' . Perlito5::Javascript2::escape_string($type) . ')'
                    }
                    if ($obj->isa('Perlito5::AST::Apply')) {
                        return $obj->emit_javascript2($level)
                    }
                    if ($obj->isa('Perlito5::AST::Buf')) {
                        return $obj->emit_javascript2($level)
                    }
                    '(' . $obj->emit_javascript2($level) . ' || (' . $obj->emit_javascript2($level) . ' = ' . ($type eq 'array' ? 'new p5ArrayRef([])' : $type eq 'hash' ? 'new p5HashRef({})' : 'new p5ScalarRef(null)') . ')' . ')'
                }
                sub Perlito5::Javascript2::emit_javascript2_list_with_tabs {
                    my($level, $argument) = @_;
                    my $tab = Perlito5::Javascript2::tab($level);
                    return map {
                        ref($_) eq 'ARRAY' ? emit_javascript2_list_with_tabs($level + 1, $_) : $tab . $_
                    } @{$argument}
                }
                sub Perlito5::Javascript2::emit_func_javascript2 {
                    my($level, $wantarray, @argument) = @_;
                    return join(chr(10), 'function () {', emit_javascript2_list_with_tabs($level, [\@argument, '}']))
                }
                sub Perlito5::Javascript2::emit_wrap_javascript2 {
                    my($level, $wantarray, @argument) = @_;
                    return join(chr(10), '(function () {', emit_javascript2_list_with_tabs($level, [\@argument, '})()']))
                }
                sub Perlito5::Javascript2::emit_function_javascript2 {
                    my($level, $wantarray, $argument) = @_;
                    if ($argument->isa('Perlito5::AST::Apply') && ($argument->code() eq 'return' || $argument->code() eq 'last' || $argument->code() eq 'next' || $argument->code() eq 'redo')) {
                        emit_func_javascript2($level, $wantarray, $argument->emit_javascript2($level, $wantarray))
                    }
                    else {
                        emit_func_javascript2($level, $wantarray, 'return ' . $argument->emit_javascript2($level + 1, $wantarray))
                    }
                }
                sub Perlito5::Javascript2::emit_wrap_statement_javascript2 {
                    my($level, $wantarray, $argument) = @_;
                    if ($wantarray eq 'void') {
                        return $argument
                    }
                    emit_wrap_javascript2($level, $wantarray, $argument)
                }
            }
            package Perlito5::Javascript2::LexicalBlock;
            {
                sub Perlito5::Javascript2::LexicalBlock::new {
                    my $class = shift;
                    bless({@_}, $class)
                }
                sub Perlito5::Javascript2::LexicalBlock::block {
                    $_[0]->{'block'}
                }
                sub Perlito5::Javascript2::LexicalBlock::has_decl {
                    my $self = $_[0];
                    my $type = $_[1];
                    for my $decl (@{$self->{'block'}}) {
                        (grep {
                            $_->{'decl'} eq $type
                        } $decl->emit_javascript2_get_decl()) && return 1
                    }
                    return 0
                }
                sub Perlito5::Javascript2::LexicalBlock::emit_javascript2_subroutine_body {
                    my($self, $level, $wantarray) = @_;
                    $self->{'top_level'} = 1;
                    my $outer_throw = $Perlito5::THROW;
                    $Perlito5::THROW = 0;
                    my $s = $self->emit_javascript2($level, $wantarray);
                    $Perlito5::THROW = $outer_throw;
                    return $s
                }
                sub Perlito5::Javascript2::LexicalBlock::emit_javascript2 {
                    my($self, $level, $wantarray) = @_;
                    my $original_level = $level;
                    my @block;
                    for my $stmt (@{$self->{'block'}}) {
                        if (defined($stmt)) {
                            push(@block, $stmt)
                        }
                    }
                    if (!@block) {
                        $wantarray eq 'list' && return 'return []';
                        $wantarray eq 'scalar' && return 'return null';
                        $wantarray eq 'runtime' && return 'return p5want ? [] : null';
                        return 'null;'
                    }
                    my @str;
                    my $has_local = $self->has_decl('local');
                    my $has_regex = 0;
                    if (grep {
                        $_->emit_javascript2_has_regex()
                    } @block) {
                        $has_local = 1;
                        $has_regex = 1
                    }
                    my $create_context = $self->{'create_context'} && $self->has_decl('my');
                    my $outer_pkg = $Perlito5::PKG_NAME;
                    if ($self->{'top_level'} || $create_context) {
                        $level++
                    }
                    my $last_statement;
                    if ($wantarray ne 'void') {
                        $last_statement = pop(@block)
                    }
                    for my $decl (@block) {
                        if (ref($decl) eq 'Perlito5::AST::Apply' && $decl->code() eq 'package') {
                            $Perlito5::PKG_NAME = $decl->{'namespace'}
                        }
                        my @var_decl = $decl->emit_javascript2_get_decl();
                        for my $arg (@var_decl) {
                            push(@str, $arg->emit_javascript2_init($level, $wantarray))
                        }
                        if (!($decl->isa('Perlito5::AST::Decl') && $decl->decl() eq 'my')) {
                            push(@str, $decl->emit_javascript2($level, 'void') . ';')
                        }
                    }
                    if ($last_statement) {
                        my @var_decl = $last_statement->emit_javascript2_get_decl();
                        for my $arg (@var_decl) {
                            push(@str, $arg->emit_javascript2_init($level, $wantarray))
                        }
                        if ($last_statement->isa('Perlito5::AST::Apply') && $last_statement->code() eq 'return' && $self->{'top_level'} && @{$last_statement->{'arguments'}}) {
                            $last_statement = $last_statement->{'arguments'}->[0]
                        }
                        if ($last_statement->isa('Perlito5::AST::For') || $last_statement->isa('Perlito5::AST::While') || $last_statement->isa('Perlito5::AST::If') || $last_statement->isa('Perlito5::AST::Block') || $last_statement->isa('Perlito5::AST::Use') || $last_statement->isa('Perlito5::AST::Apply') && $last_statement->code() eq 'goto' || $last_statement->isa('Perlito5::AST::Apply') && $last_statement->code() eq 'return') {
                            push(@str, $last_statement->emit_javascript2($level, $wantarray))
                        }
                        elsif ($has_local) {
                            push(@str, 'return p5cleanup_local(local_idx, (' . ($wantarray eq 'runtime' ? Perlito5::Javascript2::to_runtime_context([$last_statement], $level + 1) : $wantarray eq 'scalar' ? Perlito5::Javascript2::to_scalar([$last_statement], $level + 1) : $last_statement->emit_javascript2($level, $wantarray)) . '));')
                        }
                        else {
                            push(@str, 'return (' . ($wantarray eq 'runtime' ? Perlito5::Javascript2::to_runtime_context([$last_statement], $level + 1) : $wantarray eq 'scalar' ? Perlito5::Javascript2::to_scalar([$last_statement], $level + 1) : $last_statement->emit_javascript2($level, $wantarray)) . ');')
                        }
                    }
                    if ($has_local) {
                        unshift(@str, ('var local_idx = p5LOCAL.length;', ($has_regex ? ('var regex_tmp = p5_regex_capture;', 'p5LOCAL.push(function(){ p5_regex_capture = regex_tmp });') : ())));
                        push(@str, 'p5cleanup_local(local_idx, null);')
                    }
                    my $out;
                    if ($self->{'top_level'} && $Perlito5::THROW) {
                        $level = $original_level;
                        my $tab = chr(10) . Perlito5::Javascript2::tab($level + 1);
                        $out = 'try {' . $tab . join($tab, @str) . chr(10) . Perlito5::Javascript2::tab($level) . '}' . chr(10) . Perlito5::Javascript2::tab($level) . 'catch(err) {' . chr(10) . Perlito5::Javascript2::tab($level + 1) . 'if ( err instanceof Error ) {' . chr(10) . Perlito5::Javascript2::tab($level + 2) . 'throw(err);' . chr(10) . Perlito5::Javascript2::tab($level + 1) . '}' . chr(10) . Perlito5::Javascript2::tab($level + 1) . 'else {' . chr(10) . Perlito5::Javascript2::tab($level + 2) . ($has_local ? 'return p5cleanup_local(local_idx, err)' : 'return(err)') . ';' . chr(10) . Perlito5::Javascript2::tab($level + 1) . '}' . chr(10) . Perlito5::Javascript2::tab($level) . '}'
                    }
                    elsif ($create_context) {
                        $level = $original_level;
                        my $tab = chr(10) . Perlito5::Javascript2::tab($level + 1);
                        $out = '(function () {' . $tab . join($tab, @str) . chr(10) . Perlito5::Javascript2::tab($level) . '})();'
                    }
                    else {
                        $level = $original_level;
                        my $tab = chr(10) . Perlito5::Javascript2::tab($level);
                        $out = join($tab, @str)
                    }
                    $Perlito5::PKG_NAME = $outer_pkg;
                    return $out
                }
                sub Perlito5::Javascript2::LexicalBlock::emit_javascript2_has_regex {
                    ()
                }
            }
            package Perlito5::AST::CompUnit;
            {
                sub Perlito5::AST::CompUnit::emit_javascript2 {
                    my($self, $level, $wantarray) = @_;
                    return Perlito5::Javascript2::emit_wrap_javascript2($level, $wantarray, Perlito5::Javascript2::LexicalBlock::->new('block' => $self->{'body'})->emit_javascript2($level + 1, $wantarray))
                }
                sub Perlito5::AST::CompUnit::emit_javascript2_program {
                    my($comp_units, %options) = @_;
                    $Perlito5::PKG_NAME = 'main';
                    my $level = 0;
                    my $wantarray = 'void';
                    my $str;
                    $str .= Perlito5::Compiler::do_not_edit('//');
                    if ($options{'expand_use'}) {
                        $str .= Perlito5::Javascript2::Runtime::->emit_javascript2();
                        $str .= Perlito5::Javascript2::Array::->emit_javascript2();
                        $str .= Perlito5::Javascript2::CORE::->emit_javascript2();
                        $str .= Perlito5::Javascript2::IO::->emit_javascript2();
                        $str .= Perlito5::Javascript2::Sprintf::->emit_javascript2()
                    }
                    $str .= 'var p5want;' . chr(10) . 'var List__ = [];' . chr(10);
                    for my $comp_unit (@{$comp_units}) {
                        $str = $str . $comp_unit->emit_javascript2($level, $wantarray) . chr(10)
                    }
                    return $str
                }
                sub Perlito5::AST::CompUnit::emit_javascript2_get_decl {
                    ()
                }
                sub Perlito5::AST::CompUnit::emit_javascript2_has_regex {
                    ()
                }
            }
            package Perlito5::AST::Int;
            {
                sub Perlito5::AST::Int::emit_javascript2 {
                    my($self, $level, $wantarray) = @_;
                    $self->{'int'}
                }
                sub Perlito5::AST::Int::emit_javascript2_get_decl {
                    ()
                }
                sub Perlito5::AST::Int::emit_javascript2_has_regex {
                    ()
                }
            }
            package Perlito5::AST::Num;
            {
                sub Perlito5::AST::Num::emit_javascript2 {
                    my($self, $level, $wantarray) = @_;
                    $self->{'num'}
                }
                sub Perlito5::AST::Num::emit_javascript2_get_decl {
                    ()
                }
                sub Perlito5::AST::Num::emit_javascript2_has_regex {
                    ()
                }
            }
            package Perlito5::AST::Buf;
            {
                sub Perlito5::AST::Buf::emit_javascript2 {
                    my($self, $level, $wantarray) = @_;
                    Perlito5::Javascript2::escape_string($self->{'buf'})
                }
                sub Perlito5::AST::Buf::emit_javascript2_get_decl {
                    ()
                }
                sub Perlito5::AST::Buf::emit_javascript2_has_regex {
                    ()
                }
            }
            package Perlito5::AST::Block;
            {
                sub Perlito5::AST::Block::emit_javascript2 {
                    my($self, $level, $wantarray) = @_;
                    my $body;
                    if ($wantarray ne 'void') {
                        $body = Perlito5::Javascript2::LexicalBlock::->new('block' => $self->{'stmts'})
                    }
                    else {
                        $body = Perlito5::Javascript2::LexicalBlock::->new('block' => $self->{'stmts'})
                    }
                    my $init = '';
                    if ($self->{'name'} eq 'INIT') {
                        my $tmp = 'p5pkg.main.' . Perlito5::Javascript2::get_label();
                        $init = Perlito5::Javascript2::tab($level + 2) . 'if (' . $tmp . ') { return }; ' . $tmp . ' = 1;' . chr(10)
                    }
                    return ($wantarray ne 'void' ? 'return ' : '') . 'p5block(' . 'function (v) {}, ' . 'function () {' . chr(10) . $init . Perlito5::Javascript2::tab($level + 2) . $body->emit_javascript2($level + 2, $wantarray) . chr(10) . Perlito5::Javascript2::tab($level + 1) . '}, ' . '[0], ' . $self->emit_javascript2_continue($level, $wantarray) . ', ' . Perlito5::Javascript2::escape_string($self->{'label'} || '') . chr(10) . Perlito5::Javascript2::tab($level) . ')'
                }
                sub Perlito5::AST::Block::emit_javascript2_continue {
                    my $self = shift;
                    my $level = shift;
                    my $wantarray = shift;
                    if (!$self->{'continue'} || !@{$self->{'continue'}->{'stmts'}}) {
                        return 'false'
                    }
                    return 'function () {' . chr(10) . (Perlito5::Javascript2::LexicalBlock::->new('block' => $self->{'continue'}->stmts()))->emit_javascript2($level + 2, $wantarray) . chr(10) . Perlito5::Javascript2::tab($level + 1) . '}'
                }
                sub Perlito5::AST::Block::emit_javascript2_get_decl {
                    ()
                }
                sub Perlito5::AST::Block::emit_javascript2_has_regex {
                    ()
                }
            }
            package Perlito5::AST::Index;
            {
                sub Perlito5::AST::Index::emit_javascript2 {
                    my($self, $level, $wantarray, $autovivification_type) = @_;
                    my $method = $autovivification_type || 'p5aget';
                    $autovivification_type eq 'array' && ($method = 'p5aget_array');
                    $autovivification_type eq 'hash' && ($method = 'p5aget_hash');
                    if (($self->{'obj'}->isa('Perlito5::AST::Apply') && $self->{'obj'}->{'code'} eq 'prefix:<@>') || ($self->{'obj'}->isa('Perlito5::AST::Var') && $self->{'obj'}->sigil() eq '@') || ($self->{'obj'}->isa('Perlito5::AST::Apply') && $self->{'obj'}->code() eq 'circumfix:<( )>')) {
                        return 'p5list_slice(' . $self->{'obj'}->emit_javascript2($level, 'list') . ', ' . Perlito5::Javascript2::to_list([$self->{'index_exp'}], $level) . ', ' . Perlito5::Javascript2::to_context($wantarray) . ')'
                    }
                    if (($self->{'obj'}->isa('Perlito5::AST::Apply') && $self->{'obj'}->{'code'} eq 'prefix:<%>') || ($self->{'obj'}->isa('Perlito5::AST::Var') && $self->{'obj'}->sigil() eq '%')) {
                        my $obj = $self->{'obj'};
                        $obj->{'sigil'} eq '%' && ($obj->{'sigil'} = '@');
                        $obj->{'code'} eq 'prefix:<%>' && ($obj->{'code'} = 'prefix:<@>');
                        return 'p5hash_slice(' . $self->{'obj'}->emit_javascript2($level, 'list') . ', ' . Perlito5::Javascript2::to_list([$self->{'index_exp'}], $level) . ', ' . Perlito5::Javascript2::to_context($wantarray) . ')'
                    }
                    return $self->emit_javascript2_container($level) . '.' . $method . '(' . Perlito5::Javascript2::to_num($self->{'index_exp'}, $level) . ')'
                }
                sub Perlito5::AST::Index::emit_javascript2_set {
                    my($self, $arguments, $level, $wantarray) = @_;
                    if (($self->{'obj'}->isa('Perlito5::AST::Apply') && $self->{'obj'}->{'code'} eq 'prefix:<@>') || ($self->{'obj'}->isa('Perlito5::AST::Var') && $self->{'obj'}->sigil() eq '@')) {
                        return Perlito5::Javascript2::emit_wrap_javascript2($level, $wantarray, 'var a = [];', 'var v = ' . Perlito5::Javascript2::to_list([$self->{'index_exp'}], $level) . ';', 'var src=' . Perlito5::Javascript2::to_list([$arguments], $level) . ';', 'var out=' . Perlito5::Javascript2::emit_javascript2_autovivify($self->{'obj'}, $level, 'array') . ';', 'var tmp' . ';', 'for (var i=0, l=v.length; i<l; ++i) {', ['tmp = src.p5aget(i);', 'out.p5aset(v[i], tmp);', 'a.push(tmp)'], '}', 'return a')
                    }
                    return $self->emit_javascript2_container($level) . '.p5aset(' . Perlito5::Javascript2::to_num($self->{'index_exp'}, $level + 1) . ', ' . Perlito5::Javascript2::to_scalar([$arguments], $level + 1) . ')'
                }
                sub Perlito5::AST::Index::emit_javascript2_set_list {
                    my($self, $level, $list) = @_;
                    my $wantarray = 'list';
                    if (($self->{'obj'}->isa('Perlito5::AST::Apply') && $self->{'obj'}->{'code'} eq 'prefix:<@>') || ($self->{'obj'}->isa('Perlito5::AST::Var') && $self->{'obj'}->sigil() eq '@')) {
                        return Perlito5::Javascript2::emit_wrap_javascript2($level, $wantarray, 'var a = [];', 'var v = ' . Perlito5::Javascript2::to_list([$self->{'index_exp'}], $level) . ';', 'var out=' . Perlito5::Javascript2::emit_javascript2_autovivify($self->{'obj'}, $level, 'array') . ';', 'var tmp' . ';', 'for (var i=0, l=v.length; i<l; ++i) {', ['tmp = ' . $list . '.shift();', 'out.p5aset(v[i], tmp);', 'a.push(tmp)'], '}', 'return a')
                    }
                    return $self->emit_javascript2_container($level) . '.p5aset(' . Perlito5::Javascript2::to_num($self->{'index_exp'}, $level + 1) . ', ' . $list . '.shift()' . ')'
                }
                sub Perlito5::AST::Index::emit_javascript2_container {
                    my $self = shift;
                    my $level = shift;
                    if ($self->{'obj'}->isa('Perlito5::AST::Apply') && $self->{'obj'}->{'code'} eq 'prefix:<$>') {
                        my $v = Perlito5::AST::Apply::->new(%{$self->{'obj'}}, 'code' => 'prefix:<@>');
                        return $v->emit_javascript2($level)
                    }
                    if ($self->{'obj'}->isa('Perlito5::AST::Apply') && $self->{'obj'}->code() eq 'circumfix:<( )>') {
                        return Perlito5::Javascript2::to_list([$self->{'obj'}], $level)
                    }
                    if ($self->{'obj'}->isa('Perlito5::AST::Var') && $self->{'obj'}->sigil() eq '$') {
                        $self->{'obj'}->{'sigil'} = '@';
                        return $self->{'obj'}->emit_javascript2($level)
                    }
                    else {
                        return Perlito5::Javascript2::emit_javascript2_autovivify($self->{'obj'}, $level, 'array') . '._array_'
                    }
                }
                sub Perlito5::AST::Index::emit_javascript2_get_decl {
                    ()
                }
                sub Perlito5::AST::Index::emit_javascript2_has_regex {
                    ()
                }
            }
            package Perlito5::AST::Lookup;
            {
                sub Perlito5::AST::Lookup::emit_javascript2 {
                    my($self, $level, $wantarray, $autovivification_type) = @_;
                    my $method = $autovivification_type || 'p5hget';
                    $autovivification_type eq 'array' && ($method = 'p5hget_array');
                    $autovivification_type eq 'hash' && ($method = 'p5hget_hash');
                    if (($self->{'obj'}->isa('Perlito5::AST::Apply') && $self->{'obj'}->{'code'} eq 'prefix:<@>') || ($self->{'obj'}->isa('Perlito5::AST::Var') && $self->{'obj'}->sigil() eq '@')) {
                        my $v;
                        if ($self->{'obj'}->isa('Perlito5::AST::Var')) {
                            $v = $self->{'obj'}
                        }
                        $self->{'obj'}->isa('Perlito5::AST::Apply') && ($v = Perlito5::AST::Apply::->new('code' => 'prefix:<%>', 'namespace' => $self->{'obj'}->namespace(), 'arguments' => $self->{'obj'}->arguments()));
                        return 'p5list_lookup_slice(' . $v->emit_javascript2($level, 'list') . ', ' . Perlito5::Javascript2::to_list([$self->{'index_exp'}], $level) . ', ' . Perlito5::Javascript2::to_context($wantarray) . ')'
                    }
                    if (($self->{'obj'}->isa('Perlito5::AST::Apply') && $self->{'obj'}->{'code'} eq 'prefix:<%>') || ($self->{'obj'}->isa('Perlito5::AST::Var') && $self->{'obj'}->sigil() eq '%')) {
                        my $v;
                        if ($self->{'obj'}->isa('Perlito5::AST::Var')) {
                            $v = $self->{'obj'}
                        }
                        $self->{'obj'}->isa('Perlito5::AST::Apply') && ($v = Perlito5::AST::Apply::->new('code' => 'prefix:<%>', 'namespace' => $self->{'obj'}->namespace(), 'arguments' => $self->{'obj'}->arguments()));
                        return 'p5hash_lookup_slice(' . $v->emit_javascript2($level, 'list') . ', ' . Perlito5::Javascript2::to_list([$self->{'index_exp'}], $level) . ', ' . Perlito5::Javascript2::to_context($wantarray) . ')'
                    }
                    return $self->emit_javascript2_container($level) . '.' . $method . '(' . Perlito5::Javascript2::autoquote($self->{'index_exp'}, $level) . ')'
                }
                sub Perlito5::AST::Lookup::emit_javascript2_set {
                    my($self, $arguments, $level, $wantarray) = @_;
                    if (($self->{'obj'}->isa('Perlito5::AST::Apply') && $self->{'obj'}->{'code'} eq 'prefix:<@>') || ($self->{'obj'}->isa('Perlito5::AST::Var') && $self->{'obj'}->sigil() eq '@')) {
                        my $v;
                        $self->{'obj'}->isa('Perlito5::AST::Var') && ($v = $self->{'obj'});
                        $self->{'obj'}->isa('Perlito5::AST::Apply') && ($v = Perlito5::AST::Apply::->new('code' => 'prefix:<%>', 'namespace' => $self->{'obj'}->namespace(), 'arguments' => $self->{'obj'}->arguments()));
                        return Perlito5::Javascript2::emit_wrap_javascript2($level, $wantarray, 'var a = [];', 'var v = ' . Perlito5::Javascript2::to_list([$self->{'index_exp'}], $level) . ';', 'var src=' . Perlito5::Javascript2::to_list([$arguments], $level) . ';', 'var out=' . $v->emit_javascript2($level) . ';', 'var tmp' . ';', 'for (var i=0, l=v.length; i<l; ++i)' . '{', ['tmp = src.p5hget(i);', 'out.p5hset(v[i], tmp);', 'a.push(tmp)'], '}', 'return a')
                    }
                    return $self->emit_javascript2_container($level) . '.p5hset(' . Perlito5::Javascript2::autoquote($self->{'index_exp'}, $level) . ', ' . Perlito5::Javascript2::to_scalar([$arguments], $level + 1) . ')'
                }
                sub Perlito5::AST::Lookup::emit_javascript2_set_list {
                    my($self, $level, $list) = @_;
                    my $wantarray = 'list';
                    if (($self->{'obj'}->isa('Perlito5::AST::Apply') && $self->{'obj'}->{'code'} eq 'prefix:<@>') || ($self->{'obj'}->isa('Perlito5::AST::Var') && $self->{'obj'}->sigil() eq '@')) {
                        my $v;
                        $self->{'obj'}->isa('Perlito5::AST::Var') && ($v = $self->{'obj'});
                        $self->{'obj'}->isa('Perlito5::AST::Apply') && ($v = Perlito5::AST::Apply::->new('code' => 'prefix:<%>', 'namespace' => $self->{'obj'}->namespace(), 'arguments' => $self->{'obj'}->arguments()));
                        return Perlito5::Javascript2::emit_wrap_javascript2($level, $wantarray, 'var a = [];', 'var v = ' . Perlito5::Javascript2::to_list([$self->{'index_exp'}], $level) . ';', 'var out=' . $v->emit_javascript2($level) . ';', 'var tmp' . ';', 'for (var i=0, l=v.length; i<l; ++i)' . '{', ['tmp = ' . $list . '.shift();', 'out.p5hset(v[i], tmp);', 'a.push(tmp)'], '}', 'return a')
                    }
                    return $self->emit_javascript2_container($level) . '.p5hset(' . Perlito5::Javascript2::autoquote($self->{'index_exp'}, $level) . ', ' . $list . '.shift()' . ')'
                }
                sub Perlito5::AST::Lookup::emit_javascript2_container {
                    my $self = shift;
                    my $level = shift;
                    if ($self->{'obj'}->isa('Perlito5::AST::Apply') && $self->{'obj'}->{'code'} eq 'prefix:<$>') {
                        my $v = Perlito5::AST::Apply::->new(%{$self->{'obj'}}, 'code' => 'prefix:<%>');
                        return $v->emit_javascript2($level)
                    }
                    if ($self->{'obj'}->isa('Perlito5::AST::Var') && $self->{'obj'}->sigil() eq '$') {
                        my $v = Perlito5::AST::Var::->new(%{$self->{'obj'}}, 'sigil' => '%');
                        return $v->emit_javascript2($level)
                    }
                    else {
                        return Perlito5::Javascript2::emit_javascript2_autovivify($self->{'obj'}, $level, 'hash') . '._hash_'
                    }
                }
                sub Perlito5::AST::Lookup::emit_javascript2_get_decl {
                    ()
                }
                sub Perlito5::AST::Lookup::emit_javascript2_has_regex {
                    ()
                }
            }
            package Perlito5::AST::Var;
            {
                my $table = {'$' => 'v_', '@' => 'List_', '%' => 'Hash_', '&' => ''};
                sub Perlito5::AST::Var::emit_javascript2_global {
                    my($self, $level, $wantarray) = @_;
                    my $str_name = $self->{'name'};
                    my $sigil = $self->{'_real_sigil'} || $self->{'sigil'};
                    my $namespace = $self->{'namespace'} || $self->{'_namespace'};
                    if ($sigil eq '@' && $self->{'name'} eq '_' && $namespace eq 'main') {
                        my $s = 'List__';
                        if ($self->{'sigil'} eq '$#') {
                            return '(' . $s . '.length - 1)'
                        }
                        if ($wantarray eq 'scalar') {
                            return $s . '.length'
                        }
                        if ($wantarray eq 'runtime') {
                            return '(p5want' . ' ? ' . $s . ' : ' . $s . '.length' . ')'
                        }
                        return $s
                    }
                    if ($sigil eq '$' && $self->{'name'} > 0) {
                        return 'p5_regex_capture[' . ($self->{'name'} - 1) . ']'
                    }
                    if ($sigil eq '::') {
                        $self->{'namespace'} eq '__PACKAGE__' && return Perlito5::Javascript2::pkg();
                        $self->{'namespace'} eq '__SUB__' && return $Perlito5::AST::Sub::SUB_REF // '__SUB__';
                        return Perlito5::Javascript2::escape_string($namespace)
                    }
                    my $s = 'p5make_package(' . Perlito5::Javascript2::escape_string($namespace) . ')[' . Perlito5::Javascript2::escape_string($table->{$sigil} . $str_name) . ']';
                    if ($sigil eq '*') {
                        return $s
                    }
                    if ($sigil eq '&') {
                        return $s . '(List__, ' . Perlito5::Javascript2::to_context($wantarray) . ')'
                    }
                    if ($sigil eq '@') {
                        $s = $s . ' || (' . $s . ' = [])';
                        $s = 'p5pkg[' . $s . ', ' . Perlito5::Javascript2::escape_string($namespace) . '][' . Perlito5::Javascript2::escape_string($table->{$sigil} . $str_name) . ']';
                        if ($self->{'sigil'} eq '$#') {
                            return '(' . $s . '.length - 1)'
                        }
                        if ($wantarray eq 'scalar') {
                            return $s . '.length'
                        }
                    }
                    elsif ($sigil eq '%') {
                        $s = $s . ' || (' . $s . ' = {})';
                        $s = 'p5pkg[' . $s . ', ' . Perlito5::Javascript2::escape_string($namespace) . '][' . Perlito5::Javascript2::escape_string($table->{$sigil} . $str_name) . ']'
                    }
                    return $s
                }
                sub Perlito5::AST::Var::emit_javascript2 {
                    my($self, $level, $wantarray) = @_;
                    my $sigil = $self->{'_real_sigil'} || $self->{'sigil'};
                    my $str_name = $self->{'name'};
                    my $decl_type = $self->{'_decl'} || 'global';
                    if ($decl_type ne 'my') {
                        return $self->emit_javascript2_global($level, $wantarray)
                    }
                    if ($sigil eq '@') {
                        if ($wantarray eq 'scalar') {
                            return $self->emit_javascript2($level, 'list') . '.length'
                        }
                        if ($wantarray eq 'runtime') {
                            return '(p5want' . ' ? ' . $self->emit_javascript2($level, 'list') . ' : ' . $self->emit_javascript2($level, 'list') . '.length' . ')'
                        }
                    }
                    if ($self->{'sigil'} eq '$#') {
                        return '(' . $table->{'@'} . $str_name . '.length - 1)'
                    }
                    $table->{$sigil} . $str_name
                }
                sub Perlito5::AST::Var::emit_javascript2_set {
                    my($self, $arguments, $level, $wantarray) = @_;
                    my $open = $wantarray eq 'void' ? '' : '(';
                    my $close = $wantarray eq 'void' ? '' : ')';
                    my $sigil = $self->{'_real_sigil'} || $self->{'sigil'};
                    if ($sigil eq '$') {
                        return $open . $self->emit_javascript2() . ' = ' . Perlito5::Javascript2::to_scalar([$arguments], $level + 1) . $close
                    }
                    if ($sigil eq '@') {
                        if ($self->{'sigil'} eq '$#') {
                            $self->{'sigil'} = '@';
                            return $open . $self->emit_javascript2() . '.length = 1 + ' . Perlito5::Javascript2::to_scalar([$arguments], $level + 1) . $close
                        }
                        return $open . $self->emit_javascript2() . ' = ' . Perlito5::Javascript2::to_list([$arguments], $level + 1) . $close
                    }
                    if ($sigil eq '%') {
                        return $open . $self->emit_javascript2() . ' = ' . Perlito5::Javascript2::to_list([$arguments], $level + 1, 'hash') . $close
                    }
                    if ($sigil eq '*') {
                        my $namespace = $self->{'namespace'} || $self->{'_namespace'};
                        return 'p5typeglob_set(' . Perlito5::Javascript2::escape_string($namespace) . ', ' . Perlito5::Javascript2::escape_string($self->{'name'}) . ', ' . Perlito5::Javascript2::to_scalar([$arguments], $level + 1) . ')'
                    }
                    die('don' . chr(39) . 't know how to assign to variable ', $sigil, $self->name())
                }
                sub Perlito5::AST::Var::emit_javascript2_set_list {
                    my($self, $level, $list) = @_;
                    my $sigil = $self->{'_real_sigil'} || $self->{'sigil'};
                    if ($sigil eq '$') {
                        return $self->emit_javascript2() . ' = ' . $list . '.shift()'
                    }
                    if ($sigil eq '@') {
                        return join(';' . chr(10) . Perlito5::Javascript2::tab($level), $self->emit_javascript2() . ' = ' . $list, $list . ' = []')
                    }
                    if ($sigil eq '%') {
                        return join(';' . chr(10) . Perlito5::Javascript2::tab($level), $self->emit_javascript2() . ' = p5a_to_h(' . $list . ')', $list . ' = []')
                    }
                    die('don' . chr(39) . 't know how to assign to variable ', $sigil, $self->name())
                }
                sub Perlito5::AST::Var::emit_javascript2_get_decl {
                    ()
                }
                sub Perlito5::AST::Var::emit_javascript2_has_regex {
                    ()
                }
            }
            package Perlito5::AST::Decl;
            {
                sub Perlito5::AST::Decl::emit_javascript2 {
                    my($self, $level, $wantarray) = @_;
                    $self->{'var'}->emit_javascript2($level)
                }
                sub Perlito5::AST::Decl::emit_javascript2_init {
                    my($self, $level, $wantarray) = @_;
                    if ($self->{'decl'} eq 'local') {
                        my $var = $self->{'var'};
                        my $var_set;
                        my $tmp_name = Perlito5::Javascript2::get_label();
                        if (ref($var) eq 'Perlito5::AST::Var') {
                            $var_set = $var->emit_javascript2() . ' = v_' . $tmp_name
                        }
                        else {
                            my $tmp = Perlito5::AST::Var::->new('sigil' => '$', 'name' => $tmp_name, '_decl' => 'my');
                            $var_set = $var->emit_javascript2_set($tmp)
                        }
                        return Perlito5::Javascript2::emit_wrap_javascript2($level, $wantarray, 'var v_' . $tmp_name . ' = ' . $var->emit_javascript2() . ';', 'p5LOCAL.push(function(){ ' . $var_set . ' });', 'return ' . $var->emit_javascript2_set(Perlito5::AST::Apply::->new('code' => 'undef', 'arguments' => [], 'namespace' => ''), $level + 1) . ';') . ';'
                    }
                    if ($self->{'decl'} eq 'my') {
                        my $str = 'var ' . $self->{'var'}->emit_javascript2();
                        if ($self->{'var'}->sigil() eq '%') {
                            $str = $str . ' = {};'
                        }
                        elsif ($self->{'var'}->sigil() eq '@') {
                            $str = $str . ' = [];'
                        }
                        else {
                            $str = $str . ';'
                        }
                        return $str
                    }
                    elsif ($self->{'decl'} eq 'our') {
                        my $str = $self->{'var'}->emit_javascript2();
                        if ($self->{'var'}->sigil() eq '%') {
                            $str = $str . ' = {};'
                        }
                        elsif ($self->{'var'}->sigil() eq '@') {
                            $str = $str . ' = [];'
                        }
                        else {
                            return '// our ' . $str
                        }
                        return 'if (typeof ' . $self->{'var'}->emit_javascript2() . ' == "undefined" ) { ' . $str . '}'
                    }
                    elsif ($self->{'decl'} eq 'state') {
                        return '// state ' . $self->{'var'}->emit_javascript2()
                    }
                    else {
                        die('not implemented: Perlito5::AST::Decl ' . chr(39) . $self->{'decl'} . chr(39))
                    }
                }
                sub Perlito5::AST::Decl::emit_javascript2_set {
                    my($self, $arguments, $level, $wantarray) = @_;
                    $self->var()->emit_javascript2_set($arguments, $level, $wantarray)
                }
                sub Perlito5::AST::Decl::emit_javascript2_set_list {
                    my($self, $level, $list) = @_;
                    $self->var()->emit_javascript2_set_list($level, $list)
                }
                sub Perlito5::AST::Decl::emit_javascript2_get_decl {
                    my $self = shift;
                    return ($self)
                }
                sub Perlito5::AST::Decl::emit_javascript2_has_regex {
                    ()
                }
            }
            package Perlito5::AST::Call;
            {
                sub Perlito5::AST::Call::emit_javascript2 {
                    my($self, $level, $wantarray, $autovivification_type) = @_;
                    my $meth = $self->{'method'};
                    if ($meth eq 'postcircumfix:<[ ]>') {
                        my $method = $autovivification_type || 'p5aget';
                        $autovivification_type eq 'array' && ($method = 'p5aget_array');
                        $autovivification_type eq 'hash' && ($method = 'p5aget_hash');
                        return Perlito5::Javascript2::emit_javascript2_autovivify($self->{'invocant'}, $level, 'array') . '._array_.' . $method . '(' . Perlito5::Javascript2::to_num($self->{'arguments'}, $level + 1) . ')'
                    }
                    if ($meth eq 'postcircumfix:<{ }>') {
                        my $method = $autovivification_type || 'p5hget';
                        $autovivification_type eq 'array' && ($method = 'p5hget_array');
                        $autovivification_type eq 'hash' && ($method = 'p5hget_hash');
                        return Perlito5::Javascript2::emit_javascript2_autovivify($self->{'invocant'}, $level, 'hash') . '._hash_.' . $method . '(' . Perlito5::Javascript2::autoquote($self->{'arguments'}, $level + 1, 'list') . ')'
                    }
                    if ($meth eq 'postcircumfix:<( )>') {
                        my $invocant;
                        if (ref($self->{'invocant'}) eq 'Perlito5::AST::Apply' && $self->{'invocant'}->{'code'} eq 'prefix:<&>') {
                            my $arg = $self->{'invocant'}->{'arguments'}->[0];
                            $invocant = 'p5code_lookup_by_name(' . Perlito5::Javascript2::escape_string($Perlito5::PKG_NAME) . ', ' . $arg->emit_javascript2($level) . ')'
                        }
                        elsif (ref($self->{'invocant'}) eq 'Perlito5::AST::Var' && $self->{'invocant'}->{'sigil'} eq '&') {
                            $invocant = 'p5pkg[' . Perlito5::Javascript2::escape_string(($self->{'invocant'}->{'namespace'} || $Perlito5::PKG_NAME)) . '][' . Perlito5::Javascript2::escape_string($self->{'invocant'}->{'name'}) . ']'
                        }
                        else {
                            $invocant = $self->{'invocant'}->emit_javascript2($level, 'scalar')
                        }
                        return '(' . $invocant . ')(' . Perlito5::Javascript2::to_list($self->{'arguments'}) . ', ' . Perlito5::Javascript2::to_context($wantarray) . ')'
                    }
                    my $invocant = $self->{'invocant'}->emit_javascript2($level, 'scalar');
                    if (ref($meth) eq 'Perlito5::AST::Var') {
                        $meth = $meth->emit_javascript2($level, 'scalar')
                    }
                    else {
                        $meth = Perlito5::Javascript2::escape_string($meth)
                    }
                    return 'p5call(' . $invocant . ', ' . $meth . ', ' . Perlito5::Javascript2::to_list($self->{'arguments'}) . ', ' . Perlito5::Javascript2::to_context($wantarray) . ')'
                }
                sub Perlito5::AST::Call::emit_javascript2_set {
                    my($self, $arguments, $level, $wantarray) = @_;
                    if ($self->{'method'} eq 'postcircumfix:<[ ]>') {
                        return Perlito5::Javascript2::emit_javascript2_autovivify($self->{'invocant'}, $level, 'array') . '._array_.p5aset(' . Perlito5::Javascript2::to_num($self->{'arguments'}, $level + 1) . ', ' . Perlito5::Javascript2::to_scalar([$arguments], $level + 1) . ')'
                    }
                    if ($self->{'method'} eq 'postcircumfix:<{ }>') {
                        return Perlito5::Javascript2::emit_javascript2_autovivify($self->{'invocant'}, $level, 'hash') . '._hash_.p5hset(' . Perlito5::Javascript2::autoquote($self->{'arguments'}, $level + 1, 'list') . ', ' . Perlito5::Javascript2::to_scalar([$arguments], $level + 1) . ')'
                    }
                    die('don' . chr(39) . 't know how to assign to method ', $self->{'method'})
                }
                sub Perlito5::AST::Call::emit_javascript2_set_list {
                    my($self, $level, $list) = @_;
                    if ($self->{'method'} eq 'postcircumfix:<[ ]>') {
                        return Perlito5::Javascript2::emit_javascript2_autovivify($self->{'invocant'}, $level, 'array') . '._array_.p5aset(' . Perlito5::Javascript2::to_num($self->{'arguments'}, $level + 1) . ', ' . $list . '.shift()' . ')'
                    }
                    if ($self->{'method'} eq 'postcircumfix:<{ }>') {
                        return Perlito5::Javascript2::emit_javascript2_autovivify($self->{'invocant'}, $level, 'hash') . '._hash_.p5hset(' . Perlito5::Javascript2::autoquote($self->{'arguments'}, $level + 1, 'list') . ', ' . $list . '.shift()' . ')'
                    }
                    die('don' . chr(39) . 't know how to assign to method ', $self->{'method'})
                }
                sub Perlito5::AST::Call::emit_javascript2_get_decl {
                    ()
                }
                sub Perlito5::AST::Call::emit_javascript2_has_regex {
                    ()
                }
            }
            package Perlito5::AST::Apply;
            {
                sub Perlito5::AST::Apply::_emit_assignment_javascript2 {
                    my($parameters, $arguments, $level, $wantarray) = @_;
                    if ($parameters->isa('Perlito5::AST::Apply') && ($parameters->code() eq 'my' || $parameters->code() eq 'local' || $parameters->code() eq 'circumfix:<( )>')) {
                        if ($wantarray eq 'void') {
                            my $tmp = Perlito5::Javascript2::get_label();
                            return join(';' . chr(10) . Perlito5::Javascript2::tab($level), 'var ' . $tmp . ' = ' . Perlito5::Javascript2::to_list([$arguments], $level + 1), (map($_->emit_javascript2_set_list($level, $tmp), @{$parameters->arguments()})))
                        }
                        my $tmp = Perlito5::Javascript2::get_label();
                        my $tmp2 = Perlito5::Javascript2::get_label();
                        return Perlito5::Javascript2::emit_wrap_javascript2($level, $wantarray, 'var ' . $tmp . ' = ' . Perlito5::Javascript2::to_list([$arguments], $level + 1) . ';', 'var ' . $tmp2 . ' = ' . $tmp . '.slice(0);', (map($_->emit_javascript2_set_list($level + 1, $tmp) . ';', @{$parameters->arguments()})), 'return ' . $tmp2)
                    }
                    return $parameters->emit_javascript2_set($arguments, $level + 1, $wantarray)
                }
                sub Perlito5::AST::Apply::emit_regex_javascript2 {
                    my $op = shift;
                    my $var = shift;
                    my $regex = shift;
                    my $level = shift;
                    my $wantarray = shift;
                    if ($regex->isa('Perlito5::AST::Var')) {
                        $regex = {'code' => 'p5:m', 'arguments' => [$regex, '']}
                    }
                    my $str;
                    my $code = $regex->{'code'};
                    my $regex_args = $regex->{'arguments'};
                    if ($code eq 'p5:s') {
                        my $replace = $regex_args->[1];
                        my $modifier = $regex_args->[2]->{'buf'};
                        my $fun;
                        if (ref($replace) eq 'Perlito5::AST::Block') {
                            $replace = Perlito5::AST::Sub::->new('block' => $replace);
                            $fun = $replace->emit_javascript2($level + 2, $wantarray);
                            $modifier =~ s!e!!g
                        }
                        else {
                            $fun = Perlito5::Javascript2::emit_function_javascript2($level + 2, $wantarray, $replace)
                        }
                        $str = Perlito5::Javascript2::emit_wrap_javascript2($level + 1, $wantarray, 'var tmp = p5s(' . $var->emit_javascript2() . ', ' . $regex_args->[0]->emit_javascript2() . ', ' . $fun . ', ' . Perlito5::Javascript2::escape_string($modifier) . ', ' . ($wantarray eq 'runtime' ? 'p5want' : $wantarray eq 'list' ? 1 : 0) . ');', $var->emit_javascript2() . ' = tmp[0];', 'return tmp[1];')
                    }
                    elsif ($code eq 'p5:m') {
                        $str = 'p5m(' . $var->emit_javascript2() . ', ' . $regex_args->[0]->emit_javascript2() . ', ' . Perlito5::Javascript2::escape_string($regex_args->[1]->{'buf'}) . ', ' . ($wantarray eq 'runtime' ? 'p5want' : $wantarray eq 'list' ? 1 : 0) . ')'
                    }
                    elsif ($code eq 'p5:tr') {
                        $str = Perlito5::Javascript2::emit_wrap_javascript2($level + 1, $wantarray, 'var tmp = p5tr(' . $var->emit_javascript2() . ', ' . $regex_args->[0]->emit_javascript2() . ', ' . $regex_args->[1]->emit_javascript2() . ', ' . Perlito5::Javascript2::escape_string($regex_args->[2]->{'buf'}) . ', ' . ($wantarray eq 'runtime' ? 'p5want' : $wantarray eq 'list' ? 1 : 0) . ');', $var->emit_javascript2() . ' = tmp[0];', 'return tmp[1];')
                    }
                    else {
                        die('Error: regex emitter - unknown operator ' . $code)
                    }
                    if ($op eq '=~') {
                        return $str
                    }
                    if ($op eq '!~') {
                        return '!(' . $str . ')'
                    }
                    die('Error: regex emitter')
                }
                sub Perlito5::AST::Apply::emit_javascript2_set {
                    my($self, $arguments, $level, $wantarray) = @_;
                    my $code = $self->{'code'};
                    if ($code eq 'prefix:<$>') {
                        return 'p5scalar_deref_set(' . Perlito5::Javascript2::emit_javascript2_autovivify($self->{'arguments'}->[0], $level + 1, 'scalar') . ', ' . Perlito5::Javascript2::to_scalar([$arguments], $level + 1) . ', ' . Perlito5::Javascript2::escape_string($Perlito5::PKG_NAME) . ')'
                    }
                    if ($code eq 'prefix:<*>') {
                        return 'p5typeglob_deref_set(' . Perlito5::Javascript2::to_scalar($self->{'arguments'}, $level + 1) . ', ' . Perlito5::Javascript2::to_scalar([$arguments], $level + 1) . ', ' . Perlito5::Javascript2::escape_string($Perlito5::PKG_NAME) . ')'
                    }
                    my $open = $wantarray eq 'void' ? '' : '(';
                    my $close = $wantarray eq 'void' ? '' : ')';
                    $open . $self->emit_javascript2($level + 1) . ' = ' . $arguments->emit_javascript2($level + 1) . $close
                }
                my %emit_js = ('infix:<=~>' => sub {
                    my($self, $level, $wantarray) = @_;
                    emit_regex_javascript2('=~', $self->{'arguments'}->[0], $self->{'arguments'}->[1], $level, $wantarray)
                }, 'infix:<!~>' => sub {
                    my($self, $level, $wantarray) = @_;
                    emit_regex_javascript2('!~', $self->{'arguments'}->[0], $self->{'arguments'}->[1], $level, $wantarray)
                }, 'p5:s' => sub {
                    my($self, $level, $wantarray) = @_;
                    emit_regex_javascript2('=~', $self->{'arguments'}->[3], $self, $level, $wantarray)
                }, 'p5:m' => sub {
                    my($self, $level, $wantarray) = @_;
                    emit_regex_javascript2('=~', $self->{'arguments'}->[2], $self, $level, $wantarray)
                }, 'p5:tr' => sub {
                    my($self, $level, $wantarray) = @_;
                    emit_regex_javascript2('=~', $self->{'arguments'}->[3], $self, $level, $wantarray)
                }, 'p5:qr' => sub {
                    my($self, $level, $wantarray) = @_;
                    'p5qr(' . Perlito5::Javascript2::to_str($self->{'arguments'}->[0]) . ', ' . Perlito5::Javascript2::to_str($self->{'arguments'}->[1]) . ')'
                }, '__PACKAGE__' => sub {
                    my $self = $_[0];
                    Perlito5::Javascript2::escape_string($Perlito5::PKG_NAME)
                }, '__SUB__' => sub {
                    my $self = $_[0];
                    $Perlito5::AST::Sub::SUB_REF // '__SUB__'
                }, 'wantarray' => sub {
                    my $self = $_[0];
                    'p5want'
                }, 'package' => sub {
                    my $self = $_[0];
                    'p5make_package(' . Perlito5::Javascript2::escape_string($self->{'namespace'}) . ')'
                }, 'bless' => sub {
                    my($self, $level, $wantarray) = @_;
                    my $class;
                    if ($self->{'arguments'}->[1]) {
                        $class = Perlito5::Javascript2::to_str($self->{'arguments'}->[1])
                    }
                    else {
                        $class = Perlito5::Javascript2::escape_string($Perlito5::PKG_NAME)
                    }
                    'CORE.bless(p5list_to_a([' . $self->{'arguments'}->[0]->emit_javascript2($level, 'scalar') . ', ' . $class . ']))'
                }, 'infix:<~~>' => sub {
                    my($self, $level, $wantarray) = @_;
                    my $arg0 = $self->{'arguments'}->[0];
                    my $arg1 = $self->{'arguments'}->[1];
                    'p5smrt_scalar(' . $arg0->emit_javascript2($level, 'scalar') . ', ' . $arg1->emit_javascript2($level, 'scalar') . ')'
                }, 'infix:<&&>' => sub {
                    my($self, $level, $wantarray) = @_;
                    'p5and(' . $self->{'arguments'}->[0]->emit_javascript2($level, 'scalar') . ', ' . Perlito5::Javascript2::emit_function_javascript2($level, $wantarray, $self->{'arguments'}->[1]) . ')'
                }, 'infix:<and>' => sub {
                    my($self, $level, $wantarray) = @_;
                    'p5and(' . $self->{'arguments'}->[0]->emit_javascript2($level, 'scalar') . ', ' . Perlito5::Javascript2::emit_function_javascript2($level, $wantarray, $self->{'arguments'}->[1]) . ')'
                }, 'infix:<||>' => sub {
                    my($self, $level, $wantarray) = @_;
                    'p5or(' . $self->{'arguments'}->[0]->emit_javascript2($level, 'scalar') . ', ' . Perlito5::Javascript2::emit_function_javascript2($level, $wantarray, $self->{'arguments'}->[1]) . ')'
                }, 'infix:<or>' => sub {
                    my($self, $level, $wantarray) = @_;
                    'p5or(' . $self->{'arguments'}->[0]->emit_javascript2($level, 'scalar') . ', ' . Perlito5::Javascript2::emit_function_javascript2($level, $wantarray, $self->{'arguments'}->[1]) . ')'
                }, 'infix:<xor>' => sub {
                    my($self, $level, $wantarray) = @_;
                    'p5xor(' . $self->{'arguments'}->[0]->emit_javascript2($level, 'scalar') . ', ' . Perlito5::Javascript2::emit_function_javascript2($level, $wantarray, $self->{'arguments'}->[1]) . ')'
                }, 'infix:<=>>' => sub {
                    my($self, $level, $wantarray) = @_;
                    return 'p5list_to_a([' . Perlito5::AST::Lookup::->autoquote($self->{'arguments'}->[0])->emit_javascript2($level) . ', ' . $self->{'arguments'}->[1]->emit_javascript2($level) . '])'
                }, 'infix:<cmp>' => sub {
                    my $self = $_[0];
                    'p5cmp(' . join(', ', map(Perlito5::Javascript2::to_str($_), @{$self->{'arguments'}})) . ')'
                }, 'infix:<<=>>' => sub {
                    my $self = $_[0];
                    'p5cmp(' . join(', ', map(Perlito5::Javascript2::to_num($_), @{$self->{'arguments'}})) . ')'
                }, 'infix:<**>' => sub {
                    my $self = $_[0];
                    'Math.pow(' . join(', ', map(Perlito5::Javascript2::to_num($_), @{$self->{'arguments'}})) . ')'
                }, 'infix:<<<>' => sub {
                    my $self = $_[0];
                    'p5shift_left(' . join(', ', map(Perlito5::Javascript2::to_num($_), @{$self->{'arguments'}})) . ')'
                }, 'infix:<%>' => sub {
                    my $self = $_[0];
                    'p5modulo(' . join(', ', map(Perlito5::Javascript2::to_num($_), @{$self->{'arguments'}})) . ')'
                }, 'prefix:<!>' => sub {
                    my $self = shift;
                    my $level = shift;
                    '!( ' . Perlito5::Javascript2::to_bool($self->{'arguments'}->[0], $level) . ')'
                }, 'prefix:<not>' => sub {
                    my $self = shift;
                    my $level = shift;
                    my $arg = pop(@{$self->{'arguments'}});
                    if (!$arg) {
                        return 'true'
                    }
                    '!( ' . Perlito5::Javascript2::to_bool($arg, $level) . ')'
                }, 'prefix:<~>' => sub {
                    my $self = $_[0];
                    'p5complement( ' . Perlito5::Javascript2::to_num($self->{'arguments'}->[0]) . ')'
                }, 'prefix:<->' => sub {
                    my($self, $level, $wantarray) = @_;
                    'p5negative( ' . $self->{'arguments'}->[0]->emit_javascript2($level, 'scalar') . ')'
                }, 'prefix:<+>' => sub {
                    my($self, $level, $wantarray) = @_;
                    '(' . $self->{'arguments'}->[0]->emit_javascript2($level, $wantarray) . ')'
                }, 'require' => sub {
                    my($self, $level, $wantarray) = @_;
                    my $arg = $self->{'arguments'}->[0];
                    if ($arg->{'is_version_string'}) {
                        return 'p5pkg["Perlito5"]["test_perl_version"]([' . Perlito5::Javascript2::to_str($self->{'arguments'}->[0]) . '], ' . Perlito5::Javascript2::to_context($wantarray) . ')'
                    }
                    'p5pkg["Perlito5::Grammar::Use"]["require"]([' . Perlito5::Javascript2::to_str($self->{'arguments'}->[0]) . ', ' . ($self->{'arguments'}->[0]->{'bareword'} ? 1 : 0) . '], ' . Perlito5::Javascript2::to_context($wantarray) . ')'
                }, 'select' => sub {
                    my($self, $level, $wantarray) = @_;
                    'p5pkg["CORE"]["select"]([' . ($self->{'arguments'}->[0]->{'bareword'} ? Perlito5::Javascript2::to_str($self->{'arguments'}->[0]) : $self->{'arguments'}->[0]->emit_javascript2($level, 'scalar')) . '])'
                }, 'prefix:<$>' => sub {
                    my($self, $level, $wantarray) = @_;
                    my $arg = $self->{'arguments'}->[0];
                    return 'p5scalar_deref(' . $arg->emit_javascript2($level) . ', ' . Perlito5::Javascript2::escape_string($Perlito5::PKG_NAME) . ', ' . '""' . ')'
                }, 'prefix:<@>' => sub {
                    my($self, $level, $wantarray) = @_;
                    my $arg = $self->{'arguments'}->[0];
                    my $s = 'p5array_deref(' . Perlito5::Javascript2::emit_javascript2_autovivify($arg, $level, 'array') . ', ' . Perlito5::Javascript2::escape_string($Perlito5::PKG_NAME) . ')';
                    return $wantarray eq 'scalar' ? 'p5num(' . $s . ')' : $s
                }, 'prefix:<$#>' => sub {
                    my($self, $level, $wantarray) = @_;
                    my $arg = $self->{'arguments'}->[0];
                    return '(p5array_deref(' . Perlito5::Javascript2::emit_javascript2_autovivify($arg, $level, 'array') . ', ' . Perlito5::Javascript2::escape_string($Perlito5::PKG_NAME) . ').length - 1)'
                }, 'prefix:<%>' => sub {
                    my($self, $level, $wantarray) = @_;
                    my $arg = $self->{'arguments'}->[0];
                    return 'p5hash_deref(' . Perlito5::Javascript2::emit_javascript2_autovivify($arg, $level, 'hash') . ', ' . Perlito5::Javascript2::escape_string($Perlito5::PKG_NAME) . ')'
                }, 'prefix:<&>' => sub {
                    my($self, $level, $wantarray) = @_;
                    my $arg = $self->{'arguments'}->[0];
                    'p5code_lookup_by_name(' . Perlito5::Javascript2::escape_string($Perlito5::PKG_NAME) . ', ' . $arg->emit_javascript2($level) . ')([])'
                }, 'circumfix:<[ ]>' => sub {
                    my($self, $level, $wantarray) = @_;
                    '(new p5ArrayRef(' . Perlito5::Javascript2::to_list($self->{'arguments'}) . '))'
                }, 'circumfix:<{ }>' => sub {
                    my($self, $level, $wantarray) = @_;
                    '(new p5HashRef(' . Perlito5::Javascript2::to_list($self->{'arguments'}, $level, 'hash') . '))'
                }, 'prefix:<' . chr(92) . '>' => sub {
                    my($self, $level, $wantarray) = @_;
                    my $arg = $self->{'arguments'}->[0];
                    if ($arg->isa('Perlito5::AST::Apply')) {
                        if ($arg->{'code'} eq 'prefix:<@>') {
                            return '(new p5ArrayRef(' . $arg->emit_javascript2($level) . '))'
                        }
                        if ($arg->{'code'} eq 'prefix:<%>') {
                            return '(new p5HashRef(' . $arg->emit_javascript2($level) . '))'
                        }
                        if ($arg->{'code'} eq 'circumfix:<( )>') {
                            return 'p5_list_of_refs(' . Perlito5::Javascript2::to_list($arg->{'arguments'}) . ')'
                        }
                        if ($arg->{'code'} eq 'prefix:<&>') {
                            return 'p5code_lookup_by_name(' . Perlito5::Javascript2::escape_string($Perlito5::PKG_NAME) . ', ' . $arg->{'arguments'}->[0]->emit_javascript2($level) . ')'
                        }
                    }
                    if ($arg->isa('Perlito5::AST::Var')) {
                        if ($arg->sigil() eq '@') {
                            return '(new p5ArrayRef(' . $arg->emit_javascript2($level) . '))'
                        }
                        if ($arg->sigil() eq '%') {
                            return '(new p5HashRef(' . $arg->emit_javascript2($level) . '))'
                        }
                        if ($arg->sigil() eq '*') {
                            return '(new p5GlobRef(' . $arg->emit_javascript2($level) . '))'
                        }
                        if ($arg->sigil() eq '&') {
                            if ($arg->{'namespace'}) {
                                return 'p5pkg[' . Perlito5::Javascript2::escape_string($arg->{'namespace'}) . '].' . $arg->{'name'}
                            }
                            else {
                                return Perlito5::Javascript2::pkg() . '.' . $arg->{'name'}
                            }
                        }
                    }
                    return '(new p5ScalarRef(' . $arg->emit_javascript2($level) . '))'
                }, 'postfix:<++>' => sub {
                    my($self, $level, $wantarray) = @_;
                    my $arg = $self->{'arguments'}->[0];
                    if ($arg->isa('Perlito5::AST::Index') || $arg->isa('Perlito5::AST::Lookup') || $arg->isa('Perlito5::AST::Call')) {
                        return $arg->emit_javascript2($level + 1, 0, 'p5postincr')
                    }
                    if ($arg->isa('Perlito5::AST::Var') && $arg->{'sigil'} eq '$') {
                        my $tmp = Perlito5::Javascript2::get_label();
                        return Perlito5::Javascript2::emit_wrap_javascript2($level, 'scalar', 'var ' . $tmp . ' = ' . $arg->emit_javascript2($level) . ';', $arg->emit_javascript2($level) . ' = p5incr_(' . $tmp . ');', 'return ' . $tmp)
                    }
                    '(' . join(' ', map($_->emit_javascript2(), @{$self->{'arguments'}})) . ')++'
                }, 'postfix:<-->' => sub {
                    my($self, $level, $wantarray) = @_;
                    my $arg = $self->{'arguments'}->[0];
                    if ($arg->isa('Perlito5::AST::Index') || $arg->isa('Perlito5::AST::Lookup') || $arg->isa('Perlito5::AST::Call')) {
                        return $arg->emit_javascript2($level + 1, 0, 'p5postdecr')
                    }
                    if ($arg->isa('Perlito5::AST::Var') && $arg->{'sigil'} eq '$') {
                        my $tmp = Perlito5::Javascript2::get_label();
                        return Perlito5::Javascript2::emit_wrap_javascript2($level, 'scalar', 'var ' . $tmp . ' = ' . $arg->emit_javascript2($level) . ';', $arg->emit_javascript2($level) . ' = p5decr_(' . $tmp . ');', 'return ' . $tmp)
                    }
                    '(' . join(' ', map($_->emit_javascript2(), @{$self->{'arguments'}})) . ')--'
                }, 'prefix:<++>' => sub {
                    my($self, $level, $wantarray) = @_;
                    my $arg = $self->{'arguments'}->[0];
                    if ($arg->isa('Perlito5::AST::Index') || $arg->isa('Perlito5::AST::Lookup') || $arg->isa('Perlito5::AST::Call')) {
                        return $arg->emit_javascript2($level + 1, 0, 'p5incr')
                    }
                    if ($arg->isa('Perlito5::AST::Var') && $arg->{'sigil'} eq '$') {
                        my $tmp = Perlito5::Javascript2::get_label();
                        return Perlito5::Javascript2::emit_wrap_javascript2($level, 'scalar', 'var ' . $tmp . ' = ' . $arg->emit_javascript2($level) . ';', $arg->emit_javascript2($level) . ' = p5incr_(' . $tmp . ');', 'return ' . $arg->emit_javascript2($level + 1))
                    }
                    '++(' . join(' ', map($_->emit_javascript2(), @{$self->{'arguments'}})) . ')'
                }, 'prefix:<-->' => sub {
                    my($self, $level, $wantarray) = @_;
                    my $arg = $self->{'arguments'}->[0];
                    if ($arg->isa('Perlito5::AST::Index') || $arg->isa('Perlito5::AST::Lookup') || $arg->isa('Perlito5::AST::Call')) {
                        return $arg->emit_javascript2($level + 1, 0, 'p5decr')
                    }
                    if ($arg->isa('Perlito5::AST::Var') && $arg->{'sigil'} eq '$') {
                        my $tmp = Perlito5::Javascript2::get_label();
                        return Perlito5::Javascript2::emit_wrap_javascript2($level, 'scalar', 'var ' . $tmp . ' = ' . $arg->emit_javascript2($level) . ';', $arg->emit_javascript2($level) . ' = p5decr_(' . $tmp . ');', 'return ' . $arg->emit_javascript2($level + 1))
                    }
                    '--(' . join(' ', map($_->emit_javascript2(), @{$self->{'arguments'}})) . ')'
                }, 'infix:<x>' => sub {
                    my($self, $level, $wantarray) = @_;
                    my $arg = $self->{'arguments'}->[0];
                    if (ref($arg) eq 'Perlito5::AST::Apply' && ($arg->{'code'} eq 'circumfix:<( )>' || $arg->{'code'} eq 'list:<,>')) {
                        return 'p5list_replicate(' . $self->{'arguments'}->[0]->emit_javascript2($level, 'list') . ',' . Perlito5::Javascript2::to_num($self->{'arguments'}->[1], $level) . ', ' . ($wantarray eq 'runtime' ? 'p5want' : $wantarray eq 'list' ? 1 : 0) . ')'
                    }
                    'p5str_replicate(' . Perlito5::Javascript2::to_str($self->{'arguments'}->[0], $level) . ',' . Perlito5::Javascript2::to_num($self->{'arguments'}->[1], $level) . ')'
                }, 'list:<.>' => sub {
                    my($self, $level, $wantarray) = @_;
                    '(' . join(' + ', map(Perlito5::Javascript2::to_str($_), @{$self->{'arguments'}})) . ')'
                }, 'list:<,>' => sub {
                    my($self, $level, $wantarray) = @_;
                    Perlito5::Javascript2::to_list($self->{'arguments'})
                }, 'infix:<..>' => sub {
                    my($self, $level, $wantarray) = @_;
                    return 'p5range(' . $self->{'arguments'}->[0]->emit_javascript2($level) . ', ' . $self->{'arguments'}->[1]->emit_javascript2($level) . ', ' . ($wantarray eq 'runtime' ? 'p5want' : $wantarray eq 'list' ? 1 : 0) . ', ' . '"' . Perlito5::Javascript2::get_label() . '"' . ', ' . 0 . ')'
                }, 'infix:<...>' => sub {
                    my($self, $level, $wantarray) = @_;
                    return 'p5range(' . $self->{'arguments'}->[0]->emit_javascript2($level) . ', ' . $self->{'arguments'}->[1]->emit_javascript2($level) . ', ' . ($wantarray eq 'runtime' ? 'p5want' : $wantarray eq 'list' ? 1 : 0) . ', ' . '"' . Perlito5::Javascript2::get_label() . '"' . ', ' . 1 . ')'
                }, 'delete' => sub {
                    my($self, $level, $wantarray) = @_;
                    my $arg = $self->{'arguments'}->[0];
                    if ($arg->isa('Perlito5::AST::Lookup')) {
                        my $v = $arg->obj();
                        my $v_js = $v->emit_javascript2();
                        my $key_js = $arg->autoquote($arg->{'index_exp'})->emit_javascript2($level);
                        my $suffix = (($v->isa('Perlito5::AST::Var') && $v->sigil() eq '$') ? '' : '._hash_');
                        return '((function (v,k) { var ret = v[k]; delete (v[k]); return ret;})(' . $v_js . $suffix . ',' . $key_js . '))'
                    }
                    if ($arg->isa('Perlito5::AST::Index')) {
                        my $v = $arg->obj();
                        if ($v->isa('Perlito5::AST::Var') && $v->sigil() eq '$') {
                            return '(delete ' . $v->emit_javascript2() . '[' . $arg->{'index_exp'}->emit_javascript2($level) . '])'
                        }
                        return '(delete ' . $v->emit_javascript2() . '._array_[' . $arg->{'index_exp'}->emit_javascript2($level) . '])'
                    }
                    if ($arg->isa('Perlito5::AST::Call')) {
                        if ($arg->method() eq 'postcircumfix:<{ }>') {
                            return '(delete ' . $arg->invocant()->emit_javascript2() . '._hash_[' . Perlito5::AST::Lookup::->autoquote($arg->{'arguments'})->emit_javascript2($level) . '])'
                        }
                        if ($arg->method() eq 'postcircumfix:<[ ]>') {
                            return '(delete ' . $arg->invocant()->emit_javascript2() . '._array_[' . $arg->{'arguments'}->emit_javascript2($level) . '])'
                        }
                    }
                    if ($arg->isa('Perlito5::AST::Var') && $arg->sigil() eq '&') {
                        die('TODO delete &code')
                    }
                    if ($arg->isa('Perlito5::AST::Apply') && $arg->{'code'} eq 'prefix:<&>') {
                        die('TODO delete &$code')
                    }
                }, 'scalar' => sub {
                    my($self, $level, $wantarray) = @_;
                    Perlito5::Javascript2::to_scalar($self->{'arguments'}, $level + 1)
                }, 'ternary:<? :>' => sub {
                    my($self, $level, $wantarray) = @_;
                    '( ' . Perlito5::Javascript2::to_bool($self->{'arguments'}->[0]) . ' ? ' . ($self->{'arguments'}->[1])->emit_javascript2($level, $wantarray) . ' : ' . ($self->{'arguments'}->[2])->emit_javascript2($level, $wantarray) . ')'
                }, 'my' => sub {
                    my($self, $level, $wantarray) = @_;
                    'p5context(' . '[' . join(', ', map($_->emit_javascript2($level, $wantarray), @{$self->{'arguments'}})) . '], ' . ($wantarray eq 'runtime' ? 'p5want' : $wantarray eq 'list' ? 1 : 0) . ')'
                }, 'our' => sub {
                    my($self, $level, $wantarray) = @_;
                    'p5context(' . '[' . join(', ', map($_->emit_javascript2($level, $wantarray), @{$self->{'arguments'}})) . '], ' . ($wantarray eq 'runtime' ? 'p5want' : $wantarray eq 'list' ? 1 : 0) . ')'
                }, 'local' => sub {
                    my($self, $level, $wantarray) = @_;
                    'p5context(' . '[' . join(', ', map($_->emit_javascript2($level, $wantarray), @{$self->{'arguments'}})) . '], ' . ($wantarray eq 'runtime' ? 'p5want' : $wantarray eq 'list' ? 1 : 0) . ')'
                }, 'circumfix:<( )>' => sub {
                    my($self, $level, $wantarray) = @_;
                    'p5context(' . '[' . join(', ', map($_->emit_javascript2($level, $wantarray), @{$self->{'arguments'}})) . '], ' . ($wantarray eq 'runtime' ? 'p5want' : $wantarray eq 'list' ? 1 : 0) . ')'
                }, 'infix:<=>' => sub {
                    my($self, $level, $wantarray) = @_;
                    my $parameters = $self->{'arguments'}->[0];
                    my $arguments = $self->{'arguments'}->[1];
                    return _emit_assignment_javascript2($parameters, $arguments, $level, $wantarray)
                }, 'break' => sub {
                    my($self, $level, $wantarray) = @_;
                    $Perlito5::THROW = 1;
                    Perlito5::Javascript2::emit_wrap_statement_javascript2($level, $wantarray, 'throw(new p5_error("break", ""))')
                }, 'next' => sub {
                    my($self, $level, $wantarray) = @_;
                    $Perlito5::THROW = 1;
                    my $label = $self->{'arguments'}->[0]->{'code'} || '';
                    Perlito5::Javascript2::emit_wrap_statement_javascript2($level, $wantarray, 'throw(new p5_error("next", ' . Perlito5::Javascript2::escape_string($label) . '))')
                }, 'last' => sub {
                    my($self, $level, $wantarray) = @_;
                    $Perlito5::THROW = 1;
                    my $label = $self->{'arguments'}->[0]->{'code'} || '';
                    Perlito5::Javascript2::emit_wrap_statement_javascript2($level, $wantarray, 'throw(new p5_error("last", ' . Perlito5::Javascript2::escape_string($label) . '))')
                }, 'redo' => sub {
                    my($self, $level, $wantarray) = @_;
                    $Perlito5::THROW = 1;
                    my $label = $self->{'arguments'}->[0]->{'code'} || '';
                    Perlito5::Javascript2::emit_wrap_statement_javascript2($level, $wantarray, 'throw(new p5_error("redo", ' . Perlito5::Javascript2::escape_string($label) . '))')
                }, 'return' => sub {
                    my($self, $level, $wantarray) = @_;
                    $Perlito5::THROW = 1;
                    Perlito5::Javascript2::emit_wrap_statement_javascript2($level, $wantarray, 'throw(' . Perlito5::Javascript2::to_runtime_context($self->{'arguments'}, $level + 1) . ')')
                }, 'goto' => sub {
                    my($self, $level, $wantarray) = @_;
                    $Perlito5::THROW = 1;
                    Perlito5::Javascript2::emit_wrap_statement_javascript2($level, $wantarray, 'throw(' . $self->{'arguments'}->[0]->emit_javascript2($level) . ')')
                }, 'do' => sub {
                    my($self, $level, $wantarray) = @_;
                    my $arg = $self->{'arguments'}->[0];
                    if ($arg->isa('Perlito5::AST::Block')) {
                        my $block = $arg->{'stmts'};
                        return Perlito5::Javascript2::emit_wrap_javascript2($level, $wantarray, (Perlito5::Javascript2::LexicalBlock::->new('block' => $block))->emit_javascript2($level + 1, $wantarray))
                    }
                    my $tmp_strict = $Perlito5::STRICT;
                    $Perlito5::STRICT = 0;
                    my $ast = Perlito5::AST::Apply::->new('code' => 'eval', 'namespace' => '', 'arguments' => [Perlito5::AST::Apply::->new('code' => 'do_file', 'namespace' => 'Perlito5::Grammar::Use', 'arguments' => $self->{'arguments'})], '_scope' => Perlito5::Grammar::Scope::->new_base_scope());
                    my $js = $ast->emit_javascript2($level, $wantarray);
                    $Perlito5::STRICT = $tmp_strict;
                    return $js
                }, 'eval' => sub {
                    my($self, $level, $wantarray) = @_;
                    $Perlito5::THROW = 1;
                    my $arg = $self->{'arguments'}->[0];
                    my $eval;
                    if ($arg->isa('Perlito5::AST::Block')) {
                        $eval = Perlito5::AST::Apply::->new('code' => 'do', 'arguments' => [$arg])->emit_javascript2($level + 1, $wantarray)
                    }
                    else {
                        my $scope_perl5 = Perlito5::Dumper::ast_dumper([$self->{'_scope'}]);
                        my $m = Perlito5::Grammar::Expression::term_square($scope_perl5, 0);
                        if (!$m || $m->{'to'} < length($scope_perl5)) {
                            die('invalid internal scope in eval' . chr(10))
                        }
                        $m = Perlito5::Grammar::Expression::expand_list(Perlito5::Match::flat($m)->[2]);
                        my $scope_js = '(new p5ArrayRef(' . Perlito5::Javascript2::to_list($m) . '))';
                        $eval = 'eval(p5pkg["Perlito5::Javascript2::Runtime"].perl5_to_js([' . Perlito5::Javascript2::to_str($arg) . ', ' . Perlito5::Javascript2::escape_string($Perlito5::PKG_NAME) . ', ' . Perlito5::Javascript2::escape_string($wantarray) . ', ' . $scope_js . ']))'
                    }
                    my $context = Perlito5::Javascript2::to_context($wantarray);
                    Perlito5::Javascript2::emit_wrap_javascript2($level, $wantarray, ($context eq 'p5want' ? () : 'var p5want = ' . $context . ';'), 'var r;', 'p5pkg["main"]["v_@"] = "";', 'var p5strict = p5pkg["Perlito5"]["v_STRICT"];', 'p5pkg["Perlito5"]["v_STRICT"] = ' . $Perlito5::STRICT . ';', 'try {', ['r = ' . $eval . ''], '}', 'catch(err) {', ['if (err instanceof p5_error && (err.type == ' . chr(39) . 'last' . chr(39) . ' || err.type == ' . chr(39) . 'redo' . chr(39) . ' || err.type == ' . chr(39) . 'next' . chr(39) . ')) {', ['throw(err)'], '}', 'else if ( err instanceof p5_error || err instanceof Error ) {', ['p5pkg["main"]["v_@"] = err;', 'if (p5str(p5pkg["main"]["v_@"]).substr(-1, 1) != "' . chr(92) . 'n") {', ['try {' . '', ['p5pkg["main"]["v_@"] = p5pkg["main"]["v_@"] + "' . chr(92) . 'n" + err.stack + "' . chr(92) . 'n";'], '}', 'catch(err) { }'], '}'], '}', 'else {', ['return(err);'], '}'], '}', 'p5pkg["Perlito5"]["v_STRICT"] = p5strict;', 'return r;')
                }, 'substr' => sub {
                    my($self, $level, $wantarray) = @_;
                    my $length = $self->{'arguments'}->[2];
                    if ($length && $length->isa('Perlito5::AST::Int') && $length->{'int'} > 0) {
                        return Perlito5::Javascript2::to_str($self->{'arguments'}->[0]) . '.substr(' . Perlito5::Javascript2::to_num($self->{'arguments'}->[1]) . ', ' . Perlito5::Javascript2::to_num($self->{'arguments'}->[2]) . ')'
                    }
                    my $arg_list = Perlito5::Javascript2::to_list_preprocess($self->{'arguments'});
                    my $arg_code = Perlito5::Javascript2::to_list($arg_list);
                    return 'CORE.substr(' . $arg_code . ', ' . Perlito5::Javascript2::to_context($wantarray) . ')'
                }, 'undef' => sub {
                    my($self, $level, $wantarray) = @_;
                    if ($self->{'arguments'} && @{$self->{'arguments'}}) {
                        my $arg = $self->{'arguments'}->[0];
                        if (ref($arg) eq 'Perlito5::AST::Var' && $arg->{'sigil'} eq '&') {
                            return '(delete p5pkg[' . Perlito5::Javascript2::escape_string(($arg->{'namespace'} || $Perlito5::PKG_NAME)) . '][' . Perlito5::Javascript2::escape_string($arg->{'name'}) . '])'
                        }
                        return '(' . _emit_assignment_javascript2($arg, Perlito5::AST::Apply::->new('arguments' => [], 'bareword' => 1, 'code' => 'undef'), $level + 1, $wantarray) . ')'
                    }
                    return 'null'
                }, 'defined' => sub {
                    my($self, $level, $wantarray) = @_;
                    my $arg = $self->{'arguments'}->[0];
                    my $invocant;
                    if (ref($arg) eq 'Perlito5::AST::Apply' && $arg->{'code'} eq 'prefix:<&>') {
                        my $arg2 = $arg->{'arguments'}->[0];
                        $invocant = 'p5code_lookup_by_name(' . Perlito5::Javascript2::escape_string($Perlito5::PKG_NAME) . ', ' . $arg2->emit_javascript2($level) . ')'
                    }
                    elsif (ref($arg) eq 'Perlito5::AST::Var' && $arg->{'sigil'} eq '&') {
                        $invocant = 'p5pkg[' . Perlito5::Javascript2::escape_string(($arg->{'namespace'} || $Perlito5::PKG_NAME)) . '][' . Perlito5::Javascript2::escape_string($arg->{'name'}) . ']'
                    }
                    else {
                        $invocant = $arg->emit_javascript2($level, 'scalar')
                    }
                    '(' . $invocant . ' != null)'
                }, 'shift' => sub {
                    my($self, $level, $wantarray) = @_;
                    if ($self->{'arguments'} && @{$self->{'arguments'}}) {
                        return $self->{'arguments'}->[0]->emit_javascript2($level) . '.shift()'
                    }
                    return 'List__.shift()'
                }, 'pop' => sub {
                    my($self, $level, $wantarray) = @_;
                    if ($self->{'arguments'} && @{$self->{'arguments'}}) {
                        return $self->{'arguments'}->[0]->emit_javascript2($level) . '.pop()'
                    }
                    return 'List__.pop()'
                }, 'unshift' => sub {
                    my($self, $level, $wantarray) = @_;
                    my @arguments = @{$self->{'arguments'}};
                    my $v = shift(@arguments);
                    return $v->emit_javascript2($level) . '.p5unshift(' . Perlito5::Javascript2::to_list(\@arguments) . ')'
                }, 'push' => sub {
                    my($self, $level, $wantarray) = @_;
                    my @arguments = @{$self->{'arguments'}};
                    my $v = shift(@arguments);
                    return $v->emit_javascript2($level) . '.p5push(' . Perlito5::Javascript2::to_list(\@arguments) . ')'
                }, 'tie' => sub {
                    my($self, $level, $wantarray) = @_;
                    my @arguments = @{$self->{'arguments'}};
                    my $v = shift(@arguments);
                    my $meth;
                    if ($v->isa('Perlito5::AST::Var') && $v->sigil() eq '%') {
                        $meth = 'hash'
                    }
                    elsif ($v->isa('Perlito5::AST::Var') && $v->sigil() eq '@') {
                        $meth = 'array'
                    }
                    elsif ($v->isa('Perlito5::AST::Var') && $v->sigil() eq '$') {
                        $meth = 'scalar'
                    }
                    else {
                        die('tie ' . chr(39), ref($v), chr(39) . ' not implemented')
                    }
                    return 'p5tie_' . $meth . '(' . $v->emit_javascript2($level) . ', ' . Perlito5::Javascript2::to_list(\@arguments) . ')'
                }, 'untie' => sub {
                    my($self, $level, $wantarray) = @_;
                    my @arguments = @{$self->{'arguments'}};
                    my $v = shift(@arguments);
                    my $meth;
                    if ($v->isa('Perlito5::AST::Var') && $v->sigil() eq '%') {
                        $meth = 'hash'
                    }
                    elsif ($v->isa('Perlito5::AST::Var') && $v->sigil() eq '@') {
                        $meth = 'array'
                    }
                    elsif ($v->isa('Perlito5::AST::Var') && $v->sigil() eq '$') {
                        $meth = 'scalar'
                    }
                    else {
                        die('tie ' . chr(39), ref($v), chr(39) . ' not implemented')
                    }
                    return 'p5untie_' . $meth . '(' . $v->emit_javascript2($level) . ')'
                }, 'print' => sub {
                    my($self, $level, $wantarray) = @_;
                    my @in = @{$self->{'arguments'}};
                    my $fun;
                    if ($self->{'special_arg'}) {
                        $fun = $self->{'special_arg'}->emit_javascript2($level)
                    }
                    else {
                        $fun = '"STDOUT"'
                    }
                    my $list = Perlito5::Javascript2::to_list(\@in);
                    'p5pkg["Perlito5::IO"].print(' . $fun . ', ' . $list . ')'
                }, 'say' => sub {
                    my($self, $level, $wantarray) = @_;
                    my @in = @{$self->{'arguments'}};
                    my $fun;
                    if ($self->{'special_arg'}) {
                        $fun = $self->{'special_arg'}->emit_javascript2($level)
                    }
                    else {
                        $fun = '"STDOUT"'
                    }
                    my $list = Perlito5::Javascript2::to_list(\@in);
                    'p5pkg["Perlito5::IO"].say(' . $fun . ', ' . $list . ')'
                }, 'printf' => sub {
                    my($self, $level, $wantarray) = @_;
                    my @in = @{$self->{'arguments'}};
                    my $fun;
                    if ($self->{'special_arg'}) {
                        $fun = $self->{'special_arg'}->emit_javascript2($level)
                    }
                    else {
                        $fun = '"STDOUT"'
                    }
                    my $list = Perlito5::Javascript2::to_list(\@in);
                    'p5pkg["Perlito5::IO"].printf(' . $fun . ', ' . $list . ')'
                }, 'close' => sub {
                    my($self, $level, $wantarray) = @_;
                    my @in = @{$self->{'arguments'}};
                    my $fun = shift(@in);
                    'p5pkg["Perlito5::IO"].close(' . $fun->emit_javascript2($level) . ', [])'
                }, 'open' => sub {
                    my($self, $level, $wantarray) = @_;
                    my @in = @{$self->{'arguments'}};
                    my $fun = shift(@in);
                    if (ref($fun) ne 'Perlito5::AST::Apply') {
                        return Perlito5::Javascript2::emit_wrap_javascript2($level, $wantarray, $fun->emit_javascript2($level) . ' = CORE.bless([ {file_handle : {id : null}}, "GLOB" ]);', 'return CORE.open(' . Perlito5::Javascript2::to_list($self->{'arguments'}, $level) . ')')
                    }
                    else {
                        $Perlito5::STRICT = 0;
                        return 'CORE.open(' . Perlito5::Javascript2::to_list($self->{'arguments'}, $level) . ')'
                    }
                }, 'chomp' => sub {
                    my($self, $level, $wantarray) = @_;
                    my $v = $self->{'arguments'}->[0];
                    return Perlito5::Javascript2::emit_wrap_javascript2($level, $wantarray, 'var r = p5chomp(' . Perlito5::Javascript2::to_str($v, $level) . ');', $v->emit_javascript2($level) . ' = r[1];', 'return r[0]')
                }, 'chop' => sub {
                    my($self, $level, $wantarray) = @_;
                    my $v = $self->{'arguments'}->[0];
                    return Perlito5::Javascript2::emit_wrap_javascript2($level, $wantarray, 'var r = p5chop(' . Perlito5::Javascript2::to_str($v, $level) . ');', $v->emit_javascript2($level) . ' = r[1];', 'return r[0]')
                }, 'read' => sub {
                    my($self, $level, $wantarray) = @_;
                    my @in = @{$self->{'arguments'}};
                    my $fun = shift(@in);
                    my $scalar = shift(@in);
                    my $length = shift(@in);
                    return Perlito5::Javascript2::emit_wrap_javascript2($level, $wantarray, 'var r = p5pkg["Perlito5::IO"].read(' . $fun->emit_javascript2($level) . ', [' . $length->emit_javascript2($level) . ']);', $scalar->emit_javascript2($level) . ' = r[1];', 'return r[0]')
                }, 'readline' => sub {
                    my($self, $level, $wantarray) = @_;
                    my @in = @{$self->{'arguments'}};
                    my $fun = shift(@in) || bless({'arguments' => [], 'bareword' => 1, 'code' => 'ARGV', 'namespace' => ''}, 'Perlito5::AST::Apply');
                    return 'CORE.readline([' . $fun->emit_javascript2($level) . '], ' . Perlito5::Javascript2::to_context($wantarray) . ')'
                }, 'map' => sub {
                    my($self, $level, $wantarray) = @_;
                    my @in = @{$self->{'arguments'}};
                    my $fun;
                    if ($self->{'special_arg'}) {
                        $fun = $self->{'special_arg'}
                    }
                    else {
                        $fun = shift(@in)
                    }
                    my $list = Perlito5::Javascript2::to_list(\@in);
                    if (ref($fun) eq 'Perlito5::AST::Block') {
                        $fun = $fun->{'stmts'}
                    }
                    else {
                        $fun = [$fun]
                    }
                    'p5map(' . Perlito5::Javascript2::pkg() . ', ' . 'function (p5want) {' . chr(10) . Perlito5::Javascript2::tab($level + 1) . (Perlito5::Javascript2::LexicalBlock::->new('block' => $fun))->emit_javascript2($level + 1, $wantarray) . chr(10) . Perlito5::Javascript2::tab($level) . '}, ' . $list . ')'
                }, 'grep' => sub {
                    my($self, $level, $wantarray) = @_;
                    my @in = @{$self->{'arguments'}};
                    my $fun;
                    if ($self->{'special_arg'}) {
                        $fun = $self->{'special_arg'}
                    }
                    else {
                        $fun = shift(@in)
                    }
                    my $list = Perlito5::Javascript2::to_list(\@in);
                    if (ref($fun) eq 'Perlito5::AST::Block') {
                        $fun = $fun->{'stmts'}
                    }
                    else {
                        $fun = [$fun]
                    }
                    'p5grep(' . Perlito5::Javascript2::pkg() . ', ' . 'function (p5want) {' . chr(10) . Perlito5::Javascript2::tab($level + 1) . (Perlito5::Javascript2::LexicalBlock::->new('block' => $fun))->emit_javascript2($level + 1, $wantarray) . chr(10) . Perlito5::Javascript2::tab($level) . '}, ' . $list . ')'
                }, 'sort' => sub {
                    my($self, $level, $wantarray) = @_;
                    my @in = @{$self->{'arguments'}};
                    my $fun;
                    my $list;
                    if ($self->{'special_arg'}) {
                        $fun = $self->{'special_arg'}
                    }
                    elsif (ref($in[0]) eq 'Perlito5::AST::Block') {
                        $fun = shift(@in)
                    }
                    if (ref($fun) eq 'Perlito5::AST::Block') {
                        $fun = 'function (p5want) {' . chr(10) . Perlito5::Javascript2::tab($level + 1) . (Perlito5::Javascript2::LexicalBlock::->new('block' => $fun->{'stmts'}))->emit_javascript2($level + 1, $wantarray) . chr(10) . Perlito5::Javascript2::tab($level) . '}'
                    }
                    else {
                        $fun = 'null'
                    }
                    $list = Perlito5::Javascript2::to_list(\@in);
                    'p5sort(' . Perlito5::Javascript2::pkg() . ', ' . $fun . ', ' . $list . ')'
                }, 'infix:<//>' => sub {
                    my($self, $level, $wantarray) = @_;
                    'p5defined_or' . '(' . $self->{'arguments'}->[0]->emit_javascript2($level, 'scalar') . ', ' . Perlito5::Javascript2::emit_function_javascript2($level, $wantarray, $self->{'arguments'}->[1]) . ')'
                }, 'exists' => sub {
                    my($self, $level, $wantarray) = @_;
                    my $arg = $self->{'arguments'}->[0];
                    if ($arg->isa('Perlito5::AST::Lookup')) {
                        my $v = $arg->obj();
                        if ($v->isa('Perlito5::AST::Var') && $v->sigil() eq '$') {
                            $v->{'sigil'} = '%';
                            return '(' . $v->emit_javascript2() . ').hasOwnProperty(' . $arg->autoquote($arg->{'index_exp'})->emit_javascript2($level) . ')'
                        }
                        return '(' . $v->emit_javascript2() . ')._hash_.hasOwnProperty(' . $arg->autoquote($arg->{'index_exp'})->emit_javascript2($level) . ')'
                    }
                    if ($arg->isa('Perlito5::AST::Index')) {
                        my $v = $arg->obj();
                        if ($v->isa('Perlito5::AST::Var') && $v->sigil() eq '$') {
                            return '(' . $v->emit_javascript2() . ').hasOwnProperty(' . $arg->{'index_exp'}->emit_javascript2($level) . ')'
                        }
                        return '(' . $v->emit_javascript2() . ')._array_.hasOwnProperty(' . $arg->{'index_exp'}->emit_javascript2($level) . ')'
                    }
                    if ($arg->isa('Perlito5::AST::Call')) {
                        if ($arg->method() eq 'postcircumfix:<{ }>') {
                            return Perlito5::Javascript2::emit_javascript2_autovivify($arg->invocant(), $level, 'hash') . '._hash_.hasOwnProperty(' . Perlito5::AST::Lookup::->autoquote($arg->{'arguments'})->emit_javascript2($level) . ')'
                        }
                        if ($arg->method() eq 'postcircumfix:<[ ]>') {
                            return Perlito5::Javascript2::emit_javascript2_autovivify($arg->invocant(), $level, 'array') . '._array_.hasOwnProperty(' . $arg->{'arguments'}->emit_javascript2($level) . ')'
                        }
                    }
                    if ($arg->isa('Perlito5::AST::Var') && $arg->sigil() eq '&') {
                        my $name = $arg->{'name'};
                        my $namespace = $arg->{'namespace'} || $Perlito5::PKG_NAME;
                        return 'p5pkg[' . Perlito5::Javascript2::escape_string($namespace) . '].hasOwnProperty(' . Perlito5::Javascript2::escape_string($name) . ')'
                    }
                    if ($arg->isa('Perlito5::AST::Apply') && $arg->{'code'} eq 'prefix:<&>') {
                        my $arg2 = $arg->{'arguments'}->[0];
                        return 'p5sub_exists(' . Perlito5::Javascript2::to_str($arg2) . ', ' . Perlito5::Javascript2::escape_string($Perlito5::PKG_NAME) . ')'
                    }
                }, 'prototype' => sub {
                    my($self, $level, $wantarray) = @_;
                    my $arg = $self->{'arguments'}->[0];
                    return 'p5sub_prototype(' . $arg->emit_javascript2() . ', ' . Perlito5::Javascript2::escape_string($Perlito5::PKG_NAME) . ')'
                }, 'split' => sub {
                    my($self, $level, $wantarray) = @_;
                    my @js;
                    my $arg = $self->{'arguments'}->[0];
                    if ($arg && $arg->isa('Perlito5::AST::Apply') && $arg->{'code'} eq 'p5:m') {
                        push(@js, 'new RegExp(' . $arg->{'arguments'}->[0]->emit_javascript2() . ', ' . Perlito5::Javascript2::escape_string($arg->{'arguments'}->[1]->{'buf'}) . ')');
                        shift(@{$self->{'arguments'}})
                    }
                    return 'CORE.split(' . '[' . join(', ', @js, map($_->emit_javascript2(), @{$self->{'arguments'}})) . '], ' . Perlito5::Javascript2::to_context($wantarray) . ')'
                });
                sub Perlito5::AST::Apply::emit_javascript2 {
                    my($self, $level, $wantarray) = @_;
                    my $apply = $self->op_assign();
                    if ($apply) {
                        return $apply->emit_javascript2($level)
                    }
                    my $apply = $self->op_auto();
                    if ($apply) {
                        return $apply->emit_javascript2($level)
                    }
                    my $code = $self->{'code'};
                    if (ref($code) ne '') {
                        my @args = ();
                        push(@args, $_->emit_javascript2())
                            for @{$self->{'arguments'}};
                        return '(' . $self->{'code'}->emit_javascript2($level) . ')(' . join(',', @args) . ')'
                    }
                    exists($emit_js{$code}) && return $emit_js{$code}->($self, $level, $wantarray);
                    if (exists($Perlito5::Javascript2::op_infix_js_str{$code})) {
                        return '(' . join($Perlito5::Javascript2::op_infix_js_str{$code}, map {
                            Perlito5::Javascript2::to_str($_, $level)
                        } @{$self->{'arguments'}}) . ')'
                    }
                    if (exists($Perlito5::Javascript2::op_infix_js_num{$code})) {
                        return '(' . join($Perlito5::Javascript2::op_infix_js_num{$code}, map {
                            Perlito5::Javascript2::to_num($_, $level)
                        } @{$self->{'arguments'}}) . ')'
                    }
                    if (exists($Perlito5::Javascript2::op_prefix_js_str{$code})) {
                        return $Perlito5::Javascript2::op_prefix_js_str{$code} . '(' . Perlito5::Javascript2::to_str($self->{'arguments'}->[0]) . ')'
                    }
                    if ($self->{'namespace'}) {
                        if ($self->{'namespace'} eq 'JS' && $code eq 'inline') {
                            if ($self->{'arguments'}->[0]->isa('Perlito5::AST::Buf')) {
                                return $self->{'arguments'}->[0]->{'buf'}
                            }
                            else {
                                die('JS::inline needs a string constant')
                            }
                        }
                        $code = 'p5pkg[' . Perlito5::Javascript2::escape_string($self->{'namespace'}) . '].' . $code
                    }
                    else {
                        $code = Perlito5::Javascript2::pkg() . '.' . $code
                    }
                    my $sig;
                    my $may_need_autoload;
                    {
                        my $name = $self->{'code'};
                        my $namespace = $self->{'namespace'} || $Perlito5::PKG_NAME;
                        my $effective_name = $namespace . '::' . $self->{'code'};
                        if (exists($Perlito5::PROTO->{$effective_name})) {
                            $sig = $Perlito5::PROTO->{$effective_name}
                        }
                        elsif ((!$self->{'namespace'} || $namespace eq 'CORE') && exists($Perlito5::CORE_PROTO->{'CORE::' . $name})) {
                            $effective_name = 'CORE::' . $name;
                            $sig = $Perlito5::CORE_PROTO->{$effective_name}
                        }
                        elsif (exists($Perlito5::PACKAGES->{$name})) {
                            return Perlito5::Javascript2::escape_string($name)
                        }
                        else {
                            if ($self->{'bareword'}) {
                                if ($Perlito5::STRICT) {
                                    die('Bareword ' . Perlito5::Javascript2::escape_string($name) . ' not allowed while "strict subs" in use')
                                }
                                return Perlito5::Javascript2::escape_string(($self->{'namespace'} ? $self->{'namespace'} . '::' : '') . $name)
                            }
                            $may_need_autoload = 1
                        }
                        (exists($self->{'proto'})) && ($sig = $self->{'proto'})
                    }
                    if ($sig) {
                        my @out = ();
                        my @in = @{$self->{'arguments'} || []};
                        my $close = ']';
                        my $optional = 0;
                        while (length($sig)) {
                            my $c = substr($sig, 0, 1);
                            if ($c eq ';') {
                                $optional = 1
                            }
                            elsif ($c eq '$' || $c eq '_') {
                                (@in || !$optional) && push(@out, shift(@in)->emit_javascript2($level + 1, 'scalar'))
                            }
                            elsif ($c eq '+') {
                                if (@in || !$optional) {
                                    my $in = shift(@in);
                                    if (($in->isa('Perlito5::AST::Apply') && $in->{'code'} eq 'prefix:<@>') || ($in->isa('Perlito5::AST::Var') && $in->sigil() eq '@') || ($in->isa('Perlito5::AST::Apply') && $in->{'code'} eq 'prefix:<%>') || ($in->isa('Perlito5::AST::Var') && $in->sigil() eq '%')) {
                                        push(@out, $in->emit_javascript2($level + 1, 'list'))
                                    }
                                    else {
                                        push(@out, $in->emit_javascript2($level + 1, 'scalar'))
                                    }
                                }
                            }
                            elsif ($c eq '@') {
                                (@in || !$optional) && ($close = '].concat(' . Perlito5::Javascript2::to_list(\@in, $level + 1) . ')');
                                @in = ()
                            }
                            elsif ($c eq '&') {
                                push(@out, shift(@in)->emit_javascript2($level + 1, 'scalar'))
                            }
                            elsif ($c eq '*') {
                                if (@in || !$optional) {
                                    my $arg = shift(@in);
                                    if ($arg->{'bareword'}) {
                                        push(@out, Perlito5::Javascript2::escape_string($arg->{'code'}))
                                    }
                                    else {
                                        push(@out, $arg->emit_javascript2($level + 1, 'scalar'))
                                    }
                                }
                            }
                            elsif ($c eq chr(92)) {
                                if (substr($sig, 0, 2) eq chr(92) . '$') {
                                    $sig = substr($sig, 1);
                                    (@in || !$optional) && push(@out, shift(@in)->emit_javascript2($level + 1, 'scalar'))
                                }
                                elsif (substr($sig, 0, 2) eq chr(92) . '@' || substr($sig, 0, 2) eq chr(92) . '%') {
                                    $sig = substr($sig, 1);
                                    (@in || !$optional) && push(@out, shift(@in)->emit_javascript2($level + 1, 'list'))
                                }
                                elsif (substr($sig, 0, 5) eq chr(92) . '[@%]') {
                                    $sig = substr($sig, 4);
                                    (@in || !$optional) && push(@out, shift(@in)->emit_javascript2($level + 1, 'list'))
                                }
                                elsif (substr($sig, 0, 6) eq chr(92) . '[$@%]') {
                                    $sig = substr($sig, 5);
                                    (@in || !$optional) && push(@out, shift(@in)->emit_javascript2($level + 1, 'list'))
                                }
                            }
                            $sig = substr($sig, 1)
                        }
                        return $code . '([' . join(', ', @out) . $close . ', ' . Perlito5::Javascript2::to_context($wantarray) . ')'
                    }
                    my $arg_list = Perlito5::Javascript2::to_list_preprocess($self->{'arguments'});
                    my $arg_code = $self->{'code'} eq 'scalar' ? '[' . join(', ', map($_->emit_javascript2($level), @{$arg_list})) . ']' : Perlito5::Javascript2::to_list($arg_list);
                    if ($may_need_autoload) {
                        my $name = $self->{'code'};
                        my $namespace = $self->{'namespace'} || $Perlito5::PKG_NAME;
                        return 'p5call_sub(' . Perlito5::Javascript2::escape_string($namespace) . ', ' . Perlito5::Javascript2::escape_string($name) . ', ' . $arg_code . ', ' . Perlito5::Javascript2::to_context($wantarray) . ')'
                    }
                    $code . '(' . $arg_code . ', ' . Perlito5::Javascript2::to_context($wantarray) . ')'
                }
                sub Perlito5::AST::Apply::emit_javascript2_set_list {
                    my($self, $level, $list) = @_;
                    if ($self->code() eq 'undef') {
                        return $list . '.shift()'
                    }
                    if ($self->code() eq 'prefix:<$>') {
                        return 'p5scalar_deref_set(' . Perlito5::Javascript2::emit_javascript2_autovivify($self->{'arguments'}->[0], $level + 1, 'scalar') . ', ' . $list . '.shift()' . ', ' . Perlito5::Javascript2::escape_string($Perlito5::PKG_NAME) . ')'
                    }
                    die('not implemented: assign to ', $self->code())
                }
                sub Perlito5::AST::Apply::emit_javascript2_get_decl {
                    my $self = shift;
                    my $code = $self->{'code'};
                    if ($code eq 'my' || $code eq 'our' || $code eq 'state' || $code eq 'local') {
                        return (map {
                            ref($_) eq 'Perlito5::AST::Var' ? Perlito5::AST::Decl::->new('decl' => $code, 'type' => '', 'var' => $_) : ()
                        } @{$self->{'arguments'}})
                    }
                    if ($code ne 'do' && $code ne 'eval') {
                        $self->{'arguments'} && return (map(+($_->emit_javascript2_get_decl()), @{$self->{'arguments'}}))
                    }
                    return ()
                }
                sub Perlito5::AST::Apply::emit_javascript2_has_regex {
                    my $self = shift;
                    my $code = $self->{'code'};
                    if ($code eq 'p5:m' || $code eq 'p5:s' || $code eq 'infix:<=~>' || $code eq 'infix:<!~>') {
                        return 1
                    }
                    return ()
                }
            }
            package Perlito5::AST::If;
            {
                sub Perlito5::AST::If::emit_javascript2 {
                    my($self, $level, $wantarray) = @_;
                    my $cond = $self->{'cond'};
                    my @str;
                    my $old_level = $level;
                    if ($cond) {
                        my @var_decl = $cond->emit_javascript2_get_decl();
                        for my $arg (@var_decl) {
                            $level = $old_level + 1;
                            push(@str, $arg->emit_javascript2_init($level, $wantarray))
                        }
                    }
                    my $body = ref($self->{'body'}) ne 'Perlito5::AST::Block' ? $self->{'body'} : (!@{$self->{'body'}->stmts()}) ? undef : $wantarray ne 'void' ? Perlito5::Javascript2::LexicalBlock::->new('block' => $self->{'body'}->stmts()) : Perlito5::Javascript2::LexicalBlock::->new('block' => $self->{'body'}->stmts(), 'create_context' => 1);
                    my $otherwise = ref($self->{'otherwise'}) ne 'Perlito5::AST::Block' ? $self->{'otherwise'} : (!@{$self->{'otherwise'}->stmts()}) ? undef : $wantarray ne 'void' ? Perlito5::Javascript2::LexicalBlock::->new('block' => $self->{'otherwise'}->stmts()) : Perlito5::Javascript2::LexicalBlock::->new('block' => $self->{'otherwise'}->stmts(), 'create_context' => 1);
                    my $s = 'if ( ' . Perlito5::Javascript2::to_bool($cond, $level + 1) . ' ) {';
                    if ($body) {
                        $s = $s . chr(10) . Perlito5::Javascript2::tab($level + 1) . $body->emit_javascript2($level + 1, $wantarray) . chr(10) . Perlito5::Javascript2::tab($level) . '}'
                    }
                    else {
                        $s = $s . '}'
                    }
                    if ($otherwise) {
                        if (@{$otherwise->{'block'}} == 1 && ref($otherwise->{'block'}->[0]) eq 'Perlito5::AST::If') {
                            $s = $s . chr(10) . Perlito5::Javascript2::tab($level) . 'else ' . $otherwise->{'block'}->[0]->emit_javascript2($level, $wantarray)
                        }
                        else {
                            $s = $s . chr(10) . Perlito5::Javascript2::tab($level) . 'else {' . chr(10) . Perlito5::Javascript2::tab($level + 1) . $otherwise->emit_javascript2($level + 1, $wantarray) . chr(10) . Perlito5::Javascript2::tab($level) . '}'
                        }
                    }
                    push(@str, $s);
                    if (@str) {
                        $level = $old_level;
                        return ($wantarray ne 'void' ? 'return ' : '') . Perlito5::Javascript2::emit_wrap_javascript2($level, $wantarray, @str)
                    }
                    else {
                        return join(chr(10) . Perlito5::Javascript2::tab($level), @str)
                    }
                }
                sub Perlito5::AST::If::emit_javascript2_get_decl {
                    ()
                }
                sub Perlito5::AST::If::emit_javascript2_has_regex {
                    ()
                }
            }
            package Perlito5::AST::When;
            {
                sub Perlito5::AST::When::emit_javascript2 {
                    my($self, $level, $wantarray) = @_;
                    my $cond = $self->{'cond'};
                    my @str;
                    my $old_level = $level;
                    if ($cond) {
                        my @var_decl = $cond->emit_javascript2_get_decl();
                        for my $arg (@var_decl) {
                            $level = $old_level + 1;
                            push(@str, $arg->emit_javascript2_init($level, $wantarray))
                        }
                    }
                    $cond = Perlito5::AST::Apply::->new('arguments' => [Perlito5::AST::Var::->new('name' => '_', 'namespace' => 'main', 'sigil' => '$'), $cond], 'code' => 'infix:<~~>', 'namespace' => '');
                    my $next = Perlito5::AST::Apply::->new('arguments' => [], 'bareword' => 1, 'code' => 'next', 'namespace' => '');
                    my $body = ref($self->{'body'}) ne 'Perlito5::AST::Block' ? Perlito5::Javascript2::LexicalBlock::->new('block' => [$self->{'body'}]) : (!@{$self->{'body'}->stmts()}) ? undef : $wantarray ne 'void' ? Perlito5::Javascript2::LexicalBlock::->new('block' => $self->{'body'}->stmts()) : Perlito5::Javascript2::LexicalBlock::->new('block' => $self->{'body'}->stmts(), 'create_context' => 1);
                    push(@{$body->{'block'}}, $next);
                    my $s = 'if ( ' . Perlito5::Javascript2::to_bool($cond, $level + 1) . ' ) {';
                    if ($body) {
                        $s = $s . chr(10) . Perlito5::Javascript2::tab($level + 1) . $body->emit_javascript2($level + 1, $wantarray) . chr(10) . Perlito5::Javascript2::tab($level) . '}'
                    }
                    else {
                        $s = $s . '}'
                    }
                    push(@str, $s);
                    if (@str) {
                        $level = $old_level;
                        return ($wantarray ne 'void' ? 'return ' : '') . Perlito5::Javascript2::emit_wrap_javascript2($level, $wantarray, @str)
                    }
                    else {
                        return join(chr(10) . Perlito5::Javascript2::tab($level), @str)
                    }
                }
                sub Perlito5::AST::When::emit_javascript2_get_decl {
                    ()
                }
                sub Perlito5::AST::When::emit_javascript2_has_regex {
                    ()
                }
            }
            package Perlito5::AST::While;
            {
                sub Perlito5::AST::While::emit_javascript2 {
                    my($self, $level, $wantarray) = @_;
                    my $cond = $self->{'cond'};
                    my @str;
                    my $old_level = $level;
                    if ($cond) {
                        my @var_decl = $cond->emit_javascript2_get_decl();
                        for my $arg (@var_decl) {
                            $level = $old_level + 1;
                            push(@str, $arg->emit_javascript2_init($level, $wantarray))
                        }
                    }
                    if (ref($self->{'body'}) eq 'Perlito5::AST::Apply' && $self->{'body'}->{'code'} eq 'do') {
                        push(@str, 'do {' . $self->{'body'}->emit_javascript2($level + 2, $wantarray) . chr(10) . Perlito5::Javascript2::tab($level + 1) . '} while (' . Perlito5::Javascript2::to_bool($cond, $level + 2) . ')')
                    }
                    else {
                        my $body = ref($self->{'body'}) ne 'Perlito5::AST::Block' ? [$self->{'body'}] : $self->{'body'}->{'stmts'};
                        push(@str, 'p5while(' . 'function () {' . chr(10) . Perlito5::Javascript2::tab($level + 2) . (Perlito5::Javascript2::LexicalBlock::->new('block' => $body))->emit_javascript2($level + 2, $wantarray) . chr(10) . Perlito5::Javascript2::tab($level + 1) . '}, ' . Perlito5::Javascript2::emit_function_javascript2($level + 1, 'scalar', $cond) . ', ' . Perlito5::AST::Block::emit_javascript2_continue($self, $level, $wantarray) . ', ' . Perlito5::Javascript2::escape_string($self->{'label'} || '') . ', ' . 0 . ')')
                    }
                    if (@str) {
                        $level = $old_level;
                        return Perlito5::Javascript2::emit_wrap_javascript2($level, $wantarray, @str)
                    }
                    else {
                        return join(chr(10) . Perlito5::Javascript2::tab($level), @str)
                    }
                }
                sub Perlito5::AST::While::emit_javascript2_get_decl {
                    ()
                }
                sub Perlito5::AST::While::emit_javascript2_has_regex {
                    ()
                }
            }
            package Perlito5::AST::For;
            {
                sub Perlito5::AST::For::emit_javascript2 {
                    my($self, $level, $wantarray) = @_;
                    my $body = ref($self->{'body'}) ne 'Perlito5::AST::Block' ? [$self->{'body'}] : $self->{'body'}->{'stmts'};
                    my @str;
                    my $old_level = $level;
                    my $cond = ref($self->{'cond'}) eq 'ARRAY' ? $self->{'cond'} : [$self->{'cond'}];
                    for my $expr (@{$cond}, $self->{'topic'}) {
                        if ($expr) {
                            my @var_decl = $expr->emit_javascript2_get_decl();
                            for my $arg (@var_decl) {
                                $level = $old_level + 1;
                                push(@str, $arg->emit_javascript2_init($level, $wantarray))
                            }
                        }
                    }
                    if (ref($self->{'cond'}) eq 'ARRAY') {
                        push(@str, Perlito5::Javascript2::emit_wrap_javascript2($level, $wantarray, 'var label = ' . Perlito5::Javascript2::escape_string(($self->{'label'} || '')) . ';', 'for ( ' . ($self->{'cond'}->[0] ? $self->{'cond'}->[0]->emit_javascript2($level + 1) . '; ' : '; ') . ($self->{'cond'}->[1] ? Perlito5::Javascript2::to_bool($self->{'cond'}->[1], $level + 1) . '; ' : '; ') . ($self->{'cond'}->[2] ? $self->{'cond'}->[2]->emit_javascript2($level + 1) . ' ' : '') . ') {', ['var _redo;', 'do {', ['_redo = false;', 'try {', [Perlito5::Javascript2::LexicalBlock::->new('block' => $body)->emit_javascript2($level + 4, $wantarray)], '}', 'catch(err) {', ['if (err instanceof p5_error && (err.v == label || err.v == ' . chr(39) . chr(39) . ')) {', ['if (err.type == ' . chr(39) . 'last' . chr(39) . ') { return }', 'else if (err.type == ' . chr(39) . 'redo' . chr(39) . ') { _redo = true }', 'else if (err.type != ' . chr(39) . 'next' . chr(39) . ') { throw(err) }'], '}', 'else {', ['throw(err)'], '}'], '}'], '} while (_redo);'], '}'))
                    }
                    else {
                        my $cond = Perlito5::Javascript2::to_list([$self->{'cond'}], $level + 1);
                        my $topic = $self->{'topic'};
                        my $decl = '';
                        my $v = $topic;
                        if ($v->{'decl'}) {
                            $decl = $v->{'decl'};
                            $v = $v->{'var'}
                        }
                        else {
                            $decl = $v->{'_decl'} || 'global'
                        }
                        my $namespace = $v->{'namespace'} || $v->{'_namespace'} || $Perlito5::PKG_NAME;
                        my $s;
                        if ($decl eq 'my' || $decl eq 'state') {
                            my $sig = $v->emit_javascript2($level + 1);
                            push(@str, '(function(){ ' . 'var ' . $sig . '; ' . 'p5for_lex(' . 'function (v) { ' . $sig . ' = v }, ' . 'function () {' . chr(10) . Perlito5::Javascript2::tab($level + 2) . (Perlito5::Javascript2::LexicalBlock::->new('block' => $body))->emit_javascript2($level + 2, $wantarray) . chr(10) . Perlito5::Javascript2::tab($level + 1) . '}, ' . $cond . ', ' . Perlito5::AST::Block::emit_javascript2_continue($self, $level, $wantarray) . ', ' . Perlito5::Javascript2::escape_string($self->{'label'} || '') . ') ' . '})()')
                        }
                        else {
                            push(@str, 'p5for(' . 'p5make_package(' . Perlito5::Javascript2::escape_string($namespace) . '), ' . '"v_' . $v->{'name'} . '", ' . 'function () {' . chr(10) . Perlito5::Javascript2::tab($level + 2) . (Perlito5::Javascript2::LexicalBlock::->new('block' => $body))->emit_javascript2($level + 2, $wantarray) . chr(10) . Perlito5::Javascript2::tab($level + 1) . '}, ' . $cond . ', ' . Perlito5::AST::Block::emit_javascript2_continue($self, $level, $wantarray) . ', ' . Perlito5::Javascript2::escape_string($self->{'label'} || '') . ')')
                        }
                    }
                    if (@str > 1) {
                        $level = $old_level;
                        return Perlito5::Javascript2::emit_wrap_javascript2($level, $wantarray, @str)
                    }
                    else {
                        return join(chr(10) . Perlito5::Javascript2::tab($level), @str)
                    }
                }
                sub Perlito5::AST::For::emit_javascript2_get_decl {
                    ()
                }
                sub Perlito5::AST::For::emit_javascript2_has_regex {
                    ()
                }
            }
            package Perlito5::AST::Sub;
            {
                sub Perlito5::AST::Sub::emit_javascript2 {
                    my($self, $level, $wantarray) = @_;
                    my $prototype = defined($self->{'sig'}) ? Perlito5::Javascript2::escape_string($self->{'sig'}) : 'null';
                    my $sub_ref = Perlito5::Javascript2::get_label();
                    local $Perlito5::AST::Sub::SUB_REF = $sub_ref;
                    my $js_block = Perlito5::Javascript2::LexicalBlock::->new('block' => $self->{'block'}->{'stmts'})->emit_javascript2_subroutine_body($level + 2, 'runtime');
                    my $s = Perlito5::Javascript2::emit_wrap_javascript2($level, 'scalar', 'var ' . $sub_ref . ';', $sub_ref . ' = function (List__, p5want) {', [$js_block], '};', $sub_ref . '._prototype_ = ' . $prototype . ';', 'return ' . $sub_ref);
                    if ($self->{'name'}) {
                        return 'p5typeglob_set(' . Perlito5::Javascript2::escape_string($self->{'namespace'}) . ', ' . Perlito5::Javascript2::escape_string($self->{'name'}) . ', ' . $s . ')'
                    }
                    else {
                        return $s
                    }
                }
                sub Perlito5::AST::Sub::emit_javascript2_get_decl {
                    ()
                }
                sub Perlito5::AST::Sub::emit_javascript2_has_regex {
                    ()
                }
            }
            package Perlito5::AST::Use;
            {
                sub Perlito5::AST::Use::emit_javascript2 {
                    my($self, $level, $wantarray) = @_;
                    Perlito5::Grammar::Use::emit_time_eval($self);
                    if ($wantarray ne 'void') {
                        return 'p5context([], p5want)'
                    }
                    else {
                        return '// ' . $self->{'code'} . ' ' . $self->{'mod'} . chr(10)
                    }
                }
                sub Perlito5::AST::Use::emit_javascript2_get_decl {
                    ()
                }
                sub Perlito5::AST::Use::emit_javascript2_has_regex {
                    ()
                }
            }
            1
        }
    }
    {
        {
            package main;
            undef();
            package Perlito5::Javascript2::Runtime;
            sub Perlito5::Javascript2::Runtime::perl5_to_js {
                my($source, $namespace, $want, $scope_js) = @_;
                my $strict_old = $Perlito5::STRICT;
                local $_;
                local ${chr(7) . 'LOBAL_PHASE'};
                local $Perlito5::BASE_SCOPE = $scope_js->[0];
                local @Perlito5::SCOPE_STMT;
                local $Perlito5::SCOPE = $Perlito5::BASE_SCOPE;
                local $Perlito5::SCOPE_DEPTH = 0;
                local $Perlito5::PKG_NAME = $namespace;
                local @Perlito5::UNITCHECK_BLOCK;
                my $match = Perlito5::Grammar::exp_stmts($source, 0);
                if (!$match || $match->{'to'} != length($source)) {
                    die('Syntax error in eval near pos ', $match->{'to'})
                }
                my $ast = Perlito5::AST::Apply::->new('code' => 'do', 'arguments' => [Perlito5::AST::Block::->new('stmts' => $match->{'capture'})]);
                my $js_code = $ast->emit_javascript2(0, $want);
                Perlito5::set_global_phase('UNITCHECK');
                $_->()
                    while $_ = shift(@Perlito5::UNITCHECK_BLOCK);
                $Perlito5::STRICT = $strict_old;
                return $js_code
            }
            sub Perlito5::Javascript2::Runtime::emit_javascript2 {
                return '//' . chr(10) . '// lib/Perlito5/Javascript2/Runtime.js' . chr(10) . '//' . chr(10) . '// Runtime for "Perlito" Perl5-in-Javascript2' . chr(10) . '//' . chr(10) . '// AUTHORS' . chr(10) . '//' . chr(10) . '// Flavio Soibelmann Glock  fglock@gmail.com' . chr(10) . '//' . chr(10) . '// COPYRIGHT' . chr(10) . '//' . chr(10) . '// Copyright 2009, 2010, 2011, 2012 by Flavio Soibelmann Glock and others.' . chr(10) . '//' . chr(10) . '// This program is free software; you can redistribute it and/or modify it' . chr(10) . '// under the same terms as Perl itself.' . chr(10) . '//' . chr(10) . '// See http://www.perl.com/perl/misc/Artistic.html' . chr(10) . chr(10) . '"use strict";' . chr(10) . 'var isNode = typeof require != "undefined";' . chr(10) . chr(10) . 'if (typeof p5pkg !== "object") {' . chr(10) . '    var p5pkg = {};' . chr(10) . '    var p5LOCAL = [];' . chr(10) . chr(10) . '    var universal = function () {};' . chr(10) . '    p5pkg.UNIVERSAL = new universal();' . chr(10) . '    p5pkg.UNIVERSAL._ref_ = "UNIVERSAL";' . chr(10) . '    p5pkg.UNIVERSAL.isa = function (List__) {' . chr(10) . '        // TODO - use @ISA' . chr(10) . '        return List__[0]._class_._ref_ == List__[1]' . chr(10) . '    };' . chr(10) . '    p5pkg.UNIVERSAL.can = function (List__) {' . chr(10) . '        var o = List__[0];' . chr(10) . '        var s = List__[1];' . chr(10) . '        if ( s.indexOf("::") == -1 ) {' . chr(10) . '            return p5method_lookup(s, o._class_._ref_, {})' . chr(10) . '        }' . chr(10) . '        var c = s.split("::");' . chr(10) . '        s = c.pop(); ' . chr(10) . '        return p5method_lookup(s, c.join("::"), {});' . chr(10) . '    };' . chr(10) . '    p5pkg.UNIVERSAL.DOES = p5pkg.UNIVERSAL.can;' . chr(10) . chr(10) . '    var core = function () {};' . chr(10) . '    p5pkg["CORE"] = new core();' . chr(10) . '    p5pkg["CORE"]._ref_ = "CORE";' . chr(10) . chr(10) . '    var core_global = function () {};' . chr(10) . '    core_global.prototype = p5pkg.CORE;' . chr(10) . '    p5pkg["CORE::GLOBAL"] = new core_global();' . chr(10) . '    p5pkg["CORE::GLOBAL"]._ref_ = "CORE::GLOBAL";' . chr(10) . chr(10) . '    var p5_error = function (type, v) {' . chr(10) . '        this.type = type;' . chr(10) . '        this.v = this.message = v;' . chr(10) . '        this.toString = function(){' . chr(10) . '            if (this.type == ' . chr(39) . 'break' . chr(39) . ') {' . chr(10) . '                return ' . chr(39) . 'Can' . chr(92) . chr(39) . 't "break" outside a given block' . chr(39) . chr(10) . '            }' . chr(10) . '            if (this.type == ' . chr(39) . 'next' . chr(39) . ' || this.type == ' . chr(39) . 'last' . chr(39) . ' || this.type == ' . chr(39) . 'redo' . chr(39) . ') {' . chr(10) . '                if (this.v == "") { return ' . chr(39) . 'Can' . chr(92) . chr(39) . 't "' . chr(39) . ' + this.type + ' . chr(39) . '" outside a loop block' . chr(39) . ' }' . chr(10) . '                return ' . chr(39) . 'Label not found for "' . chr(39) . ' + this.type + ' . chr(39) . ' ' . chr(39) . ' + this.v + ' . chr(39) . '"' . chr(39) . ';' . chr(10) . '            }' . chr(10) . '            return this.v;' . chr(10) . '        };' . chr(10) . '    };' . chr(10) . '    p5_error.prototype = Error.prototype;' . chr(10) . '}' . chr(10) . chr(10) . 'function p5make_package(pkg_name) {' . chr(10) . '    if (!p5pkg.hasOwnProperty(pkg_name)) {' . chr(10) . '        var tmp = function () {};' . chr(10) . '        tmp.prototype = p5pkg["CORE::GLOBAL"];' . chr(10) . '        p5pkg[pkg_name] = new tmp();' . chr(10) . '        p5pkg[pkg_name]._ref_ = pkg_name;' . chr(10) . '        p5pkg[pkg_name]._class_ = p5pkg[pkg_name];  // XXX memory leak' . chr(10) . '        p5pkg[pkg_name]._is_package_ = 1;' . chr(10) . chr(10) . '        // TODO - add the other package global variables' . chr(10) . '        p5pkg[pkg_name]["List_ISA"] = [];' . chr(10) . '        p5pkg[pkg_name]["v_a"] = null;' . chr(10) . '        p5pkg[pkg_name]["v_b"] = null;' . chr(10) . '        p5pkg[pkg_name]["v__"] = null;' . chr(10) . '        p5pkg[pkg_name]["v_AUTOLOAD"] = null;' . chr(10) . '    }' . chr(10) . '    return p5pkg[pkg_name];' . chr(10) . '}' . chr(10) . chr(10) . 'function p5code_lookup_by_name(package_name, sub_name) {' . chr(10) . '    // sub_name can be a function already' . chr(10) . '    if (typeof sub_name === "function") {' . chr(10) . '        return sub_name;' . chr(10) . '    }' . chr(10) . '    // sub_name can have an optional namespace' . chr(10) . '    var parts = sub_name.split(/::/);' . chr(10) . '    if (parts.length > 1) {' . chr(10) . '        sub_name = parts.pop();' . chr(10) . '        package_name = parts.join("::");' . chr(10) . '    }' . chr(10) . '    if (p5pkg.hasOwnProperty(package_name)) {' . chr(10) . '        var c = p5pkg[package_name];' . chr(10) . '        if ( c.hasOwnProperty(sub_name) ) {' . chr(10) . '            return c[sub_name]' . chr(10) . '        }' . chr(10) . '    }' . chr(10) . '    return null;' . chr(10) . '}' . chr(10) . chr(10) . 'function p5get_class_for_method(method, class_name, seen) {' . chr(10) . '    // default mro' . chr(10) . '    // TODO - cache the methods that were already looked up' . chr(10) . '    if ( p5pkg[class_name].hasOwnProperty(method) ) {' . chr(10) . '        return class_name' . chr(10) . '    }' . chr(10) . '    var isa = p5pkg[class_name].List_ISA;' . chr(10) . '    if (isa) {' . chr(10) . '        for (var i = 0; i < isa.length; i++) {' . chr(10) . '            if (!seen[isa[i]]) {' . chr(10) . '                var m = p5get_class_for_method(method, isa[i], seen);' . chr(10) . '                if (m) {' . chr(10) . '                    return m ' . chr(10) . '                }' . chr(10) . '                seen[isa[i]]++;' . chr(10) . '            }' . chr(10) . '        }' . chr(10) . '    }' . chr(10) . '}' . chr(10) . chr(10) . 'function p5method_lookup(method, class_name, seen) {' . chr(10) . '    var c = p5get_class_for_method(method, class_name, seen);' . chr(10) . '    if (c) {' . chr(10) . '        return p5pkg[c][method]' . chr(10) . '    }' . chr(10) . '    if ( p5pkg.UNIVERSAL.hasOwnProperty(method) ) {' . chr(10) . '        return p5pkg.UNIVERSAL[method]' . chr(10) . '    }' . chr(10) . '}' . chr(10) . chr(10) . 'function p5method_not_found(method, class_name) {' . chr(10) . '    return "Can' . chr(39) . 't locate object method ' . chr(92) . '""' . chr(10) . '        + method + "' . chr(92) . '" via package ' . chr(92) . '"" + class_name + "' . chr(92) . '" (perhaps you forgot to load ' . chr(92) . '""' . chr(10) . '        + class_name + "' . chr(92) . '"?)";' . chr(10) . '}' . chr(10) . chr(10) . 'function p5call(invocant, method, list, p5want) {' . chr(10) . '    var invocant_original = invocant;' . chr(10) . '    if (typeof invocant === "string") {' . chr(10) . '        list.unshift(invocant);' . chr(10) . '        invocant = p5make_package(invocant);' . chr(10) . '    }' . chr(10) . '    else if ( invocant.hasOwnProperty("_is_package_") ) {' . chr(10) . '        list.unshift(invocant._ref_);   // invocant is a "package" object' . chr(10) . '    }' . chr(10) . '    else {' . chr(10) . '        list.unshift(invocant);' . chr(10) . '    }' . chr(10) . chr(10) . '    if ( invocant.hasOwnProperty("_class_") ) {' . chr(10) . chr(10) . '        if ( invocant._class_.hasOwnProperty(method) ) {' . chr(10) . '            return invocant._class_[method](list, p5want)' . chr(10) . '        }' . chr(10) . '        var m = p5method_lookup(method, invocant._class_._ref_, {});' . chr(10) . '        if (m) {' . chr(10) . '            return m(list, p5want)' . chr(10) . '        }' . chr(10) . chr(10) . '        // method can have an optional namespace' . chr(10) . '        var pkg_name = method.split(/::/);' . chr(10) . '        if (pkg_name.length > 1) {' . chr(10) . '            var name = pkg_name.pop();' . chr(10) . '            pkg_name = pkg_name.join("::");' . chr(10) . '            m = p5method_lookup(name, pkg_name, {});' . chr(10) . '            if (m) {' . chr(10) . '                return m(list, p5want)' . chr(10) . '            }' . chr(10) . '            p5pkg.CORE.die([p5method_not_found(name, pkg_name)]);' . chr(10) . '        }' . chr(10) . chr(10) . '        if (method == "print" || method == "printf" || method == "say" || method == "close") {' . chr(10) . '            list.shift();' . chr(10) . '            return p5pkg[' . chr(39) . 'Perlito5::IO' . chr(39) . '][method]( invocant_original, list, p5want);' . chr(10) . '        }' . chr(10) . chr(10) . '        pkg_name = p5get_class_for_method(' . chr(39) . 'AUTOLOAD' . chr(39) . ', invocant._class_._ref_, {}) || p5get_class_for_method(' . chr(39) . 'AUTOLOAD' . chr(39) . ', "UNIVERSAL", {});' . chr(10) . '        if (pkg_name) {' . chr(10) . '            p5pkg[pkg_name]["v_AUTOLOAD"] = invocant._class_._ref_ + "::" + method;' . chr(10) . '            return p5pkg[pkg_name]["AUTOLOAD"](list, p5want);' . chr(10) . '        }' . chr(10) . '        p5pkg.CORE.die([p5method_not_found(method, invocant._class_._ref_)]);' . chr(10) . '    }' . chr(10) . '    p5pkg.CORE.die(["Can' . chr(39) . 't call method ", method, " on unblessed reference"]);' . chr(10) . '}' . chr(10) . chr(10) . 'function p5call_sub(namespace, name, list, p5want) {' . chr(10) . '    if(p5pkg[namespace].hasOwnProperty(name)) {' . chr(10) . '        return p5pkg[namespace][name](list, p5want)' . chr(10) . '    }' . chr(10) . '    if(p5pkg[namespace].hasOwnProperty("AUTOLOAD")) {' . chr(10) . '        p5pkg[namespace]["v_AUTOLOAD"] = namespace + "::" + name;' . chr(10) . '        return p5pkg[namespace]["AUTOLOAD"](list, p5want)' . chr(10) . '    }' . chr(10) . '    p5pkg.CORE.die(["Undefined subroutine &" + namespace + "::" + name]);' . chr(10) . '}' . chr(10) . chr(10) . 'function p5sub_exists(name, current_pkg_name) {' . chr(10) . '    var v = name;' . chr(10) . '    var pkg_name = v.split(/::/);' . chr(10) . '    if (pkg_name.length > 1) {' . chr(10) . '        v = pkg_name.pop();' . chr(10) . '        pkg_name = pkg_name.join("::");' . chr(10) . '    }' . chr(10) . '    else {' . chr(10) . '        pkg_name = current_pkg_name;' . chr(10) . '    }' . chr(10) . '    var c = v.charCodeAt(0);' . chr(10) . '    if (c < 27) {' . chr(10) . '        pkg_name = ' . chr(39) . 'main' . chr(39) . ';' . chr(10) . '    }' . chr(10) . '    return p5pkg.hasOwnProperty(pkg_name) && p5pkg[pkg_name].hasOwnProperty(v) ' . chr(10) . '}' . chr(10) . chr(10) . 'function p5sub_prototype(name, current_pkg_name) {' . chr(10) . '    if (!name) {' . chr(10) . '        return null;' . chr(10) . '    }' . chr(10) . '    if (typeof name === "function") {' . chr(10) . '        return name._prototype_;' . chr(10) . '    }' . chr(10) . '    var v = name;' . chr(10) . '    var pkg_name = v.split(/::/);' . chr(10) . '    if (pkg_name.length > 1) {' . chr(10) . '        v = pkg_name.pop();' . chr(10) . '        pkg_name = pkg_name.join("::");' . chr(10) . '    }' . chr(10) . '    else {' . chr(10) . '        pkg_name = current_pkg_name;' . chr(10) . '    }' . chr(10) . '    var c = v.charCodeAt(0);' . chr(10) . '    if (c < 27) {' . chr(10) . '        pkg_name = ' . chr(39) . 'main' . chr(39) . ';' . chr(10) . '    }' . chr(10) . '    if (p5pkg.hasOwnProperty(pkg_name) && p5pkg[pkg_name].hasOwnProperty(v)) {' . chr(10) . '        return p5pkg[pkg_name][v]._prototype_' . chr(10) . '    }' . chr(10) . '    return p5pkg["Perlito5"].v_PROTO._hash_[name] || p5pkg["Perlito5"].v_CORE_PROTO._hash_[name]' . chr(10) . '}' . chr(10) . chr(10) . 'function p5scalar_deref(v, current_pkg_name, autoviv_type) {' . chr(10) . '    if (typeof v === "string") {' . chr(10) . '        var pkg_name = v.split(/::/);' . chr(10) . '        if (pkg_name.length > 1) {' . chr(10) . '            v = pkg_name.pop();' . chr(10) . '            pkg_name = pkg_name.join("::");' . chr(10) . '        }' . chr(10) . '        else {' . chr(10) . '            pkg_name = current_pkg_name;' . chr(10) . '        }' . chr(10) . '        var c = v.charCodeAt(0);' . chr(10) . '        if (c < 27) {' . chr(10) . '            pkg_name = ' . chr(39) . 'main' . chr(39) . ';' . chr(10) . '        }' . chr(10) . '        var name = "v_"+v;' . chr(10) . '        if (!p5make_package(pkg_name)[name]) {' . chr(10) . '            if (autoviv_type == ' . chr(39) . 'array' . chr(39) . ') {' . chr(10) . '                p5pkg[pkg_name][name] = new p5ArrayRef([]);' . chr(10) . '            }' . chr(10) . '            else if (autoviv_type == ' . chr(39) . 'hash' . chr(39) . ') {' . chr(10) . '                p5pkg[pkg_name][name] = new p5HashRef([]);' . chr(10) . '            }' . chr(10) . '            else if (autoviv_type == ' . chr(39) . 'scalar' . chr(39) . ') {' . chr(10) . '                p5pkg[pkg_name][name] = new p5ScalarRef([]);' . chr(10) . '            }' . chr(10) . '        }' . chr(10) . '        return p5pkg[pkg_name][name];' . chr(10) . '    }' . chr(10) . '    if (!v._scalar_) {' . chr(10) . '        if (autoviv_type == ' . chr(39) . 'array' . chr(39) . ') {' . chr(10) . '            v._scalar_ = new p5ArrayRef([]);' . chr(10) . '        }' . chr(10) . '        else if (autoviv_type == ' . chr(39) . 'hash' . chr(39) . ') {' . chr(10) . '            v._scalar_ = new p5HashRef([]);' . chr(10) . '        }' . chr(10) . '        else if (autoviv_type == ' . chr(39) . 'scalar' . chr(39) . ') {' . chr(10) . '            v._scalar_ = new p5ScalarRef([]);' . chr(10) . '        }' . chr(10) . '    }' . chr(10) . '    return v._scalar_;' . chr(10) . '}' . chr(10) . chr(10) . 'function p5scalar_deref_set(v, n, current_pkg_name) {' . chr(10) . '    if (typeof v === "string") {' . chr(10) . '        var pkg_name = v.split(/::/);' . chr(10) . '        if (pkg_name.length > 1) {' . chr(10) . '            v = pkg_name.pop();' . chr(10) . '            pkg_name = pkg_name.join("::");' . chr(10) . '        }' . chr(10) . '        else {' . chr(10) . '            pkg_name = current_pkg_name;' . chr(10) . '        }' . chr(10) . '        var c = v.charCodeAt(0);' . chr(10) . '        if (c < 27) {' . chr(10) . '            pkg_name = ' . chr(39) . 'main' . chr(39) . ';' . chr(10) . '        }' . chr(10) . '        var name = "v_"+v;' . chr(10) . '        p5make_package(pkg_name)[name] = n;' . chr(10) . '        return p5pkg[pkg_name][name];' . chr(10) . '    }' . chr(10) . '    v._scalar_ = n;' . chr(10) . '    return v._scalar_;' . chr(10) . '}' . chr(10) . chr(10) . 'function p5array_deref(v, current_pkg_name) {' . chr(10) . '    if (typeof v === "string") {' . chr(10) . '        var pkg_name = v.split(/::/);' . chr(10) . '        if (pkg_name.length > 1) {' . chr(10) . '            v = pkg_name.pop();' . chr(10) . '            pkg_name = pkg_name.join("::");' . chr(10) . '        }' . chr(10) . '        else {' . chr(10) . '            pkg_name = current_pkg_name;' . chr(10) . '        }' . chr(10) . '        var c = v.charCodeAt(0);' . chr(10) . '        if (c < 27) {' . chr(10) . '            pkg_name = ' . chr(39) . 'main' . chr(39) . ';' . chr(10) . '        }' . chr(10) . '        var name = "List_"+v;' . chr(10) . '        if (!p5make_package(pkg_name)[name]) {' . chr(10) . '                p5pkg[pkg_name][name] = [];' . chr(10) . '        }' . chr(10) . '        return p5pkg[pkg_name][name];' . chr(10) . '    }' . chr(10) . '    return v._array_;' . chr(10) . '}' . chr(10) . chr(10) . 'function p5hash_deref(v, current_pkg_name) {' . chr(10) . '    if (typeof v === "string") {' . chr(10) . '        var pkg_name = v.split(/::/);' . chr(10) . '        if (pkg_name.length > 1) {' . chr(10) . '            v = pkg_name.pop();' . chr(10) . '            pkg_name = pkg_name.join("::");' . chr(10) . '        }' . chr(10) . '        else {' . chr(10) . '            pkg_name = current_pkg_name;' . chr(10) . '        }' . chr(10) . '        var c = v.charCodeAt(0);' . chr(10) . '        if (c < 27) {' . chr(10) . '            pkg_name = ' . chr(39) . 'main' . chr(39) . ';' . chr(10) . '        }' . chr(10) . '        var name = "Hash_"+v;' . chr(10) . '        if (!p5make_package(pkg_name)[name]) {' . chr(10) . '                p5pkg[pkg_name][name] = [];' . chr(10) . '        }' . chr(10) . '        return p5pkg[pkg_name][name];' . chr(10) . '    }' . chr(10) . '    return v._hash_;' . chr(10) . '}' . chr(10) . chr(10) . '// regex globals' . chr(10) . 'p5make_package("Regex");' . chr(10) . 'var p5_last_regex = new RegExp("", "");' . chr(10) . 'var p5_regex_capture = [];' . chr(10) . chr(10) . 'p5make_package("main");' . chr(10) . 'p5make_package("Perlito5");' . chr(10) . 'p5pkg["Perlito5"].v_PKG_NAME = "main";' . chr(10) . 'p5make_package("main::STDIN").file_handle = { id : 0, readline_buffer : ' . chr(39) . chr(39) . ' };' . chr(10) . 'p5make_package("main::STDOUT").file_handle = { id : 1 };' . chr(10) . 'p5make_package("main::STDERR").file_handle = { id : 2 };' . chr(10) . 'p5make_package("main::STDIN")[' . chr(39) . 'List_ISA' . chr(39) . '] = [' . chr(39) . 'Perlito5::IO' . chr(39) . '];' . chr(10) . '// p5make_package("main::STDOUT")[' . chr(39) . 'List_ISA' . chr(39) . '] = [' . chr(39) . 'Perlito5::IO' . chr(39) . '];' . chr(10) . '// p5make_package("main::STDERR")[' . chr(39) . 'List_ISA' . chr(39) . '] = [' . chr(39) . 'Perlito5::IO' . chr(39) . '];' . chr(10) . 'p5make_package("ARGV").file_handle = { id : null };' . chr(10) . 'p5make_package("main")["STDOUT"] = p5pkg["main::STDOUT"];' . chr(10) . 'p5make_package("main")["STDERR"] = p5pkg["main::STDERR"];' . chr(10) . 'p5make_package("main")["STDIN"] = p5pkg["main::STDIN"];' . chr(10) . 'p5pkg["STDOUT"] = p5pkg["main::STDOUT"];' . chr(10) . 'p5pkg["STDERR"] = p5pkg["main::STDERR"];' . chr(10) . 'p5pkg["STDIN"] = p5pkg["main::STDIN"];' . chr(10) . 'p5pkg["Perlito5"].v_SELECT = "main::STDOUT";' . chr(10) . 'p5pkg["main"]["v_@"] = [];      // $@' . chr(10) . 'p5pkg["main"]["v_|"] = 0;       // $|' . chr(10) . 'p5pkg["main"]["v_/"] = "' . chr(92) . 'n";    // $/' . chr(10) . 'p5pkg["main"][' . chr(39) . 'v_"' . chr(39) . '] = " ";     // $"' . chr(10) . 'p5pkg["main"]["List_#"] = [];   // @#' . chr(10) . 'p5scalar_deref_set(String.fromCharCode(15), isNode ? "node.js" : "javascript2");  // $^O' . chr(10) . 'p5pkg["main"]["List_INC"] = [];' . chr(10) . 'p5pkg["main"]["Hash_INC"] = {};' . chr(10) . 'p5pkg["main"]["List_ARGV"] = [];' . chr(10) . 'p5pkg["main"]["Hash_ENV"] = {};' . chr(10) . 'p5pkg["main"]["Hash_SIG"] = {};' . chr(10) . 'if (isNode) {' . chr(10) . '    p5pkg["main"]["List_ARGV"] = process.argv.splice(2);' . chr(10) . chr(10) . '    p5pkg["main"]["Hash_ENV"] = {};' . chr(10) . '    for (var e in process.env) p5pkg["main"]["Hash_ENV"][e] = process.env[e];' . chr(10) . chr(10) . '    p5pkg["main"]["v_$"] = process.pid;   // $$' . chr(10) . '    p5scalar_deref_set(String.fromCharCode(24), process.argv[0]);  // $^X' . chr(10) . '} else if (typeof arguments === "object") {' . chr(10) . '    p5pkg["main"]["List_ARGV"] = arguments;' . chr(10) . '}' . chr(10) . chr(10) . 'p5make_package("Perlito5::IO");' . chr(10) . 'p5make_package("Perlito5::Runtime");' . chr(10) . 'p5make_package("Perlito5::Grammar");' . chr(10) . chr(10) . 'var sigils = { ' . chr(39) . '@' . chr(39) . ' : ' . chr(39) . 'List_' . chr(39) . ', ' . chr(39) . '%' . chr(39) . ' : ' . chr(39) . 'Hash_' . chr(39) . ', ' . chr(39) . '$' . chr(39) . ' : ' . chr(39) . 'v_' . chr(39) . ', ' . chr(39) . '&' . chr(39) . ' : ' . chr(39) . chr(39) . ' };' . chr(10) . chr(10) . 'function p5typeglob_set(namespace, name, obj) {' . chr(10) . '    p5make_package(namespace);' . chr(10) . '    if ( obj.hasOwnProperty("_ref_") ) {' . chr(10) . '        if ( obj._ref_ == "HASH" ) {' . chr(10) . '            p5pkg[namespace][sigils[' . chr(39) . '%' . chr(39) . '] + name] = obj._hash_;' . chr(10) . '        }' . chr(10) . '        else if ( obj._ref_ == "ARRAY" ) {' . chr(10) . '            p5pkg[namespace][sigils[' . chr(39) . '@' . chr(39) . '] + name] = obj._array_;' . chr(10) . '        }' . chr(10) . '        else if ( obj._ref_ == "SCALAR" ) {' . chr(10) . '            p5pkg[namespace][sigils[' . chr(39) . '$' . chr(39) . '] + name] = obj._scalar_;' . chr(10) . '        }' . chr(10) . '        else if ( obj._ref_ == "CODE" ) {' . chr(10) . '            p5pkg[namespace][sigils[' . chr(39) . '&' . chr(39) . '] + name] = obj._code_;' . chr(10) . '        }' . chr(10) . '        else if ( obj._ref_ == "GLOB" ) {' . chr(10) . '            // TODO' . chr(10) . '            p5pkg[namespace][name] = obj;' . chr(10) . '        }' . chr(10) . '    }' . chr(10) . '    else {' . chr(10) . '        p5pkg[namespace][name] = obj;   // native CODE' . chr(10) . '        // TODO - non-reference' . chr(10) . '    }' . chr(10) . '    return p5pkg[namespace][name];  // TODO - return GLOB' . chr(10) . '}' . chr(10) . chr(10) . 'function p5typeglob_deref_set(v, obj, current_pkg_name) {' . chr(10) . '    if (typeof v === "string") {' . chr(10) . '        var pkg_name = v.split(/::/);' . chr(10) . '        if (pkg_name.length > 1) {' . chr(10) . '            v = pkg_name.pop();' . chr(10) . '            pkg_name = pkg_name.join("::");' . chr(10) . '        }' . chr(10) . '        else {' . chr(10) . '            pkg_name = current_pkg_name;' . chr(10) . '        }' . chr(10) . '        return p5typeglob_set(pkg_name, v, obj);' . chr(10) . '    }' . chr(10) . '    CORE.die(["TODO: can' . chr(39) . 't p5typeglob_deref_set()"]);' . chr(10) . '}' . chr(10) . chr(10) . 'function p5cleanup_local(idx, value) {' . chr(10) . '    while (p5LOCAL.length > idx) {' . chr(10) . '        var l = p5LOCAL.pop();' . chr(10) . '        l();' . chr(10) . '    }' . chr(10) . '    return value;' . chr(10) . '}' . chr(10) . chr(10) . '//-------- Reference' . chr(10) . chr(10) . 'var p5id = Math.floor(Math.random() * 1000000000) + 1000000000;' . chr(10) . chr(10) . 'function p5HashRef(o) {' . chr(10) . '    this._hash_ = o;' . chr(10) . '    this._ref_ = "HASH";' . chr(10) . '    this.bool = function() { return 1 };' . chr(10) . '}' . chr(10) . chr(10) . 'function p5ArrayRef(o) {' . chr(10) . '    this._array_ = o;' . chr(10) . '    this._ref_ = "ARRAY";' . chr(10) . '    this.bool = function() { return 1 };' . chr(10) . '}' . chr(10) . chr(10) . 'function p5ScalarRef(o) {' . chr(10) . '    this._scalar_ = o;' . chr(10) . '    this._ref_ = "SCALAR";' . chr(10) . '    this.bool = function() { return 1 };' . chr(10) . '}' . chr(10) . chr(10) . 'function p5GlobRef(o) {' . chr(10) . '    this._scalar_ = o;' . chr(10) . '    this._ref_ = "GLOB";' . chr(10) . '    this.bool = function() { return 1 };' . chr(10) . '}' . chr(10) . chr(10) . 'function p5CodeRef(o) {' . chr(10) . '    this._code_ = o;' . chr(10) . '    this._ref_ = "CODE";' . chr(10) . '    this.bool = function() { return 1 };' . chr(10) . '}' . chr(10) . chr(10) . '//-------- Hash ' . chr(10) . chr(10) . 'Object.defineProperty( Object.prototype, "p5hget", {' . chr(10) . '    enumerable : false,' . chr(10) . '    value : function (i) { return this[i] }' . chr(10) . '});' . chr(10) . 'Object.defineProperty( Object.prototype, "p5hset", {' . chr(10) . '    enumerable : false,' . chr(10) . '    value : function (i, v) { this[i] = v; return this[i] }' . chr(10) . '});' . chr(10) . chr(10) . 'Object.defineProperty( Object.prototype, "p5incr", {' . chr(10) . '    enumerable : false,' . chr(10) . '    value : function (i) {' . chr(10) . '        this[i] = p5incr_(this[i]);' . chr(10) . '        return this[i];' . chr(10) . '    }' . chr(10) . '});' . chr(10) . 'Object.defineProperty( Object.prototype, "p5postincr", {' . chr(10) . '    enumerable : false,' . chr(10) . '    value : function (i) {' . chr(10) . '        var v = this[i];' . chr(10) . '        this[i] = p5incr_(this[i]);' . chr(10) . '        return v;' . chr(10) . '    }' . chr(10) . '});' . chr(10) . 'Object.defineProperty( Object.prototype, "p5decr", {' . chr(10) . '    enumerable : false,' . chr(10) . '    value : function (i) {' . chr(10) . '        this[i] = p5decr_(this[i]);' . chr(10) . '        return this[i];' . chr(10) . '    }' . chr(10) . '});' . chr(10) . 'Object.defineProperty( Object.prototype, "p5postdecr", {' . chr(10) . '    enumerable : false,' . chr(10) . '    value : function (i) {' . chr(10) . '        var v = this[i];' . chr(10) . '        this[i] = p5decr_(this[i]);' . chr(10) . '        return v;' . chr(10) . '    }' . chr(10) . '});' . chr(10) . chr(10) . 'Object.defineProperty( Object.prototype, "p5hget_array", {' . chr(10) . '    enumerable : false,' . chr(10) . '    value : function (i) {' . chr(10) . '        if (this[i] == null) { this[i] = new p5ArrayRef([]) }' . chr(10) . '        return this[i]' . chr(10) . '    }' . chr(10) . '});' . chr(10) . 'Object.defineProperty( Object.prototype, "p5hget_hash", {' . chr(10) . '    enumerable : false,' . chr(10) . '    value : function (i) {' . chr(10) . '        if (this[i] == null) { this[i] = new p5HashRef({}) }' . chr(10) . '        return this[i]' . chr(10) . '    }' . chr(10) . '});' . chr(10) . chr(10) . '//-------' . chr(10) . chr(10) . chr(10) . 'var p5context = function(List__, p5want) {' . chr(10) . '    if (p5want) {' . chr(10) . '        return p5list_to_a(List__);' . chr(10) . '    }' . chr(10) . '    // scalar: return the last value' . chr(10) . '    var o = List__;' . chr(10) . '    if (o instanceof Array) {' . chr(10) . '        o =   o.length' . chr(10) . '            ? o[o.length-1]' . chr(10) . '            : null;' . chr(10) . '    }' . chr(10) . '    if (o instanceof Array) {' . chr(10) . '        o =   o.length' . chr(10) . '    }' . chr(10) . '    return o;' . chr(10) . '}' . chr(10) . chr(10) . 'var p5list_to_a = function(args) {' . chr(10) . '    var res = [];' . chr(10) . '    for (var i = 0; i < args.length; i++) {' . chr(10) . '        var o = args[i];' . chr(10) . '        if  (  o == null' . chr(10) . '            || o._class_    // perl5 blessed reference' . chr(10) . '            || o._ref_      // perl5 un-blessed reference' . chr(10) . '            )' . chr(10) . '        {' . chr(10) . '            res.push(o);' . chr(10) . '        }' . chr(10) . '        else if (o instanceof Array) {' . chr(10) . '            // perl5 array' . chr(10) . '            for (var j = 0; j < o.length; j++) {' . chr(10) . '                res.push(o[j]);' . chr(10) . '            }' . chr(10) . '        }' . chr(10) . '        else if (typeof o === "object") {' . chr(10) . '            // perl5 hash' . chr(10) . '            for(var j in o) {' . chr(10) . '                if (o.hasOwnProperty(j)) {' . chr(10) . '                    res.push(j);' . chr(10) . '                    res.push(o[j]);' . chr(10) . '                }' . chr(10) . '            }' . chr(10) . '        }' . chr(10) . '        else {' . chr(10) . '            // non-ref' . chr(10) . '            res.push(o);' . chr(10) . '        }' . chr(10) . '    }' . chr(10) . '    return res;' . chr(10) . '};' . chr(10) . chr(10) . 'var p5_list_of_refs = function(a) {' . chr(10) . '    // implements ' . chr(92) . '( @a )' . chr(10) . '    var res = [];' . chr(10) . '    for (var i = 0; i < a.length; i++) {' . chr(10) . '        res.push(new p5ScalarRef(a[i]));' . chr(10) . '    }' . chr(10) . '    return res;' . chr(10) . '};' . chr(10) . chr(10) . 'var p5a_to_h = function(a) {' . chr(10) . '    var res = {};' . chr(10) . '    for (var i = 0; i < a.length; i+=2) {' . chr(10) . '        res[p5str(a[i])] = a[i+1];' . chr(10) . '    }' . chr(10) . '    return res;' . chr(10) . '};' . chr(10) . chr(10) . 'var p5idx = function(a, i) {' . chr(10) . '    return i >= 0 ? i : a.length + i' . chr(10) . '};' . chr(10) . chr(10) . 'var p5smrt_scalar = function(a1, a2) {' . chr(10) . '    if (a2 == null) {' . chr(10) . '        return a1 == null;' . chr(10) . '    }' . chr(10) . '    if (typeof a2 == "string") {' . chr(10) . '        return p5str(a1) == a2;' . chr(10) . '    }' . chr(10) . '    if (typeof a2 == "number") {' . chr(10) . '        return p5num(a1) == a2;' . chr(10) . '    }' . chr(10) . '    CORE.die("Not implemented: smartmatch operator with argument type ' . chr(39) . '", (typeof a2), "' . chr(39) . '");' . chr(10) . '};' . chr(10) . chr(10) . 'var p5str = function(o) {' . chr(10) . '    if (o == null) {' . chr(10) . '        return "";' . chr(10) . '    }' . chr(10) . '    if (typeof o === "object") {' . chr(10) . '        if (o instanceof Array) {' . chr(10) . '            return CORE.join([""].concat(o));' . chr(10) . '        }' . chr(10) . '        if ( o.hasOwnProperty("_ref_") ) {' . chr(10) . '            var class_name = ' . chr(39) . chr(39) . ';' . chr(10) . '            if (o._class_ && typeof o._class_._ref_ === "string") {' . chr(10) . '                // blessed reference' . chr(10) . '                // test for overload' . chr(10) . '                var meth = p5method_lookup(' . chr(39) . '(""' . chr(39) . ', o._class_._ref_, {});' . chr(10) . '                if (meth) {' . chr(10) . '                    return p5str(meth([o], 0));' . chr(10) . '                }' . chr(10) . '                // TODO - test the "fallback" flag' . chr(10) . '                meth = p5method_lookup(' . chr(39) . '(0+' . chr(39) . ', o._class_._ref_, {});' . chr(10) . '                if (meth) {' . chr(10) . '                    return p5str(meth([o], 0));' . chr(10) . '                }' . chr(10) . '                // no overload, strigify the reference instead' . chr(10) . '                class_name = o._class_._ref_ + ' . chr(39) . '=' . chr(39) . ';' . chr(10) . '            }' . chr(10) . '            if (!o._id_) { o._id_ = p5id++ }' . chr(10) . '            return [class_name, o._ref_, ' . chr(39) . '(0x' . chr(39) . ', o._id_.toString( 16 ), ' . chr(39) . ')' . chr(39) . '].join(' . chr(39) . chr(39) . ');' . chr(10) . '        }' . chr(10) . '    }' . chr(10) . '    if (typeof o === "function") {' . chr(10) . '        var class_name = ' . chr(39) . chr(39) . ';' . chr(10) . '        if (o._class_ && typeof o._class_._ref_ === "string") {' . chr(10) . '            // blessed reference' . chr(10) . '            class_name = o._class_._ref_ + ' . chr(39) . '=' . chr(39) . ';' . chr(10) . '        }' . chr(10) . '        if (!o._id_) { o._id_ = p5id++ }' . chr(10) . '        return [class_name, ' . chr(39) . 'CODE(0x' . chr(39) . ', o._id_.toString( 16 ), ' . chr(39) . ')' . chr(39) . '].join(' . chr(39) . chr(39) . ');' . chr(10) . '    }' . chr(10) . '    if (typeof o == "number" && Math.abs(o) < 0.0001 && o != 0) {' . chr(10) . '        return o.toExponential().replace(/e-(' . chr(92) . 'd)$/,"e-0$1");' . chr(10) . '    }' . chr(10) . '    if (typeof o === "boolean") {' . chr(10) . '        return o ? "1" : "";' . chr(10) . '    }' . chr(10) . '    if (typeof o !== "string") {' . chr(10) . '        return "" + o;' . chr(10) . '    }' . chr(10) . '    return o;' . chr(10) . '};' . chr(10) . chr(10) . 'var p5num = function(o) {' . chr(10) . '    if (o == null) {' . chr(10) . '        return 0;' . chr(10) . '    }' . chr(10) . '    if (typeof o === "object") {' . chr(10) . '        if (o instanceof Array) {' . chr(10) . '            return o.length;' . chr(10) . '        }' . chr(10) . '        if ( o.hasOwnProperty("_ref_") ) {' . chr(10) . '            if (o._class_ && typeof o._class_._ref_ === "string") {' . chr(10) . '                // blessed reference' . chr(10) . '                // test for overload' . chr(10) . '                var meth = p5method_lookup(' . chr(39) . '(0+' . chr(39) . ', o._class_._ref_, {});' . chr(10) . '                if (meth) {' . chr(10) . '                    return p5num(meth([o], 0));' . chr(10) . '                }' . chr(10) . '                // TODO - test the "fallback" flag' . chr(10) . '                meth = p5method_lookup(' . chr(39) . '(""' . chr(39) . ', o._class_._ref_, {});' . chr(10) . '                if (meth) {' . chr(10) . '                    return p5num(meth([o], 0));' . chr(10) . '                }' . chr(10) . '            }' . chr(10) . '        }' . chr(10) . '    }' . chr(10) . '    if (typeof o !== "number") {' . chr(10) . '        var s = p5str(o).trim();' . chr(10) . '        var s1 = s.substr(0, 3).toUpperCase();' . chr(10) . '        if ( s1 == "NAN" ) { return NaN };' . chr(10) . '        if ( s1 == "INF" ) { return Infinity };' . chr(10) . '        s1 = s.substr(0, 4).toUpperCase();' . chr(10) . '        if ( s1 == "-NAN" ) { return NaN };' . chr(10) . '        if ( s1 == "-INF" ) { return -Infinity };' . chr(10) . '        s1 = parseFloat(s);' . chr(10) . '        if ( isNaN(s1) ) { return 0 };' . chr(10) . '        return s1;' . chr(10) . '    }' . chr(10) . '    return o;' . chr(10) . '};' . chr(10) . chr(10) . 'var p5bool = function(o) {' . chr(10) . '    if (o) {' . chr(10) . '        if (typeof o === "boolean") {' . chr(10) . '            return o;' . chr(10) . '        }' . chr(10) . '        if (typeof o === "number") {' . chr(10) . '            return o;' . chr(10) . '        }' . chr(10) . '        if (typeof o === "string") {' . chr(10) . '            return o != "" && o != "0";' . chr(10) . '        }' . chr(10) . '        if (typeof o.length === "number") {' . chr(10) . '            return o.length;' . chr(10) . '        }' . chr(10) . '        if (o instanceof Error) {' . chr(10) . '            return true;' . chr(10) . '        }' . chr(10) . '        for (var i in o) {' . chr(10) . '            return true;' . chr(10) . '        }' . chr(10) . '    }' . chr(10) . '    return false;' . chr(10) . '};' . chr(10) . chr(10) . 'var p5incr_ = function(o) {' . chr(10) . '    if (typeof o === "number") {' . chr(10) . '        return o + 1;' . chr(10) . '    }' . chr(10) . '    return p5str_inc(p5str(o));' . chr(10) . '};' . chr(10) . chr(10) . 'var p5decr_ = function(o) {' . chr(10) . '    if (typeof o === "number") {' . chr(10) . '        return o - 1;' . chr(10) . '    }' . chr(10) . '    return p5num(o) - 1;' . chr(10) . '};' . chr(10) . chr(10) . 'var p5modulo = function(o, k) {' . chr(10) . '    var m = o % k;' . chr(10) . '    if ( k < 0 && m > 0 ) {' . chr(10) . '        m = m + k;' . chr(10) . '    }' . chr(10) . '    else if ( k > 0 && m < 0 ) {' . chr(10) . '        m = m + k;' . chr(10) . '    }' . chr(10) . '    return m;' . chr(10) . '};' . chr(10) . chr(10) . 'var p5shift_left = function(o, k) {' . chr(10) . '    return k < 31 ? o << k : o * Math.pow(2, k);' . chr(10) . '};' . chr(10) . chr(10) . 'var p5and = function(a, fb) {' . chr(10) . '    if (p5bool(a)) {' . chr(10) . '        return fb();' . chr(10) . '    }' . chr(10) . '    return a;' . chr(10) . '};' . chr(10) . chr(10) . 'var p5or = function(a, fb) {' . chr(10) . '    if (p5bool(a)) {' . chr(10) . '        return a;' . chr(10) . '    }' . chr(10) . '    return fb();' . chr(10) . '};' . chr(10) . chr(10) . 'var p5defined_or = function(a, fb) {' . chr(10) . '    if (a == null) {' . chr(10) . '        return fb();' . chr(10) . '    }' . chr(10) . '    return a;' . chr(10) . '};' . chr(10) . chr(10) . 'var p5xor = function(a, fb) {' . chr(10) . '    return p5bool(a) ? !p5bool(fb()) : fb()' . chr(10) . '};' . chr(10) . chr(10) . 'var p5cmp = function(a, b) {' . chr(10) . '    return a > b ? 1 : a < b ? -1 : 0 ' . chr(10) . '};' . chr(10) . chr(10) . 'var p5complement = function(a) {' . chr(10) . '    return a < 0 ? ~a : 4294967295 - a' . chr(10) . '    // return a < 0 ? ~a : 18446744073709551615 - a' . chr(10) . '};' . chr(10) . chr(10) . 'var p5str_replicate = function(o, n) {' . chr(10) . '    n = Math.floor(n);' . chr(10) . '    return n > 0 ? Array(n + 1).join(o) : "";' . chr(10) . '};' . chr(10) . chr(10) . 'var p5list_replicate = function(o, n, want) {' . chr(10) . '    o = p5list_to_a([o]);' . chr(10) . '    n = p5num(n);' . chr(10) . chr(10) . '    if (!want) {' . chr(10) . '        return p5str_replicate(o.pop(), n);   // scalar context' . chr(10) . '    }' . chr(10) . chr(10) . '    var out = [];' . chr(10) . '    for(var i = 0; i < n; i++) {' . chr(10) . '        for(var j = 0; j < o.length; j++) {' . chr(10) . '            out.push(o[j]);' . chr(10) . '        }' . chr(10) . '    }' . chr(10) . '    return (want ? out : out.length)' . chr(10) . '};' . chr(10) . chr(10) . 'var p5list_slice = function(o, ix, want) {' . chr(10) . '    var out = [];' . chr(10) . '    for (var i=0, l=ix.length; i<l; ++i) {' . chr(10) . '        if (ix[i] < o.length) {' . chr(10) . '            out[i] = o[ix[i]];' . chr(10) . '        }' . chr(10) . '    }' . chr(10) . '    if (want) { return out }' . chr(10) . '    return out.length ? out[out.length-1] : null;' . chr(10) . '}' . chr(10) . chr(10) . 'var p5hash_slice = function(o, ix, want) {' . chr(10) . '    var out = [];' . chr(10) . '    for (var i=0, l=ix.length; i<l; ++i) {' . chr(10) . '        out.push(ix[i]);' . chr(10) . '        out.push(o[ix[i]]);' . chr(10) . '    }' . chr(10) . '    if (want) { return out }' . chr(10) . '    return out.length ? out[out.length-1] : null;' . chr(10) . '}' . chr(10) . chr(10) . 'var p5list_lookup_slice = function(o, ix, want) {' . chr(10) . '    var out = [];' . chr(10) . '    for (var i=0, l=ix.length; i<l; ++i) {' . chr(10) . '        out[i] = o[ix[i]];' . chr(10) . '    }' . chr(10) . '    if (want) { return out }' . chr(10) . '    return out.length ? out[out.length-1] : null;' . chr(10) . '}' . chr(10) . chr(10) . 'var p5hash_lookup_slice = function(o, ix, want) {' . chr(10) . '    var out = [];' . chr(10) . '    for (var i=0, l=ix.length; i<l; ++i) {' . chr(10) . '        out.push(ix[i]);' . chr(10) . '        out.push(o[ix[i]]);' . chr(10) . '    }' . chr(10) . '    if (want) { return out }' . chr(10) . '    return out.length ? out[out.length-1] : null;' . chr(10) . '}' . chr(10) . chr(10) . 'var p5str_inc = function(s) {' . chr(10) . '    if (s.length < 2) {' . chr(10) . '        if ((s >= "0" && s <= "8") || (s >= "A" && s <= "Y") || (s >= "a" && s <= "y")) {' . chr(10) . '            return String.fromCharCode(s.charCodeAt(0) + 1);' . chr(10) . '        }' . chr(10) . '        if (s == "9") {' . chr(10) . '            return "10";' . chr(10) . '        }' . chr(10) . '        if (s == "Z") {' . chr(10) . '            return "AA";' . chr(10) . '        }' . chr(10) . '        if (s == "z") {' . chr(10) . '            return "aa";' . chr(10) . '        }' . chr(10) . '        return "1";' . chr(10) . '    }' . chr(10) . '    var c0 = s.substr(0, 1);' . chr(10) . '    if (c0 >= "0" && c0 <= "9") {' . chr(10) . '        return p5str(p5num(s)+1);' . chr(10) . '    }' . chr(10) . '    var c = p5str_inc(s.substr(s.length-1, 1));' . chr(10) . '    if (c.length == 1) {' . chr(10) . '        return s.substr(0, s.length-1) + c;' . chr(10) . '    }' . chr(10) . '    return p5str_inc(s.substr(0, s.length-1)) + c.substr(c.length-1, 1);' . chr(10) . '};' . chr(10) . chr(10) . 'var p5range_state = {};' . chr(10) . 'var p5range = function(a, b, p5want, id, three_dots) {' . chr(10) . '    if (p5want) {' . chr(10) . '        // list context' . chr(10) . '        var tmp = [];' . chr(10) . '        if (typeof a === "number" || typeof b === "number") {' . chr(10) . '            a = p5num(a);' . chr(10) . '            b = p5num(b);' . chr(10) . '            while (a <= b) {' . chr(10) . '                tmp.push(a);' . chr(10) . '                a++;' . chr(10) . '            }' . chr(10) . '        }' . chr(10) . '        else {' . chr(10) . '            a = p5str(a);' . chr(10) . '            b = p5str(b);' . chr(10) . '            var c = a.substr(0, 1);' . chr(10) . '            if ( c == ' . chr(39) . '+' . chr(39) . ' ) {' . chr(10) . '                if (a == "+") {' . chr(10) . '                    return [a]' . chr(10) . '                }' . chr(10) . '                a = a.substr(1)' . chr(10) . '            }' . chr(10) . '            else if ( c == ' . chr(39) . '-' . chr(39) . ' ) {' . chr(10) . '                if (a == "-") {' . chr(10) . '                    return [a]' . chr(10) . '                }' . chr(10) . '                return p5range(p5num(a), b, p5want, id, three_dots)' . chr(10) . '            }' . chr(10) . '            c = b.substr(0, 1);' . chr(10) . '            if ( c == ' . chr(39) . '+' . chr(39) . ' ) {' . chr(10) . '                b = b.substr(1)' . chr(10) . '            }' . chr(10) . '            while (  (a.length < b.length)' . chr(10) . '                  || (a.length == b.length && a <= b) ) {' . chr(10) . '                tmp.push(a);' . chr(10) . '                a = p5incr_(a);' . chr(10) . '            }' . chr(10) . '        }' . chr(10) . '        return tmp;' . chr(10) . '    }' . chr(10) . '    // flip-flop operator' . chr(10) . '    var v;' . chr(10) . '    if (p5range_state[id]) {' . chr(10) . '        v = ++p5range_state[id];' . chr(10) . '        if (p5bool(b)) {' . chr(10) . '            p5range_state[id] = 0;' . chr(10) . '            v = v + "E0";' . chr(10) . '        }' . chr(10) . '        return v;' . chr(10) . '    }' . chr(10) . '    else {' . chr(10) . '        p5range_state[id] = 0;' . chr(10) . '        if (p5bool(a)) {' . chr(10) . '            p5range_state[id]++;' . chr(10) . '            v = p5range_state[id];' . chr(10) . '        }' . chr(10) . '        if (v && !three_dots && p5bool(b)) {' . chr(10) . '            p5range_state[id] = 0;' . chr(10) . '            v = v + "E0";' . chr(10) . '        }' . chr(10) . '        return v;' . chr(10) . '    }' . chr(10) . '};' . chr(10) . chr(10) . 'var p5negative = function(o) {' . chr(10) . '    if (o == null) {' . chr(10) . '        return ' . chr(39) . '-0' . chr(39) . ';' . chr(10) . '    }' . chr(10) . '    if (typeof o === "object" && (o instanceof Array)) {' . chr(10) . '        return -(o.length);' . chr(10) . '    }' . chr(10) . '    if (typeof o !== "number") {' . chr(10) . '        var s = p5str(o);' . chr(10) . '        var c = s.substr(0, 1);' . chr(10) . '        if ( c == ' . chr(39) . '+' . chr(39) . ' ) { s = s.substr(1); return ' . chr(39) . '-' . chr(39) . ' + s }' . chr(10) . '        if ( c == ' . chr(39) . '-' . chr(39) . ' ) { s = s.substr(1); return ' . chr(39) . '+' . chr(39) . ' + s }' . chr(10) . '        var s1 = parseFloat(s.trim());' . chr(10) . '        if ( isNaN(s1) ) {' . chr(10) . '            if ( c.length && !c.match(/[ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz]/) ) {' . chr(10) . '                if ( s.trim().substr(0,1) == "-" ) { return 0 };' . chr(10) . '                return ' . chr(39) . '-0' . chr(39) . ';' . chr(10) . '            };' . chr(10) . '            return ' . chr(39) . '-' . chr(39) . ' + s' . chr(10) . '        };' . chr(10) . '        return -s1;' . chr(10) . '    }' . chr(10) . '    return -o;' . chr(10) . '};' . chr(10) . chr(10) . 'var p5qr = function(search, modifier) {' . chr(10) . '    // TODO - "Regex" stringification' . chr(10) . '    var re = new RegExp(search, modifier);' . chr(10) . '    return CORE.bless([(new p5ScalarRef(re)), ' . chr(39) . 'Regex' . chr(39) . ']);' . chr(10) . '};' . chr(10) . chr(10) . 'var p5m = function(s, search, modifier, want) {' . chr(10) . '    // TODO - captures' . chr(10) . '    var re;' . chr(10) . '    if (search.hasOwnProperty(' . chr(39) . '_scalar_' . chr(39) . ')) {' . chr(10) . '        // search is a Regex object' . chr(10) . '        re = search._scalar_;' . chr(10) . '    }' . chr(10) . '    else {' . chr(10) . '        re = new RegExp(search, modifier);' . chr(10) . '    }' . chr(10) . chr(10) . '    p5_regex_capture = [];' . chr(10) . '    var res = [];' . chr(10) . '    var myArray;' . chr(10) . '    while ((myArray = re.exec(s)) !== null) {' . chr(10) . '        var m = myArray.shift();' . chr(10) . '        if (myArray.length) {' . chr(10) . '            res = res.concat(myArray);' . chr(10) . '            p5_regex_capture = p5_regex_capture.concat(myArray);' . chr(10) . '        }' . chr(10) . '        else {' . chr(10) . '            res.push(m);' . chr(10) . '        }' . chr(10) . '        if (re.lastIndex == 0) {' . chr(10) . '            return (want ? res : res.length)' . chr(10) . '        }' . chr(10) . '    }' . chr(10) . '    return (want ? res : res.length)' . chr(10) . '};' . chr(10) . chr(10) . 'var p5s = function(s, search, fun_replace, modifier, want) {' . chr(10) . '    // TODO - captures' . chr(10) . '    var count = null;' . chr(10) . '    var re;' . chr(10) . '    if (search.hasOwnProperty(' . chr(39) . '_scalar_' . chr(39) . ')) {' . chr(10) . '        // search is a Regex object' . chr(10) . '        re = search._scalar_;' . chr(10) . '    }' . chr(10) . '    else {' . chr(10) . '        re = new RegExp(search, modifier);' . chr(10) . '    }' . chr(10) . chr(10) . '    p5_regex_capture = [];' . chr(10) . '    var res = [];' . chr(10) . '    var myArray;' . chr(10) . '    var last_index = 0;' . chr(10) . '    while ((myArray = re.exec(s)) !== null) {' . chr(10) . '        var m = myArray.shift();' . chr(10) . '        p5_regex_capture = [].concat(myArray);' . chr(10) . '        if (myArray.index > last_index) {' . chr(10) . '            res.push(s.substr(last_index, myArray.index - last_index));' . chr(10) . '        }' . chr(10) . '        res.push(fun_replace());' . chr(10) . '        last_index = re.lastIndex;' . chr(10) . '        if (last_index == 0) {' . chr(10) . '            count = 1;' . chr(10) . '            last_index = myArray.index + m.length;' . chr(10) . '            if (s.length > last_index) {' . chr(10) . '                res.push(s.substr(last_index, s.length - last_index));' . chr(10) . '            }' . chr(10) . '            return [res.join(' . chr(39) . chr(39) . '), count]' . chr(10) . '        }' . chr(10) . '        count++;' . chr(10) . '    }' . chr(10) . '    if (s.length > last_index) {' . chr(10) . '        res.push(s.substr(last_index, s.length - last_index));' . chr(10) . '    }' . chr(10) . '    return [res.join(' . chr(39) . chr(39) . '), count]' . chr(10) . '};' . chr(10) . chr(10) . 'var p5tr = function(s, search, replace, modifier, want) {' . chr(10) . '    var count = 0;' . chr(10) . '    // TODO - expand character lists in spec' . chr(10) . '    // TODO - modifiers' . chr(10) . '    search = search.split("");' . chr(10) . '    replace = replace.split("");' . chr(10) . '    while (search.length > replace.length) {' . chr(10) . '        replace.push(replace[replace.length-1]);' . chr(10) . '    }' . chr(10) . '    var tr = {};' . chr(10) . '    for(var i = 0; i < search.length; i++) {' . chr(10) . '        tr[search[i]] = replace[i];' . chr(10) . '    }' . chr(10) . '    var res = s.split("");' . chr(10) . '    for(var i = 0; i < res.length; i++) {' . chr(10) . '        if (tr.hasOwnProperty(res[i])) {' . chr(10) . '            res[i] = tr[res[i]];' . chr(10) . '            count++;' . chr(10) . '        }' . chr(10) . '    }' . chr(10) . '    return [res.join(' . chr(39) . chr(39) . '), count]' . chr(10) . '};' . chr(10) . chr(10) . 'var p5chop = function(s) {' . chr(10) . '    // TODO - array, hash' . chr(10) . '    return [s.substr(-1,1), s.substr(0,s.length-1)]' . chr(10) . '};' . chr(10) . chr(10) . 'var p5chomp = function(s) {' . chr(10) . '    // TODO - array, hash' . chr(10) . '    // TODO - special cases of $/ - empty string, reference' . chr(10) . '    var sep = p5pkg["main"]["v_/"];  // $/' . chr(10) . '    var c = s.substr(-sep.length);' . chr(10) . '    if (c == sep) {' . chr(10) . '        return [c.length, s.substr(0,s.length-sep.length)]' . chr(10) . '    }' . chr(10) . '    else {' . chr(10) . '        return [0, s]' . chr(10) . '    }' . chr(10) . '};' . chr(10) . chr(10) . 'var p5for = function(namespace, var_name, func, args, cont, label) {' . chr(10) . '    var local_idx = p5LOCAL.length;' . chr(10) . '    var v_old = namespace[var_name];' . chr(10) . '    var _redo;' . chr(10) . '    p5LOCAL.push(function(){ namespace[var_name] = v_old });' . chr(10) . '    for(var i = 0; i < args.length; i++) {' . chr(10) . '        namespace[var_name] = args[i];' . chr(10) . '        do {' . chr(10) . '            _redo = false;' . chr(10) . '            try {' . chr(10) . '                func()' . chr(10) . '            }' . chr(10) . '            catch(err) {' . chr(10) . '                if (err instanceof p5_error && (err.v == label || err.v == ' . chr(39) . chr(39) . ')) {' . chr(10) . '                    if (err.type == ' . chr(39) . 'last' . chr(39) . ') {' . chr(10) . '                        p5cleanup_local(local_idx, null);' . chr(10) . '                        return' . chr(10) . '                    }' . chr(10) . '                    else if (err.type == ' . chr(39) . 'redo' . chr(39) . ') { _redo = true }' . chr(10) . '                    else if (err.type != ' . chr(39) . 'next' . chr(39) . ') { throw(err) }' . chr(10) . '                }' . chr(10) . '                else {' . chr(10) . '                    throw(err)' . chr(10) . '                }' . chr(10) . '            }' . chr(10) . '            if (cont) {' . chr(10) . '                try {' . chr(10) . '                    if (!_redo) { cont() }' . chr(10) . '                }' . chr(10) . '                catch(err) {' . chr(10) . '                    if (err instanceof p5_error && (err.v == label || err.v == ' . chr(39) . chr(39) . ')) {' . chr(10) . '                        if (err.type == ' . chr(39) . 'last' . chr(39) . ') {' . chr(10) . '                            p5cleanup_local(local_idx, null);' . chr(10) . '                            return' . chr(10) . '                        }' . chr(10) . '                        else if (err.type == ' . chr(39) . 'redo' . chr(39) . ') { _redo = true }' . chr(10) . '                        else if (err.type != ' . chr(39) . 'next' . chr(39) . ') { throw(err) }' . chr(10) . '                    }            ' . chr(10) . '                    else {' . chr(10) . '                        throw(err)' . chr(10) . '                    }' . chr(10) . '                }' . chr(10) . '            }' . chr(10) . '        } while (_redo);' . chr(10) . '    }' . chr(10) . '    p5cleanup_local(local_idx, null);' . chr(10) . '};' . chr(10) . chr(10) . 'var p5for_lex = function(set_var, func, args, cont, label) {' . chr(10) . '    var local_idx = p5LOCAL.length;' . chr(10) . '    var _redo;' . chr(10) . '    for(var i = 0; i < args.length; i++) {' . chr(10) . '        set_var(args[i]);' . chr(10) . '        do {' . chr(10) . '            _redo = false;' . chr(10) . '            try {' . chr(10) . '                func()' . chr(10) . '            }' . chr(10) . '            catch(err) {' . chr(10) . '                if (err instanceof p5_error && (err.v == label || err.v == ' . chr(39) . chr(39) . ')) {' . chr(10) . '                    if (err.type == ' . chr(39) . 'last' . chr(39) . ') {' . chr(10) . '                        p5cleanup_local(local_idx, null);' . chr(10) . '                        return' . chr(10) . '                    }' . chr(10) . '                    else if (err.type == ' . chr(39) . 'redo' . chr(39) . ') { _redo = true }' . chr(10) . '                    else if (err.type != ' . chr(39) . 'next' . chr(39) . ') { throw(err) }' . chr(10) . '                }            ' . chr(10) . '                else {' . chr(10) . '                    throw(err)' . chr(10) . '                }' . chr(10) . '            }' . chr(10) . '            if (cont) {' . chr(10) . '                try {' . chr(10) . '                    if (!_redo) { cont() }' . chr(10) . '                }' . chr(10) . '                catch(err) {' . chr(10) . '                    if (err instanceof p5_error && (err.v == label || err.v == ' . chr(39) . chr(39) . ')) {' . chr(10) . '                        if (err.type == ' . chr(39) . 'last' . chr(39) . ') {' . chr(10) . '                            p5cleanup_local(local_idx, null);' . chr(10) . '                            return' . chr(10) . '                        }' . chr(10) . '                        else if (err.type == ' . chr(39) . 'redo' . chr(39) . ') { _redo = true }' . chr(10) . '                        else if (err.type != ' . chr(39) . 'next' . chr(39) . ') { throw(err) }' . chr(10) . '                    }            ' . chr(10) . '                    else {' . chr(10) . '                        throw(err)' . chr(10) . '                    }' . chr(10) . '                }' . chr(10) . '            }' . chr(10) . '        } while (_redo);' . chr(10) . '    }' . chr(10) . '    p5cleanup_local(local_idx, null);' . chr(10) . '};' . chr(10) . chr(10) . 'var p5block = function(set_var, func, args, cont, label) {' . chr(10) . '    var local_idx = p5LOCAL.length;' . chr(10) . '    var _redo;' . chr(10) . '    for(var i = 0; i < args.length; i++) {' . chr(10) . '        set_var(args[i]);' . chr(10) . '        do {' . chr(10) . '            _redo = false;' . chr(10) . '            try {' . chr(10) . '                return func()' . chr(10) . '            }' . chr(10) . '            catch(err) {' . chr(10) . '                if (err instanceof p5_error && (err.v == label || err.v == ' . chr(39) . chr(39) . ')) {' . chr(10) . '                    if (err.type == ' . chr(39) . 'last' . chr(39) . ') {' . chr(10) . '                        p5cleanup_local(local_idx, null);' . chr(10) . '                        return' . chr(10) . '                    }' . chr(10) . '                    else if (err.type == ' . chr(39) . 'redo' . chr(39) . ') { _redo = true }' . chr(10) . '                    else if (err.type != ' . chr(39) . 'next' . chr(39) . ') { throw(err) }' . chr(10) . '                }            ' . chr(10) . '                else {' . chr(10) . '                    throw(err)' . chr(10) . '                }' . chr(10) . '            }' . chr(10) . '            if (cont) {' . chr(10) . '                try {' . chr(10) . '                    if (!_redo) { cont() }' . chr(10) . '                }' . chr(10) . '                catch(err) {' . chr(10) . '                    if (err instanceof p5_error && (err.v == label || err.v == ' . chr(39) . chr(39) . ')) {' . chr(10) . '                        if (err.type == ' . chr(39) . 'last' . chr(39) . ') {' . chr(10) . '                            p5cleanup_local(local_idx, null);' . chr(10) . '                            return' . chr(10) . '                        }' . chr(10) . '                        else if (err.type == ' . chr(39) . 'redo' . chr(39) . ') { _redo = true }' . chr(10) . '                        else if (err.type != ' . chr(39) . 'next' . chr(39) . ') { throw(err) }' . chr(10) . '                    }            ' . chr(10) . '                    else {' . chr(10) . '                        throw(err)' . chr(10) . '                    }' . chr(10) . '                }' . chr(10) . '            }' . chr(10) . '        } while (_redo);' . chr(10) . '    }' . chr(10) . '    p5cleanup_local(local_idx, null);' . chr(10) . '};' . chr(10) . chr(10) . chr(10) . 'var p5while = function(func, cond, cont, label, redo) {' . chr(10) . '    var local_idx = p5LOCAL.length;' . chr(10) . '    while (redo || p5bool(cond())) {' . chr(10) . '        redo = false;' . chr(10) . '        try {' . chr(10) . '            func()' . chr(10) . '        }' . chr(10) . '        catch(err) {' . chr(10) . '            if (err instanceof p5_error && (err.v == label || err.v == ' . chr(39) . chr(39) . ')) {' . chr(10) . '                if (err.type == ' . chr(39) . 'last' . chr(39) . ') {' . chr(10) . '                    p5cleanup_local(local_idx, null);' . chr(10) . '                    return' . chr(10) . '                }' . chr(10) . '                else if (err.type == ' . chr(39) . 'redo' . chr(39) . ') { redo = true }' . chr(10) . '                else if (err.type != ' . chr(39) . 'next' . chr(39) . ') { throw(err) }' . chr(10) . '            }            ' . chr(10) . '            else {' . chr(10) . '                throw(err)' . chr(10) . '            }' . chr(10) . '        }' . chr(10) . '        if (cont) {' . chr(10) . '            try {' . chr(10) . '                if (!redo) { cont() }' . chr(10) . '            }' . chr(10) . '            catch(err) {' . chr(10) . '                if (err instanceof p5_error && (err.v == label || err.v == ' . chr(39) . chr(39) . ')) {' . chr(10) . '                    if (err.type == ' . chr(39) . 'last' . chr(39) . ') {' . chr(10) . '                        p5cleanup_local(local_idx, null);' . chr(10) . '                        return' . chr(10) . '                    }' . chr(10) . '                    else if (err.type == ' . chr(39) . 'redo' . chr(39) . ') { redo = true }' . chr(10) . '                    else if (err.type != ' . chr(39) . 'next' . chr(39) . ') { throw(err) }' . chr(10) . '                }            ' . chr(10) . '                else {' . chr(10) . '                    throw(err)' . chr(10) . '                }' . chr(10) . '            }' . chr(10) . '        }' . chr(10) . '    }' . chr(10) . '    p5cleanup_local(local_idx, null);' . chr(10) . '};' . chr(10) . chr(10) . 'var p5map = function(namespace, func, args) {' . chr(10) . '    var v_old = p5pkg["main"]["v__"];' . chr(10) . '    var out = [];' . chr(10) . '    for(var i = 0; i < args.length; i++) {' . chr(10) . '        p5pkg["main"]["v__"] = args[i];' . chr(10) . '        var o = p5list_to_a([func(1)]);' . chr(10) . '        for(var j = 0; j < o.length; j++) {' . chr(10) . '            out.push(o[j]);' . chr(10) . '        }' . chr(10) . '    }' . chr(10) . '    p5pkg["main"]["v__"] = v_old;' . chr(10) . '    return out;' . chr(10) . '};' . chr(10) . chr(10) . 'var p5grep = function(namespace, func, args) {' . chr(10) . '    var v_old = p5pkg["main"]["v__"];' . chr(10) . '    var out = [];' . chr(10) . '    for(var i = 0; i < args.length; i++) {' . chr(10) . '        p5pkg["main"]["v__"] = args[i];' . chr(10) . '        if (p5bool(func(0))) {' . chr(10) . '            out.push(args[i])' . chr(10) . '        }' . chr(10) . '    }' . chr(10) . '    p5pkg["main"]["v__"] = v_old;' . chr(10) . '    return out;' . chr(10) . '};' . chr(10) . chr(10) . 'var p5sort = function(namespace, func, args) {' . chr(10) . '    var a_old = namespace["v_a"];' . chr(10) . '    var b_old = namespace["v_b"];' . chr(10) . '    var out = ' . chr(10) . '        func == null' . chr(10) . '        ? args.sort()' . chr(10) . '        : args.sort(' . chr(10) . '            function(a, b) {' . chr(10) . '                namespace["v_a"] = a;' . chr(10) . '                namespace["v_b"] = b;' . chr(10) . '                return func(0);' . chr(10) . '            }' . chr(10) . '        );' . chr(10) . '    namespace["v_a"] = a_old;' . chr(10) . '    namespace["v_b"] = b_old;' . chr(10) . '    return out;' . chr(10) . '};' . chr(10) . chr(10)
            }
            1
        }
    }
    {
        {
            package main;
            undef();
            package Perlito5::Javascript2::Array;
            sub Perlito5::Javascript2::Array::emit_javascript2 {
                return '//' . chr(10) . '// lib/Perlito5/Javascript2/Runtime.js' . chr(10) . '//' . chr(10) . '// Runtime for "Perlito" Perl5-in-Javascript2' . chr(10) . '//' . chr(10) . '// AUTHORS' . chr(10) . '//' . chr(10) . '// Flavio Soibelmann Glock  fglock@gmail.com' . chr(10) . '//' . chr(10) . '// COPYRIGHT' . chr(10) . '//' . chr(10) . '// Copyright 2009, 2010, 2011, 2012 by Flavio Soibelmann Glock and others.' . chr(10) . '//' . chr(10) . '// This program is free software; you can redistribute it and/or modify it' . chr(10) . '// under the same terms as Perl itself.' . chr(10) . '//' . chr(10) . '// See http://www.perl.com/perl/misc/Artistic.html' . chr(10) . chr(10) . '//-------- Array ' . chr(10) . chr(10) . 'Object.defineProperty( Array.prototype, "p5aget", {' . chr(10) . '    enumerable : false,' . chr(10) . '    value : function (i) {' . chr(10) . '        if (i < 0) { i =  this.length + i };' . chr(10) . '        return this[i] ' . chr(10) . '    }' . chr(10) . '});' . chr(10) . 'Object.defineProperty( Array.prototype, "p5aset", {' . chr(10) . '    enumerable : false,' . chr(10) . '    value : function (i, v) {' . chr(10) . '        if (i < 0) { i =  this.length + i };' . chr(10) . '        this[i] = v;' . chr(10) . '        return this[i]' . chr(10) . '    }' . chr(10) . '});' . chr(10) . chr(10) . 'Object.defineProperty( Array.prototype, "p5incr", {' . chr(10) . '    enumerable : false,' . chr(10) . '    value : function (i) {' . chr(10) . '        if (i < 0) { i =  this.length + i };' . chr(10) . '        this[i] = p5incr_(this[i]);' . chr(10) . '        return this[i];' . chr(10) . '    }' . chr(10) . '});' . chr(10) . 'Object.defineProperty( Array.prototype, "p5postincr", {' . chr(10) . '    enumerable : false,' . chr(10) . '    value : function (i) {' . chr(10) . '        if (i < 0) { i =  this.length + i };' . chr(10) . '        var v = this[i];' . chr(10) . '        this[i] = p5incr_(this[i]);' . chr(10) . '        return v;' . chr(10) . '    }' . chr(10) . '});' . chr(10) . 'Object.defineProperty( Array.prototype, "p5decr", {' . chr(10) . '    enumerable : false,' . chr(10) . '    value : function (i) {' . chr(10) . '        if (i < 0) { i =  this.length + i };' . chr(10) . '        this[i] = p5decr_(this[i]);' . chr(10) . '        return this[i];' . chr(10) . '    }' . chr(10) . '});' . chr(10) . 'Object.defineProperty( Array.prototype, "p5postdecr", {' . chr(10) . '    enumerable : false,' . chr(10) . '    value : function (i) {' . chr(10) . '        if (i < 0) { i =  this.length + i };' . chr(10) . '        var v = this[i];' . chr(10) . '        this[i] = p5decr_(this[i]);' . chr(10) . '        return v;' . chr(10) . '    }' . chr(10) . '});' . chr(10) . chr(10) . 'Object.defineProperty( Array.prototype, "p5aget_array", {' . chr(10) . '    enumerable : false,' . chr(10) . '    value : function (i) {' . chr(10) . '        if (i < 0) { i =  this.length + i };' . chr(10) . '        if (this[i] == null) { this[i] = new p5ArrayRef([]) }' . chr(10) . '        return this[i]' . chr(10) . '    }' . chr(10) . '});' . chr(10) . 'Object.defineProperty( Array.prototype, "p5aget_hash", {' . chr(10) . '    enumerable : false,' . chr(10) . '    value : function (i) {' . chr(10) . '        if (i < 0) { i =  this.length + i };' . chr(10) . '        if (this[i] == null) { this[i] = new p5HashRef({}) }' . chr(10) . '        return this[i]' . chr(10) . '    }' . chr(10) . '});' . chr(10) . 'Object.defineProperty( Array.prototype, "p5unshift", {' . chr(10) . '    enumerable : false,' . chr(10) . '    configurable : true,' . chr(10) . '    value : function (args) { ' . chr(10) . '        for(var i = args.length-1; i >= 0; i--) {' . chr(10) . '            this.unshift(args[i]);' . chr(10) . '        }' . chr(10) . '        return this.length; ' . chr(10) . '    }' . chr(10) . '});' . chr(10) . 'Object.defineProperty( Array.prototype, "p5push", {' . chr(10) . '    enumerable : false,' . chr(10) . '    configurable : true,' . chr(10) . '    value : function (args) { ' . chr(10) . '        for(var i = 0; i < args.length; i++) {' . chr(10) . '            this.push(args[i]);' . chr(10) . '        }' . chr(10) . '        return this.length; ' . chr(10) . '    }' . chr(10) . '});' . chr(10) . chr(10) . 'var p5tie_array = function(v, List__) {' . chr(10) . '    var pkg_name = p5str(List__.shift());' . chr(10) . chr(10) . '    var res = p5call(pkg_name, ' . chr(39) . 'TIEARRAY' . chr(39) . ', List__, null);' . chr(10) . '    ' . chr(10) . '    // TODO' . chr(10) . '    ' . chr(10) . '    //  A class implementing an ordinary array should have the following methods:' . chr(10) . '    //      TIEARRAY pkg_name, LIST' . chr(10) . '    //      FETCH this, key' . chr(10) . '    //      STORE this, key, value' . chr(10) . '    //      FETCHSIZE this' . chr(10) . '    //      STORESIZE this, count' . chr(10) . '    //      CLEAR this' . chr(10) . '    //      PUSH this, LIST' . chr(10) . '    //      POP this' . chr(10) . '    //      SHIFT this' . chr(10) . '    //      UNSHIFT this, LIST' . chr(10) . '    //      SPLICE this, offset, length, LIST' . chr(10) . '    //      EXTEND this, count' . chr(10) . '    //      DESTROY this' . chr(10) . '    //      UNTIE this' . chr(10) . '    ' . chr(10) . '    Object.defineProperty( v, "p5aget", {' . chr(10) . '        enumerable : false,' . chr(10) . '        configurable : true,' . chr(10) . '        value : function (i) {' . chr(10) . '            return p5call(res, ' . chr(39) . 'FETCH' . chr(39) . ', [i]);' . chr(10) . '        }' . chr(10) . '    });' . chr(10) . '    Object.defineProperty( v, "p5aset", {' . chr(10) . '        enumerable : false,' . chr(10) . '        configurable : true,' . chr(10) . '        value : function (i, value) {' . chr(10) . '            p5call(res, ' . chr(39) . 'STORE' . chr(39) . ', [i, value]);' . chr(10) . '            return value;' . chr(10) . '        }' . chr(10) . '    });' . chr(10) . '    Object.defineProperty( v, "p5incr", {' . chr(10) . '        enumerable : false,' . chr(10) . '        configurable : true,' . chr(10) . '        value : function (i) {' . chr(10) . '            var value = p5incr_(p5call(res, ' . chr(39) . 'FETCH' . chr(39) . ', [i]));' . chr(10) . '            p5call(res, ' . chr(39) . 'STORE' . chr(39) . ', [i, value]);' . chr(10) . '            return value;' . chr(10) . '        }' . chr(10) . '    });' . chr(10) . '    Object.defineProperty( v, "p5postincr", {' . chr(10) . '        enumerable : false,' . chr(10) . '        configurable : true,' . chr(10) . '        value : function (i) {' . chr(10) . '            var value = p5call(res, ' . chr(39) . 'FETCH' . chr(39) . ', [i]);' . chr(10) . '            p5call(res, ' . chr(39) . 'STORE' . chr(39) . ', [i, p5incr_(value)]);' . chr(10) . '            return value;' . chr(10) . '        }' . chr(10) . '    });' . chr(10) . '    Object.defineProperty( v, "p5decr", {' . chr(10) . '        enumerable : false,' . chr(10) . '        configurable : true,' . chr(10) . '        value : function (i) {' . chr(10) . '            var value = p5decr_(p5call(res, ' . chr(39) . 'FETCH' . chr(39) . ', [i]));' . chr(10) . '            p5call(res, ' . chr(39) . 'STORE' . chr(39) . ', [i, value]);' . chr(10) . '            return value;' . chr(10) . '        }' . chr(10) . '    });' . chr(10) . '    Object.defineProperty( v, "p5postdecr", {' . chr(10) . '        enumerable : false,' . chr(10) . '        configurable : true,' . chr(10) . '        value : function (i) {' . chr(10) . '            var value = p5call(res, ' . chr(39) . 'FETCH' . chr(39) . ', [i]);' . chr(10) . '            p5call(res, ' . chr(39) . 'STORE' . chr(39) . ', [i, p5decr_(value)]);' . chr(10) . '            return value;' . chr(10) . '        }' . chr(10) . '    });' . chr(10) . '    ' . chr(10) . '    Object.defineProperty( v, "p5aget_array", {' . chr(10) . '        enumerable : false,' . chr(10) . '        configurable : true,' . chr(10) . '        value : function (i) {' . chr(10) . '            var value = p5call(res, ' . chr(39) . 'FETCH' . chr(39) . ', [i]);' . chr(10) . '            if (value == null) {' . chr(10) . '                value = new p5ArrayRef([]);' . chr(10) . '                p5call(res, ' . chr(39) . 'STORE' . chr(39) . ', [i, value]);' . chr(10) . '            }' . chr(10) . '            return value;' . chr(10) . '        }' . chr(10) . '    });' . chr(10) . '    Object.defineProperty( v, "p5aget_hash", {' . chr(10) . '        enumerable : false,' . chr(10) . '        configurable : true,' . chr(10) . '        value : function (i) {' . chr(10) . '            var value = p5call(res, ' . chr(39) . 'FETCH' . chr(39) . ', [i]);' . chr(10) . '            if (value == null) {' . chr(10) . '                value = new p5HashRef({});' . chr(10) . '                p5call(res, ' . chr(39) . 'STORE' . chr(39) . ', [i, value]);' . chr(10) . '            }' . chr(10) . '            return value;' . chr(10) . '        }' . chr(10) . '    });' . chr(10) . '    Object.defineProperty( v, "p5untie", {' . chr(10) . '        enumerable : false,' . chr(10) . '        configurable : true,' . chr(10) . '        value : function (i) { return p5call(res, ' . chr(39) . 'UNTIE' . chr(39) . ', []) }' . chr(10) . '    });' . chr(10) . '    Object.defineProperty( v, "shift", {' . chr(10) . '        enumerable : false,' . chr(10) . '        configurable : true,' . chr(10) . '        value : function () { return p5call(res, ' . chr(39) . 'SHIFT' . chr(39) . ', []) }' . chr(10) . '    });' . chr(10) . '    Object.defineProperty( v, "pop", {' . chr(10) . '        enumerable : false,' . chr(10) . '        configurable : true,' . chr(10) . '        value : function () { return p5call(res, ' . chr(39) . 'POP' . chr(39) . ', []) }' . chr(10) . '    });' . chr(10) . '    Object.defineProperty( v, "p5unshift", {' . chr(10) . '        enumerable : false,' . chr(10) . '        configurable : true,' . chr(10) . '        value : function (args) { ' . chr(10) . '            for(var i = args.length-1; i >= 0; i--) {' . chr(10) . '                p5call(res, ' . chr(39) . 'UNSHIFT' . chr(39) . ', [args[i]]);' . chr(10) . '            }' . chr(10) . '            return p5call(res, ' . chr(39) . 'FETCHSIZE' . chr(39) . ', []); ' . chr(10) . '        }' . chr(10) . '    });' . chr(10) . '    Object.defineProperty( v, "p5push", {' . chr(10) . '        enumerable : false,' . chr(10) . '        configurable : true,' . chr(10) . '        value : function (args) { ' . chr(10) . '            for(var i = 0; i < args.length; i++) {' . chr(10) . '                p5call(res, ' . chr(39) . 'PUSH' . chr(39) . ', [args[i]]);' . chr(10) . '            }' . chr(10) . '            return p5call(res, ' . chr(39) . 'FETCHSIZE' . chr(39) . ', []); ' . chr(10) . '        }' . chr(10) . '    });' . chr(10) . chr(10) . '    return res;' . chr(10) . '};' . chr(10) . chr(10) . 'var p5untie_array = function(v) {' . chr(10) . '    if (v.hasOwnProperty(' . chr(39) . 'p5untie' . chr(39) . ')) {' . chr(10) . '        var res = v.p5untie();  // call UNTIE' . chr(10) . '        delete v.p5aget;' . chr(10) . '        delete v.p5aset;' . chr(10) . '        delete v.p5incr;' . chr(10) . '        delete v.p5postincr;' . chr(10) . '        delete v.p5decr;' . chr(10) . '        delete v.p5postdecr;' . chr(10) . '        delete v.p5aget_array;' . chr(10) . '        delete v.p5aget_hash;' . chr(10) . '        delete v.p5untie;' . chr(10) . '        delete v.shift;' . chr(10) . '        delete v.pop;' . chr(10) . '        delete v.p5unshift;' . chr(10) . '        delete v.p5push;' . chr(10) . '        return res;' . chr(10) . '    }' . chr(10) . '    else {' . chr(10) . '        return null;' . chr(10) . '    }' . chr(10) . '};' . chr(10) . chr(10) . chr(10) . 'function p5ArrayOfAlias(o) {' . chr(10) . chr(10) . '    // this is the structure that represents @_' . chr(10) . '    // _array = [ ref, index,' . chr(10) . '    //            ref, index,' . chr(10) . '    //            ...' . chr(10) . '    //          ]' . chr(10) . chr(10) . '    // TODO - autovivify array cells' . chr(10) . chr(10) . '    this._array_ = o;' . chr(10) . chr(10) . '    this.p5aget = function (i) {' . chr(10) . '        if (i < 0) { i =  this.length + i };' . chr(10) . '        return this._array_[i+i][this._array_[i+i+1]]; ' . chr(10) . '    }' . chr(10) . '    this.p5aset = function (i, v) {' . chr(10) . '        if (i < 0) { i =  this.length + i };' . chr(10) . '        this._array_[i+i][this._array_[i+i+1]] = v;' . chr(10) . '        return this._array_[i+i][this._array_[i+i+1]]' . chr(10) . '    }' . chr(10) . '    this.p5incr = function (i) {' . chr(10) . '        if (i < 0) { i =  this.length + i };' . chr(10) . '        this._array_[i+i][this._array_[i+i+1]] = p5incr_(this._array_[i+i][this._array_[i+i+1]]);' . chr(10) . '        return this._array_[i+i][this._array_[i+i+1]];' . chr(10) . '    }' . chr(10) . '    this.p5postincr = function (i) {' . chr(10) . '        if (i < 0) { i =  this.length + i };' . chr(10) . '        var v = this._array_[i+i][this._array_[i+i+1]];' . chr(10) . '        this._array_[i+i][this._array_[i+i+1]] = p5incr_(this._array_[i+i][this._array_[i+i+1]]);' . chr(10) . '        return v;' . chr(10) . '    }' . chr(10) . '    this.p5decr = function (i) {' . chr(10) . '        if (i < 0) { i =  this.length + i };' . chr(10) . '        this._array_[i+i][this._array_[i+i+1]] = p5decr_(this._array_[i+i][this._array_[i+i+1]]);' . chr(10) . '        return this._array_[i+i][this._array_[i+i+1]];' . chr(10) . '    }' . chr(10) . '    this.p5postdecr = function (i) {' . chr(10) . '        if (i < 0) { i =  this.length + i };' . chr(10) . '        var v = this._array_[i+i][this._array_[i+i+1]];' . chr(10) . '        this._array_[i+i][this._array_[i+i+1]] = p5decr_(this._array_[i+i][this._array_[i+i+1]]);' . chr(10) . '        return v;' . chr(10) . '    }' . chr(10) . '    this.p5aget_array = function (i) {' . chr(10) . '        if (i < 0) { i =  this.length + i };' . chr(10) . '        if (this._array_[i+i][this._array_[i+i+1]] == null) {' . chr(10) . '            this._array_[i+i][this._array_[i+i+1]] = new p5ArrayRef([])' . chr(10) . '        }' . chr(10) . '        return this._array_[i+i][this._array_[i+i+1]]' . chr(10) . '    }' . chr(10) . '    this.p5aget_hash = function (i) {' . chr(10) . '        if (i < 0) { i =  this.length + i };' . chr(10) . '        if (this._array_[i+i][this._array_[i+i+1]] == null) {' . chr(10) . '            this._array_[i+i][this._array_[i+i+1]] = new p5HashRef({})' . chr(10) . '        }' . chr(10) . '        return this._array_[i+i][this._array_[i+i+1]]' . chr(10) . '    }' . chr(10) . '    this.p5unshift = function (args) { ' . chr(10) . '        for(var i = args.length-1; i >= 0; i--) {' . chr(10) . '            this.unshift(0);' . chr(10) . '            this.unshift([args[i]]);' . chr(10) . '        }' . chr(10) . '        return this._array_.length / 2; ' . chr(10) . '    }' . chr(10) . '    this.p5push = function (args) { ' . chr(10) . '        for(var i = 0; i < args.length; i++) {' . chr(10) . '            this.push([args[i]]);' . chr(10) . '            this.push(0);' . chr(10) . '        }' . chr(10) . '        return this._array_.length / 2; ' . chr(10) . '    }' . chr(10) . '    this.shift = function () { ' . chr(10) . '        var v0 = this._array_.shift();' . chr(10) . '        return v0[this._array_.shift()];' . chr(10) . '    }' . chr(10) . '    this.pop = function () { ' . chr(10) . '        var v1 = this._array_.pop();' . chr(10) . '        var v0 = this._array_.pop();' . chr(10) . '        return v0[v1];' . chr(10) . '    }' . chr(10) . '}' . chr(10) . chr(10) . chr(10)
            }
            1
        }
    }
    {
        {
            package main;
            undef();
            package Perlito5::Javascript2::CORE;
            sub Perlito5::Javascript2::CORE::emit_javascript2 {
                return '//' . chr(10) . '//' . chr(10) . '// lib/Perlito5/Javascript2/CORE.js' . chr(10) . '//' . chr(10) . '// CORE functions for "Perlito" Perl5-in-Javascript2' . chr(10) . '//' . chr(10) . '// AUTHORS' . chr(10) . '//' . chr(10) . '// Flavio Soibelmann Glock  fglock@gmail.com' . chr(10) . '//' . chr(10) . '// COPYRIGHT' . chr(10) . '//' . chr(10) . '// Copyright 2009, 2010, 2011, 2012 by Flavio Soibelmann Glock and others.' . chr(10) . '//' . chr(10) . '// This program is free software; you can redistribute it and/or modify it' . chr(10) . '// under the same terms as Perl itself.' . chr(10) . '//' . chr(10) . '// See http://www.perl.com/perl/misc/Artistic.html' . chr(10) . chr(10) . 'var CORE = p5pkg.CORE;' . chr(10) . chr(10) . 'var isNode = typeof require != "undefined";' . chr(10) . chr(10) . 'if (isNode) {' . chr(10) . '    try {' . chr(10) . '        var sleep = require("sleep");' . chr(10) . '        CORE.sleep = function(List__) {' . chr(10) . '            var n = p5num(List__[0]) || 1;' . chr(10) . '            sleep.usleep(n * 1000000);  // sleep for n seconds (1 second is 1000000 microseconds)' . chr(10) . '            return n;' . chr(10) . '        }' . chr(10) . '    }' . chr(10) . '    catch (err) {' . chr(10) . '        CORE.sleep = function(List__) {' . chr(10) . '            CORE.die("sleep() function failed. Maybe you need ' . chr(39) . 'npm install sleep' . chr(39) . '?' . chr(92) . 'n" + err);' . chr(10) . '        }' . chr(10) . '    }' . chr(10) . '}' . chr(10) . 'if (!CORE.sleep) {' . chr(10) . '    CORE.sleep = function(List__) {' . chr(10) . '        CORE.die("sleep() not supported for this platform");' . chr(10) . '    }' . chr(10) . '}' . chr(10) . chr(10) . 'if (isNode) {' . chr(10) . '    try {' . chr(10) . '        var crypt = require("crypt3");' . chr(10) . '        CORE.crypt = function(List__) {' . chr(10) . '            var text = p5str(List__[0]);' . chr(10) . '            var salt = p5str(List__[1]);' . chr(10) . '            while(salt.length() < 2) {' . chr(10) . '                salt += "A";' . chr(10) . '            }' . chr(10) . '            return crypt(text, salt);' . chr(10) . '        }' . chr(10) . '    }' . chr(10) . '    catch (err) {' . chr(10) . '        CORE.crypt = function(List__) {' . chr(10) . '            CORE.die("crypt() function failed. Maybe you need ' . chr(39) . 'npm install crypt3' . chr(39) . '?' . chr(92) . 'n" + err);' . chr(10) . '        }' . chr(10) . '    }' . chr(10) . '}' . chr(10) . 'if (!CORE.crypt) {' . chr(10) . '    CORE.crypt = function(List__) {' . chr(10) . '        CORE.die("crypt() not supported for this platform");' . chr(10) . '    }' . chr(10) . '}' . chr(10) . chr(10) . 'CORE.time = function(List__) {' . chr(10) . '    return CORE.int([Date.now() / 1000]);' . chr(10) . '}' . chr(10) . 'var _fmt_date = function(date) {' . chr(10) . '    return [' . chr(39) . 'Sun' . chr(39) . ',' . chr(39) . 'Mon' . chr(39) . ',' . chr(39) . 'Tue' . chr(39) . ',' . chr(39) . 'Wed' . chr(39) . ',' . chr(39) . 'Thu' . chr(39) . ',' . chr(39) . 'Fri' . chr(39) . ',' . chr(39) . 'Sat' . chr(39) . '][date.getDay()] + ' . chr(39) . ' ' . chr(39) . ' +' . chr(10) . '        [' . chr(39) . 'Jan' . chr(39) . ',' . chr(39) . 'Feb' . chr(39) . ',' . chr(39) . 'Mar' . chr(39) . ',' . chr(39) . 'Apr' . chr(39) . ',' . chr(39) . 'May' . chr(39) . ',' . chr(39) . 'Jun' . chr(39) . ',' . chr(39) . 'Jul' . chr(39) . ',' . chr(39) . 'Aug' . chr(39) . ',' . chr(39) . 'Sep' . chr(39) . ',' . chr(39) . 'Oct' . chr(39) . ',' . chr(39) . 'Nov' . chr(39) . ',' . chr(39) . 'Dec' . chr(39) . '][date.getMonth()] + ' . chr(39) . ' ' . chr(39) . ' +' . chr(10) . '        date.getDate() + ' . chr(39) . ' ' . chr(39) . ' + ' . chr(10) . '        CORE.sprintf([ "%02d:%02d:%02d ", date.getHours(), date.getMinutes(), date.getSeconds() ]) +' . chr(10) . '        date.getFullYear();' . chr(10) . '}' . chr(10) . 'var _list_date = function(date) {' . chr(10) . '    var year_start = new Date(date);' . chr(10) . '    year_start.setMonth(0, 1);' . chr(10) . '    var year_day = Math.round((date-year_start)/8.64e7);' . chr(10) . chr(10) . '    var isdst = 0;  // not implemented' . chr(10) . chr(10) . '    return [date.getSeconds(),date.getMinutes(),date.getHours(),date.getDate(),' . chr(10) . '        date.getMonth(),date.getFullYear()-1900,date.getDay(),' . chr(10) . '        year_day,' . chr(10) . '        isdst' . chr(10) . '    ];' . chr(10) . '}' . chr(10) . 'CORE.localtime = function(List__, want) {' . chr(10) . '    var n = List__.length ? p5num(List__[0]) : CORE.time() ;' . chr(10) . '    var date = new Date(n*1000);' . chr(10) . '    if (!want) {' . chr(10) . '        return _fmt_date(date);' . chr(10) . '    }' . chr(10) . '    return _list_date(date);' . chr(10) . '}' . chr(10) . 'CORE.gmtime = function(List__, want) {' . chr(10) . '    var n = List__.length ? p5num(List__[0]) : CORE.time() ;' . chr(10) . '    var ofs = new Date().getTimezoneOffset() * 60;' . chr(10) . '    var date = new Date((n + ofs)*1000);' . chr(10) . '    if (!want) {' . chr(10) . '        return _fmt_date(date);' . chr(10) . '    }' . chr(10) . '    return _list_date(date);' . chr(10) . '}' . chr(10) . chr(10) . 'CORE.bless = function(List__) {' . chr(10) . '    var o        = List__[0];' . chr(10) . '    var pkg_name = List__[1];' . chr(10) . '    if (typeof pkg_name === "object") {' . chr(10) . '        // bless {}, Class' . chr(10) . '        o._class_ = pkg_name;' . chr(10) . '        return o;' . chr(10) . '    }' . chr(10) . '    if (!p5pkg.hasOwnProperty(pkg_name)) {' . chr(10) . '        p5make_package(pkg_name);' . chr(10) . '    }' . chr(10) . '    o._class_ = p5pkg[pkg_name];' . chr(10) . '    return o;' . chr(10) . '};' . chr(10) . chr(10) . 'CORE.caller = function(List__, want) {' . chr(10) . '    if (p5pkg["Perlito5"].v_CALLER && p5pkg["Perlito5"].v_CALLER._array_ && p5pkg["Perlito5"].v_CALLER._array_.p5aget(0) ) {' . chr(10) . '        // TODO' . chr(10) . '        return p5pkg["Perlito5"].v_CALLER._array_.p5aget(0)._array_' . chr(10) . '    }' . chr(10) . '    return p5context([], want);' . chr(10) . '};' . chr(10) . chr(10) . 'CORE.chr = function(List__) {' . chr(10) . '    var v = p5num(List__[0]);' . chr(10) . '    return String.fromCharCode(v >= 0 ? v : 65533);' . chr(10) . '};' . chr(10) . chr(10) . 'CORE.ord = function(List__) {' . chr(10) . '    return p5str(List__[0]).charCodeAt(0);' . chr(10) . '};' . chr(10) . chr(10) . 'CORE.hex = function(List__) {' . chr(10) . '    var v = List__[0];' . chr(10) . chr(10) . '    for(var i = 0; i < v.length; i++) {' . chr(10) . '        if (v.charCodeAt(i) > 255) {' . chr(10) . '            CORE.die(["Wide character in hex"]);' . chr(10) . '        }' . chr(10) . '    }' . chr(10) . chr(10) . '    var b1 = v.substr(0,1);' . chr(10) . '    var b2 = v.substr(0,2);' . chr(10) . '    if (b1 == "x" || b1 == "X" || b2 == "0x" || b2 == "0X") {' . chr(10) . '        return CORE.oct(List__);' . chr(10) . '    }' . chr(10) . '    v = "0x" + v;' . chr(10) . '    return CORE.oct([v]);' . chr(10) . '};' . chr(10) . chr(10) . 'CORE.oct = function(List__) {' . chr(10) . '    var v = List__[0];' . chr(10) . '    v = v.trim();' . chr(10) . chr(10) . '    for(var i = 0; i < v.length; i++) {' . chr(10) . '        if (v.charCodeAt(i) > 255) {' . chr(10) . '            CORE.die(["Wide character in oct"]);' . chr(10) . '        }' . chr(10) . '    }' . chr(10) . chr(10) . '    var b = v.substr(0,1);' . chr(10) . '    if (b == "b" || b == "B" || b == "x" || b == "X") {' . chr(10) . '        v = "0" + v;' . chr(10) . '    }' . chr(10) . '    b = v.substr(0,2);' . chr(10) . chr(10) . '    for(var i = 2; i < v.length; i++) {' . chr(10) . '        if (v.substr(i,2) == "__") {' . chr(10) . '            v = v.substr(0, i);' . chr(10) . '        }' . chr(10) . '    }' . chr(10) . chr(10) . '    var re = new RegExp(' . chr(39) . '_' . chr(39) . ', ' . chr(39) . 'g' . chr(39) . ');' . chr(10) . '    v = v.replace(re, "");' . chr(10) . '    var result;' . chr(10) . chr(10) . '    if (b == "0b" || b == "0B") {' . chr(10) . '        for(var i = 2; i < v.length; i++) {' . chr(10) . '            var c = v.substr(i,1);' . chr(10) . '            if (c >= "0" && c <= "1") {}' . chr(10) . '            else {' . chr(10) . '                v = v.substr(0, i);' . chr(10) . '            }' . chr(10) . '        }' . chr(10) . '        if (v.length == 2) { return 0 }' . chr(10) . '        result = parseInt(v.substr(2), 2);' . chr(10) . '    }' . chr(10) . '    else if (b == "0x" || b == "0X") {' . chr(10) . '        for(var i = 2; i < v.length; i++) {' . chr(10) . '            var c = v.substr(i,1);' . chr(10) . '            if (c >= "0" && c <= "9" || c >= "A" && c <= "F" || c >= "a" && c <= "f") {}' . chr(10) . '            else {' . chr(10) . '                v = v.substr(0, i);' . chr(10) . '            }' . chr(10) . '        }' . chr(10) . '        if (v.length == 2) { return 0 }' . chr(10) . '        result = parseInt(v.substr(2), 16);' . chr(10) . '    }' . chr(10) . '    else {' . chr(10) . '        result = parseInt(v, 8);' . chr(10) . '    }' . chr(10) . '    return isNaN(result) ? 0 : result;' . chr(10) . '};' . chr(10) . chr(10) . 'CORE.abs   = function(List__) { return Math.abs(List__[0]) };' . chr(10) . 'CORE.exp   = function(List__) { return Math.exp(List__[0]) };' . chr(10) . 'CORE.log   = function(List__) { return Math.log(List__[0]) };' . chr(10) . 'CORE.cos   = function(List__) { return Math.cos(List__[0]) };' . chr(10) . 'CORE.sin   = function(List__) { return Math.sin(List__[0]) };' . chr(10) . 'CORE.sqrt  = function(List__) { return Math.sqrt(List__[0]) };' . chr(10) . 'CORE.atan2 = function(List__) { return Math.atan2(List__[0], List__[1]) };' . chr(10) . 'CORE.int   = function(List__) { return List__[0] > 0 ? Math.floor(List__[0]) : Math.ceil(List__[0]) };' . chr(10) . chr(10) . 'var p5rand = function(v) { return Math.random() * v };' . chr(10) . 'CORE.srand = function(List__) {' . chr(10) . '    if (List__.length > 0) {' . chr(10) . '        var v = p5num(List__[0]) || 1;' . chr(10) . '        p5rand = function() {' . chr(10) . '            v = Math.sin(v) * 10000;' . chr(10) . '            return v - Math.floor(v);' . chr(10) . '        };' . chr(10) . '        return List__[0];' . chr(10) . '    }' . chr(10) . '    return CORE.int(CORE.rand(100000));' . chr(10) . '};' . chr(10) . 'CORE.rand = function(List__) {' . chr(10) . '    var v = p5num(List__[0]) || 1;' . chr(10) . '    return p5rand(v);' . chr(10) . '};' . chr(10) . chr(10) . 'CORE.lc      = function(List__) { return p5str(List__[0]).toLowerCase() };' . chr(10) . 'CORE.uc      = function(List__) { return p5str(List__[0]).toUpperCase() };' . chr(10) . chr(10) . 'CORE.lcfirst = function(List__) {' . chr(10) . '    var s = p5str(List__[0]);' . chr(10) . '    var c = s.length > 0 ? s.slice(0,1).toLowerCase() : "";' . chr(10) . '    s = s.length > 1 ? s.substr(1) : "";' . chr(10) . '    return c + s' . chr(10) . '};' . chr(10) . chr(10) . 'CORE.ucfirst = function(List__) {' . chr(10) . '    var s = p5str(List__[0]);' . chr(10) . '    var c = s.length > 0 ? s.slice(0,1).toUpperCase() : "";' . chr(10) . '    s = s.length > 1 ? s.substr(1) : "";' . chr(10) . '    return c + s' . chr(10) . '};' . chr(10) . chr(10) . 'CORE.quotemeta = function(List__) {' . chr(10) . '    var s = p5str(List__[0]);' . chr(10) . '    var out = [];' . chr(10) . '    for(var i = 0; i < s.length; i++) {' . chr(10) . '        if (s.substr(i, 1).match(/[^0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz]/)) {' . chr(10) . '            out.push(String.fromCharCode(92));' . chr(10) . '        }' . chr(10) . '        out.push(s.substr(i, 1));' . chr(10) . '    }' . chr(10) . '    return out.join("");       ' . chr(10) . '};' . chr(10) . chr(10) . 'CORE.substr = function(List__) {' . chr(10) . '    var expr        = List__[0];' . chr(10) . '    var offset      = List__[1];' . chr(10) . '    var length      = List__[2];' . chr(10) . '    var replacement = List__[3];' . chr(10) . '    if (length < 0) {' . chr(10) . '        var s = p5str(expr);' . chr(10) . '        length = s.length - offset + length;' . chr(10) . '    } ' . chr(10) . '    return p5str(expr).substr(offset, length);' . chr(10) . '};' . chr(10) . chr(10) . 'CORE.values = function(List__, p5want) {' . chr(10) . '    var o = List__[0];' . chr(10) . '    delete o["_each_"];' . chr(10) . '    if (p5want) {' . chr(10) . '        if (o == null) {' . chr(10) . '            return [];' . chr(10) . '        };' . chr(10) . '        if (typeof o.values === "function") {' . chr(10) . '            return o.values();' . chr(10) . '        }' . chr(10) . '        var out = [];' . chr(10) . '        for (var i in o) {' . chr(10) . '            out.push(o[i]);' . chr(10) . '        }' . chr(10) . '        return out;' . chr(10) . '    }' . chr(10) . '    return CORE.keys(List__, p5want);' . chr(10) . '};' . chr(10) . chr(10) . 'CORE.keys = function(List__, p5want) {' . chr(10) . '    var o = List__[0];' . chr(10) . '    delete o["_each_"];' . chr(10) . '    if (p5want) {' . chr(10) . '        if (o == null) {' . chr(10) . '            return [];' . chr(10) . '        }' . chr(10) . '        if (typeof o.keys === "function") {' . chr(10) . '            return o.keys();' . chr(10) . '        }' . chr(10) . '        var out = [];' . chr(10) . '        for (var i in o) {' . chr(10) . '            out.push(i);' . chr(10) . '        }' . chr(10) . '        return out;' . chr(10) . '    }' . chr(10) . '    else {' . chr(10) . '        if (o == null) {' . chr(10) . '            return 0;' . chr(10) . '        }' . chr(10) . '        if (typeof o.keys === "function") {' . chr(10) . '            return p5num(o.keys());' . chr(10) . '        }' . chr(10) . '        var out = 0;' . chr(10) . '        for (var i in o) {' . chr(10) . '            out++;' . chr(10) . '        }' . chr(10) . '        return out;' . chr(10) . '    }' . chr(10) . '};' . chr(10) . chr(10) . 'CORE.each = function(List__, p5want) {' . chr(10) . '    var o = List__[0];' . chr(10) . '    if (o.hasOwnProperty("_each_")) {' . chr(10) . '        return o._each_(p5want)' . chr(10) . '    }' . chr(10) . '    var keys = CORE.keys([o], 1);' . chr(10) . '    var i = 0;' . chr(10) . '    o._each_ = function () {' . chr(10) . '        if (i < keys.length) {' . chr(10) . '            i++;' . chr(10) . '            return p5want ? [keys[i-1], o[keys[i-1]]] : keys[i-1];' . chr(10) . '        }' . chr(10) . '        i = 0;' . chr(10) . '        return p5want ? [] : null;' . chr(10) . '    };' . chr(10) . '    return o._each_(p5want);' . chr(10) . '};' . chr(10) . chr(10) . 'CORE.reverse = function(List__, p5want) {' . chr(10) . '    var o = List__;' . chr(10) . '    if (p5want) {' . chr(10) . '        if (o == null) {' . chr(10) . '            return [];' . chr(10) . '        }' . chr(10) . '        return List__.reverse();' . chr(10) . '    }' . chr(10) . '    o = p5str(o);' . chr(10) . '    return o.split("").reverse().join("")' . chr(10) . '};' . chr(10) . chr(10) . 'CORE.splice = function(List__, p5want) {' . chr(10) . '    var array  = List__.shift();' . chr(10) . '    // CORE.say([ array ]);' . chr(10) . '    var offset = p5num(List__.shift());' . chr(10) . '    var limit  = List__.length ? p5num(List__.shift()) : (array.length + 1);' . chr(10) . chr(10) . '    if (limit < 0) {' . chr(10) . '        limit = array.length + limit - 1;' . chr(10) . '    }' . chr(10) . chr(10) . '    var list = [offset, limit];' . chr(10) . '    for(var i = 0; i < List__.length; i++) {' . chr(10) . '        list = p5list_to_a([ list, List__[i] ]);' . chr(10) . '    }' . chr(10) . chr(10) . '    var out = array.splice.apply(array, list);' . chr(10) . '    // CORE.say([ CORE.join([":",array]), " ofs=", offset, " lim=", limit, " list=", list, " out=", CORE.join([":",out])  ]);' . chr(10) . '    return p5want ? out : out.pop();' . chr(10) . '};' . chr(10) . chr(10) . 'CORE.join = function(List__) {' . chr(10) . '    var s = List__.shift();' . chr(10) . '    var o = [];' . chr(10) . '    for (var i = 0; i < List__.length; i++) {' . chr(10) . '        o.push(p5str(List__[i]));' . chr(10) . '    }' . chr(10) . '    return o.join(s);' . chr(10) . '};' . chr(10) . chr(10) . 'CORE.index = function(List__) {' . chr(10) . '    var o = List__[0];' . chr(10) . '    var s = List__[1];' . chr(10) . '    try {' . chr(10) . '        return o.indexOf(s, p5num(List__[2]));' . chr(10) . '    }' . chr(10) . '    catch(err) {' . chr(10) . '        return -1;' . chr(10) . '    }' . chr(10) . '};' . chr(10) . 'CORE.rindex = function(List__) {' . chr(10) . '    var o = List__[0];' . chr(10) . '    var s = List__[1];' . chr(10) . '    try {' . chr(10) . '        if (List__.length > 2) {' . chr(10) . '            var i = p5num(List__[2]);' . chr(10) . '            if (i < 0) {' . chr(10) . '                if (s.length == 0) {' . chr(10) . '                    return 0;' . chr(10) . '                }' . chr(10) . '                return -1;' . chr(10) . '            }' . chr(10) . '            return o.lastIndexOf(s, i);' . chr(10) . '        }' . chr(10) . '        return o.lastIndexOf(s);' . chr(10) . '    }' . chr(10) . '    catch(err) {' . chr(10) . '        return -1;' . chr(10) . '    }' . chr(10) . '};' . chr(10) . chr(10) . 'CORE.length = function(List__) {' . chr(10) . '    return p5str(List__[0]).length;' . chr(10) . '};' . chr(10) . chr(10) . 'CORE.pack    = function(List__) { CORE.warn([ "CORE::pack not implemented" ]) };' . chr(10) . 'CORE.unpack  = function(List__) { CORE.warn([ "CORE::unpack not implemented" ]) };' . chr(10) . chr(10) . 'CORE.ref = function(List__) {' . chr(10) . '    var o = List__[0];' . chr(10) . '    if (o == null) {' . chr(10) . '        return "";' . chr(10) . '    }' . chr(10) . '    if (o._class_ && typeof o._class_._ref_ === "string") {' . chr(10) . '        // blessed reference' . chr(10) . '        return o._class_._ref_;' . chr(10) . '    }' . chr(10) . '    if (typeof o._ref_ === "string") {' . chr(10) . '        // un-blessed reference' . chr(10) . '        return o._ref_;' . chr(10) . '    }' . chr(10) . '    if (typeof o === "function") {' . chr(10) . '        return "CODE";' . chr(10) . '    }' . chr(10) . '    return "";' . chr(10) . '};' . chr(10) . chr(10) . 'CORE.split = function(List__, want) {' . chr(10) . '    var pattern = List__[0];' . chr(10) . '    var s       = p5str(List__[1]);' . chr(10) . '    var limit   = p5num(List__[2]);' . chr(10) . '    if (!want) {' . chr(10) . '        // scalar context' . chr(10) . '        return p5num(CORE.split(List__, 1));' . chr(10) . '    }' . chr(10) . '    if (limit == 0) {' . chr(10) . '        // strip trailing empty strings and undef' . chr(10) . '        var res = CORE.split([pattern, s, -1], 1);' . chr(10) . '        while (res.length && (res[res.length - 1] == ' . chr(39) . chr(39) . ' || typeof res[res.length - 1] == "undefined") ) {' . chr(10) . '            res.pop()' . chr(10) . '        }' . chr(10) . '        return res;' . chr(10) . '    }' . chr(10) . '    if (s == ' . chr(39) . chr(39) . ') {' . chr(10) . '        return []' . chr(10) . '    }' . chr(10) . '    // make sure pattern is a RegExp' . chr(10) . '    if (typeof pattern === "object" && (pattern instanceof RegExp)) {' . chr(10) . '        pattern = pattern.source;' . chr(10) . '    }' . chr(10) . '    else {' . chr(10) . '        pattern = p5str(pattern);' . chr(10) . '        if (pattern == " ") {' . chr(10) . '            // single space string is special' . chr(10) . '            pattern = "(?: |' . chr(92) . 't|' . chr(92) . 'n)+";' . chr(10) . '            s = s.replace(/^(?: |' . chr(92) . 't|' . chr(92) . 'n)+/, "");' . chr(10) . '        }' . chr(10) . '    }' . chr(10) . '    // add "g", "m" modifiers' . chr(10) . '    var flags = "g";' . chr(10) . '    if (pattern.substr(0, 1) == "^" || pattern.substr(-1,1) == "$") {' . chr(10) . '        flags = flags + "m";' . chr(10) . '    }' . chr(10) . '    pattern = new RegExp(pattern, flags);' . chr(10) . '    var res = [];' . chr(10) . '    var pos = 0;' . chr(10) . '    var count = 0;' . chr(10) . '    while (1) {' . chr(10) . '        if (limit > 0 && limit <= (count + 1)) {' . chr(10) . '            res.push(s.substr(pos));' . chr(10) . '            return res;' . chr(10) . '        }' . chr(10) . '        var m = pattern.exec(s);' . chr(10) . '        if (m === null) {' . chr(10) . '            // no match' . chr(10) . '            res.push(s.substr(pos));' . chr(10) . '            return res;' . chr(10) . '        }' . chr(10) . '        if (m[0].length == 0 && m.index == pos) {' . chr(10) . '            // pointer didn' . chr(39) . 't move' . chr(10) . '            pattern.lastIndex = pattern.lastIndex + 1;' . chr(10) . '        }' . chr(10) . '        else {' . chr(10) . '            var part = s.substr(pos, m.index - pos);' . chr(10) . '            res.push(part);' . chr(10) . '            count++;' . chr(10) . '            pos = m.index + m[0].length;' . chr(10) . '            pattern.lastIndex = pos;' . chr(10) . '        }' . chr(10) . '        for (var i = 1; i < m.length ; i++) {' . chr(10) . '            res.push(m[i]);     // captured substrings; don' . chr(39) . 't increment count' . chr(10) . '        }' . chr(10) . '    }' . chr(10) . '};' . chr(10) . chr(10) . chr(10)
            }
            1
        }
    }
    {
        {
            package main;
            undef();
            package Perlito5::Javascript2::IO;
            sub Perlito5::Javascript2::IO::emit_javascript2 {
                return '//' . chr(10) . '//' . chr(10) . '// lib/Perlito5/Javascript2/IO.js' . chr(10) . '//' . chr(10) . '// I/O functions for "Perlito" Perl5-in-Javascript2' . chr(10) . '//' . chr(10) . '// AUTHORS' . chr(10) . '//' . chr(10) . '// Flavio Soibelmann Glock  fglock@gmail.com' . chr(10) . '//' . chr(10) . '// COPYRIGHT' . chr(10) . '//' . chr(10) . '// Copyright 2009, 2010, 2011, 2012 by Flavio Soibelmann Glock and others.' . chr(10) . '//' . chr(10) . '// This program is free software; you can redistribute it and/or modify it' . chr(10) . '// under the same terms as Perl itself.' . chr(10) . '//' . chr(10) . '// See http://www.perl.com/perl/misc/Artistic.html' . chr(10) . chr(10) . 'var isNode = typeof require != "undefined";' . chr(10) . 'if (isNode) {' . chr(10) . chr(10) . '    var fs = require("fs");' . chr(10) . chr(10) . '    p5typeglob_set("Perlito5::IO", "print", function (filehandle, List__, p5want) {' . chr(10) . '        try {' . chr(10) . '            var v = filehandle;' . chr(10) . '            var pkg;' . chr(10) . '            if (CORE.ref([v])) {' . chr(10) . '                // looks like a filehandle' . chr(10) . '                pkg = v;' . chr(10) . '            }' . chr(10) . '            else {' . chr(10) . '                // looks like a package name' . chr(10) . '                pkg = p5make_package(v);' . chr(10) . '            }' . chr(10) . '            if (!pkg.file_handle) {' . chr(10) . '                pkg.file_handle = {};' . chr(10) . '            }' . chr(10) . '            var handle_id = pkg.file_handle.id;' . chr(10) . '            if (handle_id == 1) {' . chr(10) . '                for (var i = 0; i < List__.length; i++) {' . chr(10) . '                    process.stdout.write(p5str(List__[i]));' . chr(10) . '                }' . chr(10) . '            }' . chr(10) . '            else if (handle_id == 2) {' . chr(10) . '                for (var i = 0; i < List__.length; i++) {' . chr(10) . '                    process.stderr.write(p5str(List__[i]));' . chr(10) . '                }' . chr(10) . '            }' . chr(10) . '            else {' . chr(10) . '                for (var i = 0; i < List__.length; i++) {' . chr(10) . '                    fs.writeSync(handle_id, p5str(List__[i]));' . chr(10) . '                }' . chr(10) . '            }' . chr(10) . '            return 1;' . chr(10) . '        }' . chr(10) . '        catch(err) {' . chr(10) . '            p5pkg["main"]["v_!"] = err;' . chr(10) . '            return ' . chr(39) . chr(39) . ';' . chr(10) . '        }' . chr(10) . '    } );' . chr(10) . chr(10) . '    var p5_extra_buffer_size = 100;' . chr(10) . '    p5typeglob_set("Perlito5::IO", "read", function (filehandle, List__, p5want) {' . chr(10) . '        try {' . chr(10) . '            var v = filehandle;' . chr(10) . '            var length = List__.shift();' . chr(10) . '            var pkg;' . chr(10) . '            if (CORE.ref([v])) {' . chr(10) . '                // looks like a filehandle' . chr(10) . '                pkg = v;' . chr(10) . '            }' . chr(10) . '            else {' . chr(10) . '                // looks like a package name' . chr(10) . '                pkg = p5make_package(v);' . chr(10) . '            }' . chr(10) . '            if (!pkg.file_handle) {' . chr(10) . '                pkg.file_handle = {};' . chr(10) . '            }' . chr(10) . '            var handle_id = pkg.file_handle.id;' . chr(10) . chr(10) . '            if (!pkg.file_handle.buffer) {' . chr(10) . '                // we don' . chr(39) . 't have any data yet' . chr(10) . '                var length_wanted = length + 2 * p5_extra_buffer_size;' . chr(10) . '                var buffer = new Buffer(length_wanted);' . chr(10) . '                var bytes_read = fs.readSync(handle_id, buffer, 0, length_wanted, null);' . chr(10) . '                if (bytes_read < length_wanted) {' . chr(10) . '                    pkg.file_handle.buffer_eof = 1;' . chr(10) . '                }' . chr(10) . '                pkg.file_handle.buffer = buffer;' . chr(10) . '                pkg.file_handle.buffer_start = 0;' . chr(10) . '                pkg.file_handle.buffer_end = bytes_read;' . chr(10) . '                pkg.file_handle.buffer_length = pkg.file_handle.buffer_end;' . chr(10) . '            }' . chr(10) . '            else if (pkg.file_handle.buffer_length > (length + p5_extra_buffer_size)) {' . chr(10) . '                // we have enough data' . chr(10) . '            }' . chr(10) . '            else if (!pkg.file_handle.buffer_eof) {' . chr(10) . '                // we have some data; append more data to the internal buffer' . chr(10) . '                var length_wanted = length + 2 * p5_extra_buffer_size;' . chr(10) . '                var buffer = new Buffer(pkg.file_handle.buffer_length + length_wanted);' . chr(10) . '                pkg.file_handle.buffer.copy(buffer, 0, pkg.file_handle.buffer_start, pkg.file_handle.buffer_end);' . chr(10) . '                var bytes_read = fs.readSync(handle_id, buffer, pkg.file_handle.buffer_length, length_wanted, null);' . chr(10) . '                if (bytes_read < length_wanted) {' . chr(10) . '                    pkg.file_handle.buffer_eof = 1;' . chr(10) . '                }' . chr(10) . '                pkg.file_handle.buffer = buffer;' . chr(10) . '                pkg.file_handle.buffer_start = 0;' . chr(10) . '                pkg.file_handle.buffer_end = pkg.file_handle.buffer_length + bytes_read;' . chr(10) . '                pkg.file_handle.buffer_length = pkg.file_handle.buffer_end;' . chr(10) . '            }' . chr(10) . chr(10) . '            var s = pkg.file_handle.buffer.toString(' . chr(39) . 'utf-8' . chr(39) . ', pkg.file_handle.buffer_start, pkg.file_handle.buffer_end).substr(0, length);' . chr(10) . chr(10) . '            // how many bytes we actually used' . chr(10) . '            var buffer_used = Buffer.byteLength(s, ' . chr(39) . 'utf-8' . chr(39) . ');' . chr(10) . chr(10) . '            pkg.file_handle.buffer_start = pkg.file_handle.buffer_start + buffer_used;' . chr(10) . '            pkg.file_handle.buffer_length = pkg.file_handle.buffer_length - buffer_used;' . chr(10) . chr(10) . '            if ( handle_id == 0) {' . chr(10) . '                // STDIN' . chr(10) . '                pkg.file_handle.buffer_eof = (s.length ? 0 : 1);' . chr(10) . '                pkg.file_handle.eof = (s.length ? 0 : 1);' . chr(10) . '            }' . chr(10) . '            else if ( pkg.file_handle.buffer_eof && pkg.file_handle.buffer_length <= 0 ) {' . chr(10) . '                pkg.file_handle.eof = 1;' . chr(10) . '            }' . chr(10) . chr(10) . '            return [s.length, s];' . chr(10) . '        }' . chr(10) . '        catch(err) {' . chr(10) . '            p5pkg["main"]["v_!"] = err;' . chr(10) . '            return [];' . chr(10) . '        }' . chr(10) . '    } );' . chr(10) . chr(10) . '    var p5ARGV = 0;' . chr(10) . '    (function (f) {' . chr(10) . '        p5typeglob_set("Perlito5::IO", "readline", f);' . chr(10) . '        p5typeglob_set("Perlito5::IO", "getline", f);' . chr(10) . '    })(function (List__, p5want) {' . chr(10) . '        var filehandle = List__.shift();' . chr(10) . chr(10) . '        if (p5want) {' . chr(10) . '            var out = [];' . chr(10) . '            while (1) {' . chr(10) . '                var s = p5pkg["Perlito5::IO"].readline([filehandle], 0);' . chr(10) . '                if (s == null) {' . chr(10) . '                    return out;' . chr(10) . '                }' . chr(10) . '                out.push(s);' . chr(10) . '            }' . chr(10) . '        }' . chr(10) . chr(10) . '        var v = filehandle;' . chr(10) . '        var pkg;' . chr(10) . '        if (CORE.ref([v])) {' . chr(10) . '            // looks like a filehandle' . chr(10) . '            pkg = v;' . chr(10) . '        }' . chr(10) . '        else {' . chr(10) . '            // looks like a package name' . chr(10) . '            pkg = p5make_package(v);' . chr(10) . '            if (v == "ARGV") {' . chr(10) . '                // ARGV is magical' . chr(10) . '                if (pkg.file_handle.id == null) {' . chr(10) . '                    if (!p5ARGV) {' . chr(10) . '                        if (p5pkg["main"]["List_ARGV"].length == 0) {' . chr(10) . '                            p5pkg["main"]["List_ARGV"].push(' . chr(39) . '-' . chr(39) . ');' . chr(10) . '                        }' . chr(10) . '                    }' . chr(10) . '                    p5ARGV = 1;' . chr(10) . '                    // TODO - open $ARGV[1], ...' . chr(10) . '                    var filename = p5pkg["main"]["List_ARGV"].shift();' . chr(10) . '                    CORE.open([ "ARGV", "<", filename ]) || CORE.die([ p5pkg["main"]["v_!"] ]);' . chr(10) . '                }' . chr(10) . '            }' . chr(10) . '        }' . chr(10) . '        if (!pkg.file_handle) {' . chr(10) . '            pkg.file_handle = {};' . chr(10) . '        }' . chr(10) . chr(10) . '        if (CORE.eof([v])) {' . chr(10) . '            return null;' . chr(10) . '        }' . chr(10) . chr(10) . '        var separator = p5pkg["main"]["v_/"];  // input record separator' . chr(10) . '        var buf = pkg.file_handle.readline_buffer;' . chr(10) . '        var pos;' . chr(10) . chr(10) . '        if (separator) {' . chr(10) . '            pos = buf.indexOf(separator);' . chr(10) . '            while ( pos < 0 && !pkg.file_handle.eof ) {' . chr(10) . '                var r = p5pkg["Perlito5::IO"].read(filehandle, [100]);' . chr(10) . '                buf = buf + r[1];' . chr(10) . '                pos = buf.indexOf(separator);' . chr(10) . '            }' . chr(10) . '        }' . chr(10) . '        else {' . chr(10) . '            // no separator' . chr(10) . '            pos = -1;' . chr(10) . '            while ( !pkg.file_handle.eof ) {' . chr(10) . '                var r = p5pkg["Perlito5::IO"].read(filehandle, [100]);' . chr(10) . '                buf = buf + r[1];' . chr(10) . '            }' . chr(10) . '        }' . chr(10) . chr(10) . '        if (pos < 0) {' . chr(10) . '            pkg.file_handle.readline_buffer = ' . chr(39) . chr(39) . ';' . chr(10) . '            if (!buf.length) {' . chr(10) . '                pkg.file_handle.readline_buffer = ' . chr(39) . chr(39) . ';' . chr(10) . '                pkg.file_handle.eof = 1;' . chr(10) . '                return null' . chr(10) . '            }' . chr(10) . '            return buf;' . chr(10) . '        }' . chr(10) . '        var s = buf.substr(0, pos + separator.length);' . chr(10) . '        pkg.file_handle.readline_buffer = buf.substr(pos + separator.length);' . chr(10) . '        if (!s.length) {' . chr(10) . '            pkg.file_handle.readline_buffer = ' . chr(39) . chr(39) . ';' . chr(10) . '            pkg.file_handle.eof = 1;' . chr(10) . '            return null' . chr(10) . '        }' . chr(10) . '        return s;' . chr(10) . '    });' . chr(10) . chr(10) . '    p5typeglob_set("Perlito5::IO", "close", function (filehandle, List__, p5want) {' . chr(10) . '        try {' . chr(10) . '            var v = filehandle;' . chr(10) . '            var pkg;' . chr(10) . '            if (CORE.ref([v])) {' . chr(10) . '                // looks like a filehandle' . chr(10) . '                pkg = v;' . chr(10) . '            }' . chr(10) . '            else {' . chr(10) . '                // looks like a package name' . chr(10) . '                pkg = p5make_package(v);' . chr(10) . '            }' . chr(10) . '            if (!pkg.file_handle) {' . chr(10) . '                pkg.file_handle = {};' . chr(10) . '            }' . chr(10) . '            var handle_id = pkg.file_handle.id;' . chr(10) . '            if (handle_id == 1) {' . chr(10) . '                process.stdout.close();' . chr(10) . '            }' . chr(10) . '            else if (handle_id == 2) {' . chr(10) . '                process.stderr.close();' . chr(10) . '            }' . chr(10) . '            else {' . chr(10) . '                fs.closeSync(handle_id);' . chr(10) . '            }' . chr(10) . '            pkg.file_handle.id = null;' . chr(10) . '            return 1;' . chr(10) . '        }' . chr(10) . '        catch(err) {' . chr(10) . '            p5pkg["main"]["v_!"] = err;' . chr(10) . '            return ' . chr(39) . chr(39) . ';' . chr(10) . '        }' . chr(10) . '    } );' . chr(10) . chr(10) . '    CORE.eof = function(List__) {' . chr(10) . '        try {' . chr(10) . '            var filehandle = List__.shift();' . chr(10) . '            var v = filehandle;' . chr(10) . '            var pkg;' . chr(10) . '            if (CORE.ref([v])) {' . chr(10) . '                // looks like a filehandle' . chr(10) . '                pkg = v;' . chr(10) . '            }' . chr(10) . '            else {' . chr(10) . '                // looks like a package name' . chr(10) . '                pkg = p5make_package(v);' . chr(10) . '            }' . chr(10) . '            if (!pkg.file_handle) {' . chr(10) . '                pkg.file_handle = {};' . chr(10) . '            }' . chr(10) . '            var handle_id = pkg.file_handle.id;' . chr(10) . '            if (handle_id == null) {' . chr(10) . '                return 1;  // file is not open' . chr(10) . '            }' . chr(10) . '            return pkg.file_handle.eof && pkg.file_handle.readline_buffer.length == 0;' . chr(10) . '        }' . chr(10) . '        catch(err) {' . chr(10) . '            p5pkg["main"]["v_!"] = err;' . chr(10) . '            return ' . chr(39) . chr(39) . ';' . chr(10) . '        }' . chr(10) . '    };' . chr(10) . chr(10) . '    CORE.open = function(List__) {' . chr(10) . '        try {' . chr(10) . '            var filehandle = List__.shift();' . chr(10) . '            var flags = List__.shift();' . chr(10) . '            var path;' . chr(10) . '            if (List__.length) {' . chr(10) . '                path = List__.shift();' . chr(10) . '            }' . chr(10) . '            else {' . chr(10) . '                // 2-argument open' . chr(10) . '                var re = new RegExp("^([<>+|]*)(.*)$", "");' . chr(10) . '                var capture = re.exec(flags);' . chr(10) . '                flags = capture[1];' . chr(10) . '                path = capture[2];' . chr(10) . '            }' . chr(10) . '            var v = filehandle;' . chr(10) . '            var pkg;' . chr(10) . '            if (CORE.ref([v])) {' . chr(10) . '                // looks like a filehandle' . chr(10) . '                pkg = v;' . chr(10) . '            }' . chr(10) . '            else {' . chr(10) . '                // looks like a package name' . chr(10) . '                pkg = p5make_package(v);' . chr(10) . '                if (path == "-") {' . chr(10) . '                    if (flags == ' . chr(39) . '>' . chr(39) . ' || flags == ' . chr(39) . '>>' . chr(39) . ' || flags == ' . chr(39) . '+>' . chr(39) . ' || flags == ' . chr(39) . '+>>' . chr(39) . ') {' . chr(10) . '                        pkg.file_handle = p5pkg["STDOUT"].file_handle;' . chr(10) . '                    }' . chr(10) . '                    else {' . chr(10) . '                        pkg.file_handle = p5pkg["STDIN"].file_handle;' . chr(10) . '                    }' . chr(10) . '                }' . chr(10) . '            }' . chr(10) . '            if (!pkg.file_handle) {' . chr(10) . '                pkg.file_handle = {};' . chr(10) . '            }' . chr(10) . '            var handle_id = pkg.file_handle.id;' . chr(10) . '            if (handle_id != null) {' . chr(10) . '                if (handle_id < 2) {' . chr(10) . '                    return 1;   // STDIN, STDOUT, STDERR' . chr(10) . '                }' . chr(10) . '                p5pkg["Perlito5::IO"].close(filehandle, []);' . chr(10) . '            }' . chr(10) . '            if (flags == ' . chr(39) . '>' . chr(39) . ') {' . chr(10) . '                flags = ' . chr(39) . 'w' . chr(39) . chr(10) . '            }' . chr(10) . '            else if (flags == ' . chr(39) . '>>' . chr(39) . ') {' . chr(10) . '                flags = ' . chr(39) . 'a' . chr(39) . chr(10) . '            }' . chr(10) . '            else if (flags == ' . chr(39) . '<' . chr(39) . ' || flags == ' . chr(39) . chr(39) . ' || flags == ' . chr(39) . '<:encoding(UTF-8)' . chr(39) . ') {' . chr(10) . '                flags = ' . chr(39) . 'r' . chr(39) . chr(10) . '            }' . chr(10) . '            else if (flags == ' . chr(39) . '+>' . chr(39) . ') {' . chr(10) . '                flags = ' . chr(39) . 'w+' . chr(39) . chr(10) . '            }' . chr(10) . '            else if (flags == ' . chr(39) . '+>>' . chr(39) . ') {' . chr(10) . '                flags = ' . chr(39) . 'a+' . chr(39) . chr(10) . '            }' . chr(10) . '            else if (flags == ' . chr(39) . '+<' . chr(39) . ') {' . chr(10) . '                flags = ' . chr(39) . 'r+' . chr(39) . chr(10) . '            }' . chr(10) . '            else {' . chr(10) . '                CORE.die([ "don' . chr(39) . 't know what to do with MODE ' . chr(39) . '", flags, "' . chr(39) . '" ]);' . chr(10) . '            }' . chr(10) . '            var id = fs.openSync(path, flags);' . chr(10) . '            pkg.file_handle = { id : id, readline_buffer : ' . chr(39) . chr(39) . ' };' . chr(10) . '            return 1;' . chr(10) . '        }' . chr(10) . '        catch(err) {' . chr(10) . '            p5pkg["main"]["v_!"] = err;' . chr(10) . '            return ' . chr(39) . chr(39) . ';' . chr(10) . '        }' . chr(10) . '    };' . chr(10) . chr(10) . '    var p5atime = function(s) {' . chr(10) . '        try {' . chr(10) . '            var stat = fs.statSync(s); return stat["atime"];' . chr(10) . '        }' . chr(10) . '        catch(err) {' . chr(10) . '            return ' . chr(39) . chr(39) . ';' . chr(10) . '        }' . chr(10) . '    };' . chr(10) . '    var p5mtime = function(s) {' . chr(10) . '        try {' . chr(10) . '            var stat = fs.statSync(s); return stat["mtime"];' . chr(10) . '        }' . chr(10) . '        catch(err) {' . chr(10) . '            return ' . chr(39) . chr(39) . ';' . chr(10) . '        }' . chr(10) . '    };' . chr(10) . '    var p5ctime = function(s) {' . chr(10) . '        try {' . chr(10) . '            var stat = fs.statSync(s); return stat["ctime"];' . chr(10) . '        }' . chr(10) . '        catch(err) {' . chr(10) . '            return ' . chr(39) . chr(39) . ';' . chr(10) . '        }' . chr(10) . '    };' . chr(10) . '    var p5size = function(s) {' . chr(10) . '        try {' . chr(10) . '            var stat = fs.statSync(s); return stat["size"];' . chr(10) . '        }' . chr(10) . '        catch(err) {' . chr(10) . '            return ' . chr(39) . chr(39) . ';' . chr(10) . '        }' . chr(10) . '    };' . chr(10) . '    var p5is_file = function(s) {' . chr(10) . '        try {' . chr(10) . '            var stat = fs.statSync(s); return stat.isFile() ? 1 : 0;' . chr(10) . '        }' . chr(10) . '        catch(err) {' . chr(10) . '            return ' . chr(39) . chr(39) . ';' . chr(10) . '        }' . chr(10) . '    };' . chr(10) . '    var p5is_directory = function(s) {' . chr(10) . '        try {' . chr(10) . '            var stat = fs.statSync(s); return stat.isDirectory() ? 1 : 0;' . chr(10) . '        }' . chr(10) . '        catch(err) {' . chr(10) . '            return ' . chr(39) . chr(39) . ';' . chr(10) . '        }' . chr(10) . '    };' . chr(10) . '    var p5file_exists = function(s) {' . chr(10) . '        return p5is_file(s) || p5is_directory(s);' . chr(10) . '    };' . chr(10) . '    var p5is_pipe = function(s) {' . chr(10) . '        try {' . chr(10) . '            var stat = fs.statSync(s);' . chr(10) . '            return stat.isFIFO() ? 1 : "";' . chr(10) . '        }' . chr(10) . '        catch(err) {' . chr(10) . '            try {' . chr(10) . '                var filehandle = s;' . chr(10) . '                var v = filehandle;' . chr(10) . '                var pkg;' . chr(10) . '                if (CORE.ref([v])) {' . chr(10) . '                    // looks like a filehandle' . chr(10) . '                    pkg = v;' . chr(10) . '                }' . chr(10) . '                else {' . chr(10) . '                    // looks like a package name' . chr(10) . '                    pkg = p5make_package(v);' . chr(10) . '                }' . chr(10) . '                if (!pkg.file_handle) {' . chr(10) . '                    pkg.file_handle = {};' . chr(10) . '                }' . chr(10) . '                var handle_id = pkg.file_handle.id;' . chr(10) . '                if (handle_id == 0) {' . chr(10) . '                    return process.stdin.isTTY ? "" : 1;' . chr(10) . '                }' . chr(10) . '                else if (handle_id == 1) {' . chr(10) . '                    return process.stdout.isTTY ? "" : 1;' . chr(10) . '                }' . chr(10) . '                else if (handle_id == 2) {' . chr(10) . '                    return process.stderr.isTTY ? "" : 1;' . chr(10) . '                }' . chr(10) . '            }' . chr(10) . '            catch(err) {' . chr(10) . '            }' . chr(10) . '        }' . chr(10) . '        return ' . chr(39) . chr(39) . ';' . chr(10) . '    };' . chr(10) . chr(10) . '    CORE.binmode = function(List__) {' . chr(10) . '        try {' . chr(10) . '            // TODO' . chr(10) . '            return 1;' . chr(10) . '        }' . chr(10) . '        catch(err) {' . chr(10) . '            p5pkg["main"]["v_!"] = err;' . chr(10) . '            return ' . chr(39) . chr(39) . ';' . chr(10) . '        }' . chr(10) . '    };' . chr(10) . chr(10) . '    CORE.rmdir = function(List__) {' . chr(10) . '        try {' . chr(10) . '            fs.rmdir(p5str(List__[0]));' . chr(10) . '            return 1;' . chr(10) . '        }' . chr(10) . '        catch(err) {' . chr(10) . '            p5pkg["main"]["v_!"] = err;' . chr(10) . '            return ' . chr(39) . chr(39) . ';' . chr(10) . '        }' . chr(10) . '    };' . chr(10) . chr(10) . '    CORE.chdir = function(List__) {' . chr(10) . '        try {' . chr(10) . '            process.chdir(p5str(List__[0]));' . chr(10) . '            return 1;' . chr(10) . '        }' . chr(10) . '        catch(err) {' . chr(10) . '            p5pkg["main"]["v_!"] = err;' . chr(10) . '            return ' . chr(39) . chr(39) . ';' . chr(10) . '        }' . chr(10) . '    };' . chr(10) . chr(10) . '    CORE.exit = function(List__) {' . chr(10) . '        process.exit(List__[0]);' . chr(10) . '    };' . chr(10) . chr(10) . '    CORE.rename = function(List__) {' . chr(10) . '        try {' . chr(10) . '            fs.renameSync(p5str(List__[0]), p5str(List__[1]));' . chr(10) . '            return 1;' . chr(10) . '        }' . chr(10) . '        catch(err) {' . chr(10) . '            p5pkg["main"]["v_!"] = err;' . chr(10) . '            return ' . chr(39) . chr(39) . ';' . chr(10) . '        }' . chr(10) . '    };' . chr(10) . chr(10) . '    CORE.unlink = function(List__) {' . chr(10) . '        var count = 0;' . chr(10) . '        try {' . chr(10) . '            for(var i = 0; i < List__.length; i++) {' . chr(10) . '                fs.unlinkSync(p5str(List__[i]));' . chr(10) . '                count++;' . chr(10) . '            }' . chr(10) . '            return count;' . chr(10) . '        }' . chr(10) . '        catch(err) {' . chr(10) . '            p5pkg["main"]["v_!"] = err;' . chr(10) . '            return count;' . chr(10) . '        }' . chr(10) . '    };' . chr(10) . chr(10) . '} else {' . chr(10) . '    // not running in node.js' . chr(10) . '    p5typeglob_set("Perlito5::IO", "print", function (filehandle, List__, p5want) {' . chr(10) . '        var s = "";' . chr(10) . '        for (var i = 0; i < List__.length; i++) {' . chr(10) . '            s = s + p5str(List__[i]);' . chr(10) . '        }' . chr(10) . '        if (console && typeof console.log === ' . chr(39) . 'function' . chr(39) . ') {' . chr(10) . '            console.log(s);' . chr(10) . '        }' . chr(10) . '        else if (typeof write === ' . chr(39) . 'function' . chr(39) . ') {' . chr(10) . '            // d8 shell uses "write"' . chr(10) . '            write(s);' . chr(10) . '        }' . chr(10) . '        else if (typeof print === ' . chr(39) . 'function' . chr(39) . ') {' . chr(10) . '            // Rhino uses "print"' . chr(10) . '            print(s);' . chr(10) . '        }' . chr(10) . '        else {' . chr(10) . '            alert(s);' . chr(10) . '        }' . chr(10) . '        return 1;' . chr(10) . '    });' . chr(10) . '}' . chr(10) . chr(10) . 'p5typeglob_set("Perlito5::IO", "say", function (filehandle, List__, p5want) {' . chr(10) . '    p5pkg[' . chr(39) . 'Perlito5::IO' . chr(39) . '].print( filehandle, List__);' . chr(10) . '    p5pkg[' . chr(39) . 'Perlito5::IO' . chr(39) . '].print( filehandle, ["' . chr(92) . 'n"]);' . chr(10) . '    return 1;' . chr(10) . '} );' . chr(10) . 'p5typeglob_set("Perlito5::IO", "printf", function (filehandle, List__, p5want) {' . chr(10) . '    p5pkg["Perlito5::IO"].print( filehandle, CORE.sprintf(List__));' . chr(10) . '    return 1;' . chr(10) . '} );' . chr(10) . chr(10) . 'CORE.select = function(List__) {' . chr(10) . '    if (List__.length == 1) {' . chr(10) . '        var v = List__[0];' . chr(10) . '        p5pkg["Perlito5"].v_SELECT = v;' . chr(10) . '    }' . chr(10) . '    return p5pkg["Perlito5"].v_SELECT;' . chr(10) . '};' . chr(10) . chr(10) . 'CORE.die = function(List__) {' . chr(10) . '    var i;' . chr(10) . '    var s = "";' . chr(10) . '    for (var i = 0; i < List__.length; i++) {' . chr(10) . '        s = s + p5str(List__[i]);' . chr(10) . '    }' . chr(10) . '    if (s.substr(-1, 1) != "' . chr(92) . 'n") {' . chr(10) . '        try {' . chr(10) . '            if (s == "") {' . chr(10) . '                s = "Died";' . chr(10) . '            }' . chr(10) . '            s = s + " at " + p5pkg["Perlito5"].v_FILE_NAME + " line " + p5pkg["Perlito5"].v_LINE_NUMBER;' . chr(10) . '            s = s + "' . chr(92) . 'n" + new Error().stack + "' . chr(92) . 'n";' . chr(10) . '        }' . chr(10) . '        catch(err) { }' . chr(10) . '    }' . chr(10) . '    p5pkg["main"]["v_@"] = s;' . chr(10) . '    throw(new p5_error("die", s));' . chr(10) . '};' . chr(10) . chr(10) . 'CORE.say = function(List__) {' . chr(10) . '    return p5pkg[' . chr(39) . 'Perlito5::IO' . chr(39) . '].say( ' . chr(39) . 'STDOUT' . chr(39) . ', List__);' . chr(10) . '};' . chr(10) . 'CORE.print = function(List__) {' . chr(10) . '    return p5pkg[' . chr(39) . 'Perlito5::IO' . chr(39) . '].print( ' . chr(39) . 'STDOUT' . chr(39) . ', List__);' . chr(10) . '};' . chr(10) . 'CORE.printf = function(List__) {' . chr(10) . '    return p5pkg[' . chr(39) . 'Perlito5::IO' . chr(39) . '].printf( ' . chr(39) . 'STDOUT' . chr(39) . ', List__);' . chr(10) . '};' . chr(10) . 'CORE.readline = function(List__, p5want) {' . chr(10) . '    return p5pkg[' . chr(39) . 'Perlito5::IO' . chr(39) . '].readline(List__, p5want);' . chr(10) . '};' . chr(10) . chr(10) . 'CORE.warn = function(List__) {' . chr(10) . '    var i;' . chr(10) . '    var s = "";' . chr(10) . '    for (var i = 0; i < List__.length; i++) {' . chr(10) . '        s = s + p5str(List__[i]);' . chr(10) . '    }' . chr(10) . '    if (s.substr(-1, 1) != "' . chr(92) . 'n") {' . chr(10) . '        try {' . chr(10) . '            if (s == "") {' . chr(10) . '                s = "Warning: something' . chr(39) . 's wrong";' . chr(10) . '            }' . chr(10) . '            s = s + " at " + p5pkg["Perlito5"].v_FILE_NAME + " line " + p5pkg["Perlito5"].v_LINE_NUMBER;' . chr(10) . '            s = s + "' . chr(92) . 'n" + new Error().stack + "' . chr(92) . 'n";' . chr(10) . '        }' . chr(10) . '        catch(err) { }' . chr(10) . '    }' . chr(10) . '    p5pkg[' . chr(39) . 'Perlito5::IO' . chr(39) . '].print( ' . chr(39) . 'STDERR' . chr(39) . ', [s]);' . chr(10) . '};' . chr(10) . chr(10) . chr(10)
            }
            1
        }
    }
    {
        {
            package main;
            undef();
            package Perlito5::Javascript2::Sprintf;
            sub Perlito5::Javascript2::Sprintf::emit_javascript2 {
                return '/**' . chr(10) . ' * Copyright (c) 2010 Jakob Westhoff' . chr(10) . ' *' . chr(10) . ' * Permission is hereby granted, free of charge, to any person obtaining a copy' . chr(10) . ' * of this software and associated documentation files (the "Software"), to deal' . chr(10) . ' * in the Software without restriction, including without limitation the rights' . chr(10) . ' * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell' . chr(10) . ' * copies of the Software, and to permit persons to whom the Software is' . chr(10) . ' * furnished to do so, subject to the following conditions:' . chr(10) . ' * ' . chr(10) . ' * The above copyright notice and this permission notice shall be included in' . chr(10) . ' * all copies or substantial portions of the Software.' . chr(10) . ' * ' . chr(10) . ' * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR' . chr(10) . ' * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,' . chr(10) . ' * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE' . chr(10) . ' * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER' . chr(10) . ' * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,' . chr(10) . ' * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN' . chr(10) . ' * THE SOFTWARE.' . chr(10) . ' */' . chr(10) . chr(10) . 'CORE.sprintf = function(List__) {' . chr(10) . '    var format = List__.shift();' . chr(10) . '    var list = List__;' . chr(10) . chr(10) . '    // Check for format definition' . chr(10) . '    if ( typeof format != ' . chr(39) . 'string' . chr(39) . ' ) {' . chr(10) . '        CORE.die(["sprintf: The first arguments need to be a valid format string."]);' . chr(10) . '    }' . chr(10) . '    ' . chr(10) . '    /**' . chr(10) . '     * Define the regex to match a formating string' . chr(10) . '     * The regex consists of the following parts:' . chr(10) . '     * percent sign to indicate the start' . chr(10) . '     * (optional) sign specifier' . chr(10) . '     * (optional) padding specifier' . chr(10) . '     * (optional) alignment specifier' . chr(10) . '     * (optional) width specifier' . chr(10) . '     * (optional) precision specifier' . chr(10) . '     * type specifier:' . chr(10) . '     *  % - literal percent sign' . chr(10) . '     *  b - binary number' . chr(10) . '     *  c - ASCII character represented by the given value' . chr(10) . '     *  d - signed decimal number' . chr(10) . '     *  f - floating point value' . chr(10) . '     *  o - octal number' . chr(10) . '     *  s - string' . chr(10) . '     *  x - hexadecimal number (lowercase characters)' . chr(10) . '     *  X - hexadecimal number (uppercase characters)' . chr(10) . '     */' . chr(10) . '    var r = new RegExp( /%(' . chr(92) . '+)?([0 ]|' . chr(39) . '(.))?(-)?([0-9]+)?(' . chr(92) . '.([0-9]+))?([%bcdfosxX])/g );' . chr(10) . chr(10) . '    /**' . chr(10) . '     * Each format string is splitted into the following parts:' . chr(10) . '     * 0: Full format string' . chr(10) . '     * 1: sign specifier (+)' . chr(10) . '     * 2: padding specifier (0/<space>/' . chr(39) . '<any char>)' . chr(10) . '     * 3: if the padding character starts with a ' . chr(39) . ' this will be the real ' . chr(10) . '     *    padding character' . chr(10) . '     * 4: alignment specifier' . chr(10) . '     * 5: width specifier' . chr(10) . '     * 6: precision specifier including the dot' . chr(10) . '     * 7: precision specifier without the dot' . chr(10) . '     * 8: type specifier' . chr(10) . '     */' . chr(10) . '    var parts      = [];' . chr(10) . '    var paramIndex = 0;' . chr(10) . '    var part;' . chr(10) . '    while ( part = r.exec( format ) ) {' . chr(10) . '        // Check if an input value has been provided, for the current' . chr(10) . '        // format string' . chr(10) . '        if ( paramIndex >= list.length ) {' . chr(10) . '            CORE.die(["sprintf: At least one argument was missing."]);' . chr(10) . '        }' . chr(10) . chr(10) . '        parts[parts.length] = {' . chr(10) . '            /* beginning of the part in the string */' . chr(10) . '            begin: part.index,' . chr(10) . '            /* end of the part in the string */' . chr(10) . '            end: part.index + part[0].length,' . chr(10) . '            /* force sign */' . chr(10) . '            sign: ( part[1] == ' . chr(39) . '+' . chr(39) . ' ),' . chr(10) . '            /* is the given data negative */' . chr(10) . '            negative: ( parseInt( list[paramIndex] ) < 0 ) ? true : false,' . chr(10) . '            /* padding character (default: <space>) */' . chr(10) . '            padding: ( part[2] == undefined )' . chr(10) . '                     ? ( ' . chr(39) . ' ' . chr(39) . ' ) /* default */' . chr(10) . '                     : ( ( part[2].substring( 0, 1 ) == "' . chr(39) . '" ) ' . chr(10) . '                         ? ( part[3] ) /* use special char */' . chr(10) . '                         : ( part[2] ) /* use normal <space> or zero */' . chr(10) . '                       ),' . chr(10) . '            /* should the output be aligned left?*/' . chr(10) . '            alignLeft: ( part[4] == ' . chr(39) . '-' . chr(39) . ' ),' . chr(10) . '            /* width specifier (number or false) */' . chr(10) . '            width: ( part[5] != undefined ) ? part[5] : false,' . chr(10) . '            /* precision specifier (number or false) */' . chr(10) . '            precision: ( part[7] != undefined ) ? part[7] : false,' . chr(10) . '            /* type specifier */' . chr(10) . '            type: part[8],' . chr(10) . '            /* the given data associated with this part converted to a string */' . chr(10) . '            data: ( part[8] != ' . chr(39) . '%' . chr(39) . ' ) ? String ( list[paramIndex++] ) : false' . chr(10) . '        };' . chr(10) . '    }' . chr(10) . chr(10) . '    var newString = "";' . chr(10) . '    var start = 0;' . chr(10) . '    // Generate our new formated string' . chr(10) . '    for( var i=0; i<parts.length; ++i ) {' . chr(10) . '        // Add first unformated string part' . chr(10) . '        newString += format.substring( start, parts[i].begin );' . chr(10) . '        ' . chr(10) . '        // Mark the new string start' . chr(10) . '        start = parts[i].end;' . chr(10) . chr(10) . '        // Create the appropriate preformat substitution' . chr(10) . '        // This substitution is only the correct type conversion. All the' . chr(10) . '        // different options and flags haven' . chr(39) . 't been applied to it at this' . chr(10) . '        // point' . chr(10) . '        var preSubstitution = "";' . chr(10) . '        switch ( parts[i].type ) {' . chr(10) . '            case ' . chr(39) . '%' . chr(39) . ':' . chr(10) . '                preSubstitution = "%";' . chr(10) . '            break;' . chr(10) . '            case ' . chr(39) . 'b' . chr(39) . ':' . chr(10) . '                preSubstitution = Math.abs( parseInt( parts[i].data ) ).toString( 2 );' . chr(10) . '            break;' . chr(10) . '            case ' . chr(39) . 'c' . chr(39) . ':' . chr(10) . '                preSubstitution = String.fromCharCode( Math.abs( parseInt( parts[i].data ) ) );' . chr(10) . '            break;' . chr(10) . '            case ' . chr(39) . 'd' . chr(39) . ':' . chr(10) . '                preSubstitution = String( Math.abs( parseInt( parts[i].data ) ) );' . chr(10) . '            break;' . chr(10) . '            case ' . chr(39) . 'f' . chr(39) . ':' . chr(10) . '                preSubstitution = ( parts[i].precision == false )' . chr(10) . '                                  ? ( String( ( Math.abs( parseFloat( parts[i].data ) ) ) ) )' . chr(10) . '                                  : ( Math.abs( parseFloat( parts[i].data ) ).toFixed( parts[i].precision ) );' . chr(10) . '            break;' . chr(10) . '            case ' . chr(39) . 'o' . chr(39) . ':' . chr(10) . '                preSubstitution = Math.abs( parseInt( parts[i].data ) ).toString( 8 );' . chr(10) . '            break;' . chr(10) . '            case ' . chr(39) . 's' . chr(39) . ':' . chr(10) . '                preSubstitution = parts[i].data.substring( 0, parts[i].precision ? parts[i].precision : parts[i].data.length ); /* Cut if precision is defined */' . chr(10) . '            break;' . chr(10) . '            case ' . chr(39) . 'x' . chr(39) . ':' . chr(10) . '                preSubstitution = Math.abs( parseInt( parts[i].data ) ).toString( 16 ).toLowerCase();' . chr(10) . '            break;' . chr(10) . '            case ' . chr(39) . 'X' . chr(39) . ':' . chr(10) . '                preSubstitution = Math.abs( parseInt( parts[i].data ) ).toString( 16 ).toUpperCase();' . chr(10) . '            break;' . chr(10) . '            default:' . chr(10) . '                throw ' . chr(39) . 'sprintf: Unknown type "' . chr(39) . ' + parts[i].type + ' . chr(39) . '" detected. This should never happen. Maybe the regex is wrong.' . chr(39) . ';' . chr(10) . '        }' . chr(10) . chr(10) . '        // The % character is a special type and does not need further processing' . chr(10) . '        if ( parts[i].type ==  "%" ) {' . chr(10) . '            newString += preSubstitution;' . chr(10) . '            continue;' . chr(10) . '        }' . chr(10) . chr(10) . '        // Modify the preSubstitution by taking sign, padding and width' . chr(10) . '        // into account' . chr(10) . chr(10) . '        // Pad the string based on the given width' . chr(10) . '        if ( parts[i].width != false ) {' . chr(10) . '            // Padding needed?' . chr(10) . '            if ( parts[i].width > preSubstitution.length ) ' . chr(10) . '            {' . chr(10) . '                var origLength = preSubstitution.length;' . chr(10) . '                for( var j = 0; j < parts[i].width - origLength; ++j ) ' . chr(10) . '                {' . chr(10) . '                    preSubstitution = ( parts[i].alignLeft == true ) ' . chr(10) . '                                      ? ( preSubstitution + parts[i].padding )' . chr(10) . '                                      : ( parts[i].padding + preSubstitution );' . chr(10) . '                }' . chr(10) . '            }' . chr(10) . '        }' . chr(10) . chr(10) . '        // Add a sign symbol if neccessary or enforced, but only if we are' . chr(10) . '        // not handling a string' . chr(10) . '        if ( parts[i].type == ' . chr(39) . 'b' . chr(39) . ' ' . chr(10) . '          || parts[i].type == ' . chr(39) . 'd' . chr(39) . ' ' . chr(10) . '          || parts[i].type == ' . chr(39) . 'o' . chr(39) . ' ' . chr(10) . '          || parts[i].type == ' . chr(39) . 'f' . chr(39) . ' ' . chr(10) . '          || parts[i].type == ' . chr(39) . 'x' . chr(39) . ' ' . chr(10) . '          || parts[i].type == ' . chr(39) . 'X' . chr(39) . ' ) {' . chr(10) . '            if ( parts[i].negative == true ) {' . chr(10) . '                preSubstitution = "-" + preSubstitution;' . chr(10) . '            }' . chr(10) . '            else if ( parts[i].sign == true ) {' . chr(10) . '                preSubstitution = "+" + preSubstitution;' . chr(10) . '            }' . chr(10) . '        }' . chr(10) . chr(10) . '        // Add the substitution to the new string' . chr(10) . '        newString += preSubstitution;' . chr(10) . '    }' . chr(10) . chr(10) . '    // Add the last part of the given format string, which may still be there' . chr(10) . '    newString += format.substring( start, format.length );' . chr(10) . chr(10) . '    return newString;' . chr(10) . '};' . chr(10) . chr(10)
            }
            1
        }
    }
    {
        {
            package main;
            undef();
            undef();
            undef();
            undef();
            package Perlito5::Javascript3;
            {
                my %label;
                sub Perlito5::Javascript3::pkg {
                    'p5pkg["' . $Perlito5::PKG_NAME . '"]'
                }
                sub Perlito5::Javascript3::pkg_new_var {
                    $label{$Perlito5::PKG_NAME} = 'p5' . $Perlito5::ID++
                }
                sub Perlito5::Javascript3::get_label {
                    $Perlito5::ID++
                }
                sub Perlito5::Javascript3::tab {
                    my $level = shift;
                    chr(9) x $level
                }
                our %op_prefix_js_str = ('prefix:<-A>' => 'p5atime', 'prefix:<-C>' => 'p5ctime', 'prefix:<-M>' => 'p5mtime', 'prefix:<-d>' => 'p5is_directory', 'prefix:<-e>' => 'p5file_exists', 'prefix:<-f>' => 'p5is_file', 'prefix:<-s>' => 'p5size');
                our %op_infix_js_str = ('infix:<eq>' => ' == ', 'infix:<ne>' => ' != ', 'infix:<le>' => ' <= ', 'infix:<ge>' => ' >= ', 'infix:<lt>' => ' < ', 'infix:<gt>' => ' > ');
                our %op_infix_js_num = ('infix:<==>' => ' == ', 'infix:<!=>' => ' != ', 'infix:<+>' => ' + ', 'infix:<->' => ' - ', 'infix:<*>' => ' * ', 'infix:</>' => ' / ', 'infix:<%>' => ' % ', 'infix:<>>' => ' > ', 'infix:<<>' => ' < ', 'infix:<>=>' => ' >= ', 'infix:<<=>' => ' <= ', 'infix:<&>' => ' & ', 'infix:<|>' => ' | ', 'infix:<^>' => ' ^ ', 'infix:<>>>' => ' >>> ', 'infix:<<<>' => ' << ');
                our %op_to_bool = map(+($_ => 1), 'prefix:<!>', 'infix:<!=>', 'infix:<==>', 'infix:<<=>', 'infix:<>=>', 'infix:<>>', 'infix:<<>', 'infix:<eq>', 'infix:<ne>', 'infix:<ge>', 'infix:<le>', 'infix:<gt>', 'infix:<lt>', 'prefix:<not>', 'exists', 'defined');
                our %op_to_str = map(+($_ => 1), 'substr', 'join', 'list:<.>', 'chr');
                our %op_to_num = map(+($_ => 1), 'length', 'index', 'ord', 'oct', 'infix:<->', 'infix:<+>', 'infix:<*>', 'infix:</>', 'infix:<%>', 'infix:<**>');
                my %safe_char = (' ' => 1, '!' => 1, '"' => 1, '#' => 1, '$' => 1, '%' => 1, '&' => 1, '(' => 1, ')' => 1, '*' => 1, '+' => 1, ',' => 1, '-' => 1, '.' => 1, '/' => 1, ':' => 1, ';' => 1, '<' => 1, '=' => 1, '>' => 1, '?' => 1, '@' => 1, '[' => 1, ']' => 1, '^' => 1, '_' => 1, '`' => 1, '{' => 1, '|' => 1, '}' => 1, '~' => 1);
                sub Perlito5::Javascript3::escape_string {
                    my $s = shift;
                    my @out;
                    my $tmp = '';
                    $s eq '' && return chr(39) . chr(39);
                    for my $i (0 .. length($s) - 1) {
                        my $c = substr($s, $i, 1);
                        if (($c ge 'a' && $c le 'z') || ($c ge 'A' && $c le 'Z') || ($c ge 0 && $c le 9) || exists($safe_char{$c})) {
                            $tmp = $tmp . $c
                        }
                        else {
                            $tmp ne '' && push(@out, chr(39) . $tmp . chr(39));
                            push(@out, 'String.fromCharCode(' . ord($c) . ')');
                            $tmp = ''
                        }
                    }
                    $tmp ne '' && push(@out, chr(39) . $tmp . chr(39));
                    return join(' + ', @out)
                }
                sub Perlito5::Javascript3::to_str {
                    my $cond = shift;
                    my $level = shift;
                    my $wantarray = 'scalar';
                    if ($cond->isa('Perlito5::AST::Apply') && $cond->code() eq 'circumfix:<( )>' && $cond->{'arguments'} && @{$cond->{'arguments'}}) {
                        return to_str($cond->{'arguments'}->[0], $level)
                    }
                    if (($cond->isa('Perlito5::AST::Buf')) || ($cond->isa('Perlito5::AST::Apply') && exists($op_to_str{$cond->code()}))) {
                        return $cond->emit_javascript3($level, $wantarray)
                    }
                    else {
                        return 'p5str(' . $cond->emit_javascript3($level, $wantarray) . ')'
                    }
                }
                sub Perlito5::Javascript3::to_num {
                    my $cond = shift;
                    my $level = shift;
                    my $wantarray = 'scalar';
                    if ($cond->isa('Perlito5::AST::Int') || $cond->isa('Perlito5::AST::Num') || ($cond->isa('Perlito5::AST::Apply') && exists($op_to_num{$cond->code()}))) {
                        return $cond->emit_javascript3($level, $wantarray)
                    }
                    else {
                        return 'p5num(' . $cond->emit_javascript3($level, $wantarray) . ')'
                    }
                }
                sub Perlito5::Javascript3::to_bool {
                    my $cond = shift;
                    my $level = shift;
                    my $wantarray = 'scalar';
                    if ($cond->isa('Perlito5::AST::Apply') && $cond->code() eq 'circumfix:<( )>' && $cond->{'arguments'} && @{$cond->{'arguments'}}) {
                        return to_bool($cond->{'arguments'}->[0], $level)
                    }
                    if ($cond->isa('Perlito5::AST::Apply') && ($cond->code() eq 'infix:<&&>' || $cond->code() eq 'infix:<and>')) {
                        return '(' . to_bool($cond->{'arguments'}->[0], $level) . ' && ' . to_bool($cond->{'arguments'}->[1], $level) . ')'
                    }
                    if ($cond->isa('Perlito5::AST::Apply') && ($cond->code() eq 'infix:<||>' || $cond->code() eq 'infix:<or>')) {
                        return '(' . to_bool($cond->{'arguments'}->[0], $level) . ' || ' . to_bool($cond->{'arguments'}->[1], $level) . ')'
                    }
                    if (($cond->isa('Perlito5::AST::Int')) || ($cond->isa('Perlito5::AST::Num')) || ($cond->isa('Perlito5::AST::Apply') && exists($op_to_bool{$cond->code()}))) {
                        return $cond->emit_javascript3($level, $wantarray)
                    }
                    else {
                        return 'p5bool(' . $cond->emit_javascript3($level, $wantarray) . ')'
                    }
                }
                sub Perlito5::Javascript3::is_scalar {
                    !$_[0]->isa('Perlito5::AST::Int') && !$_[0]->isa('Perlito5::AST::Num') && !$_[0]->isa('Perlito5::AST::Buf') && !$_[0]->isa('Perlito5::AST::Sub') && !($_[0]->isa('Perlito5::AST::Var') && $_[0]->{'sigil'} eq '$') && !($_[0]->isa('Perlito5::AST::Apply') && (exists($op_to_str{$_[0]->{'code'}}) || exists($op_to_num{$_[0]->{'code'}}) || exists($op_to_bool{$_[0]->{'code'}}) || $_[0]->{'code'} eq 'prefix:<' . chr(92) . '>'))
                }
                sub Perlito5::Javascript3::to_value {
                    my $v = shift;
                    my $level = shift;
                    my $wantarray = shift;
                    return !$v ? 'null' : $v->isa('Perlito5::AST::Var') && $v->sigil() eq '$' ? $v->emit_javascript3($level, $wantarray) . '.FETCH()' : $v->emit_javascript3($level, $wantarray)
                }
                sub Perlito5::Javascript3::to_list {
                    my $items = to_list_preprocess($_[0]);
                    my $level = $_[1];
                    my $literal_type = $_[2] || 'array';
                    my $wantarray = 'list';
                    my $interpolate = 0;
                    for $_ (@{$items}) {
                        is_scalar($_) && ($interpolate = 1)
                    }
                    if ($literal_type eq 'hash') {
                        if (!$interpolate) {
                            my @out;
                            my $printable = 1;
                            my @in = @{$items};
                            while (@in) {
                                my $k = shift(@in);
                                my $v = shift(@in);
                                $k = $k->emit_javascript3($level, 0);
                                $k =~ m![ \[]! && ($printable = 0);
                                $v = to_value($v, $level, $wantarray);
                                push(@out, $k . ' : ' . $v)
                            }
                            $printable && return '{' . join(', ', @out) . '}'
                        }
                        return 'p5a_to_h(' . to_list($items, $level, 'array') . ')'
                    }
                    $interpolate ? ('p5list_to_a(' . join(', ', map($_->emit_javascript3($level, $wantarray), @{$items})) . ')') : ('[' . join(', ', map(to_value($_, $level, $wantarray), @{$items})) . ']')
                }
                sub Perlito5::Javascript3::to_list_preprocess {
                    my @items;
                    for my $item (@{$_[0]}) {
                        if ($item->isa('Perlito5::AST::Apply') && ($item->code() eq 'circumfix:<( )>' || $item->code() eq 'list:<,>' || $item->code() eq 'infix:<=>>')) {
                            if ($item->isa('Perlito5::AST::Apply') && $item->code() eq 'infix:<=>>') {
                                $item->{'arguments'}->[0] = Perlito5::AST::Lookup::->autoquote($item->{'arguments'}->[0])
                            }
                            for my $arg (@{to_list_preprocess($item->arguments())}) {
                                push(@items, $arg)
                            }
                        }
                        else {
                            push(@items, $item)
                        }
                    }
                    return \@items
                }
                sub Perlito5::Javascript3::to_scalar {
                    my $items = to_scalar_preprocess($_[0]);
                    my $level = $_[1];
                    my $wantarray = 'scalar';
                    @{$items} ? '(' . join(', ', map($_->emit_javascript3($level, $wantarray), @{$items})) . ')' : 'null'
                }
                sub Perlito5::Javascript3::to_scalar_preprocess {
                    my @items;
                    for my $item (@{$_[0]}) {
                        if ($item->isa('Perlito5::AST::Apply') && ($item->code() eq 'list:<,>' || $item->code() eq 'infix:<=>>')) {
                            if ($item->isa('Perlito5::AST::Apply') && $item->code() eq 'infix:<=>>') {
                                $item->{'arguments'}->[0] = Perlito5::AST::Lookup::->autoquote($item->{'arguments'}->[0])
                            }
                            for my $arg (@{to_scalar_preprocess($item->arguments())}) {
                                push(@items, $arg)
                            }
                        }
                        else {
                            push(@items, $item)
                        }
                    }
                    return \@items
                }
                sub Perlito5::Javascript3::to_runtime_context {
                    my $items = to_scalar_preprocess($_[0]);
                    my $level = $_[1];
                    my $wantarray = 'runtime';
                    @{$items} == 1 && is_scalar($items->[0]) && return $items->[0]->emit_javascript3($level, $wantarray);
                    'p5context(' . '[' . join(', ', map($_->emit_javascript3($level, $wantarray), @{$items})) . ']' . ', p5want)'
                }
                sub Perlito5::Javascript3::autoquote {
                    my $index = shift;
                    my $level = shift;
                    if ($index->isa('Perlito5::AST::Apply') && $index->{'bareword'}) {
                        my $full_name = ($index->{'namespace'} ? $index->{'namespace'} . '::' : '') . $index->{'code'};
                        if (!exists($Perlito5::PROTO->{$full_name})) {
                            $index = Perlito5::AST::Buf::->new('buf' => $full_name)
                        }
                    }
                    return to_str($index, $level)
                }
                sub Perlito5::Javascript3::emit_javascript3_autovivify {
                    my $obj = shift;
                    my $level = shift;
                    my $type = shift;
                    my $wantarray = 'scalar';
                    return $obj->emit_javascript3($level, $wantarray, $type)
                }
                sub Perlito5::Javascript3::emit_function_javascript3 {
                    my $level = shift;
                    my $wantarray = shift;
                    my $argument = shift;
                    if ($argument->isa('Perlito5::AST::Apply') && $argument->code() eq 'return') {
                        return 'function () { ' . $argument->emit_javascript3($level, $wantarray) . ' }'
                    }
                    return 'function () { return ' . $argument->emit_javascript3($level, $wantarray) . ' }'
                }
            }
            package Perlito5::Javascript3::LexicalBlock;
            {
                sub Perlito5::Javascript3::LexicalBlock::new {
                    my $class = shift;
                    bless({@_}, $class)
                }
                sub Perlito5::Javascript3::LexicalBlock::block {
                    $_[0]->{'block'}
                }
                sub Perlito5::Javascript3::LexicalBlock::needs_return {
                    $_[0]->{'needs_return'}
                }
                sub Perlito5::Javascript3::LexicalBlock::top_level {
                    $_[0]->{'top_level'}
                }
                sub Perlito5::Javascript3::LexicalBlock::has_decl {
                    my $self = $_[0];
                    my $type = $_[1];
                    for my $decl (@{$self->{'block'}}) {
                        if (defined($decl)) {
                            if ($decl->isa('Perlito5::AST::Decl') && $decl->decl() eq $type || $decl->isa('Perlito5::AST::Apply') && $decl->code() eq $type) {
                                return 1
                            }
                            if ($decl->isa('Perlito5::AST::Apply') && $decl->code() eq 'infix:<=>') {
                                my $var = $decl->arguments()->[0];
                                if ($var->isa('Perlito5::AST::Decl') && $var->decl() eq $type || $decl->isa('Perlito5::AST::Apply') && $decl->code() eq $type) {
                                    return 1
                                }
                            }
                        }
                    }
                    return 0
                }
                sub Perlito5::Javascript3::LexicalBlock::emit_javascript3 {
                    my $self = shift;
                    my $level = shift;
                    my $wantarray = shift;
                    my @block;
                    for $_ (@{$self->{'block'}}) {
                        if (defined($_)) {
                            push(@block, $_)
                        }
                    }
                    if (!@block) {
                        return Perlito5::Javascript3::tab($level) . 'null;'
                    }
                    my $out = '';
                    my @str;
                    my $has_local = $self->has_decl('local');
                    my $create_context = $self->{'create_context'} && $self->has_decl('my');
                    my $outer_pkg = $Perlito5::PKG_NAME;
                    my $outer_throw = $Perlito5::THROW;
                    $self->{'top_level'} && ($Perlito5::THROW = 0);
                    $has_local && ($out .= Perlito5::Javascript3::tab($level) . 'var local_idx = p5LOCAL.length;' . chr(10));
                    if ($self->{'top_level'}) {
                        $level++
                    }
                    if ($create_context) {
                        $out .= Perlito5::Javascript3::tab($level) . '(function () {' . chr(10);
                        $level++
                    }
                    my $tab = Perlito5::Javascript3::tab($level);
                    my $last_statement;
                    if ($self->{'needs_return'}) {
                        $last_statement = pop(@block)
                    }
                    for my $decl (@block) {
                        if (ref($decl) eq 'Perlito5::AST::Apply' && $decl->code() eq 'package') {
                            $Perlito5::PKG_NAME = $decl->{'namespace'}
                        }
                        if ($decl->isa('Perlito5::AST::Decl')) {
                            push(@str, $decl->emit_javascript3_init())
                        }
                        if ($decl->isa('Perlito5::AST::Apply') && $decl->code() eq 'my') {
                            for $_ (@{$decl->{'arguments'}}) {
                                if ($_->isa('Perlito5::AST::Var')) {
                                    my $d = Perlito5::AST::Decl::->new('decl' => $decl->code(), 'var' => $_);
                                    push(@str, $d->emit_javascript3_init())
                                }
                            }
                        }
                        if ($decl->isa('Perlito5::AST::Apply') && $decl->code() eq 'infix:<=>') {
                            my $arg = $decl->{'arguments'}->[0];
                            if ($arg->isa('Perlito5::AST::Decl')) {
                                push(@str, $arg->emit_javascript3_init())
                            }
                            if ($arg->isa('Perlito5::AST::Apply') && $arg->code() eq 'my') {
                                for $_ (@{$arg->{'arguments'}}) {
                                    if ($_->isa('Perlito5::AST::Var')) {
                                        my $d = Perlito5::AST::Decl::->new('decl' => $arg->code(), 'var' => $_);
                                        push(@str, $d->emit_javascript3_init())
                                    }
                                }
                            }
                        }
                        if (!($decl->isa('Perlito5::AST::Decl') && $decl->decl() eq 'my')) {
                            push(@str, $decl->emit_javascript3($level, 'void') . ';')
                        }
                    }
                    if ($self->{'needs_return'} && $last_statement) {
                        if ($last_statement->isa('Perlito5::AST::Decl')) {
                            push(@str, $last_statement->emit_javascript3_init())
                        }
                        if ($last_statement->isa('Perlito5::AST::Apply') && $last_statement->code() eq 'infix:<=>') {
                            if ($last_statement->{'arguments'}->[0]->isa('Perlito5::AST::Decl')) {
                                push(@str, $last_statement->{'arguments'}->[0]->emit_javascript3_init())
                            }
                        }
                        if ($last_statement->isa('Perlito5::AST::Apply') && $last_statement->code() eq 'return' && $self->{'top_level'} && @{$last_statement->{'arguments'}}) {
                            $last_statement = $last_statement->{'arguments'}->[0]
                        }
                        if ($last_statement->isa('Perlito5::AST::If')) {
                            my $cond = $last_statement->cond();
                            my $body = $last_statement->body();
                            my $otherwise = $last_statement->otherwise();
                            $body = Perlito5::Javascript3::LexicalBlock::->new('block' => $body->stmts(), 'needs_return' => 1);
                            push(@str, 'if ( ' . Perlito5::Javascript3::to_bool($cond, $level + 1) . ' ) {' . chr(10) . $body->emit_javascript3($level + 1) . chr(10) . Perlito5::Javascript3::tab($level) . '}');
                            if ($otherwise) {
                                $otherwise = Perlito5::Javascript3::LexicalBlock::->new('block' => $otherwise->stmts(), 'needs_return' => 1);
                                push(@str, chr(10) . Perlito5::Javascript3::tab($level) . 'else {' . chr(10) . $otherwise->emit_javascript3($level + 1) . chr(10) . Perlito5::Javascript3::tab($level) . '}')
                            }
                        }
                        elsif ($last_statement->isa('Perlito5::AST::Block')) {
                            my $body = Perlito5::Javascript3::LexicalBlock::->new('block' => $last_statement->{'stmts'}, 'needs_return' => 1);
                            push(@str, 'for (var i_ = 0; i_ < 1 ; i_++) {' . chr(10) . $body->emit_javascript3($level + 1) . chr(10) . Perlito5::Javascript3::tab($level) . '}')
                        }
                        elsif ($last_statement->isa('Perlito5::AST::For') || $last_statement->isa('Perlito5::AST::While') || $last_statement->isa('Perlito5::AST::Apply') && $last_statement->code() eq 'goto' || $last_statement->isa('Perlito5::AST::Apply') && $last_statement->code() eq 'return') {
                            push(@str, $last_statement->emit_javascript3($level, 'runtime'))
                        }
                        elsif ($has_local) {
                            push(@str, 'return p5cleanup_local(local_idx, (' . Perlito5::Javascript3::to_runtime_context([$last_statement], $level) . '));')
                        }
                        else {
                            push(@str, 'return (' . Perlito5::Javascript3::to_runtime_context([$last_statement], $level) . ');')
                        }
                    }
                    if ($has_local) {
                        push(@str, 'p5cleanup_local(local_idx, null);')
                    }
                    if ($create_context) {
                        $level--;
                        push(@str, '})();')
                    }
                    if ($self->{'top_level'} && $Perlito5::THROW) {
                        $level--;
                        $out .= Perlito5::Javascript3::tab($level) . 'try {' . chr(10) . join(chr(10), map($tab . $_, @str)) . chr(10) . Perlito5::Javascript3::tab($level) . '}' . chr(10) . Perlito5::Javascript3::tab($level) . 'catch(err) {' . chr(10) . Perlito5::Javascript3::tab($level + 1) . 'if ( err instanceof Error ) {' . chr(10) . Perlito5::Javascript3::tab($level + 2) . 'throw(err);' . chr(10) . Perlito5::Javascript3::tab($level + 1) . '}' . chr(10) . Perlito5::Javascript3::tab($level + 1) . 'else {' . chr(10) . Perlito5::Javascript3::tab($level + 2) . ($has_local ? 'return p5cleanup_local(local_idx, err)' : 'return(err)') . ';' . chr(10) . Perlito5::Javascript3::tab($level + 1) . '}' . chr(10) . Perlito5::Javascript3::tab($level) . '}'
                    }
                    else {
                        $out .= join(chr(10), map($tab . $_, @str))
                    }
                    $Perlito5::PKG_NAME = $outer_pkg;
                    $self->{'top_level'} && ($Perlito5::THROW = $outer_throw);
                    return $out
                }
            }
            package Perlito5::AST::CompUnit;
            {
                sub Perlito5::AST::CompUnit::emit_javascript3 {
                    my $self = $_[0];
                    my $level = $_[1];
                    my $str = '(function () {' . chr(10) . Perlito5::Javascript3::LexicalBlock::->new('block' => $self->{'body'}, 'needs_return' => 0)->emit_javascript3($level + 1) . chr(10) . Perlito5::Javascript3::tab($level) . '})()' . chr(10);
                    return $str
                }
                sub Perlito5::AST::CompUnit::emit_javascript3_program {
                    my($comp_units, %options) = @_;
                    $Perlito5::PKG_NAME = 'main';
                    my $str;
                    $str .= Perlito5::Compiler::do_not_edit('//');
                    if ($options{'expand_use'}) {
                        $str .= Perlito5::Javascript3::Runtime::->emit_javascript2();
                        $str .= Perlito5::Javascript3::Array::->emit_javascript2();
                        $str .= Perlito5::Javascript3::CORE::->emit_javascript2();
                        $str .= Perlito5::Javascript3::IO::->emit_javascript2();
                        $str .= Perlito5::Javascript3::Sprintf::->emit_javascript2()
                    }
                    $str .= 'var p5want = null;' . chr(10) . 'var ' . Perlito5::Javascript3::pkg_new_var() . ' = p5pkg[' . chr(39) . $Perlito5::PKG_NAME . chr(39) . '];' . chr(10);
                    for my $comp_unit (@{$comp_units}) {
                        $str = $str . $comp_unit->emit_javascript3() . chr(10)
                    }
                    return $str
                }
            }
            package Perlito5::AST::Int;
            {
                sub Perlito5::AST::Int::emit_javascript3 {
                    my $self = shift;
                    my $level = shift;
                    $self->{'int'}
                }
            }
            package Perlito5::AST::Num;
            {
                sub Perlito5::AST::Num::emit_javascript3 {
                    my $self = shift;
                    my $level = shift;
                    $self->{'num'}
                }
            }
            package Perlito5::AST::Buf;
            {
                sub Perlito5::AST::Buf::emit_javascript3 {
                    my $self = shift;
                    my $level = shift;
                    Perlito5::Javascript3::escape_string($self->{'buf'})
                }
            }
            package Perlito5::AST::Block;
            {
                sub Perlito5::AST::Block::emit_javascript3 {
                    my $self = shift;
                    my $level = shift;
                    my $init = '';
                    if ($self->{'name'} eq 'INIT') {
                        my $tmp = 'p5pkg.main._tmp' . Perlito5::Javascript3::get_label();
                        $init = Perlito5::Javascript3::tab($level + 2) . 'if (' . $tmp . ') { return }; ' . $tmp . ' = 1;' . chr(10)
                    }
                    return 'p5for_lex(' . 'function () {' . chr(10) . $init . (Perlito5::Javascript3::LexicalBlock::->new('block' => $self->{'stmts'}, 'needs_return' => 0, 'top_level' => 0))->emit_javascript3($level + 2) . chr(10) . Perlito5::Javascript3::tab($level + 1) . '}, ' . '[0], ' . $self->emit_javascript3_continue($level) . ', ' . '"' . ($self->{'label'} || '') . '"' . ')'
                }
                sub Perlito5::AST::Block::emit_javascript3_continue {
                    my $self = shift;
                    my $level = shift;
                    if (!$self->{'continue'} || !@{$self->{'continue'}->{'stmts'}}) {
                        return 'false'
                    }
                    return 'function () {' . chr(10) . (Perlito5::Javascript3::LexicalBlock::->new('block' => $self->{'continue'}->stmts(), 'needs_return' => 0, 'top_level' => 0))->emit_javascript3($level + 2) . chr(10) . Perlito5::Javascript3::tab($level + 1) . '}'
                }
            }
            package Perlito5::AST::Index;
            {
                sub Perlito5::AST::Index::emit_javascript3 {
                    my $self = shift;
                    my $level = shift;
                    my $wantarray = shift;
                    my $type = shift;
                    $type = $type ? '"' . $type . '"' : 'null';
                    if ($self->{'obj'}->isa('Perlito5::AST::Var') && $self->{'obj'}->sigil() eq '$') {
                        my $v = Perlito5::AST::Var::->new('sigil' => '@', 'namespace' => $self->{'obj'}->namespace(), 'name' => $self->{'obj'}->name());
                        return $v->emit_javascript3($level) . '.aget(' . Perlito5::Javascript3::to_num($self->{'index_exp'}, $level) . ', ' . $type . ')'
                    }
                    if ($self->{'obj'}->isa('Perlito5::AST::Apply') && $self->{'obj'}->{'code'} eq 'prefix:<$>') {
                        return Perlito5::Javascript3::emit_javascript3_autovivify($self->{'obj'}->{'arguments'}->[0], $level, 'array') . '.aget(' . Perlito5::Javascript3::to_num($self->{'index_exp'}) . ', ' . $type . ')'
                    }
                    return Perlito5::Javascript3::emit_javascript3_autovivify($self->{'obj'}, $level, 'array') . '.aget(' . Perlito5::Javascript3::to_num($self->{'index_exp'}, $level) . ', ' . $type . ')'
                }
                sub Perlito5::AST::Index::emit_javascript3_set {
                    my $self = shift;
                    my $arguments = shift;
                    my $level = shift;
                    if ($self->{'obj'}->isa('Perlito5::AST::Var') && $self->{'obj'}->sigil() eq '$') {
                        my $v = Perlito5::AST::Var::->new('sigil' => '@', 'namespace' => $self->{'obj'}->namespace(), 'name' => $self->{'obj'}->name());
                        return $v->emit_javascript3($level) . '.aset(' . Perlito5::Javascript3::to_num($self->{'index_exp'}, $level + 1) . ', ' . Perlito5::Javascript3::to_scalar([$arguments], $level + 1) . ')'
                    }
                    if ($self->{'obj'}->isa('Perlito5::AST::Apply') && $self->{'obj'}->{'code'} eq 'prefix:<$>') {
                        return Perlito5::Javascript3::emit_javascript3_autovivify($self->{'obj'}->{'arguments'}->[0], $level, 'array') . '.aset(' . Perlito5::Javascript3::to_num($self->{'index_exp'}) . ', ' . Perlito5::Javascript3::to_scalar([$arguments], $level + 1) . ')'
                    }
                    return Perlito5::Javascript3::emit_javascript3_autovivify($self->{'obj'}, $level, 'array') . '.aset(' . Perlito5::Javascript3::to_num($self->{'index_exp'}, $level + 1) . ', ' . Perlito5::Javascript3::to_scalar([$arguments], $level + 1) . ')'
                }
            }
            package Perlito5::AST::Lookup;
            {
                sub Perlito5::AST::Lookup::emit_javascript3 {
                    my $self = shift;
                    my $level = shift;
                    my $wantarray = shift;
                    my $type = shift;
                    $type = $type ? '"' . $type . '"' : 'null';
                    if ($self->{'obj'}->isa('Perlito5::AST::Var') && $self->{'obj'}->sigil() eq '$') {
                        my $v = Perlito5::AST::Var::->new('sigil' => '%', 'namespace' => $self->{'obj'}->namespace(), 'name' => $self->{'obj'}->name());
                        return Perlito5::Javascript3::emit_javascript3_autovivify($v, $level, 'hash') . '.hget(' . Perlito5::Javascript3::autoquote($self->{'index_exp'}, $level) . ', ' . $type . ')'
                    }
                    if ($self->{'obj'}->isa('Perlito5::AST::Apply') && $self->{'obj'}->{'code'} eq 'prefix:<$>') {
                        return Perlito5::Javascript3::emit_javascript3_autovivify($self->{'obj'}->{'arguments'}->[0], $level, 'hash') . '.hget(' . Perlito5::Javascript3::autoquote($self->{'index_exp'}, $level, 'list') . ', ' . $type . ')'
                    }
                    Perlito5::Javascript3::emit_javascript3_autovivify($self->{'obj'}, $level, 'hash') . '.hget(' . Perlito5::Javascript3::autoquote($self->{'index_exp'}, $level) . ', ' . $type . ')'
                }
                sub Perlito5::AST::Lookup::emit_javascript3_set {
                    my $self = shift;
                    my $arguments = shift;
                    my $level = shift;
                    if ($self->{'obj'}->isa('Perlito5::AST::Var') && $self->{'obj'}->sigil() eq '$') {
                        my $v = Perlito5::AST::Var::->new('sigil' => '%', 'namespace' => $self->{'obj'}->namespace(), 'name' => $self->{'obj'}->name());
                        return $v->emit_javascript3($level) . '.hset(' . Perlito5::Javascript3::autoquote($self->{'index_exp'}, $level) . ', ' . Perlito5::Javascript3::to_scalar([$arguments], $level + 1) . ')'
                    }
                    if ($self->{'obj'}->isa('Perlito5::AST::Apply') && $self->{'obj'}->{'code'} eq 'prefix:<$>') {
                        return Perlito5::Javascript3::emit_javascript3_autovivify($self->{'obj'}->{'arguments'}->[0], $level, 'hash') . '.hset(' . Perlito5::Javascript3::autoquote($self->{'index_exp'}, $level, 'list') . ', ' . Perlito5::Javascript3::to_scalar([$arguments], $level + 1) . ')'
                    }
                    Perlito5::Javascript3::emit_javascript3_autovivify($self->{'obj'}, $level, 'hash') . '.hset(' . Perlito5::Javascript3::autoquote($self->{'index_exp'}, $level) . ', ' . Perlito5::Javascript3::to_scalar([$arguments], $level + 1) . ')'
                }
            }
            package Perlito5::AST::Var;
            {
                my $table = {'$' => 'v_', '@' => 'List_', '%' => 'Hash_', '&' => ''};
                sub Perlito5::AST::Var::emit_javascript3 {
                    my $self = shift;
                    my $level = shift;
                    my $wantarray = shift;
                    my $str_name = $self->{'name'};
                    $str_name eq chr(92) && ($str_name = chr(92) . chr(92));
                    $str_name eq '"' && ($str_name = chr(92) . '"');
                    if ($self->{'sigil'} eq '@') {
                        if ($wantarray eq 'scalar') {
                            return $self->emit_javascript3($level, 'list') . '.FETCHSIZE()'
                        }
                        if ($wantarray eq 'runtime') {
                            return '(p5want' . ' ? ' . $self->emit_javascript3($level, 'list') . ' : ' . $self->emit_javascript3($level, 'list') . '.FETCHSIZE()' . ')'
                        }
                    }
                    if ($self->{'sigil'} eq '&') {
                        return 'p5pkg["' . ($self->{'namespace'} || $Perlito5::PKG_NAME) . '"]["' . $str_name . '"]'
                    }
                    if ($self->{'sigil'} eq '*') {
                        return 'p5pkg["' . ($self->{'namespace'} || $Perlito5::PKG_NAME) . '"]["' . $str_name . '"]'
                    }
                    my $decl_type = $self->{'_decl'} || 'global';
                    if ($decl_type eq 'our') {
                        my $sigil = $self->{'sigil'} eq '$#' ? '@' : $self->{'sigil'};
                        my $s = 'p5pkg["' . ($self->{'namespace'} || $self->{'_namespace'}) . '"]["' . $table->{$sigil} . $str_name . '"]';
                        if ($self->{'sigil'} eq '$#') {
                            return '(' . $s . '.FETCHSIZE() - 1)'
                        }
                        return $s
                    }
                    my $ns = '';
                    if ($self->{'namespace'}) {
                        {
                            if ($self->{'sigil'} eq '$#') {
                                return '(p5global("@", "' . $self->{'namespace'} . '", "' . $str_name . '").FETCHSIZE() - 1)'
                            }
                            return 'p5global("' . $self->{'sigil'} . '", "' . $self->{'namespace'} . '", "' . $str_name . '")'
                        }
                    }
                    if ($self->{'sigil'} eq '$#') {
                        return '(' . $ns . $table->{'@'} . $str_name . '.FETCHSIZE() - 1)'
                    }
                    $ns . $table->{$self->{'sigil'}} . $str_name
                }
            }
            package Perlito5::AST::Decl;
            {
                sub Perlito5::AST::Decl::emit_javascript3 {
                    my $self = shift;
                    my $level = shift;
                    $self->{'var'}->emit_javascript3($level)
                }
                sub Perlito5::AST::Decl::emit_javascript3_init {
                    my $self = shift;
                    if ($self->{'decl'} eq 'my') {
                        my $str = '';
                        $str = $str . 'var ' . $self->{'var'}->emit_javascript3() . ' = ';
                        if ($self->{'var'}->sigil() eq '%') {
                            $str = $str . 'new p5Hash({});'
                        }
                        elsif ($self->{'var'}->sigil() eq '@') {
                            $str = $str . 'new p5Array([]);'
                        }
                        else {
                            $str = $str . 'new p5Scalar(null);'
                        }
                        return $str
                    }
                    elsif ($self->{'decl'} eq 'our') {
                        my $str_name = $self->{'var'}->{'name'};
                        $str_name eq chr(92) && ($str_name = chr(92) . chr(92));
                        $str_name eq '"' && ($str_name = chr(92) . '"');
                        return 'p5global("' . $self->{'var'}->{'sigil'} . '", ' . '"' . ($self->{'var'}->{'namespace'} || $Perlito5::PKG_NAME) . '", ' . '"' . $str_name . '")'
                    }
                    elsif ($self->{'decl'} eq 'local') {
                        my $decl_namespace = $self->{'var'}->{'_namespace'};
                        my $ns = 'p5pkg["' . ($self->{'var'}->{'namespace'} || $decl_namespace || $Perlito5::PKG_NAME) . '"]';
                        return 'p5set_local(' . $ns . ',' . Perlito5::Javascript3::escape_string($self->{'var'}->{'name'}) . ',' . Perlito5::Javascript3::escape_string($self->{'var'}->{'sigil'}) . '); '
                    }
                    elsif ($self->{'decl'} eq 'state') {
                        return '// state ' . $self->{'var'}->emit_javascript3()
                    }
                    else {
                        die('not implemented: Perlito5::AST::Decl ' . chr(39) . $self->{'decl'} . chr(39))
                    }
                }
            }
            package Perlito5::AST::Call;
            {
                sub Perlito5::AST::Call::emit_javascript3 {
                    my $self = shift;
                    my $level = shift;
                    my $wantarray = shift;
                    my $type = shift;
                    $type = $type ? '"' . $type . '"' : 'null';
                    my $meth = $self->{'method'};
                    if ($meth eq 'postcircumfix:<[ ]>') {
                        return Perlito5::Javascript3::emit_javascript3_autovivify($self->{'invocant'}, $level, 'array') . '.aget(' . Perlito5::Javascript3::to_num($self->{'arguments'}) . ', ' . $type . ')'
                    }
                    if ($meth eq 'postcircumfix:<{ }>') {
                        return Perlito5::Javascript3::emit_javascript3_autovivify($self->{'invocant'}, $level, 'hash') . '.hget(' . Perlito5::Javascript3::autoquote($self->{'arguments'}, $level, 'list') . ', ' . $type . ')'
                    }
                    my $invocant = $self->{'invocant'}->emit_javascript3($level, 'scalar');
                    if ($meth eq 'postcircumfix:<( )>') {
                        return 'p5code(' . $invocant . ')(' . Perlito5::Javascript3::to_list($self->{'arguments'}) . ', ' . ($wantarray eq 'list' ? 1 : $wantarray eq 'scalar' ? 0 : $wantarray eq 'void' ? 'null' : 'p5want') . ')'
                    }
                    if (ref($meth) eq 'Perlito5::AST::Var') {
                        $meth = $meth->emit_javascript3($level, 'scalar')
                    }
                    else {
                        $meth = '"' . $meth . '"'
                    }
                    return 'p5call(' . $invocant . ', ' . $meth . ', ' . Perlito5::Javascript3::to_list($self->{'arguments'}) . ', ' . ($wantarray eq 'list' ? 1 : $wantarray eq 'scalar' ? 0 : $wantarray eq 'void' ? 'null' : 'p5want') . ')'
                }
            }
            package Perlito5::AST::Apply;
            {
                sub Perlito5::AST::Apply::emit_regex_javascript3 {
                    my $op = shift;
                    my $var = shift;
                    my $regex = shift;
                    if ($regex->isa('Perlito5::AST::Var')) {
                        $regex = {'code' => 'p5:m', 'arguments' => [$regex, '']}
                    }
                    my $str;
                    my $code = $regex->{'code'};
                    my $regex_args = $regex->{'arguments'};
                    if ($code eq 'p5:s') {
                        $str = $var->emit_javascript3() . '.assign(p5str(' . $var->emit_javascript3() . ').replace(/' . $regex_args->[0]->{'buf'} . '/' . $regex_args->[2]->{'buf'} . ', ' . $regex_args->[1]->emit_javascript3() . '))'
                    }
                    elsif ($code eq 'p5:m') {
                        my $ast = $regex_args->[0];
                        if ($ast->isa('Perlito5::AST::Buf')) {
                            $str = '(' . 'p5str(' . $var->emit_javascript3() . ')' . '.match(/' . $ast->{'buf'} . '/' . $regex_args->[1]->{'buf'} . ')' . ' ? 1 : 0)'
                        }
                        else {
                            $str = '(new RegExp(' . $ast->emit_javascript3() . ', ' . '"' . $regex_args->[1]->{'buf'} . '"' . '))' . '.exec(' . 'p5str(' . $var->emit_javascript3() . ')' . ')'
                        }
                    }
                    elsif ($code eq 'p5:tr') {
                        $str = 'p5tr(' . $var->emit_javascript3() . ', ' . $regex_args->[0]->emit_javascript3() . ', ' . $regex_args->[1]->emit_javascript3() . ')'
                    }
                    else {
                        die('Error: regex emitter - unknown operator ' . $code)
                    }
                    if ($op eq '=~') {
                        return $str
                    }
                    if ($op eq '!~') {
                        return '!(' . $str . ')'
                    }
                    die('Error: regex emitter')
                }
                my %emit_js = ('infix:<=~>' => sub {
                    my $self = $_[0];
                    emit_regex_javascript3('=~', $self->{'arguments'}->[0], $self->{'arguments'}->[1])
                }, 'infix:<!~>' => sub {
                    my $self = $_[0];
                    emit_regex_javascript3('!~', $self->{'arguments'}->[0], $self->{'arguments'}->[1])
                }, 'p5:s' => sub {
                    my $self = $_[0];
                    emit_regex_javascript3('=~', Perlito5::AST::Var::->new('sigil' => '$', 'namespace' => '', 'name' => '_'), $self)
                }, 'p5:m' => sub {
                    my $self = $_[0];
                    emit_regex_javascript3('=~', Perlito5::AST::Var::->new('sigil' => '$', 'namespace' => '', 'name' => '_'), $self)
                }, 'p5:tr' => sub {
                    my $self = $_[0];
                    emit_regex_javascript3('=~', Perlito5::AST::Var::->new('sigil' => '$', 'namespace' => '', 'name' => '_'), $self)
                }, '__PACKAGE__' => sub {
                    my $self = $_[0];
                    '"' . $Perlito5::PKG_NAME . '"'
                }, 'wantarray' => sub {
                    my $self = $_[0];
                    'p5want'
                }, 'package' => sub {
                    my $self = $_[0];
                    'var ' . Perlito5::Javascript3::pkg_new_var() . ' = p5make_package("' . $self->{'namespace'} . '")'
                }, 'infix:<=>>' => sub {
                    my $self = shift;
                    my $level = shift;
                    my $wantarray = shift;
                    Perlito5::Javascript3::autoquote($self->{'arguments'}->[0], $level) . ', ' . $self->{'arguments'}->[1]->emit_javascript3($level)
                }, 'infix:<cmp>' => sub {
                    my $self = $_[0];
                    'p5cmp(' . join(', ', map(Perlito5::Javascript3::to_str($_), @{$self->{'arguments'}})) . ')'
                }, 'infix:<<=>>' => sub {
                    my $self = $_[0];
                    'p5cmp(' . join(', ', map(Perlito5::Javascript3::to_num($_), @{$self->{'arguments'}})) . ')'
                }, 'infix:<**>' => sub {
                    my $self = $_[0];
                    'Math.pow(' . join(', ', map(Perlito5::Javascript3::to_num($_), @{$self->{'arguments'}})) . ')'
                }, 'prefix:<!>' => sub {
                    my $self = shift;
                    my $level = shift;
                    '!( ' . Perlito5::Javascript3::to_bool($self->{'arguments'}->[0], $level) . ')'
                }, 'prefix:<not>' => sub {
                    my $self = shift;
                    my $level = shift;
                    '!( ' . Perlito5::Javascript3::to_bool($self->{'arguments'}->[0], $level) . ')'
                }, 'prefix:<~>' => sub {
                    my $self = $_[0];
                    'p5complement( ' . Perlito5::Javascript3::to_num($self->{'arguments'}->[0]) . ')'
                }, 'prefix:<->' => sub {
                    my $self = shift;
                    my $level = shift;
                    my $wantarray = shift;
                    '-( ' . $self->{'arguments'}->[0]->emit_javascript3($level, 'scalar') . ')'
                }, 'prefix:<+>' => sub {
                    my $self = shift;
                    my $level = shift;
                    my $wantarray = shift;
                    '(' . $self->{'arguments'}->[0]->emit_javascript3($level, $wantarray) . ')'
                }, 'require' => sub {
                    my $self = $_[0];
                    my $level = $_[1];
                    my $arg = $self->{'arguments'}->[0];
                    if ($arg->isa('Perlito5::AST::Num')) {
                        return 1
                    }
                    'p5pkg["Perlito5::Grammar::Use"].require([' . Perlito5::Javascript3::to_str($self->{'arguments'}->[0]) . ', ' . ($self->{'arguments'}->[0]->{'bareword'} ? 1 : 0) . '])'
                }, 'prefix:<$>' => sub {
                    my $self = $_[0];
                    my $level = $_[1];
                    my $arg = $self->{'arguments'}->[0];
                    Perlito5::Javascript3::emit_javascript3_autovivify($arg, $level, 'scalar') . '.sderef()'
                }, 'prefix:<@>' => sub {
                    my $self = $_[0];
                    my $level = $_[1];
                    my $arg = $self->{'arguments'}->[0];
                    Perlito5::Javascript3::emit_javascript3_autovivify($arg, $level, 'array') . '.aderef()'
                }, 'prefix:<$#>' => sub {
                    my $self = $_[0];
                    my $level = $_[1];
                    my $arg = $self->{'arguments'}->[0];
                    '(' . Perlito5::Javascript3::emit_javascript3_autovivify($arg, $level, 'array') . '.aderef().FETCHSIZE() - 1)'
                }, 'prefix:<%>' => sub {
                    my $self = $_[0];
                    my $level = $_[1];
                    my $arg = $self->{'arguments'}->[0];
                    Perlito5::Javascript3::emit_javascript3_autovivify($arg, $level, 'hash') . '.hderef()'
                }, 'prefix:<&>' => sub {
                    my $self = $_[0];
                    my $level = $_[1];
                    my $arg = $self->{'arguments'}->[0];
                    'p5code_lookup_by_name("' . $Perlito5::PKG_NAME . '", ' . $arg->emit_javascript3($level) . ')'
                }, 'circumfix:<[ ]>' => sub {
                    my $self = $_[0];
                    my $level = $_[1];
                    '(new p5ArrayRef(new p5Array(' . Perlito5::Javascript3::to_list($self->{'arguments'}) . ')))'
                }, 'circumfix:<{ }>' => sub {
                    my $self = $_[0];
                    my $level = $_[1];
                    '(new p5HashRef(new p5Hash(' . Perlito5::Javascript3::to_list($self->{'arguments'}, $level, 'hash') . ')))'
                }, 'prefix:<' . chr(92) . '>' => sub {
                    my $self = $_[0];
                    my $level = $_[1];
                    my $arg = $self->{'arguments'}->[0];
                    if ($arg->isa('Perlito5::AST::Var')) {
                        if ($arg->sigil() eq '@') {
                            return '(new p5ArrayRef(' . $arg->emit_javascript3($level) . '))'
                        }
                        if ($arg->sigil() eq '%') {
                            return '(new p5HashRef(' . $arg->emit_javascript3($level) . '))'
                        }
                        if ($arg->sigil() eq '*') {
                            return '(new p5GlobRef(' . $arg->emit_javascript3($level) . '))'
                        }
                        if ($arg->sigil() eq '&') {
                            if ($arg->{'namespace'}) {
                                return 'p5pkg["' . $arg->{'namespace'} . '"].' . $arg->{'name'}
                            }
                            else {
                                return Perlito5::Javascript3::pkg() . '.' . $arg->{'name'}
                            }
                        }
                    }
                    return '(new p5ScalarRef(' . $arg->emit_javascript3($level) . '))'
                }, 'postfix:<++>' => sub {
                    my $self = $_[0];
                    my $level = $_[1];
                    Perlito5::Javascript3::emit_javascript3_autovivify($self->{'arguments'}->[0], $level, 'lvalue') . '.p5postincr()'
                }, 'postfix:<-->' => sub {
                    my $self = $_[0];
                    my $level = $_[1];
                    Perlito5::Javascript3::emit_javascript3_autovivify($self->{'arguments'}->[0], $level, 'lvalue') . '.p5postdecr()'
                }, 'prefix:<++>' => sub {
                    my $self = $_[0];
                    my $level = $_[1];
                    Perlito5::Javascript3::emit_javascript3_autovivify($self->{'arguments'}->[0], $level, 'lvalue') . '.p5incr()'
                }, 'prefix:<-->' => sub {
                    my $self = $_[0];
                    my $level = $_[1];
                    Perlito5::Javascript3::emit_javascript3_autovivify($self->{'arguments'}->[0], $level, 'lvalue') . '.p5decr()'
                }, 'infix:<x>' => sub {
                    my $self = $_[0];
                    'p5str_replicate(' . join(', ', map($_->emit_javascript3(), @{$self->{'arguments'}})) . ')'
                }, 'list:<.>' => sub {
                    my $self = $_[0];
                    '(' . join(' + ', map(Perlito5::Javascript3::to_str($_), @{$self->{'arguments'}})) . ')'
                }, 'list:<,>' => sub {
                    my $self = $_[0];
                    Perlito5::Javascript3::to_list($self->{'arguments'})
                }, 'infix:<..>' => sub {
                    my $self = $_[0];
                    '(function (a) { ' . 'for (var i=' . $self->{'arguments'}->[0]->emit_javascript3() . ', l=' . $self->{'arguments'}->[1]->emit_javascript3() . '; ' . 'i<=l; ++i)' . '{ ' . 'a.push(i) ' . '}; ' . 'return a ' . '})([])'
                }, 'delete' => sub {
                    my $self = $_[0];
                    '(delete ' . $self->{'arguments'}->[0]->emit_javascript3() . ')'
                }, 'scalar' => sub {
                    my $self = $_[0];
                    my $level = $_[1];
                    Perlito5::Javascript3::to_scalar($self->{'arguments'}, $level + 1)
                }, 'ternary:<? :>' => sub {
                    my $self = shift;
                    my $level = shift;
                    my $wantarray = shift;
                    '( ' . Perlito5::Javascript3::to_bool($self->{'arguments'}->[0]) . ' ? ' . ($self->{'arguments'}->[1])->emit_javascript3($level, $wantarray) . ' : ' . ($self->{'arguments'}->[2])->emit_javascript3($level, $wantarray) . ')'
                }, 'my' => sub {
                    my $self = shift;
                    my $level = shift;
                    my $wantarray = shift;
                    'p5context(' . '[' . join(', ', map($_->emit_javascript3($level, $wantarray), @{$self->{'arguments'}})) . '], ' . ($wantarray eq 'runtime' ? 'p5want' : $wantarray eq 'list' ? 1 : 0) . ')'
                }, 'our' => sub {
                    my $self = shift;
                    my $level = shift;
                    my $wantarray = shift;
                    'p5context(' . '[' . join(', ', map($_->emit_javascript3($level, $wantarray), @{$self->{'arguments'}})) . '], ' . ($wantarray eq 'runtime' ? 'p5want' : $wantarray eq 'list' ? 1 : 0) . ')'
                }, 'local' => sub {
                    my $self = shift;
                    my $level = shift;
                    my $wantarray = shift;
                    'p5context(' . '[' . join(', ', map($_->emit_javascript3($level, $wantarray), @{$self->{'arguments'}})) . '], ' . ($wantarray eq 'runtime' ? 'p5want' : $wantarray eq 'list' ? 1 : 0) . ')'
                }, 'circumfix:<( )>' => sub {
                    my $self = shift;
                    my $level = shift;
                    my $wantarray = shift;
                    'p5context(' . '[' . join(', ', map($_->emit_javascript3($level, $wantarray), @{$self->{'arguments'}})) . '], ' . ($wantarray eq 'runtime' ? 'p5want' : $wantarray eq 'list' ? 1 : 0) . ')'
                }, 'infix:<=>' => sub {
                    my $self = shift;
                    my $level = shift;
                    my $wantarray = shift;
                    my $parameters = $self->{'arguments'}->[0];
                    my $arguments = $self->{'arguments'}->[1];
                    if ($parameters->isa('Perlito5::AST::Apply') && $parameters->code() eq 'prefix:<*>') {
                        return 'p5set_glob(' . $parameters->{'arguments'}->[0]->emit_javascript3() . ', ' . Perlito5::Javascript3::to_scalar([$arguments], $level + 1) . ')'
                    }
                    if ($parameters->isa('Perlito5::AST::Apply') && ($parameters->code() eq 'my' || $parameters->code() eq 'our' || $parameters->code() eq 'local' || $parameters->code() eq 'circumfix:<( )>')) {
                        my $tmp = 'tmp' . Perlito5::Javascript3::get_label();
                        my $tmp2 = 'tmp' . Perlito5::Javascript3::get_label();
                        return '(function () { ' . 'var ' . $tmp . ' = ' . Perlito5::Javascript3::to_list([$arguments], $level + 1) . '; ' . 'var ' . $tmp2 . ' = ' . $tmp . '.slice(0); ' . join('; ', (map(+($_->isa('Perlito5::AST::Apply') && $_->code() eq 'undef' ? $tmp . '.shift()' : $_->sigil() eq '$' ? $_->emit_javascript3() . '.assign(' . $tmp . '.shift())' : $_->sigil() eq '@' ? $_->emit_javascript3() . '.assign(' . $tmp . '); ' . $tmp . ' = []' : $_->sigil() eq '%' ? $_->emit_javascript3() . '.assign(p5a_to_h(' . $tmp . ')); ' . $tmp . ' = []' : die('not implemented')), @{$parameters->arguments()})), 'return ' . $tmp2) . ' })()'
                    }
                    if ($parameters->isa('Perlito5::AST::Var') && $parameters->sigil() eq '$' || $parameters->isa('Perlito5::AST::Decl') && $parameters->var()->sigil() eq '$') {
                        return '' . $parameters->emit_javascript3() . '.assign(' . Perlito5::Javascript3::to_scalar([$arguments], $level + 1) . ')'
                    }
                    if ($parameters->isa('Perlito5::AST::Call') && $parameters->{'method'} eq 'postcircumfix:<[ ]>') {
                        return Perlito5::Javascript3::emit_javascript3_autovivify($parameters->{'invocant'}, $level, 'array') . '.aset(' . Perlito5::Javascript3::to_num($parameters->{'arguments'}) . ', ' . Perlito5::Javascript3::to_scalar([$arguments], $level + 1) . ')'
                    }
                    elsif ($parameters->isa('Perlito5::AST::Call') && $parameters->{'method'} eq 'postcircumfix:<{ }>') {
                        return Perlito5::Javascript3::emit_javascript3_autovivify($parameters->{'invocant'}, $level, 'hash') . '.hset(' . Perlito5::Javascript3::autoquote($parameters->{'arguments'}, $level) . ', ' . Perlito5::Javascript3::to_scalar([$arguments], $level + 1) . ')'
                    }
                    elsif ($parameters->isa('Perlito5::AST::Index')) {
                        return $parameters->emit_javascript3_set($arguments, $level + 1)
                    }
                    elsif ($parameters->isa('Perlito5::AST::Lookup')) {
                        return $parameters->emit_javascript3_set($arguments, $level + 1)
                    }
                    if ($parameters->isa('Perlito5::AST::Var') && $parameters->sigil() eq '@') {
                        return $parameters->emit_javascript3() . '.assign(new p5Array(' . Perlito5::Javascript3::to_list([$arguments], $level + 1) . '))'
                    }
                    elsif ($parameters->isa('Perlito5::AST::Decl') && $parameters->var()->sigil() eq '@') {
                        return $parameters->var()->emit_javascript3() . '.assign(new p5Array(' . Perlito5::Javascript3::to_list([$arguments], $level + 1) . '))'
                    }
                    elsif ($parameters->isa('Perlito5::AST::Var') && $parameters->sigil() eq '%' || $parameters->isa('Perlito5::AST::Decl') && $parameters->var()->sigil() eq '%') {
                        return $parameters->emit_javascript3() . '.assign(new p5Hash(' . Perlito5::Javascript3::to_list([$arguments], $level + 1, 'hash') . '))'
                    }
                    if ($parameters->isa('Perlito5::AST::Var') && $parameters->sigil() eq '*') {
                        return '(' . $parameters->emit_javascript3($level) . ' = ' . $arguments->emit_javascript3($level + 1) . ')'
                    }
                    print(Perlito5::Dumper::ast_dumper($parameters));
                    die('assignment: don' . chr(39) . 't know what to do with left side isa ', ref($parameters))
                }, 'break' => sub {
                    my $self = shift;
                    my $level = shift;
                    $Perlito5::THROW = 1;
                    'throw(new p5_error("break", ""))'
                }, 'next' => sub {
                    my $self = shift;
                    my $level = shift;
                    $Perlito5::THROW = 1;
                    my $label = $self->{'arguments'}->[0]->{'code'} || '';
                    'throw(new p5_error("next", "' . $label . '"))'
                }, 'last' => sub {
                    my $self = shift;
                    my $level = shift;
                    $Perlito5::THROW = 1;
                    my $label = $self->{'arguments'}->[0]->{'code'} || '';
                    'throw(new p5_error("last", "' . $label . '"))'
                }, 'redo' => sub {
                    my $self = shift;
                    my $level = shift;
                    $Perlito5::THROW = 1;
                    my $label = $self->{'arguments'}->[0]->{'code'} || '';
                    'throw(new p5_error("redo", "' . $label . '"))'
                }, 'return' => sub {
                    my $self = shift;
                    my $level = shift;
                    $Perlito5::THROW = 1;
                    'throw(' . Perlito5::Javascript3::to_runtime_context($self->{'arguments'}, $level) . ')'
                }, 'goto' => sub {
                    my $self = $_[0];
                    $Perlito5::THROW = 1;
                    'throw((' . $self->{'arguments'}->[0]->emit_javascript3() . ')([List__, p5want]))'
                }, 'do' => sub {
                    my $self = shift;
                    my $level = shift;
                    my $wantarray = shift;
                    my $ast = Perlito5::AST::Apply::->new('code' => 'eval', 'namespace' => '', 'arguments' => [Perlito5::AST::Apply::->new('code' => 'do_file', 'namespace' => 'Perlito5::Grammar::Use', 'arguments' => $self->{'arguments'})]);
                    $ast->emit_javascript3($level)
                }, 'eval' => sub {
                    my $self = shift;
                    my $level = shift;
                    my $wantarray = shift;
                    $Perlito5::THROW = 1;
                    my $arg = $self->{'arguments'}->[0];
                    my $eval;
                    if ($arg->isa('Perlito5::AST::Block')) {
                        my $block = $arg->{'stmts'};
                        return Perlito5::Javascript3::emit_wrap_javascript3($level, $wantarray, (Perlito5::Javascript3::LexicalBlock::->new('block' => $block, 'needs_return' => 1))->emit_javascript2($level + 1, $wantarray))
                    }
                    else {
                        my $var_env_perl5 = Perlito5::Dumper::ast_dumper([]);
                        my $m = Perlito5::Grammar::Expression::term_square($var_env_perl5, 0);
                        $m = Perlito5::Grammar::Expression::expand_list(Perlito5::Match::flat($m)->[2]);
                        my $var_env_js = '(new p5ArrayRef(new p5Array(' . Perlito5::Javascript3::to_list($m) . ')))';
                        $eval = 'eval(perl5_to_js(' . Perlito5::Javascript3::to_str($arg) . ', ' . '"' . $Perlito5::PKG_NAME . '", ' . $var_env_js . ', ' . '"' . $wantarray . '"' . '))'
                    }
                    '(function (p5want) {' . chr(10) . 'var r = null;' . chr(10) . 'p5pkg["main"]["v_@"].assign("");' . chr(10) . 'try {' . chr(10) . 'r = ' . $eval . chr(10) . '}' . chr(10) . 'catch(err) {' . chr(10) . 'if ( err instanceof p5_error ) {' . chr(10) . 'p5pkg["main"]["v_@"].assign(err);' . chr(10) . '}' . chr(10) . 'else if ( err instanceof Error ) {' . chr(10) . 'p5pkg["main"]["v_@"].assign(err);' . chr(10) . '}' . chr(10) . 'else {' . chr(10) . 'return(err);' . chr(10) . '}' . chr(10) . '}' . chr(10) . 'return r;' . chr(10) . '})(' . ($wantarray eq 'list' ? 1 : $wantarray eq 'scalar' ? 0 : $wantarray eq 'void' ? 'null' : 'p5want') . ')'
                }, 'undef' => sub {
                    my $self = shift;
                    my $level = shift;
                    my $wantarray = shift;
                    if ($self->{'arguments'} && @{$self->{'arguments'}}) {
                        return $self->{'arguments'}->[0]->emit_javascript3() . '.assign(null)'
                    }
                    return 'null'
                }, 'shift' => sub {
                    my $self = shift;
                    my $level = shift;
                    my $wantarray = shift;
                    if ($self->{'arguments'} && @{$self->{'arguments'}}) {
                        return Perlito5::Javascript3::pkg() . '.shift([' . join(', ', map($_->emit_javascript3($level), @{$self->{'arguments'}})) . '])'
                    }
                    return Perlito5::Javascript3::pkg() . '.shift([List__])'
                }, 'map' => sub {
                    my $self = shift;
                    my $level = shift;
                    my $wantarray = shift;
                    my @in = @{$self->{'arguments'}};
                    my $fun = shift(@in);
                    my $list = Perlito5::Javascript3::to_list(\@in);
                    if (ref($fun) eq 'Perlito5::AST::Block') {
                        $fun = $fun->{'stmts'}
                    }
                    else {
                        $fun = [$fun]
                    }
                    'p5map(' . Perlito5::Javascript3::pkg() . ', ' . 'function (p5want) {' . chr(10) . (Perlito5::Javascript3::LexicalBlock::->new('block' => $fun, 'needs_return' => 1, 'top_level' => 0))->emit_javascript3($level + 1) . chr(10) . Perlito5::Javascript3::tab($level) . '}, ' . $list . ')'
                }, 'grep' => sub {
                    my $self = shift;
                    my $level = shift;
                    my $wantarray = shift;
                    my @in = @{$self->{'arguments'}};
                    my $fun = shift(@in);
                    my $list = Perlito5::Javascript3::to_list(\@in);
                    if (ref($fun) eq 'Perlito5::AST::Block') {
                        $fun = $fun->{'stmts'}
                    }
                    else {
                        $fun = [$fun]
                    }
                    'p5grep(' . Perlito5::Javascript3::pkg() . ', ' . 'function (p5want) {' . chr(10) . (Perlito5::Javascript3::LexicalBlock::->new('block' => $fun, 'needs_return' => 1, 'top_level' => 0))->emit_javascript3($level + 1) . chr(10) . Perlito5::Javascript3::tab($level) . '}, ' . $list . ')'
                }, 'sort' => sub {
                    my $self = shift;
                    my $level = shift;
                    my $wantarray = shift;
                    my @in = @{$self->{'arguments'}};
                    my $fun;
                    my $list;
                    if (ref($in[0]) eq 'Perlito5::AST::Block') {
                        $fun = shift(@in);
                        $fun = 'function (p5want) {' . chr(10) . (Perlito5::Javascript3::LexicalBlock::->new('block' => $fun->{'stmts'}, 'needs_return' => 1, 'top_level' => 0))->emit_javascript3($level + 1) . chr(10) . Perlito5::Javascript3::tab($level) . '}'
                    }
                    else {
                        $fun = 'null'
                    }
                    $list = Perlito5::Javascript3::to_list(\@in);
                    'p5sort(' . Perlito5::Javascript3::pkg() . ', ' . $fun . ', ' . $list . ')'
                }, 'infix:<//>' => sub {
                    my $self = shift;
                    my $level = shift;
                    my $wantarray = shift;
                    'p5defined_or' . '(' . $self->{'arguments'}->[0]->emit_javascript3($level, 'scalar') . ', ' . Perlito5::Javascript3::emit_function_javascript3($level, $wantarray, $self->{'arguments'}->[1]) . ')'
                }, 'exists' => sub {
                    my $self = shift;
                    my $level = shift;
                    my $wantarray = shift;
                    my $arg = $self->{'arguments'}->[0];
                    if ($arg->isa('Perlito5::AST::Lookup')) {
                        my $v = $arg->obj();
                        if ($v->isa('Perlito5::AST::Var') && $v->sigil() eq '$') {
                            $v = Perlito5::AST::Var::->new('sigil' => '%', 'namespace' => $v->namespace(), 'name' => $v->name());
                            return '(' . $v->emit_javascript3() . ').exists(' . Perlito5::Javascript3::autoquote($arg->{'index_exp'}, $level) . ')'
                        }
                        return '(' . $v->emit_javascript3() . ').hderef().exists(' . Perlito5::Javascript3::autoquote($arg->{'index_exp'}, $level) . ')'
                    }
                    if ($arg->isa('Perlito5::AST::Call')) {
                        if ($arg->method() eq 'postcircumfix:<{ }>') {
                            return '(' . $arg->invocant()->emit_javascript3() . ').hderef().exists(' . Perlito5::Javascript3::autoquote($arg->{'arguments'}, $level) . ')'
                        }
                    }
                });
                sub Perlito5::AST::Apply::emit_javascript3 {
                    my $self = shift;
                    my $level = shift;
                    my $wantarray = shift;
                    my $apply = $self->op_assign();
                    if ($apply) {
                        return $apply->emit_javascript3($level)
                    }
                    my $code = $self->{'code'};
                    if (ref($code) ne '') {
                        my @args = ();
                        push(@args, $_->emit_javascript3())
                            for @{$self->{'arguments'}};
                        return 'p5code(' . $self->{'code'}->emit_javascript3($level) . ')(' . join(',', @args) . ')'
                    }
                    exists($emit_js{$code}) && return $emit_js{$code}->($self, $level, $wantarray);
                    if (exists($Perlito5::Javascript3::op_infix_js_str{$code})) {
                        return '(' . join($Perlito5::Javascript3::op_infix_js_str{$code}, map(Perlito5::Javascript3::to_str($_), @{$self->{'arguments'}})) . ')'
                    }
                    if (exists($Perlito5::Javascript3::op_infix_js_num{$code})) {
                        return '(' . join($Perlito5::Javascript3::op_infix_js_num{$code}, map(Perlito5::Javascript3::to_num($_), @{$self->{'arguments'}})) . ')'
                    }
                    if (exists($Perlito5::Javascript3::op_prefix_js_str{$code})) {
                        return $Perlito5::Javascript3::op_prefix_js_str{$code} . '(' . Perlito5::Javascript3::to_str($self->{'arguments'}->[0]) . ')'
                    }
                    if ($code eq 'infix:<&&>' || $code eq 'infix:<and>') {
                        return 'p5and' . '(' . $self->{'arguments'}->[0]->emit_javascript3($level, 'scalar') . ', ' . Perlito5::Javascript3::emit_function_javascript3($level, $wantarray, $self->{'arguments'}->[1]) . ')'
                    }
                    if ($code eq 'infix:<||>' || $code eq 'infix:<or>') {
                        return 'p5or' . '(' . $self->{'arguments'}->[0]->emit_javascript3($level, 'scalar') . ', ' . Perlito5::Javascript3::emit_function_javascript3($level, $wantarray, $self->{'arguments'}->[1]) . ')'
                    }
                    if ($self->{'namespace'}) {
                        if ($self->{'namespace'} eq 'JS' && $code eq 'inline') {
                            if ($self->{'arguments'}->[0]->isa('Perlito5::AST::Buf')) {
                                return $self->{'arguments'}->[0]->{'buf'}
                            }
                            else {
                                die('JS::inline needs a string constant')
                            }
                        }
                        $code = 'p5pkg["' . $self->{'namespace'} . '"].' . $code
                    }
                    else {
                        $code = Perlito5::Javascript3::pkg() . '.' . $code
                    }
                    my $sig;
                    my $may_need_autoload;
                    {
                        my $name = $self->{'code'};
                        my $namespace = $self->{'namespace'} || $Perlito5::PKG_NAME;
                        my $effective_name = $namespace . '::' . $self->{'code'};
                        if (exists($Perlito5::PROTO->{$effective_name})) {
                            $sig = $Perlito5::PROTO->{$effective_name}
                        }
                        elsif ((!$self->{'namespace'} || $namespace eq 'CORE') && exists($Perlito5::CORE_PROTO->{'CORE::' . $name})) {
                            $effective_name = 'CORE::' . $name;
                            $sig = $Perlito5::CORE_PROTO->{$effective_name}
                        }
                        else {
                            if ($self->{'bareword'}) {
                                if ($Perlito5::STRICT) {
                                    die('Bareword "' . $name . '" not allowed while "strict subs" in use')
                                }
                                return Perlito5::Javascript3::escape_string(($self->{'namespace'} ? $self->{'namespace'} . '::' : '') . $name)
                            }
                            $may_need_autoload = 1
                        }
                    }
                    if (($self->{'code'} eq 'say' || $self->{'code'} eq 'print') && !$self->{'namespace'} && $self->{'bareword'}) {
                        $self->{'arguments'} = [Perlito5::AST::Var::->new('sigil' => '$', 'namespace' => '', 'name' => '_')]
                    }
                    if ($sig) {
                        my @out = ();
                        my @in = @{$self->{'arguments'} || []};
                        my $optional = 0;
                        while (length($sig)) {
                            my $c = substr($sig, 0, 1);
                            if ($c eq ';') {
                                $optional = 1
                            }
                            elsif ($c eq '$' || $c eq '_') {
                                (@in || !$optional) && push(@out, shift(@in)->emit_javascript3($level, 'scalar'))
                            }
                            elsif ($c eq '@') {
                                (@in || !$optional) && push(@out, 'new p5Array(' . Perlito5::Javascript3::to_list(\@in) . ')');
                                @in = ()
                            }
                            elsif ($c eq '*') {
                                if (@in || !$optional) {
                                    my $arg = shift(@in);
                                    if ($arg->{'bareword'}) {
                                        push(@out, 'p5pkg["' . ($arg->{'namespace'} || $Perlito5::PKG_NAME) . '"]["f_' . $arg->{'code'} . '"]')
                                    }
                                    else {
                                        push(@out, $arg->emit_javascript3($level, 'scalar'))
                                    }
                                }
                            }
                            elsif ($c eq chr(92)) {
                                if (substr($sig, 0, 2) eq chr(92) . '$') {
                                    $sig = substr($sig, 1);
                                    (@in || !$optional) && push(@out, shift(@in)->emit_javascript3($level, 'scalar'))
                                }
                                elsif (substr($sig, 0, 2) eq chr(92) . '@' || substr($sig, 0, 2) eq chr(92) . '%') {
                                    $sig = substr($sig, 1);
                                    (@in || !$optional) && push(@out, shift(@in)->emit_javascript3($level, 'list'))
                                }
                                elsif (substr($sig, 0, 5) eq chr(92) . '[@%]') {
                                    $sig = substr($sig, 4);
                                    (@in || !$optional) && push(@out, shift(@in)->emit_javascript3($level, 'list'))
                                }
                            }
                            $sig = substr($sig, 1)
                        }
                        return $code . '([' . join(', ', @out) . '], ' . ($wantarray eq 'list' ? 1 : $wantarray eq 'scalar' ? 0 : $wantarray eq 'void' ? 'null' : 'p5want') . ')'
                    }
                    my @args = ();
                    my $arg_list = Perlito5::Javascript3::to_list_preprocess($self->{'arguments'});
                    push(@args, $_->emit_javascript3($level))
                        for @{$arg_list};
                    my $arg_code = $self->{'code'} eq 'scalar' ? '[' . join(', ', @args) . ']' : 'p5param_list(' . join(', ', map($_->emit_javascript3($level, 'list', 'lvalue'), @{$arg_list})) . ')';
                    if ($may_need_autoload) {
                        my $name = $self->{'code'};
                        my $namespace = $self->{'namespace'} || $Perlito5::PKG_NAME;
                        return 'p5call_sub(' . '"' . $namespace . '", ' . '"' . $name . '", ' . $arg_code . ', ' . ($wantarray eq 'list' ? 1 : $wantarray eq 'scalar' ? 0 : $wantarray eq 'void' ? 'null' : 'p5want') . ')'
                    }
                    $code . '(' . $arg_code . ', ' . ($wantarray eq 'list' ? 1 : $wantarray eq 'scalar' ? 0 : $wantarray eq 'void' ? 'null' : 'p5want') . ')'
                }
            }
            package Perlito5::AST::If;
            {
                sub Perlito5::AST::If::emit_javascript3 {
                    my $self = shift;
                    my $level = shift;
                    my $cond = $self->{'cond'};
                    my $body = Perlito5::Javascript3::LexicalBlock::->new('block' => $self->{'body'}->stmts(), 'needs_return' => 0, 'create_context' => 1);
                    my $s = 'if ( ' . Perlito5::Javascript3::to_bool($cond, $level + 1) . ' ) {' . chr(10) . $body->emit_javascript3($level + 1) . chr(10) . Perlito5::Javascript3::tab($level) . '}';
                    if (@{$self->{'otherwise'}->stmts()}) {
                        my $otherwise = Perlito5::Javascript3::LexicalBlock::->new('block' => $self->{'otherwise'}->stmts(), 'needs_return' => 0, 'create_context' => 1);
                        $s = $s . chr(10) . Perlito5::Javascript3::tab($level) . 'else {' . chr(10) . $otherwise->emit_javascript3($level + 1) . chr(10) . Perlito5::Javascript3::tab($level) . '}'
                    }
                    return $s
                }
            }
            package Perlito5::AST::When;
            {
                sub Perlito5::AST::When::emit_javascript3 {
                    my $self = shift;
                    my $level = shift;
                    my $cond = $self->{'cond'};
                    my $body = Perlito5::Javascript3::LexicalBlock::->new('block' => $self->{'body'}->stmts(), 'needs_return' => 0, 'create_context' => 1);
                    my $expr = Perlito5::AST::Apply::->new('code' => 'infix:<==>', 'arguments' => [Perlito5::AST::Var::->new('sigil' => '$', 'namespace' => '', 'name' => '_'), $cond]);
                    my $label = '';
                    my $s = 'if ( ' . Perlito5::Javascript3::to_bool($expr, $level + 1) . ' ) {' . chr(10) . $body->emit_javascript3($level + 1) . chr(10) . Perlito5::Javascript3::tab($level + 1) . 'throw(new p5_error("next", "' . $label . '"))' . Perlito5::Javascript3::tab($level) . '}';
                    return $s
                }
            }
            package Perlito5::AST::While;
            {
                sub Perlito5::AST::While::emit_javascript3 {
                    my $self = shift;
                    my $level = shift;
                    my $cond = $self->{'cond'};
                    return 'p5while(' . 'function () {' . chr(10) . (Perlito5::Javascript3::LexicalBlock::->new('block' => $self->{'body'}->stmts(), 'needs_return' => 0, 'top_level' => 0))->emit_javascript3($level + 2) . chr(10) . Perlito5::Javascript3::tab($level + 1) . '}, ' . Perlito5::Javascript3::emit_function_javascript3($level, 0, $cond) . ', ' . Perlito5::AST::Block::emit_javascript3_continue($self, $level) . ', ' . '"' . ($self->{'label'} || '') . '"' . ')'
                }
            }
            package Perlito5::AST::For;
            {
                sub Perlito5::AST::For::emit_javascript3 {
                    my $self = shift;
                    my $level = shift;
                    if (ref($self->{'cond'}) eq 'ARRAY') {
                        my $body = Perlito5::Javascript3::LexicalBlock::->new('block' => $self->{'body'}->stmts(), 'needs_return' => 0, 'create_context' => 1);
                        return 'for ( ' . ($self->{'cond'}->[0] ? $self->{'cond'}->[0]->emit_javascript3($level + 1) . '; ' : '; ') . ($self->{'cond'}->[1] ? $self->{'cond'}->[1]->emit_javascript3($level + 1) . '; ' : '; ') . ($self->{'cond'}->[2] ? $self->{'cond'}->[2]->emit_javascript3($level + 1) . ' ' : ' ') . ') {' . chr(10) . $body->emit_javascript3($level + 1) . chr(10) . Perlito5::Javascript3::tab($level) . '}'
                    }
                    my $cond = Perlito5::Javascript3::to_list([$self->{'cond'}], $level + 1);
                    if ($self->{'topic'}) {
                        my $v = $self->{'topic'};
                        my $sig = $v->emit_javascript3($level + 1);
                        return 'p5for_lex(' . 'function (' . $sig . ') {' . chr(10) . (Perlito5::Javascript3::LexicalBlock::->new('block' => $self->{'body'}->stmts(), 'needs_return' => 0, 'top_level' => 0))->emit_javascript3($level + 2) . chr(10) . Perlito5::Javascript3::tab($level + 1) . '}, ' . $cond . ', ' . Perlito5::AST::Block::emit_javascript3_continue($self, $level) . ', ' . '"' . ($self->{'label'} || '') . '"' . ')'
                    }
                    else {
                        return 'p5for(' . Perlito5::Javascript3::pkg() . ', ' . 'function () {' . chr(10) . (Perlito5::Javascript3::LexicalBlock::->new('block' => $self->{'body'}->stmts(), 'needs_return' => 0, 'top_level' => 0))->emit_javascript3($level + 2) . chr(10) . Perlito5::Javascript3::tab($level + 1) . '}, ' . $cond . ', ' . Perlito5::AST::Block::emit_javascript3_continue($self, $level) . ', ' . '"' . ($self->{'label'} || '') . '"' . ')'
                    }
                }
            }
            package Perlito5::AST::Sub;
            {
                sub Perlito5::AST::Sub::emit_javascript3 {
                    my $self = shift;
                    my $level = shift;
                    my $s = 'function (List__, p5want) {' . chr(10) . Perlito5::Javascript3::tab($level + 1) . 'List__ = new p5Array(List__);' . chr(10) . (Perlito5::Javascript3::LexicalBlock::->new('block' => $self->{'block'}, 'needs_return' => 1, 'top_level' => 1))->emit_javascript3($level) . chr(10) . Perlito5::Javascript3::tab($level) . '}';
                    if ($self->{'name'}) {
                        return 'p5typeglob_set("' . $self->{'namespace'} . '", "' . $self->{'name'} . '", ' . $s . ')'
                    }
                    else {
                        return $s
                    }
                }
            }
            package Perlito5::AST::Use;
            {
                sub Perlito5::AST::Use::emit_javascript3 {
                    my $self = shift;
                    my $level = shift;
                    Perlito5::Grammar::Use::emit_time_eval($self);
                    '// ' . $self->{'code'} . ' ' . $self->{'mod'} . chr(10)
                }
            }
            1
        }
    }
    {
        {
            package main;
            undef();
            package Perlito5::Javascript3::Runtime;
            sub Perlito5::Javascript3::Runtime::emit_javascript3 {
                return '//' . chr(10) . '// lib/Perlito5/Javascript3/Runtime.js' . chr(10) . '//' . chr(10) . '// Runtime for "Perlito" Perl5-in-Javascript3' . chr(10) . '//' . chr(10) . '// AUTHORS' . chr(10) . '//' . chr(10) . '// Flavio Soibelmann Glock  fglock@gmail.com' . chr(10) . '//' . chr(10) . '// COPYRIGHT' . chr(10) . '//' . chr(10) . '// Copyright 2009, 2010, 2011, 2012 by Flavio Soibelmann Glock and others.' . chr(10) . '//' . chr(10) . '// This program is free software; you can redistribute it and/or modify it' . chr(10) . '// under the same terms as Perl itself.' . chr(10) . '//' . chr(10) . '// See http://www.perl.com/perl/misc/Artistic.html' . chr(10) . chr(10) . 'var isNode = typeof require != "undefined";' . chr(10) . chr(10) . 'if (typeof p5pkg !== "object") {' . chr(10) . '    p5pkg = {};' . chr(10) . '    p5LOCAL = [];' . chr(10) . chr(10) . '    var universal = function () {};' . chr(10) . '    p5pkg.UNIVERSAL = new universal();' . chr(10) . '    p5pkg.UNIVERSAL._ref_ = "UNIVERSAL";' . chr(10) . '    p5pkg.UNIVERSAL.isa = function (List__) {' . chr(10) . '        // TODO - use @ISA' . chr(10) . '        var o = List__[0];' . chr(10) . '        var s = p5str(List__[1]);' . chr(10) . '        if (o instanceof p5Scalar) {' . chr(10) . '            o = o.FETCH();' . chr(10) . '        }' . chr(10) . '        return o._class_._ref_ == s' . chr(10) . '    };' . chr(10) . '    p5pkg.UNIVERSAL.can = function (List__) {' . chr(10) . '        var o = List__[0];' . chr(10) . '        var s = p5str(List__[1]);' . chr(10) . '        if (o instanceof p5Scalar) {' . chr(10) . '            o = o.FETCH();' . chr(10) . '        }' . chr(10) . '        if ( s.indexOf("::") == -1 ) {' . chr(10) . '            return p5method_lookup(s, o._class_._ref_, {})' . chr(10) . '        }' . chr(10) . '        var c = s.split("::");' . chr(10) . '        s = c.pop(); ' . chr(10) . '        return p5method_lookup(s, c.join("::"), {});' . chr(10) . '    };' . chr(10) . '    p5pkg.UNIVERSAL.DOES = p5pkg.UNIVERSAL.can;' . chr(10) . chr(10) . '    var core = function () {};' . chr(10) . '    p5pkg["CORE"] = new core();' . chr(10) . '    p5pkg["CORE"]._ref_ = "CORE";' . chr(10) . chr(10) . '    var core_global = function () {};' . chr(10) . '    core_global.prototype = p5pkg.CORE;' . chr(10) . '    p5pkg["CORE::GLOBAL"] = new core_global();' . chr(10) . '    p5pkg["CORE::GLOBAL"]._ref_ = "CORE::GLOBAL";' . chr(10) . chr(10) . '    p5_error = function (type, v) {' . chr(10) . '        this.type = type;' . chr(10) . '        this.v = this.message = v;' . chr(10) . '        this.toString = function(){' . chr(10) . '            if (this.type == ' . chr(39) . 'break' . chr(39) . ') {' . chr(10) . '                return ' . chr(39) . 'Can' . chr(92) . chr(39) . 't "break" outside a given block' . chr(39) . chr(10) . '            }' . chr(10) . '            if (this.type == ' . chr(39) . 'next' . chr(39) . ' || this.type == ' . chr(39) . 'last' . chr(39) . ' || this.type == ' . chr(39) . 'redo' . chr(39) . ') {' . chr(10) . '                if (this.v == "") { return ' . chr(39) . 'Can' . chr(92) . chr(39) . 't "' . chr(39) . ' + this.type + ' . chr(39) . '" outside a loop block' . chr(39) . ' }' . chr(10) . '                return ' . chr(39) . 'Label not found for "' . chr(39) . ' + this.type + ' . chr(39) . ' ' . chr(39) . ' + this.v + ' . chr(39) . '"' . chr(39) . ';' . chr(10) . '            }' . chr(10) . '            return this.v;' . chr(10) . '        };' . chr(10) . '    };' . chr(10) . '    p5_error.prototype = Error.prototype;' . chr(10) . '}' . chr(10) . chr(10) . 'function p5make_package(pkg_name) {' . chr(10) . '    if (!p5pkg.hasOwnProperty(pkg_name)) {' . chr(10) . '        var tmp = function () {};' . chr(10) . '        tmp.prototype = p5pkg["CORE::GLOBAL"];' . chr(10) . '        p5pkg[pkg_name] = new tmp();' . chr(10) . '        p5pkg[pkg_name]._ref_ = pkg_name;' . chr(10) . '        p5pkg[pkg_name]._class_ = p5pkg[pkg_name];  // XXX memory leak' . chr(10) . chr(10) . '        // TODO - add the other package global variables' . chr(10) . '        p5pkg[pkg_name]["List_ISA"] = new p5Array([]);' . chr(10) . '        p5pkg[pkg_name]["v_a"] = new p5Scalar(null);' . chr(10) . '        p5pkg[pkg_name]["v_b"] = new p5Scalar(null);' . chr(10) . '        p5pkg[pkg_name]["v__"] = new p5Scalar(null);' . chr(10) . '        p5pkg[pkg_name]["v_AUTOLOAD"] = new p5Scalar(null);' . chr(10) . '    }' . chr(10) . '    return p5pkg[pkg_name];' . chr(10) . '}' . chr(10) . chr(10) . 'function p5code_lookup_by_name(package_name, sub_name) {' . chr(10) . '    // sub_name can have an optional namespace' . chr(10) . '    var parts = sub_name.split(/::/);' . chr(10) . '    if (parts.length > 1) {' . chr(10) . '        sub_name = parts.pop();' . chr(10) . '        package_name = parts.join("::");' . chr(10) . '    }' . chr(10) . '    if (p5pkg.hasOwnProperty(package_name)) {' . chr(10) . '        var c = p5pkg[package_name];' . chr(10) . '        if ( c.hasOwnProperty(sub_name) ) {' . chr(10) . '            return c[sub_name]' . chr(10) . '        }' . chr(10) . '    }' . chr(10) . '    return null;' . chr(10) . '}' . chr(10) . chr(10) . 'function p5get_class_for_method(method, class_name, seen) {' . chr(10) . '    // default mro' . chr(10) . '    // TODO - cache the methods that were already looked up' . chr(10) . '    if ( p5pkg[class_name].hasOwnProperty(method) ) {' . chr(10) . '        return class_name' . chr(10) . '    }' . chr(10) . '    var isa = p5pkg[class_name].List_ISA;' . chr(10) . '    for (var i = 0; i < isa.length; i++) {' . chr(10) . '        if (!seen[isa[i]]) {' . chr(10) . '            var m = p5get_class_for_method(method, isa[i], seen);' . chr(10) . '            if (m) {' . chr(10) . '                return m ' . chr(10) . '            }' . chr(10) . '            seen[isa[i]]++;' . chr(10) . '        }' . chr(10) . '    }' . chr(10) . '}' . chr(10) . chr(10) . 'function p5method_lookup(method, class_name, seen) {' . chr(10) . '    var c = p5get_class_for_method(method, class_name, seen);' . chr(10) . '    if (c) {' . chr(10) . '        return p5pkg[c][method]' . chr(10) . '    }' . chr(10) . '    if ( p5pkg.UNIVERSAL.hasOwnProperty(method) ) {' . chr(10) . '        return p5pkg.UNIVERSAL[method]' . chr(10) . '    }' . chr(10) . '}' . chr(10) . chr(10) . 'function p5call(invocant, method, list, p5want) {' . chr(10) . '    list.unshift(invocant);' . chr(10) . chr(10) . '    if (invocant instanceof p5Scalar) {' . chr(10) . '        // TODO - move p5call() to p5Scalar method' . chr(10) . '        invocant = invocant.FETCH();' . chr(10) . '    }' . chr(10) . chr(10) . '    if ( invocant.hasOwnProperty("_class_") ) {' . chr(10) . chr(10) . '        if ( invocant._class_.hasOwnProperty(method) ) {' . chr(10) . '            return invocant._class_[method](list, p5want)' . chr(10) . '        }' . chr(10) . '        var m = p5method_lookup(method, invocant._class_._ref_, {});' . chr(10) . '        if (m) {' . chr(10) . '            return m(list, p5want)' . chr(10) . '        }' . chr(10) . chr(10) . '        // method can have an optional namespace' . chr(10) . '        var pkg_name = method.split(/::/);' . chr(10) . '        if (pkg_name.length > 1) {' . chr(10) . '            var name = pkg_name.pop();' . chr(10) . '            pkg_name = pkg_name.join("::");' . chr(10) . '            m = p5method_lookup(name, pkg_name, {});' . chr(10) . '            if (m) {' . chr(10) . '                return m(list, p5want)' . chr(10) . '            }' . chr(10) . '            p5pkg.CORE.die(["method not found: ", name, " in class ", pkg_name]);' . chr(10) . '        }' . chr(10) . chr(10) . '        pkg_name = p5get_class_for_method(' . chr(39) . 'AUTOLOAD' . chr(39) . ', invocant._class_._ref_, {}) || p5get_class_for_method(' . chr(39) . 'AUTOLOAD' . chr(39) . ', "UNIVERSAL", {});' . chr(10) . '        if (pkg_name) {' . chr(10) . '            p5pkg[pkg_name]["v_AUTOLOAD"] = invocant._class_._ref_ + "::" + method;' . chr(10) . '            return p5pkg[pkg_name]["AUTOLOAD"](list, p5want);' . chr(10) . '        }' . chr(10) . chr(10) . '        p5pkg.CORE.die(["method not found: ", method, " in class ", invocant._class_._ref_]);' . chr(10) . chr(10) . '    }' . chr(10) . chr(10) . '    // the invocant doesn' . chr(39) . 't have a class' . chr(10) . chr(10) . '    if (typeof invocant === "string") {' . chr(10) . '        var aclass = p5make_package(invocant);' . chr(10) . '        return p5call(aclass, method, list, p5want);' . chr(10) . '    }' . chr(10) . chr(10) . '    p5pkg.CORE.die(["Can' . chr(39) . 't call method ", method, " on unblessed reference"]);' . chr(10) . chr(10) . '}' . chr(10) . chr(10) . 'function p5call_sub(namespace, name, list, p5want) {' . chr(10) . '    if(p5pkg[namespace].hasOwnProperty(name)) {' . chr(10) . '        return p5pkg[namespace][name](list, p5want)' . chr(10) . '    }' . chr(10) . '    if(p5pkg[namespace].hasOwnProperty("AUTOLOAD")) {' . chr(10) . '        p5pkg[namespace]["v_AUTOLOAD"] = namespace + "::" + name;' . chr(10) . '        return p5pkg[namespace]["AUTOLOAD"](list, p5want)' . chr(10) . '    }' . chr(10) . '    p5pkg.CORE.die(["Undefined subroutine &" + namespace + "::" + name]);' . chr(10) . '}' . chr(10) . chr(10) . 'function p5scalar_deref(v) {' . chr(10) . '    if (typeof v === "string") {' . chr(10) . '        var pkg_name = v.split(/::/);' . chr(10) . '        if (pkg_name.length > 1) {' . chr(10) . '            v = pkg_name.pop();' . chr(10) . '            pkg_name = pkg_name.join("::");' . chr(10) . '        }' . chr(10) . '        else {' . chr(10) . '            pkg_name = p5pkg["Perlito5"].v_PKG_NAME;' . chr(10) . '        }' . chr(10) . '        var c = v.charCodeAt(0);' . chr(10) . '        if (c < 27) {' . chr(10) . '            v = String.fromCharCode(c + 64) + v.substr(1);' . chr(10) . '            pkg_name = ' . chr(39) . 'main' . chr(39) . ';' . chr(10) . '        }' . chr(10) . '        return p5pkg[pkg_name]["v_"+v];' . chr(10) . '    }' . chr(10) . '    return v._scalar_;' . chr(10) . '}' . chr(10) . chr(10) . 'function p5scalar_deref_set(v, n) {' . chr(10) . '    if (typeof v === "string") {' . chr(10) . '        var pkg_name = v.split(/::/);' . chr(10) . '        if (pkg_name.length > 1) {' . chr(10) . '            v = pkg_name.pop();' . chr(10) . '            pkg_name = pkg_name.join("::");' . chr(10) . '        }' . chr(10) . '        else {' . chr(10) . '            pkg_name = p5pkg["Perlito5"].v_PKG_NAME;' . chr(10) . '        }' . chr(10) . '        var c = v.charCodeAt(0);' . chr(10) . '        if (c < 27) {' . chr(10) . '            v = String.fromCharCode(c + 64) + v.substr(1);' . chr(10) . '            pkg_name = ' . chr(39) . 'main' . chr(39) . ';' . chr(10) . '        }' . chr(10) . '        p5pkg[pkg_name]["v_"+v] = n;' . chr(10) . '        return p5pkg[pkg_name]["v_"+v];' . chr(10) . '    }' . chr(10) . '    v._scalar_ = n;' . chr(10) . '    return v._scalar_;' . chr(10) . '}' . chr(10) . chr(10) . 'p5make_package("main");' . chr(10) . 'p5make_package("Perlito5");' . chr(10) . 'p5pkg["Perlito5"].v_PKG_NAME = "main";' . chr(10) . 'p5pkg["main"]["v_@"]       = new p5Scalar("");  // $@' . chr(10) . 'p5pkg["main"]["v_|"]       = new p5Scalar(0);   // $|' . chr(10) . 'p5pkg["main"]["List_#"]    = new p5Array([]);   // @#' . chr(10) . 'p5scalar_deref_set(String.fromCharCode(15), isNode ? "node.js" : "javascript2");  // $^O' . chr(10) . 'p5pkg["main"]["List_INC"]  = new p5Array([]);' . chr(10) . 'p5pkg["main"]["Hash_INC"]  = new p5Hash({});' . chr(10) . 'p5pkg["main"]["List_ARGV"] = new p5Array([]);' . chr(10) . 'p5pkg["main"]["Hash_ENV"]  = new p5Hash({});' . chr(10) . 'if (isNode) {' . chr(10) . '    p5pkg["main"]["List_ARGV"] = new p5Array(process.argv.splice(2));' . chr(10) . '    p5pkg["main"]["Hash_ENV"]  = new p5Hash(process.env);' . chr(10) . '    p5pkg["main"]["v_$"]       = new p5Scalar(process.pid);' . chr(10) . '} else if (typeof arguments === "object") {' . chr(10) . '    p5pkg["main"]["List_ARGV"] = new p5Array(arguments);' . chr(10) . '}' . chr(10) . chr(10) . 'p5make_package("Perlito5::IO");' . chr(10) . 'p5make_package("Perlito5::Runtime");' . chr(10) . 'p5make_package("Perlito5::Grammar");' . chr(10) . chr(10) . 'function p5typeglob_set(pkg_name, sub_name, func) {' . chr(10) . '    p5make_package(pkg_name);' . chr(10) . '    p5pkg[pkg_name][sub_name] = func;' . chr(10) . '}' . chr(10) . chr(10) . 'function p5set_glob(name, data) {' . chr(10) . '    if ( name.indexOf("::") == -1 ) {' . chr(10) . '        p5pkg[ p5pkg["Perlito5"].v_PKG_NAME.FETCH() ][name] = data;' . chr(10) . '        return data;' . chr(10) . '    }' . chr(10) . '    var c = name.split("::");' . chr(10) . '    s = c.pop(); ' . chr(10) . '    var pkg = c.join("::");' . chr(10) . '    p5make_package(pkg);' . chr(10) . '    p5pkg[pkg][s] = data;' . chr(10) . '    return data;' . chr(10) . '}' . chr(10) . chr(10) . 'var sigils = { ' . chr(39) . '@' . chr(39) . ' : ' . chr(39) . 'List_' . chr(39) . ', ' . chr(39) . '%' . chr(39) . ' : ' . chr(39) . 'Hash_' . chr(39) . ', ' . chr(39) . '$' . chr(39) . ' : ' . chr(39) . 'v_' . chr(39) . ' };' . chr(10) . chr(10) . 'function p5set_local(namespace, name, sigil) {' . chr(10) . '    var vname = sigils[sigil] + name;' . chr(10) . '    p5LOCAL.push([namespace, vname, namespace[vname]]);' . chr(10) . chr(10) . '    if (sigil == ' . chr(39) . '$' . chr(39) . ') {' . chr(10) . '        namespace[vname] = new p5Scalar(null);' . chr(10) . '    }' . chr(10) . '    else if (sigil == ' . chr(39) . '@' . chr(39) . ') {' . chr(10) . '        namespace[vname] = new p5Array([]);' . chr(10) . '    }' . chr(10) . '    else if (sigil == ' . chr(39) . '%' . chr(39) . ') {' . chr(10) . '        namespace[vname] = new p5Hash({});' . chr(10) . '    }' . chr(10) . '    return namespace[vname];' . chr(10) . '}' . chr(10) . chr(10) . 'function p5cleanup_local(idx, value) {' . chr(10) . '    while (p5LOCAL.length > idx) {' . chr(10) . '        l = p5LOCAL.pop();' . chr(10) . '        l[0][l[1]] = l[2];' . chr(10) . '    }' . chr(10) . '    return value;' . chr(10) . '}' . chr(10) . chr(10) . 'function p5global(sigil, namespace, name) {' . chr(10) . '    // TODO - autovivify namespace' . chr(10) . '    var vname = sigils[sigil] + name;' . chr(10) . '    var v = p5pkg[namespace][vname];' . chr(10) . '    if (v != null) {' . chr(10) . '        return v;' . chr(10) . '    }' . chr(10) . '    if (sigil == ' . chr(39) . '$' . chr(39) . ') {' . chr(10) . '        p5pkg[namespace][vname] = new p5Scalar(null);' . chr(10) . '    }' . chr(10) . '    else if (sigil == ' . chr(39) . '@' . chr(39) . ') {' . chr(10) . '        p5pkg[namespace][vname] = new p5Array([]);' . chr(10) . '    }' . chr(10) . '    else if (sigil == ' . chr(39) . '%' . chr(39) . ') {' . chr(10) . '        p5pkg[namespace][vname] = new p5Hash({});' . chr(10) . '    }' . chr(10) . '    return p5pkg[namespace][vname];' . chr(10) . '}' . chr(10) . chr(10) . 'function p5HashRef(o) {' . chr(10) . '    this._href_ = o;' . chr(10) . '    this._ref_ = "HASH";' . chr(10) . '    this.p5bool = function() { return 1 };' . chr(10) . '    this.p5string = function() {' . chr(10) . '        return "HASH(0x0000)";  // TODO' . chr(10) . '    };' . chr(10) . '    this.hderef = function() {' . chr(10) . '        return this._href_;' . chr(10) . '    };' . chr(10) . '    this.hset = function(i, v) {' . chr(10) . '        return this._href_.hset(i, v);' . chr(10) . '    };' . chr(10) . '    this.hget = function(i, autoviv) {' . chr(10) . '        return this._href_.hget(i, autoviv);' . chr(10) . '    }' . chr(10) . '}' . chr(10) . chr(10) . 'function p5ArrayRef(o) {' . chr(10) . '    this._aref_ = o;' . chr(10) . '    this._ref_ = "ARRAY";' . chr(10) . '    this.p5bool = function() { return 1 };' . chr(10) . '    this.p5string = function() {' . chr(10) . '        return "ARRAY(0x0000)";  // TODO' . chr(10) . '    };' . chr(10) . '    this.aderef = function() {' . chr(10) . '        return this._aref_;' . chr(10) . '    };' . chr(10) . '    this.aset = function(i, v) {' . chr(10) . '        return this._aref_.aset(i, v);' . chr(10) . '    }' . chr(10) . '    this.aget = function(i, autoviv) {' . chr(10) . '        return this._aref_.aget(i, autoviv);' . chr(10) . '    }' . chr(10) . '}' . chr(10) . chr(10) . 'function p5ScalarRef(o) {' . chr(10) . '    this._scalar_ = o;' . chr(10) . '    this._ref_ = "SCALAR";' . chr(10) . '    this.p5bool = function() { return 1 };' . chr(10) . '    this.p5string = function() {' . chr(10) . '        return "SCALAR(0x0000)";  // TODO' . chr(10) . '    };' . chr(10) . '    this.sderef = function() {' . chr(10) . '        return this._scalar_;' . chr(10) . '    };' . chr(10) . '}' . chr(10) . chr(10) . 'function p5GlobRef(o) {' . chr(10) . '    this._scalar_ = o;' . chr(10) . '    this._ref_ = "GLOB";' . chr(10) . '    this.p5bool = function() { return 1 };' . chr(10) . '    this.p5string = function() {' . chr(10) . '        return "GLOB(0x0000)";  // TODO' . chr(10) . '    };' . chr(10) . '}' . chr(10) . chr(10) . 'function p5Array(o) {' . chr(10) . '    // TODO - array slice' . chr(10) . '    this._array_ = o;' . chr(10) . '    this._ref_ = "";' . chr(10) . '    this.p5bool = function() {' . chr(10) . '        return this._array_.length != 0' . chr(10) . '    };' . chr(10) . '    this.p5string = function() {' . chr(10) . '        return ' . chr(39) . chr(39) . ' + this._array_.length;' . chr(10) . '    };' . chr(10) . '    this.p5num = function() {' . chr(10) . '        return this._array_.length;' . chr(10) . '    };' . chr(10) . '    this.aset = function(i, v) {' . chr(10) . '        if (i < 0) {' . chr(10) . '            i = this._array_.length + i;' . chr(10) . '        }' . chr(10) . '        if (this._array_[i] instanceof p5Scalar) {' . chr(10) . '            this._array_[i].assign(v);' . chr(10) . '        }' . chr(10) . '        else {' . chr(10) . '            if (v instanceof p5Scalar) {' . chr(10) . '                this._array_[i] = v.FETCH();' . chr(10) . '            }' . chr(10) . '            else {' . chr(10) . '                this._array_[i] = v;' . chr(10) . '            }' . chr(10) . '        }' . chr(10) . '        return v;' . chr(10) . '    };' . chr(10) . '    this.aget = function(i, autoviv) {' . chr(10) . '        if (i < 0) {' . chr(10) . '            i = this._array_.length + i;' . chr(10) . '        }' . chr(10) . '        if (autoviv) {' . chr(10) . '            if (autoviv == ' . chr(39) . 'lvalue' . chr(39) . ') {' . chr(10) . '                if (this._array_.length < i) {' . chr(10) . '                    // don' . chr(39) . 't vivify yet; create a proxy object' . chr(10) . '                    return new p5ArrayProxy(this, i);' . chr(10) . '                }' . chr(10) . '                if (!(this._array_[i] instanceof p5Scalar)) {' . chr(10) . '                    this._array_[i] = new p5Scalar(this._array_[i]);' . chr(10) . '                }' . chr(10) . '            }' . chr(10) . '            else if (autoviv == ' . chr(39) . 'array' . chr(39) . ') {' . chr(10) . '                if (!(this._array_[i] instanceof p5ArrayRef) &&' . chr(10) . '                    !(this._array_[i] instanceof p5Scalar))' . chr(10) . '                {' . chr(10) . '                    this._array_[i] = new p5ArrayRef(new p5Array([]));' . chr(10) . '                }' . chr(10) . '            }' . chr(10) . '            else if (autoviv == ' . chr(39) . 'hash' . chr(39) . ') {' . chr(10) . '                if (!(this._array_[i] instanceof p5HashRef) &&' . chr(10) . '                    !(this._array_[i] instanceof p5Scalar))' . chr(10) . '                {' . chr(10) . '                    this._array_[i] = new p5HashRef(new p5Hash({}));' . chr(10) . '                }' . chr(10) . '            }' . chr(10) . '        }' . chr(10) . '        return this._array_[i];' . chr(10) . '    };' . chr(10) . '    this.get_values = function(o) {' . chr(10) . '        // add values to the param (a native js list)' . chr(10) . '        for(var i = 0; i < this._array_.length; i++) {' . chr(10) . '            o.push(this._array_[i]);' . chr(10) . '        }' . chr(10) . '        return o;' . chr(10) . '    };' . chr(10) . '    this.get_lvalues = function(o) {' . chr(10) . '        // add lvalues to the param (a native js list)' . chr(10) . '        for(var i = 0; i < this._array_.length; i++) {' . chr(10) . '            o.push(this._array_[i] instanceof p5Scalar ? this._array_[i] : this.aget(i, "lvalue"));' . chr(10) . '        }' . chr(10) . '        return o;' . chr(10) . '    };' . chr(10) . '    this.assign = function(a) {' . chr(10) . '        if (a instanceof Array) {' . chr(10) . '            // TODO - cleanup, this shouldn' . chr(39) . 't happen' . chr(10) . '            this._array_ = a;' . chr(10) . '        }' . chr(10) . '        else {' . chr(10) . '            this._array_ = a._array_;' . chr(10) . '        }' . chr(10) . '        return this;' . chr(10) . '    };' . chr(10) . chr(10) . '    // operations that can be tie()' . chr(10) . '    this.FETCHSIZE = function() {' . chr(10) . '        return this._array_.length;' . chr(10) . '    };' . chr(10) . '    this.PUSH = function(v) {' . chr(10) . '        for(var i = 0; i < v._array_.length; i++) {' . chr(10) . '            this._array_.push(v._array_[i] instanceof p5Scalar ? v._array_[i].FETCH() :  v._array_[i]);' . chr(10) . '        }' . chr(10) . '        return this._array_.length;' . chr(10) . '    };' . chr(10) . '    this.UNSHIFT = function(v) {' . chr(10) . '        for(var i = v._array_.length-1; i >= 0; i--) {' . chr(10) . '            this._array_.unshift(v._array_[i] instanceof p5Scalar ? v._array_[i].FETCH() :  v._array_[i]);' . chr(10) . '        }' . chr(10) . '        return this._array_.length;' . chr(10) . '    };' . chr(10) . '    this.POP = function() {' . chr(10) . '        if (this._array_.length == null) {' . chr(10) . '            return null;' . chr(10) . '        }' . chr(10) . '        return this._array_.pop();' . chr(10) . '    };' . chr(10) . '    this.SHIFT = function(v) {' . chr(10) . '        if (this._array_.length == null) {' . chr(10) . '            return null;' . chr(10) . '        }' . chr(10) . '        return this._array_.shift();' . chr(10) . '    };' . chr(10) . '}' . chr(10) . chr(10) . 'function p5Hash(o) {' . chr(10) . '    // TODO - hash slice' . chr(10) . '    this._hash_ = o;' . chr(10) . '    this._ref_ = "";' . chr(10) . '    this.p5bool = function() {' . chr(10) . '        o = this._hash_;' . chr(10) . '        for (var i in o) {' . chr(10) . '            return true;' . chr(10) . '        }' . chr(10) . '        return false;' . chr(10) . '    };' . chr(10) . '    this.p5string = function() {' . chr(10) . '        return ' . chr(39) . chr(39) . ' + this.p5num() + ' . chr(39) . '/8' . chr(39) . ';' . chr(10) . '    };' . chr(10) . '    this.p5num = function() {' . chr(10) . '        var out = 0;' . chr(10) . '        for (var i in this._hash_) {' . chr(10) . '            out++;' . chr(10) . '        }' . chr(10) . '        return out;' . chr(10) . '    };' . chr(10) . '    this.exists = function(i) {' . chr(10) . '        return this._hash_.hasOwnProperty(i);' . chr(10) . '    };' . chr(10) . '    this.hset = function(i, v) {' . chr(10) . '        if (this._hash_[i] instanceof p5Scalar) {' . chr(10) . '            this._hash_[i].assign(v);' . chr(10) . '        }' . chr(10) . '        else {' . chr(10) . '            if (v instanceof p5Scalar) {' . chr(10) . '                this._hash_[i] = v.FETCH();' . chr(10) . '            }' . chr(10) . '            else {' . chr(10) . '                this._hash_[i] = v;' . chr(10) . '            }' . chr(10) . '        }' . chr(10) . '        return v;' . chr(10) . '    };' . chr(10) . '    this.hget = function(i, autoviv) {' . chr(10) . '        if (autoviv) {' . chr(10) . '            if (autoviv == ' . chr(39) . 'lvalue' . chr(39) . ') {' . chr(10) . '                if (! this._hash_.hasOwnProperty(i)) {' . chr(10) . '                    // don' . chr(39) . 't autovivify yet; create a proxy object' . chr(10) . '                    return new p5HashProxy(this, i);' . chr(10) . '                }' . chr(10) . '                if (!(this._hash_[i] instanceof p5Scalar)) {' . chr(10) . '                    this._hash_[i] = new p5Scalar(this._hash_[i]);' . chr(10) . '                }' . chr(10) . '            }' . chr(10) . '            else if (autoviv == ' . chr(39) . 'array' . chr(39) . ') {' . chr(10) . '                if (!(this._hash_[i] instanceof p5ArrayRef) &&' . chr(10) . '                    !(this._hash_[i] instanceof p5Scalar))' . chr(10) . '                {' . chr(10) . '                    this._hash_[i] = new p5ArrayRef(new p5Array([]));' . chr(10) . '                }' . chr(10) . '            }' . chr(10) . '            else if (autoviv == ' . chr(39) . 'hash' . chr(39) . ') {' . chr(10) . '                if (!(this._hash_[i] instanceof p5HashRef) &&' . chr(10) . '                    !(this._hash_[i] instanceof p5Scalar))' . chr(10) . '                {' . chr(10) . '                    this._hash_[i] = new p5HashRef(new p5Hash({}));' . chr(10) . '                }' . chr(10) . '            }' . chr(10) . '        }' . chr(10) . '        return this._hash_[i];' . chr(10) . '    };' . chr(10) . '    this.get_values = function(o) {' . chr(10) . '        // add a native list of values to the param' . chr(10) . '        for (var i in this._hash_) {' . chr(10) . '            o.push(i);' . chr(10) . '            o.push(this._hash_[i]);' . chr(10) . '        }' . chr(10) . '        return o;' . chr(10) . '    };' . chr(10) . '    this.get_lvalues = function(o) {' . chr(10) . '        // add a native list of lvalues to the param' . chr(10) . '        for (var i in this._hash_) {' . chr(10) . '            o.push(i);' . chr(10) . '            o.push(this._hash_[i] instanceof p5Scalar ? this._hash_[i] : this.hget(i, "lvalue"));' . chr(10) . '        }' . chr(10) . '        return o;' . chr(10) . '    };' . chr(10) . '    this.assign = function(h) {' . chr(10) . '        if (h instanceof p5Hash) {' . chr(10) . '            this._hash_ = h._hash_;' . chr(10) . '        }' . chr(10) . '        else {' . chr(10) . '            // TODO - cleanup, this shouldn' . chr(39) . 't happen' . chr(10) . '            this._hash_ = h;' . chr(10) . '        }' . chr(10) . '        return this;' . chr(10) . '    }' . chr(10) . '}' . chr(10) . chr(10) . 'function p5Scalar(o) {' . chr(10) . '    this._v_ = o;' . chr(10) . '    this._ref_ = "";' . chr(10) . chr(10) . '    // be a value' . chr(10) . '    this.p5bool = function() {' . chr(10) . '        return p5bool(this._v_);' . chr(10) . '    };' . chr(10) . '    this.p5string = function() {' . chr(10) . '        return p5str(this._v_);' . chr(10) . '    };' . chr(10) . '    this.p5num = function() {' . chr(10) . '        return p5num(this._v_);' . chr(10) . '    };' . chr(10) . '    this.p5code = function() {' . chr(10) . '        return p5code(this._v_);' . chr(10) . '    };' . chr(10) . '    this.p5incr = function() {' . chr(10) . '        this._v_ = p5incr(this._v_);' . chr(10) . '        return this._v_;' . chr(10) . '    };' . chr(10) . '    this.p5postincr = function() {' . chr(10) . '        var v = this._v_;' . chr(10) . '        this._v_ = p5incr(this._v_);' . chr(10) . '        return v;' . chr(10) . '    };' . chr(10) . '    this.p5decr = function() {' . chr(10) . '        this._v_ = p5decr(this._v_);' . chr(10) . '        return this._v_;' . chr(10) . '    };' . chr(10) . '    this.p5postdecr = function() {' . chr(10) . '        var v = this._v_;' . chr(10) . '        this._v_ = p5decr(this._v_);' . chr(10) . '        return v;' . chr(10) . '    };' . chr(10) . chr(10) . '    // be a scalar ref' . chr(10) . '    this.sderef = function(i) {' . chr(10) . '        // TODO - autovivify scalar (with proxy object?)' . chr(10) . '        return this._v_.sderef();' . chr(10) . '    };' . chr(10) . chr(10) . '    // be an array ref' . chr(10) . '    this.aderef = function() {' . chr(10) . '        // TODO - autovivify array (with proxy object?)' . chr(10) . '        return this._v_.aderef();' . chr(10) . '    };' . chr(10) . '    this.aget = function(i, autoviv) {' . chr(10) . '        // TODO - autovivify array (with proxy object?)' . chr(10) . '        if (this._v_ == null) {' . chr(10) . '            this._v_ = new p5ArrayRef(new p5Array([]));' . chr(10) . '        }' . chr(10) . '        return this._v_.aget(i, autoviv);' . chr(10) . '    };' . chr(10) . '    this.aset = function(i, v) {' . chr(10) . '        if (this._v_ == null) {' . chr(10) . '            this._v_ = new p5ArrayRef(new p5Array([]));' . chr(10) . '        }' . chr(10) . '        return this._v_.aset(i, v);' . chr(10) . '    };' . chr(10) . chr(10) . '    // be a hash ref' . chr(10) . '    this.hderef = function() {' . chr(10) . '        // TODO - autovivify hash (with proxy object?)' . chr(10) . '        if (this._v_ == null) {' . chr(10) . '            this._v_ = new p5HashRef(new p5Hash([]));' . chr(10) . '        }' . chr(10) . '        return this._v_.hderef();' . chr(10) . '    };' . chr(10) . '    this.hget = function(i, autoviv) {' . chr(10) . '        // TODO - autovivify hash (with proxy object?)' . chr(10) . '        if (this._v_ == null) {' . chr(10) . '            this._v_ = new p5HashRef(new p5Hash([]));' . chr(10) . '        }' . chr(10) . '        return this._v_.hget(i, autoviv);' . chr(10) . '    }' . chr(10) . '    this.hset = function(i, v) {' . chr(10) . '        if (this._v_ == null) {' . chr(10) . '            this._v_ = new p5HashRef(new p5Hash([]));' . chr(10) . '        }' . chr(10) . '        return this._v_.hset(i, v);' . chr(10) . '    }' . chr(10) . chr(10) . '    // be a container' . chr(10) . '    this.get_values = function(o) {' . chr(10) . '        // add a native list of values to the param' . chr(10) . '        o.push(this);' . chr(10) . '        return o;' . chr(10) . '    };' . chr(10) . '    this.get_lvalues = function(o) {' . chr(10) . '        // add a native list of lvalues to the param' . chr(10) . '        o.push(this);' . chr(10) . '        return o;' . chr(10) . '    };' . chr(10) . '    this.assign = function(v) {' . chr(10) . '        if (v instanceof p5Scalar) {' . chr(10) . '            this._v_ = v.FETCH();' . chr(10) . '        }' . chr(10) . '        else {' . chr(10) . '            this._v_ = v;' . chr(10) . '        }' . chr(10) . '        return this;' . chr(10) . '    };' . chr(10) . chr(10) . '    // operations that can be tie()' . chr(10) . '    this.FETCH = function() {' . chr(10) . '        // not an lvalue' . chr(10) . '        return this._v_;' . chr(10) . '    };' . chr(10) . '}' . chr(10) . chr(10) . chr(10) . 'function p5HashProxy(h, k) {' . chr(10) . '    this._hashobj_ = h;' . chr(10) . '    this._key_ = k;' . chr(10) . '    this._v_ = null;' . chr(10) . '    this.assign = function(v) {' . chr(10) . '        // write-through; alternately, use read-through' . chr(10) . '        if (v instanceof p5Scalar) {' . chr(10) . '            this._v_ = v.FETCH();' . chr(10) . '        }' . chr(10) . '        else {' . chr(10) . '            this._v_ = v;' . chr(10) . '        }' . chr(10) . '        return this._hashobj_.hset(this._key_, this._v_);' . chr(10) . '    }' . chr(10) . '}' . chr(10) . 'p5HashProxy.prototype = new p5Scalar();' . chr(10) . chr(10) . chr(10) . 'function p5ArrayProxy(a, k) {' . chr(10) . '    this._arrayobj_ = a;' . chr(10) . '    this._key_ = k;' . chr(10) . '    this._v_ = null;' . chr(10) . '    this.assign = function(v) {' . chr(10) . '        // write-through; alternately, use read-through' . chr(10) . '        if (v instanceof p5Scalar) {' . chr(10) . '            this._v_ = v.FETCH();' . chr(10) . '        }' . chr(10) . '        else {' . chr(10) . '            this._v_ = v;' . chr(10) . '        }' . chr(10) . '        return this._arrayobj_.aset(this._key_, this._v_);' . chr(10) . '    }' . chr(10) . '}' . chr(10) . 'p5ArrayProxy.prototype = new p5Scalar();' . chr(10) . chr(10) . chr(10) . 'p5param_list = function() {' . chr(10) . '    var res = [];' . chr(10) . '    for (i = 0; i < arguments.length; i++) {' . chr(10) . '        if (arguments[i] == null) {' . chr(10) . '            res.push(null)' . chr(10) . '        }' . chr(10) . '        else if (arguments[i].hasOwnProperty("get_lvalues")) {' . chr(10) . '            // container' . chr(10) . '            arguments[i].get_lvalues(res);' . chr(10) . '        }' . chr(10) . '        else if (arguments[i] instanceof Array) {' . chr(10) . '            // js Array -- possibly generated by p5context()' . chr(10) . '            // maybe too late to get lvalues -- needs more testing' . chr(10) . '            // this doesn' . chr(39) . 't handle nested Array' . chr(10) . '            o = arguments[i];' . chr(10) . '            for (j = 0; j < o.length; j++) {' . chr(10) . '                res.push(o[j]);' . chr(10) . '            }' . chr(10) . '        }' . chr(10) . '        else {' . chr(10) . '            // non-container' . chr(10) . '            res.push(arguments[i]);' . chr(10) . '        }' . chr(10) . '    }' . chr(10) . '    return res;' . chr(10) . '};' . chr(10) . chr(10) . 'p5list_to_a = function() {' . chr(10) . '    var res = [];' . chr(10) . '    for (i = 0; i < arguments.length; i++) {' . chr(10) . '        if (arguments[i] == null) {' . chr(10) . '            res.push(null)' . chr(10) . '        }' . chr(10) . '        else if (arguments[i].hasOwnProperty("get_values")) {' . chr(10) . '            // container' . chr(10) . '            arguments[i].get_values(res);' . chr(10) . '        }' . chr(10) . '        else if (arguments[i] instanceof Array) {' . chr(10) . '            // js Array -- possibly generated by p5context()' . chr(10) . '            o = arguments[i];' . chr(10) . '            for (j = 0; j < o.length; j++) {' . chr(10) . '                res.push(o[j]);' . chr(10) . '            }' . chr(10) . '        }' . chr(10) . '        else {' . chr(10) . '            // non-container' . chr(10) . '            res.push(arguments[i]);' . chr(10) . '        }' . chr(10) . '    }' . chr(10) . '    return res;' . chr(10) . '};' . chr(10) . chr(10) . 'p5a_to_h = function(a) {' . chr(10) . '    var res = {};' . chr(10) . '    for (i = 0; i < a.length; i+=2) {' . chr(10) . '        res[p5str(a[i])] = a[i+1];' . chr(10) . '    }' . chr(10) . '    return res;' . chr(10) . '};' . chr(10) . chr(10) . 'if (isNode) {' . chr(10) . '    var fs = require("fs");' . chr(10) . '}' . chr(10) . chr(10) . 'p5context = function(List__, p5want) {' . chr(10) . '    if (p5want) {' . chr(10) . '        return p5list_to_a.apply(null, List__);' . chr(10) . '    }' . chr(10) . '    // scalar: return the last value' . chr(10) . '    var o = List__;' . chr(10) . '    while (o instanceof Array) {' . chr(10) . '        o =   o.length' . chr(10) . '            ? o[o.length-1]' . chr(10) . '            : null;' . chr(10) . '    }' . chr(10) . '    return o;' . chr(10) . '}' . chr(10) . chr(10) . 'p5code = function(o) {' . chr(10) . '    if (typeof o === "function") {' . chr(10) . '        return o;' . chr(10) . '    }' . chr(10) . '    return o.p5code();' . chr(10) . '};' . chr(10) . chr(10) . 'p5str = function(o) {' . chr(10) . '    if (o == null) {' . chr(10) . '        return "";' . chr(10) . '    }' . chr(10) . '    if (typeof o === "object" && (o instanceof Array)) {' . chr(10) . '        return CORE.join(["", o]);' . chr(10) . '    }' . chr(10) . '    if (typeof o.p5string === "function") {' . chr(10) . '        return o.p5string();' . chr(10) . '    }' . chr(10) . '    if (typeof o == "number" && Math.abs(o) < 0.0001 && o != 0) {' . chr(10) . '        return o.toExponential().replace(/e-(' . chr(92) . 'd)$/,"e-0$1");' . chr(10) . '    }' . chr(10) . '    if (typeof o === "boolean") {' . chr(10) . '        return o ? "1" : "";' . chr(10) . '    }' . chr(10) . '    if (typeof o !== "string") {' . chr(10) . '        return "" + o;' . chr(10) . '    }' . chr(10) . '    return o;' . chr(10) . '};' . chr(10) . chr(10) . 'p5num = function(o) {' . chr(10) . '    if (o == null) {' . chr(10) . '        return 0;' . chr(10) . '    }' . chr(10) . '    if (typeof o === "object" && (o instanceof Array)) {' . chr(10) . '        return o.length;' . chr(10) . '    }' . chr(10) . '    if (typeof o.p5num === "function") {' . chr(10) . '        return o.p5num();' . chr(10) . '    }' . chr(10) . '    if (typeof o !== "number") {' . chr(10) . '        return parseFloat(p5str(o));' . chr(10) . '    }' . chr(10) . '    return o;' . chr(10) . '};' . chr(10) . chr(10) . 'p5bool = function(o) {' . chr(10) . '    if (o) {' . chr(10) . '        if (typeof o === "boolean") {' . chr(10) . '            return o;' . chr(10) . '        }' . chr(10) . '        if (typeof o === "number") {' . chr(10) . '            return o;' . chr(10) . '        }' . chr(10) . '        if (typeof o === "string") {' . chr(10) . '            return o != "" && o != "0";' . chr(10) . '        }' . chr(10) . '        if (typeof o.p5bool === "function") {' . chr(10) . '            return o.p5bool();' . chr(10) . '        }' . chr(10) . '        if (typeof o.length === "number") {' . chr(10) . '            return o.length;' . chr(10) . '        }' . chr(10) . '        if (o instanceof Error) {' . chr(10) . '            return true;' . chr(10) . '        }' . chr(10) . '        for (var i in o) {' . chr(10) . '            return true;' . chr(10) . '        }' . chr(10) . '    }' . chr(10) . '    return false;' . chr(10) . '};' . chr(10) . chr(10) . 'p5incr = function(o) {' . chr(10) . '    if (typeof o === "number") {' . chr(10) . '        return o + 1;' . chr(10) . '    }' . chr(10) . '    return p5str_inc(p5str(o));' . chr(10) . '};' . chr(10) . chr(10) . 'p5decr = function(o) {' . chr(10) . '    if (typeof o === "number") {' . chr(10) . '        return o - 1;' . chr(10) . '    }' . chr(10) . '    return p5num(o) - 1;' . chr(10) . '};' . chr(10) . chr(10) . 'p5and = function(a, fb) {' . chr(10) . '    if (p5bool(a)) {' . chr(10) . '        return fb();' . chr(10) . '    }' . chr(10) . '    return a;' . chr(10) . '};' . chr(10) . chr(10) . 'p5or = function(a, fb) {' . chr(10) . '    if (p5bool(a)) {' . chr(10) . '        return a;' . chr(10) . '    }' . chr(10) . '    return fb();' . chr(10) . '};' . chr(10) . chr(10) . 'p5defined_or = function(a, fb) {' . chr(10) . '    if (a == null) {' . chr(10) . '        return fb();' . chr(10) . '    }' . chr(10) . '    return a;' . chr(10) . '};' . chr(10) . chr(10) . 'p5cmp = function(a, b) {' . chr(10) . '    return a > b ? 1 : a < b ? -1 : 0 ' . chr(10) . '};' . chr(10) . chr(10) . 'p5complement = function(a) {' . chr(10) . '    return a < 0 ? ~a : 4294967295 - a' . chr(10) . '    // return a < 0 ? ~a : 18446744073709551615 - a' . chr(10) . '};' . chr(10) . chr(10) . 'p5str_replicate = function(o, n) {' . chr(10) . '    n = p5num(n);' . chr(10) . '    return n ? Array(n + 1).join(o) : "";' . chr(10) . '};' . chr(10) . chr(10) . 'p5str_inc = function(s) {' . chr(10) . '    s = p5str(s);' . chr(10) . '    if (s.length < 2) {' . chr(10) . '        if (s.match(/[012345678ABCDEFGHIJKLMNOPQRSTUVWXYabcdefghijklmnopqrstuvwxy]/)) {' . chr(10) . '            return String.fromCharCode(s.charCodeAt(0) + 1);' . chr(10) . '        }' . chr(10) . '        if (s == "9") {' . chr(10) . '            return "10";' . chr(10) . '        }' . chr(10) . '        if (s == "Z") {' . chr(10) . '            return "AA";' . chr(10) . '        }' . chr(10) . '        if (s == "z") {' . chr(10) . '            return "aa";' . chr(10) . '        }' . chr(10) . '        return "1";' . chr(10) . '    }' . chr(10) . '    var c = p5str_inc(s.substr(s.length-1, 1));' . chr(10) . '    if (c.length == 1) {' . chr(10) . '        return s.substr(0, s.length-1) + c;' . chr(10) . '    }' . chr(10) . '    return p5str_inc(s.substr(0, s.length-1)) + c.substr(c.length-1, 1);' . chr(10) . '};' . chr(10) . chr(10) . 'p5for = function(namespace, func, args, cont, label) {' . chr(10) . '    var _redo = false;' . chr(10) . chr(10) . '    var v_old = namespace["v__"];' . chr(10) . '    namespace["v__"] = new p5Scalar(null);' . chr(10) . chr(10) . '    for(var i = 0; i < args.length; i++) {' . chr(10) . '        namespace["v__"].assign(args[i]);   // ??? - should this be a bind?' . chr(10) . '        try {' . chr(10) . '            func()' . chr(10) . '        }' . chr(10) . '        catch(err) {' . chr(10) . '            if (err instanceof p5_error && err.v == label) {' . chr(10) . '                if (err.type == ' . chr(39) . 'last' . chr(39) . ') { return }' . chr(10) . '                else if (err.type == ' . chr(39) . 'redo' . chr(39) . ') { i--; _redo = true }' . chr(10) . '                else if (err.type != ' . chr(39) . 'next' . chr(39) . ') { throw(err) }' . chr(10) . '            }' . chr(10) . '            else {' . chr(10) . '                throw(err)' . chr(10) . '            }' . chr(10) . '        }' . chr(10) . '        if (cont) {' . chr(10) . '            try {' . chr(10) . '                if (!_redo) { cont() }' . chr(10) . '            }' . chr(10) . '            catch(err) {' . chr(10) . '                if (err instanceof p5_error && err.v == label) {' . chr(10) . '                    if (err.type == ' . chr(39) . 'last' . chr(39) . ') { return }' . chr(10) . '                    else if (err.type == ' . chr(39) . 'redo' . chr(39) . ') { _redo = true }' . chr(10) . '                    else if (err.type != ' . chr(39) . 'next' . chr(39) . ') { throw(err) }' . chr(10) . '                }            ' . chr(10) . '                else {' . chr(10) . '                    throw(err)' . chr(10) . '                }' . chr(10) . '            }' . chr(10) . '        }' . chr(10) . '    }' . chr(10) . '    namespace["v__"] = v_old;' . chr(10) . '};' . chr(10) . chr(10) . 'p5for_lex = function(func, args, cont, label) {' . chr(10) . '    var _redo = false;' . chr(10) . '    var _arg  = new p5Scalar(null);' . chr(10) . '    for(var i = 0; i < args.length; i++) {' . chr(10) . '        try {' . chr(10) . '            _arg.assign(args[i]);' . chr(10) . '            func(_arg)' . chr(10) . '        }' . chr(10) . '        catch(err) {' . chr(10) . '            if (err instanceof p5_error && err.v == label) {' . chr(10) . '                if (err.type == ' . chr(39) . 'last' . chr(39) . ') { return }' . chr(10) . '                else if (err.type == ' . chr(39) . 'redo' . chr(39) . ') { i--; _redo = true }' . chr(10) . '                else if (err.type != ' . chr(39) . 'next' . chr(39) . ') { throw(err) }' . chr(10) . '            }            ' . chr(10) . '            else {' . chr(10) . '                throw(err)' . chr(10) . '            }' . chr(10) . '        }' . chr(10) . '        if (cont) {' . chr(10) . '            try {' . chr(10) . '                if (!_redo) { cont() }' . chr(10) . '            }' . chr(10) . '            catch(err) {' . chr(10) . '                if (err instanceof p5_error && err.v == label) {' . chr(10) . '                    if (err.type == ' . chr(39) . 'last' . chr(39) . ') { return }' . chr(10) . '                    else if (err.type == ' . chr(39) . 'redo' . chr(39) . ') { _redo = true }' . chr(10) . '                    else if (err.type != ' . chr(39) . 'next' . chr(39) . ') { throw(err) }' . chr(10) . '                }            ' . chr(10) . '                else {' . chr(10) . '                    throw(err)' . chr(10) . '                }' . chr(10) . '            }' . chr(10) . '        }' . chr(10) . '    }' . chr(10) . '};' . chr(10) . chr(10) . 'p5while = function(func, cond, cont, label) {' . chr(10) . '    var _redo = false;' . chr(10) . '    while (_redo || p5bool(cond())) {' . chr(10) . '        _redo = false;' . chr(10) . '        try {' . chr(10) . '            func()' . chr(10) . '        }' . chr(10) . '        catch(err) {' . chr(10) . '            if (err instanceof p5_error && err.v == label) {' . chr(10) . '                if (err.type == ' . chr(39) . 'last' . chr(39) . ') { return }' . chr(10) . '                else if (err.type == ' . chr(39) . 'redo' . chr(39) . ') { _redo = true }' . chr(10) . '                else if (err.type != ' . chr(39) . 'next' . chr(39) . ') { throw(err) }' . chr(10) . '            }            ' . chr(10) . '            else {' . chr(10) . '                throw(err)' . chr(10) . '            }' . chr(10) . '        }' . chr(10) . '        if (cont) {' . chr(10) . '            try {' . chr(10) . '                if (!_redo) { cont() }' . chr(10) . '            }' . chr(10) . '            catch(err) {' . chr(10) . '                if (err instanceof p5_error && err.v == label) {' . chr(10) . '                    if (err.type == ' . chr(39) . 'last' . chr(39) . ') { return }' . chr(10) . '                    else if (err.type == ' . chr(39) . 'redo' . chr(39) . ') { _redo = true }' . chr(10) . '                    else if (err.type != ' . chr(39) . 'next' . chr(39) . ') { throw(err) }' . chr(10) . '                }            ' . chr(10) . '                else {' . chr(10) . '                    throw(err)' . chr(10) . '                }' . chr(10) . '            }' . chr(10) . '        }' . chr(10) . '    }' . chr(10) . '};' . chr(10) . chr(10) . 'p5map = function(namespace, func, args) {' . chr(10) . '    var v_old = namespace["v__"];' . chr(10) . '    namespace["v__"] = new p5Scalar(null);' . chr(10) . chr(10) . '    var out = [];' . chr(10) . '    for(var i = 0; i < args.length; i++) {' . chr(10) . '        namespace["v__"].assign(args[i]);' . chr(10) . '        var o = p5list_to_a(func(1));' . chr(10) . '        for(var j = 0; j < o.length; j++) {' . chr(10) . '            out.push(o[j]);' . chr(10) . '        }' . chr(10) . '    }' . chr(10) . '    namespace["v__"] = v_old;' . chr(10) . '    return out;' . chr(10) . '};' . chr(10) . chr(10) . 'p5grep = function(namespace, func, args) {' . chr(10) . '    var v_old = namespace["v__"];' . chr(10) . '    namespace["v__"] = new p5Scalar(null);' . chr(10) . chr(10) . '    var out = [];' . chr(10) . '    for(var i = 0; i < args.length; i++) {' . chr(10) . '        namespace["v__"].assign(args[i]);' . chr(10) . '        if (p5bool(func(0))) {' . chr(10) . '            out.push(args[i])' . chr(10) . '        }' . chr(10) . '    }' . chr(10) . '    namespace["v__"] = v_old;' . chr(10) . '    return out;' . chr(10) . '};' . chr(10) . chr(10) . 'p5sort = function(namespace, func, args) {' . chr(10) . '    var a_old = namespace["v_a"];' . chr(10) . '    var b_old = namespace["v_b"];' . chr(10) . '    namespace["v_a"] = new p5Scalar(null);' . chr(10) . '    namespace["v_b"] = new p5Scalar(null);' . chr(10) . chr(10) . '    var out = ' . chr(10) . '        func == null' . chr(10) . '        ? args.sort()' . chr(10) . '        : args.sort(' . chr(10) . '            function(a, b) {' . chr(10) . '                namespace["v_a"].assign(a);' . chr(10) . '                namespace["v_b"].assign(b);' . chr(10) . '                return func(0);' . chr(10) . '            }' . chr(10) . '        );' . chr(10) . '    namespace["v_a"] = a_old;' . chr(10) . '    namespace["v_b"] = b_old;' . chr(10) . '    return out;' . chr(10) . '};' . chr(10) . chr(10) . 'perl5_to_js = function( source, namespace, var_env_js, p5want ) {' . chr(10) . '    // CORE.say(["source: [" + source + "]"]);' . chr(10) . chr(10) . '    var strict_old = p5global("$", "Perlito5", "STRICT").FETCH();' . chr(10) . chr(10) . '    var namespace_old = p5global("$", "Perlito5", "PKG_NAME").FETCH();' . chr(10) . '    p5pkg["Perlito5"].v_PKG_NAME.assign(namespace);' . chr(10) . chr(10) . '    match = p5call(p5pkg["Perlito5::Grammar"], "exp_stmts", [source, 0]);' . chr(10) . chr(10) . '    if ( !p5bool(match) || p5str(match.hget("to")) != source.length ) {' . chr(10) . '        CORE.die(["Syntax error in eval near pos ", match.hget("to") ]);' . chr(10) . '    }' . chr(10) . chr(10) . '    ast = p5pkg.CORE.bless([' . chr(10) . '        new p5HashRef(new p5Hash({' . chr(10) . '            code: "do",' . chr(10) . '            arguments: [ p5pkg.CORE.bless([' . chr(10) . '                        new p5HashRef(new p5Hash({' . chr(10) . '                            stmts:   p5pkg["Perlito5::Match"].flat([match])' . chr(10) . '                        })),' . chr(10) . '                        p5pkg["Perlito5::AST::Block"]' . chr(10) . '                    ]) ]' . chr(10) . '        })),' . chr(10) . '        p5pkg["Perlito5::AST::Apply"]' . chr(10) . '    ]);' . chr(10) . chr(10) . '    // CORE.say(["ast: [" + ast + "]"]);' . chr(10) . '    js_code = p5call(ast, "emit_javascript3", [0, p5want]);' . chr(10) . '    // CORE.say(["js-source: [" + js_code + "]"]);' . chr(10) . chr(10) . '    p5pkg["Perlito5"].v_PKG_NAME.assign(namespace_old);' . chr(10) . '    p5pkg["Perlito5"].v_STRICT.assign(strict_old);' . chr(10) . '    return js_code;' . chr(10) . '}' . chr(10) . chr(10)
            }
            1
        }
    }
    {
        {
            package main;
            undef();
            package Perlito5::Javascript3::CORE;
            sub Perlito5::Javascript3::CORE::emit_javascript3 {
                return '//' . chr(10) . '//' . chr(10) . '// lib/Perlito5/Javascript3/CORE.js' . chr(10) . '//' . chr(10) . '// CORE functions for "Perlito" Perl5-in-Javascript3' . chr(10) . '//' . chr(10) . '// AUTHORS' . chr(10) . '//' . chr(10) . '// Flavio Soibelmann Glock  fglock@gmail.com' . chr(10) . '//' . chr(10) . '// COPYRIGHT' . chr(10) . '//' . chr(10) . '// Copyright 2009, 2010, 2011, 2012 by Flavio Soibelmann Glock and others.' . chr(10) . '//' . chr(10) . '// This program is free software; you can redistribute it and/or modify it' . chr(10) . '// under the same terms as Perl itself.' . chr(10) . '//' . chr(10) . '// See http://www.perl.com/perl/misc/Artistic.html' . chr(10) . chr(10) . 'var CORE = p5pkg.CORE;' . chr(10) . chr(10) . 'var isNode = typeof require != "undefined";' . chr(10) . 'if (isNode) {' . chr(10) . '    CORE.print = function(List__) {' . chr(10) . '        var i;' . chr(10) . '        for (i = 0; i < List__.length; i++) {' . chr(10) . '            process.stdout.write(p5str(List__[i]));' . chr(10) . '        }' . chr(10) . '        return 1;' . chr(10) . '    }' . chr(10) . '} else {' . chr(10) . '    CORE.print = function(List__) {' . chr(10) . '        var i;' . chr(10) . '        for (i = 0; i < List__.length; i++) {' . chr(10) . '            write(p5str(List__[i]));' . chr(10) . '        }' . chr(10) . '        return 1;' . chr(10) . '    };' . chr(10) . '}' . chr(10) . chr(10) . 'CORE.say = function(List__) {' . chr(10) . '    CORE.print(List__);' . chr(10) . '    return CORE.print(["' . chr(92) . 'n"]);' . chr(10) . '};' . chr(10) . chr(10) . 'CORE.die = function(List__) {' . chr(10) . '    var o = List__[0]._array_;   // prototype is ' . chr(39) . '@' . chr(39) . chr(10) . '    var i;' . chr(10) . '    var s = "";' . chr(10) . '    for (i = 0; i < o.length; i++) {' . chr(10) . '        s = s + p5str(o[i]);' . chr(10) . '    }' . chr(10) . '    try {' . chr(10) . '        s = s + "' . chr(92) . 'n" + new Error().stack;' . chr(10) . '    }' . chr(10) . '    catch(err) { }' . chr(10) . '    p5pkg["main"]["v_@"].assign("Died: " + s);' . chr(10) . '    throw(new p5_error("die", "Died: " + s));' . chr(10) . '};' . chr(10) . chr(10) . 'CORE.warn = function(List__) {' . chr(10) . '    var o = List__[0]._array_;   // prototype is ' . chr(39) . '@' . chr(39) . chr(10) . '    var i;' . chr(10) . '    var s = "";' . chr(10) . '    for (i = 0; i < o.length; i++) {' . chr(10) . '        s = s + p5str(o[i]);' . chr(10) . '    }' . chr(10) . '    try {' . chr(10) . '        s = s + "' . chr(92) . 'n" + new Error().stack;' . chr(10) . '    }' . chr(10) . '    catch(err) { }' . chr(10) . '    CORE.print(["Warning: " + s + "' . chr(92) . 'n"]);' . chr(10) . '};' . chr(10) . chr(10) . 'CORE.bless = function(List__) {' . chr(10) . '    var o        = List__[0];' . chr(10) . '    var pkg_name = List__[1];' . chr(10) . '    if (o instanceof p5Scalar) {' . chr(10) . '        o = o.FETCH();' . chr(10) . '    }' . chr(10) . '    if (pkg_name instanceof p5Scalar) {' . chr(10) . '        pkg_name = pkg_name.FETCH();' . chr(10) . '    }' . chr(10) . '    if (typeof pkg_name === "object") {' . chr(10) . '        // bless {}, Class' . chr(10) . '        o._class_ = pkg_name;' . chr(10) . '        return o;' . chr(10) . '    }' . chr(10) . '    if (!p5pkg.hasOwnProperty(pkg_name)) {' . chr(10) . '        p5make_package(pkg_name);' . chr(10) . '    }' . chr(10) . '    o._class_ = p5pkg[pkg_name];' . chr(10) . '    return o;' . chr(10) . '};' . chr(10) . chr(10) . 'CORE.caller = function(List__, p5want) {' . chr(10) . '    if (p5want) {' . chr(10) . '        return p5pkg["Perlito5"]["CALLER"][0];' . chr(10) . '    }' . chr(10) . '    return p5pkg["Perlito5"]["CALLER"][0][0];' . chr(10) . '};' . chr(10) . chr(10) . 'CORE.chr = function(List__) {' . chr(10) . '    var v = p5num(List__[0]);' . chr(10) . '    return String.fromCharCode(v >= 0 ? v : 65533);' . chr(10) . '};' . chr(10) . chr(10) . 'CORE.ord = function(List__) {' . chr(10) . '    return p5str(List__[0]).charCodeAt(0);' . chr(10) . '};' . chr(10) . chr(10) . 'CORE.oct = function(List__) {' . chr(10) . '    var v = p5str(List__[0]);' . chr(10) . '    var b = v.substr(0,2);' . chr(10) . '    v = v.replace("_", "");' . chr(10) . '    if (b == "0b" || b == "0B") { return parseInt(v.substr(2), 2)  }' . chr(10) . '    if (b == "0x" || b == "0X") { return parseInt(v.substr(2), 16) }' . chr(10) . '    return parseInt(v, 8);' . chr(10) . '};' . chr(10) . chr(10) . 'CORE.abs   = function(List__) { return Math.abs(p5num(List__[0])) };' . chr(10) . 'CORE.exp   = function(List__) { return Math.exp(p5num(List__[0])) };' . chr(10) . 'CORE.log   = function(List__) { return Math.log(p5num(List__[0])) };' . chr(10) . 'CORE.cos   = function(List__) { return Math.cos(p5num(List__[0])) };' . chr(10) . 'CORE.sin   = function(List__) { return Math.sin(p5num(List__[0])) };' . chr(10) . 'CORE.sqrt  = function(List__) { return Math.sqrt(p5num(List__[0])) };' . chr(10) . 'CORE.atan2 = function(List__) { return Math.atan2(p5num(List__[0]), p5num(List__[1])) };' . chr(10) . 'CORE.int   = function(List__) { ' . chr(10) . '    var v = p5num(List__[0]);' . chr(10) . '    return v > 0 ? Math.floor(v) : Math.ceil(v)' . chr(10) . '};' . chr(10) . chr(10) . 'CORE.rand = function(List__) {' . chr(10) . '    var v = p5num(List__[0]) || 1;' . chr(10) . '    return Math.random() * v;' . chr(10) . '};' . chr(10) . chr(10) . 'CORE.lc      = function(List__) { return p5str(List__[0]).toLowerCase() };' . chr(10) . 'CORE.uc      = function(List__) { return p5str(List__[0]).toUpperCase() };' . chr(10) . chr(10) . 'CORE.lcfirst = function(List__) {' . chr(10) . '    var s = p5str(List__[0]);' . chr(10) . '    var c = s.length > 0 ? s.slice(0,1).toLowerCase() : "";' . chr(10) . '    s = s.length > 1 ? s.substr(1) : "";' . chr(10) . '    return c + s' . chr(10) . '};' . chr(10) . chr(10) . 'CORE.ucfirst = function(List__) {' . chr(10) . '    var s = p5str(List__[0]);' . chr(10) . '    var c = s.length > 0 ? s.slice(0,1).toUpperCase() : "";' . chr(10) . '    s = s.length > 1 ? s.substr(1) : "";' . chr(10) . '    return c + s' . chr(10) . '};' . chr(10) . chr(10) . 'CORE.quotemeta = function(List__) {' . chr(10) . '    var s = p5str(List__[0]);' . chr(10) . '    var out = [];' . chr(10) . '    for(var i = 0; i < s.length; i++) {' . chr(10) . '        if (s.substr(i, 1).match(/[^0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz]/)) {' . chr(10) . '            out.push(String.fromCharCode(92));' . chr(10) . '        }' . chr(10) . '        out.push(s.substr(i, 1));' . chr(10) . '    }' . chr(10) . '    return out.join("");       ' . chr(10) . '};' . chr(10) . chr(10) . 'CORE.substr = function(List__) {' . chr(10) . chr(10) . '    // TODO - lvalue substr()' . chr(10) . chr(10) . '    var s           = p5str(List__[0]);' . chr(10) . '    var offset      = p5num(List__[1]);' . chr(10) . '    var length      = List__.length > 2 ? p5num(List__[2]) : s.length;' . chr(10) . '    var replacement = List__[3];' . chr(10) . chr(10) . '    if (length < 0) {' . chr(10) . '        length = s.length - offset + length;' . chr(10) . '    }' . chr(10) . '    return s.substr(offset, length);' . chr(10) . '};' . chr(10) . chr(10) . 'CORE.defined = function(List__) {' . chr(10) . '    return (List__[0] instanceof p5Scalar) ? ( List__[0].FETCH() != null ) : ( List__[0] != null )' . chr(10) . '};' . chr(10) . chr(10) . 'CORE.values = function(List__, p5want) {' . chr(10) . '    var o = List__[0]._hash_;' . chr(10) . '    delete o["_each_"];' . chr(10) . '    if (p5want) {' . chr(10) . '        if (o == null) {' . chr(10) . '            return new p5Array([]);' . chr(10) . '        };' . chr(10) . '        if (typeof o.values === "function") {' . chr(10) . '            return o.values();' . chr(10) . '        }' . chr(10) . '        var out = [];' . chr(10) . '        for (var i in o) {' . chr(10) . '            out.push(o[i]);' . chr(10) . '        }' . chr(10) . '        return new p5Array(out);' . chr(10) . '    }' . chr(10) . '    return CORE.keys(List__, p5want);' . chr(10) . '};' . chr(10) . chr(10) . 'CORE.keys = function(List__, p5want) {' . chr(10) . '    var o = List__[0]._hash_;' . chr(10) . '    delete o["_each_"];' . chr(10) . '    if (p5want) {' . chr(10) . '        if (o == null) {' . chr(10) . '            return new p5Array([]);' . chr(10) . '        }' . chr(10) . '        if (typeof o.keys === "function") {' . chr(10) . '            return o.keys();' . chr(10) . '        }' . chr(10) . '        var out = [];' . chr(10) . '        for (var i in o) {' . chr(10) . '            out.push(i);' . chr(10) . '        }' . chr(10) . '        return new p5Array(out);' . chr(10) . '    }' . chr(10) . '    else {' . chr(10) . '        if (o == null) {' . chr(10) . '            return 0;' . chr(10) . '        }' . chr(10) . '        if (typeof o.keys === "function") {' . chr(10) . '            return CORE.scalar([o.keys()]);' . chr(10) . '        }' . chr(10) . '        var out = 0;' . chr(10) . '        for (var i in o) {' . chr(10) . '            out++;' . chr(10) . '        }' . chr(10) . '        return out;' . chr(10) . '    }' . chr(10) . '};' . chr(10) . chr(10) . 'CORE.each = function(List__, p5want) {' . chr(10) . '    var o = List__[0];' . chr(10) . '    if (o.hasOwnProperty("_each_")) {' . chr(10) . '        return o._each_(p5want)' . chr(10) . '    }' . chr(10) . '    var keys = CORE.keys([o], 1);' . chr(10) . '    var i = 0;' . chr(10) . '    o._each_ = function () {' . chr(10) . '        if (i < keys.length) {' . chr(10) . '            i++;' . chr(10) . '            return p5want ? [keys[i-1], o[keys[i-1]]] : keys[i-1];' . chr(10) . '        }' . chr(10) . '        i = 0;' . chr(10) . '        return p5want ? [] : null;' . chr(10) . '    };' . chr(10) . '    return o._each_(p5want);' . chr(10) . '};' . chr(10) . chr(10) . 'CORE.reverse = function(List__) {' . chr(10) . '    var o = List__[0];' . chr(10) . '    if (o instanceof p5Scalar) {' . chr(10) . '        o = o.FETCH();' . chr(10) . '    }' . chr(10) . '    if (o == null) {' . chr(10) . '        return "";' . chr(10) . '    }' . chr(10) . '    if (typeof o === "string") {' . chr(10) . '        return o.split("").reverse().join("")' . chr(10) . '    }' . chr(10) . '    var out = [];' . chr(10) . '    for(var i = 0; i < o.length; i++) {' . chr(10) . '        out.unshift(o[i]);' . chr(10) . '    }' . chr(10) . '    return out;' . chr(10) . '};' . chr(10) . chr(10) . 'CORE.splice = function(List__, p5want) {' . chr(10) . '    var array  = List__.shift()._array_;' . chr(10) . '    // CORE.say([ array ]);' . chr(10) . '    var offset = p5num(List__.shift());' . chr(10) . '    var limit  = List__.length ? p5num(List__.shift()) : (array.length + 1);' . chr(10) . chr(10) . '    if (limit < 0) {' . chr(10) . '        limit = array.length + limit - 1;' . chr(10) . '    }' . chr(10) . chr(10) . '    var list = [offset, limit];' . chr(10) . '    for(var i = 0; i < List__.length; i++) {' . chr(10) . '        list = p5list_to_a( list, List__[i]);' . chr(10) . '    }' . chr(10) . chr(10) . '    out = array.splice.apply(array, list);' . chr(10) . '    // CORE.say([ CORE.join([":",array]), " ofs=", offset, " lim=", limit, " list=", list, " out=", CORE.join([":",out])  ]);' . chr(10) . '    return p5want ? out : out.pop();' . chr(10) . '};' . chr(10) . chr(10) . 'CORE.pop = function(List__) {' . chr(10) . '    return List__[0].POP();' . chr(10) . '};' . chr(10) . chr(10) . 'CORE.shift = function(List__) {' . chr(10) . '    return List__[0].SHIFT();' . chr(10) . '};' . chr(10) . chr(10) . 'CORE.push = function(List__) {' . chr(10) . '    return List__[0].PUSH(List__[1]);' . chr(10) . '};' . chr(10) . chr(10) . 'CORE.unshift = function(List__) {' . chr(10) . '    return List__[0].UNSHIFT(List__[1]);' . chr(10) . '};' . chr(10) . chr(10) . 'CORE.join = function(List__) {' . chr(10) . '    var s = List__[0];' . chr(10) . '    var o = List__[1]._array_;' . chr(10) . '    var a = [];' . chr(10) . '    for (i = 0; i < o.length; i++) {' . chr(10) . '        a.push( p5str(o[i]) );' . chr(10) . '    }' . chr(10) . '    return a.join(s);' . chr(10) . '};' . chr(10) . chr(10) . 'CORE.index = function(List__) {' . chr(10) . '    try {' . chr(10) . '        return p5str(List__[0]).indexOf(p5str(List__[1]), p5num(List__[2]));' . chr(10) . '    }' . chr(10) . '    catch(err) {' . chr(10) . '        return -1;' . chr(10) . '    }' . chr(10) . '};' . chr(10) . 'CORE.rindex = function(List__) {' . chr(10) . '    var o = p5str(List__[0]);' . chr(10) . '    var s = List__[1];' . chr(10) . '    try {' . chr(10) . '        if (List__.length > 2) {' . chr(10) . '            var i = p5num(List__[2]);' . chr(10) . '            if (i < 0) {' . chr(10) . '                if (s.length == 0) {' . chr(10) . '                    return 0;' . chr(10) . '                }' . chr(10) . '                return -1;' . chr(10) . '            }' . chr(10) . '            return o.lastIndexOf(s, i);' . chr(10) . '        }' . chr(10) . '        return o.lastIndexOf(s);' . chr(10) . '    }' . chr(10) . '    catch(err) {' . chr(10) . '        return -1;' . chr(10) . '    }' . chr(10) . '};' . chr(10) . chr(10) . 'CORE.length = function(List__) {' . chr(10) . '    var o = p5str(List__[0]);' . chr(10) . '    return o.length;' . chr(10) . '};' . chr(10) . chr(10) . 'CORE.pack    = function(List__) { CORE.warn([ "CORE::pack not implemented" ]) };' . chr(10) . 'CORE.unpack  = function(List__) { CORE.warn([ "CORE::unpack not implemented" ]) };' . chr(10) . chr(10) . 'CORE.ref = function(List__) {' . chr(10) . '    var o = List__[0];' . chr(10) . '    if (o instanceof p5Scalar) {' . chr(10) . '        o = o.FETCH();' . chr(10) . '    }' . chr(10) . '    if (o == null) {' . chr(10) . '        return "";' . chr(10) . '    }' . chr(10) . '    if (o._class_ && typeof o._class_._ref_ === "string") {' . chr(10) . '        // blessed reference' . chr(10) . '        return o._class_._ref_;' . chr(10) . '    }' . chr(10) . '    if (typeof o._ref_ === "string") {' . chr(10) . '        // un-blessed reference' . chr(10) . '        return o._ref_;' . chr(10) . '    }' . chr(10) . '    if (typeof o === "function") {' . chr(10) . '        return "CODE";' . chr(10) . '    }' . chr(10) . '    return "";' . chr(10) . '};' . chr(10) . chr(10) . 'CORE.split = function(List__) {' . chr(10) . '    var pattern = List__[0];' . chr(10) . '    var s       = p5str(List__[1]);' . chr(10) . '    var limit   = List__[2];' . chr(10) . '    if (typeof pattern === "string") {' . chr(10) . '        if (pattern == " ") {' . chr(10) . '            var res = [];' . chr(10) . '            for (var i_ = 0, a_ = s.split(/(?: |' . chr(92) . 'n)+/); i_ < a_.length ; i_++) {' . chr(10) . '                if (a_[i_] != "") {' . chr(10) . '                    res.push(a_[i_])' . chr(10) . '                }' . chr(10) . '            }' . chr(10) . '            return res;' . chr(10) . '        }' . chr(10) . '        return s.split(pattern);' . chr(10) . '    }' . chr(10) . '    CORE.die(["not implemented"]);' . chr(10) . '};' . chr(10) . chr(10) . 'CORE.prototype = function(List__, data) {' . chr(10) . '    var name = List__[0];' . chr(10) . '    // TODO - fully qualify "name" using information from "data"' . chr(10) . '    // XXX - lookup in CORE::GLOBAL?' . chr(10) . '    p5pkg["Perlito5"].v_PROTO._hash_[name] || p5pkg["Perlito5"].v_CORE_PROTO._hash_[name]' . chr(10) . '};' . chr(10) . chr(10)
            }
            1
        }
    }
    {
        {
            package main;
            undef();
            package Perlito5::Javascript3::IO;
            sub Perlito5::Javascript3::IO::emit_javascript3 {
                return '//' . chr(10) . '//' . chr(10) . '// lib/Perlito5/Javascript3/IO.js' . chr(10) . '//' . chr(10) . '// I/O functions for "Perlito" Perl5-in-Javascript3' . chr(10) . '//' . chr(10) . '// AUTHORS' . chr(10) . '//' . chr(10) . '// Flavio Soibelmann Glock  fglock@gmail.com' . chr(10) . '//' . chr(10) . '// COPYRIGHT' . chr(10) . '//' . chr(10) . '// Copyright 2009, 2010, 2011, 2012 by Flavio Soibelmann Glock and others.' . chr(10) . '//' . chr(10) . '// This program is free software; you can redistribute it and/or modify it' . chr(10) . '// under the same terms as Perl itself.' . chr(10) . '//' . chr(10) . '// See http://www.perl.com/perl/misc/Artistic.html' . chr(10) . chr(10) . 'var isNode = typeof require != "undefined";' . chr(10) . 'if (isNode) {' . chr(10) . chr(10) . '    var fs = require("fs");' . chr(10) . chr(10) . '    p5atime = function(s) {' . chr(10) . '        s = p5str(s);' . chr(10) . '        try {' . chr(10) . '            var stat = fs.statSync(s); return stat["atime"];' . chr(10) . '        }' . chr(10) . '        catch(err) {' . chr(10) . '            return ' . chr(39) . chr(39) . ';' . chr(10) . '        }' . chr(10) . '    };' . chr(10) . '    p5mtime = function(s) {' . chr(10) . '        s = p5str(s);' . chr(10) . '        try {' . chr(10) . '            var stat = fs.statSync(s); return stat["mtime"];' . chr(10) . '        }' . chr(10) . '        catch(err) {' . chr(10) . '            return ' . chr(39) . chr(39) . ';' . chr(10) . '        }' . chr(10) . '    };' . chr(10) . '    p5ctime = function(s) {' . chr(10) . '        s = p5str(s);' . chr(10) . '        try {' . chr(10) . '            var stat = fs.statSync(s); return stat["ctime"];' . chr(10) . '        }' . chr(10) . '        catch(err) {' . chr(10) . '            return ' . chr(39) . chr(39) . ';' . chr(10) . '        }' . chr(10) . '    };' . chr(10) . '    p5size = function(s) {' . chr(10) . '        s = p5str(s);' . chr(10) . '        try {' . chr(10) . '            var stat = fs.statSync(s); return stat["size"];' . chr(10) . '        }' . chr(10) . '        catch(err) {' . chr(10) . '            return ' . chr(39) . chr(39) . ';' . chr(10) . '        }' . chr(10) . '    };' . chr(10) . '    p5is_file = function(s) {' . chr(10) . '        s = p5str(s);' . chr(10) . '        try {' . chr(10) . '            var stat = fs.statSync(s); return stat.isFile() ? 1 : 0;' . chr(10) . '        }' . chr(10) . '        catch(err) {' . chr(10) . '            return ' . chr(39) . chr(39) . ';' . chr(10) . '        }' . chr(10) . '    };' . chr(10) . '    p5is_directory = function(s) {' . chr(10) . '        s = p5str(s);' . chr(10) . '        try {' . chr(10) . '            var stat = fs.statSync(s); return stat.isDirectory() ? 1 : 0;' . chr(10) . '        }' . chr(10) . '        catch(err) {' . chr(10) . '            return ' . chr(39) . chr(39) . ';' . chr(10) . '        }' . chr(10) . '    };' . chr(10) . '    p5file_exists = function(s) {' . chr(10) . '        s = p5str(s);' . chr(10) . '        return p5is_file(s) || p5is_directory(s);' . chr(10) . '    };' . chr(10) . chr(10) . '    CORE.chdir = function(List__) {' . chr(10) . '        try {' . chr(10) . '            process.chdir(p5str(List__[0]));' . chr(10) . '            return 1;' . chr(10) . '        }' . chr(10) . '        catch(err) {' . chr(10) . '            return ' . chr(39) . chr(39) . ';' . chr(10) . '        }' . chr(10) . '    };' . chr(10) . chr(10) . '    CORE.close = function(List__) {' . chr(10) . '        try {' . chr(10) . '            fs.closeSync(p5str(List__[0]));' . chr(10) . '            return 1;' . chr(10) . '        }' . chr(10) . '        catch(err) {' . chr(10) . '            p5pkg["main"]["v_!"] = err;' . chr(10) . '            return ' . chr(39) . chr(39) . ';' . chr(10) . '        }' . chr(10) . '    };' . chr(10) . chr(10) . '    CORE.exit = function(List__) {' . chr(10) . '        process.exit(List__[0]);' . chr(10) . '    };' . chr(10) . chr(10) . '    CORE.rename = function(List__) {' . chr(10) . '        try {' . chr(10) . '            fs.renameSync(p5str(List__[0]), p5str(List__[1]));' . chr(10) . '            return 1;' . chr(10) . '        }' . chr(10) . '        catch(err) {' . chr(10) . '            p5pkg["main"]["v_!"] = err;' . chr(10) . '            return ' . chr(39) . chr(39) . ';' . chr(10) . '        }' . chr(10) . '    };' . chr(10) . chr(10) . '    CORE.unlink = function(List__) {' . chr(10) . '        var count = 0;' . chr(10) . '        try {' . chr(10) . '            for(var i = 0; i < List__.length; i++) {' . chr(10) . '                fs.unlinkSync(p5str(List__[i]));' . chr(10) . '                count++;' . chr(10) . '            }' . chr(10) . '            return count;' . chr(10) . '        }' . chr(10) . '        catch(err) {' . chr(10) . '            p5pkg["main"]["v_!"] = err;' . chr(10) . '            return count;' . chr(10) . '        }' . chr(10) . '    };' . chr(10) . chr(10) . '}' . chr(10) . chr(10)
            }
            1
        }
    }
    {
        {
            package main;
            undef();
            package Perlito5::Javascript3::Sprintf;
            sub Perlito5::Javascript3::Sprintf::emit_javascript3 {
                return '/**' . chr(10) . ' * Copyright (c) 2010 Jakob Westhoff' . chr(10) . ' *' . chr(10) . ' * Permission is hereby granted, free of charge, to any person obtaining a copy' . chr(10) . ' * of this software and associated documentation files (the "Software"), to deal' . chr(10) . ' * in the Software without restriction, including without limitation the rights' . chr(10) . ' * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell' . chr(10) . ' * copies of the Software, and to permit persons to whom the Software is' . chr(10) . ' * furnished to do so, subject to the following conditions:' . chr(10) . ' * ' . chr(10) . ' * The above copyright notice and this permission notice shall be included in' . chr(10) . ' * all copies or substantial portions of the Software.' . chr(10) . ' * ' . chr(10) . ' * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR' . chr(10) . ' * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,' . chr(10) . ' * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE' . chr(10) . ' * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER' . chr(10) . ' * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,' . chr(10) . ' * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN' . chr(10) . ' * THE SOFTWARE.' . chr(10) . ' */' . chr(10) . chr(10) . 'CORE.sprintf = function(List__) {' . chr(10) . '    var format = List__[0];' . chr(10) . '    var list = List__[1];' . chr(10) . chr(10) . '    // Check for format definition' . chr(10) . '    if ( typeof format != ' . chr(39) . 'string' . chr(39) . ' ) {' . chr(10) . '        CORE.die(["sprintf: The first arguments need to be a valid format string."]);' . chr(10) . '    }' . chr(10) . '    ' . chr(10) . '    /**' . chr(10) . '     * Define the regex to match a formating string' . chr(10) . '     * The regex consists of the following parts:' . chr(10) . '     * percent sign to indicate the start' . chr(10) . '     * (optional) sign specifier' . chr(10) . '     * (optional) padding specifier' . chr(10) . '     * (optional) alignment specifier' . chr(10) . '     * (optional) width specifier' . chr(10) . '     * (optional) precision specifier' . chr(10) . '     * type specifier:' . chr(10) . '     *  % - literal percent sign' . chr(10) . '     *  b - binary number' . chr(10) . '     *  c - ASCII character represented by the given value' . chr(10) . '     *  d - signed decimal number' . chr(10) . '     *  f - floating point value' . chr(10) . '     *  o - octal number' . chr(10) . '     *  s - string' . chr(10) . '     *  x - hexadecimal number (lowercase characters)' . chr(10) . '     *  X - hexadecimal number (uppercase characters)' . chr(10) . '     */' . chr(10) . '    var r = new RegExp( /%(' . chr(92) . '+)?([0 ]|' . chr(39) . '(.))?(-)?([0-9]+)?(' . chr(92) . '.([0-9]+))?([%bcdfosxX])/g );' . chr(10) . chr(10) . '    /**' . chr(10) . '     * Each format string is splitted into the following parts:' . chr(10) . '     * 0: Full format string' . chr(10) . '     * 1: sign specifier (+)' . chr(10) . '     * 2: padding specifier (0/<space>/' . chr(39) . '<any char>)' . chr(10) . '     * 3: if the padding character starts with a ' . chr(39) . ' this will be the real ' . chr(10) . '     *    padding character' . chr(10) . '     * 4: alignment specifier' . chr(10) . '     * 5: width specifier' . chr(10) . '     * 6: precision specifier including the dot' . chr(10) . '     * 7: precision specifier without the dot' . chr(10) . '     * 8: type specifier' . chr(10) . '     */' . chr(10) . '    var parts      = [];' . chr(10) . '    var paramIndex = 0;' . chr(10) . '    while ( part = r.exec( format ) ) {' . chr(10) . '        // Check if an input value has been provided, for the current' . chr(10) . '        // format string' . chr(10) . '        if ( paramIndex >= list.length ) {' . chr(10) . '            CORE.die(["sprintf: At least one argument was missing."]);' . chr(10) . '        }' . chr(10) . chr(10) . '        parts[parts.length] = {' . chr(10) . '            /* beginning of the part in the string */' . chr(10) . '            begin: part.index,' . chr(10) . '            /* end of the part in the string */' . chr(10) . '            end: part.index + part[0].length,' . chr(10) . '            /* force sign */' . chr(10) . '            sign: ( part[1] == ' . chr(39) . '+' . chr(39) . ' ),' . chr(10) . '            /* is the given data negative */' . chr(10) . '            negative: ( parseInt( list[paramIndex] ) < 0 ) ? true : false,' . chr(10) . '            /* padding character (default: <space>) */' . chr(10) . '            padding: ( part[2] == undefined )' . chr(10) . '                     ? ( ' . chr(39) . ' ' . chr(39) . ' ) /* default */' . chr(10) . '                     : ( ( part[2].substring( 0, 1 ) == "' . chr(39) . '" ) ' . chr(10) . '                         ? ( part[3] ) /* use special char */' . chr(10) . '                         : ( part[2] ) /* use normal <space> or zero */' . chr(10) . '                       ),' . chr(10) . '            /* should the output be aligned left?*/' . chr(10) . '            alignLeft: ( part[4] == ' . chr(39) . '-' . chr(39) . ' ),' . chr(10) . '            /* width specifier (number or false) */' . chr(10) . '            width: ( part[5] != undefined ) ? part[5] : false,' . chr(10) . '            /* precision specifier (number or false) */' . chr(10) . '            precision: ( part[7] != undefined ) ? part[7] : false,' . chr(10) . '            /* type specifier */' . chr(10) . '            type: part[8],' . chr(10) . '            /* the given data associated with this part converted to a string */' . chr(10) . '            data: ( part[8] != ' . chr(39) . '%' . chr(39) . ' ) ? String ( list[paramIndex++] ) : false' . chr(10) . '        };' . chr(10) . '    }' . chr(10) . chr(10) . '    var newString = "";' . chr(10) . '    var start = 0;' . chr(10) . '    // Generate our new formated string' . chr(10) . '    for( var i=0; i<parts.length; ++i ) {' . chr(10) . '        // Add first unformated string part' . chr(10) . '        newString += format.substring( start, parts[i].begin );' . chr(10) . '        ' . chr(10) . '        // Mark the new string start' . chr(10) . '        start = parts[i].end;' . chr(10) . chr(10) . '        // Create the appropriate preformat substitution' . chr(10) . '        // This substitution is only the correct type conversion. All the' . chr(10) . '        // different options and flags haven' . chr(39) . 't been applied to it at this' . chr(10) . '        // point' . chr(10) . '        var preSubstitution = "";' . chr(10) . '        switch ( parts[i].type ) {' . chr(10) . '            case ' . chr(39) . '%' . chr(39) . ':' . chr(10) . '                preSubstitution = "%";' . chr(10) . '            break;' . chr(10) . '            case ' . chr(39) . 'b' . chr(39) . ':' . chr(10) . '                preSubstitution = Math.abs( parseInt( parts[i].data ) ).toString( 2 );' . chr(10) . '            break;' . chr(10) . '            case ' . chr(39) . 'c' . chr(39) . ':' . chr(10) . '                preSubstitution = String.fromCharCode( Math.abs( parseInt( parts[i].data ) ) );' . chr(10) . '            break;' . chr(10) . '            case ' . chr(39) . 'd' . chr(39) . ':' . chr(10) . '                preSubstitution = String( Math.abs( parseInt( parts[i].data ) ) );' . chr(10) . '            break;' . chr(10) . '            case ' . chr(39) . 'f' . chr(39) . ':' . chr(10) . '                preSubstitution = ( parts[i].precision == false )' . chr(10) . '                                  ? ( String( ( Math.abs( parseFloat( parts[i].data ) ) ) ) )' . chr(10) . '                                  : ( Math.abs( parseFloat( parts[i].data ) ).toFixed( parts[i].precision ) );' . chr(10) . '            break;' . chr(10) . '            case ' . chr(39) . 'o' . chr(39) . ':' . chr(10) . '                preSubstitution = Math.abs( parseInt( parts[i].data ) ).toString( 8 );' . chr(10) . '            break;' . chr(10) . '            case ' . chr(39) . 's' . chr(39) . ':' . chr(10) . '                preSubstitution = parts[i].data.substring( 0, parts[i].precision ? parts[i].precision : parts[i].data.length ); /* Cut if precision is defined */' . chr(10) . '            break;' . chr(10) . '            case ' . chr(39) . 'x' . chr(39) . ':' . chr(10) . '                preSubstitution = Math.abs( parseInt( parts[i].data ) ).toString( 16 ).toLowerCase();' . chr(10) . '            break;' . chr(10) . '            case ' . chr(39) . 'X' . chr(39) . ':' . chr(10) . '                preSubstitution = Math.abs( parseInt( parts[i].data ) ).toString( 16 ).toUpperCase();' . chr(10) . '            break;' . chr(10) . '            default:' . chr(10) . '                throw ' . chr(39) . 'sprintf: Unknown type "' . chr(39) . ' + parts[i].type + ' . chr(39) . '" detected. This should never happen. Maybe the regex is wrong.' . chr(39) . ';' . chr(10) . '        }' . chr(10) . chr(10) . '        // The % character is a special type and does not need further processing' . chr(10) . '        if ( parts[i].type ==  "%" ) {' . chr(10) . '            newString += preSubstitution;' . chr(10) . '            continue;' . chr(10) . '        }' . chr(10) . chr(10) . '        // Modify the preSubstitution by taking sign, padding and width' . chr(10) . '        // into account' . chr(10) . chr(10) . '        // Pad the string based on the given width' . chr(10) . '        if ( parts[i].width != false ) {' . chr(10) . '            // Padding needed?' . chr(10) . '            if ( parts[i].width > preSubstitution.length ) ' . chr(10) . '            {' . chr(10) . '                var origLength = preSubstitution.length;' . chr(10) . '                for( var j = 0; j < parts[i].width - origLength; ++j ) ' . chr(10) . '                {' . chr(10) . '                    preSubstitution = ( parts[i].alignLeft == true ) ' . chr(10) . '                                      ? ( preSubstitution + parts[i].padding )' . chr(10) . '                                      : ( parts[i].padding + preSubstitution );' . chr(10) . '                }' . chr(10) . '            }' . chr(10) . '        }' . chr(10) . chr(10) . '        // Add a sign symbol if neccessary or enforced, but only if we are' . chr(10) . '        // not handling a string' . chr(10) . '        if ( parts[i].type == ' . chr(39) . 'b' . chr(39) . ' ' . chr(10) . '          || parts[i].type == ' . chr(39) . 'd' . chr(39) . ' ' . chr(10) . '          || parts[i].type == ' . chr(39) . 'o' . chr(39) . ' ' . chr(10) . '          || parts[i].type == ' . chr(39) . 'f' . chr(39) . ' ' . chr(10) . '          || parts[i].type == ' . chr(39) . 'x' . chr(39) . ' ' . chr(10) . '          || parts[i].type == ' . chr(39) . 'X' . chr(39) . ' ) {' . chr(10) . '            if ( parts[i].negative == true ) {' . chr(10) . '                preSubstitution = "-" + preSubstitution;' . chr(10) . '            }' . chr(10) . '            else if ( parts[i].sign == true ) {' . chr(10) . '                preSubstitution = "+" + preSubstitution;' . chr(10) . '            }' . chr(10) . '        }' . chr(10) . chr(10) . '        // Add the substitution to the new string' . chr(10) . '        newString += preSubstitution;' . chr(10) . '    }' . chr(10) . chr(10) . '    // Add the last part of the given format string, which may still be there' . chr(10) . '    newString += format.substring( start, format.length );' . chr(10) . chr(10) . '    return newString;' . chr(10) . '};' . chr(10) . chr(10) . 'CORE.printf = function(List__) {' . chr(10) . '    return CORE.print([ CORE.sprintf(List__) ]);' . chr(10) . '};' . chr(10) . chr(10)
            }
            1
        }
    }
    {
        {
            package main;
            undef();
            undef();
            # use strict
            package Perlito5::Perl5;
            {
                sub Perlito5::Perl5::escape_string {
                    return Perlito5::Dumper::escape_string($_[0])
                }
                sub Perlito5::Perl5::emit_perl5_block {
                    my $block = $_[0];
                    return ['block', map {
                        defined($_) && $_->emit_perl5()
                    } @{$block}]
                }
            }
            package Perlito5::AST::CompUnit;
            {
                sub Perlito5::AST::CompUnit::emit_perl5 {
                    my $self = $_[0];
                    return ['block', (['stmt' => ['keyword' => 'package'], ['bareword' => $self->{'name'}]], map {
                        defined($_) && $_->emit_perl5()
                    } @{$self->{'body'}})]
                }
                sub Perlito5::AST::CompUnit::emit_perl5_program {
                    my $comp_units = $_[0];
                    return ['comment' => Perlito5::Compiler::do_not_edit('#')], map {
                        $_->emit_perl5()
                    } @{$comp_units}
                }
            }
            package Perlito5::AST::Int;
            {
                sub Perlito5::AST::Int::emit_perl5 {
                    my $self = $_[0];
                    ['number' => $self->{'int'}]
                }
            }
            package Perlito5::AST::Num;
            {
                sub Perlito5::AST::Num::emit_perl5 {
                    my $self = $_[0];
                    ['number' => $self->{'num'}]
                }
            }
            package Perlito5::AST::Buf;
            {
                sub Perlito5::AST::Buf::emit_perl5 {
                    my $self = $_[0];
                    Perlito5::Perl5::escape_string($self->{'buf'})
                }
            }
            package Perlito5::AST::Block;
            {
                sub Perlito5::AST::Block::emit_perl5 {
                    my $self = $_[0];
                    my @out;
                    $self->{'label'} && push(@out, ['label' => $self->{'label'}]);
                    if ($self->{'name'}) {
                        push(@out, ['stmt' => ['keyword' => $self->{'name'}], Perlito5::Perl5::emit_perl5_block($self->{'stmts'})])
                    }
                    else {
                        push(@out, Perlito5::Perl5::emit_perl5_block($self->{'stmts'}))
                    }
                    if ($self->{'continue'} && @{$self->{'continue'}->{'stmts'}}) {
                        push(@out, ['stmt' => ['keyword' => 'continue'], Perlito5::Perl5::emit_perl5_block($self->{'continue'}->{'stmts'})])
                    }
                    return @out
                }
            }
            package Perlito5::AST::Index;
            {
                sub Perlito5::AST::Index::emit_perl5 {
                    my $self = $_[0];
                    if (($self->{'obj'}->isa('Perlito5::AST::Apply') && $self->{'obj'}->{'code'} eq 'prefix:<@>') || ($self->{'obj'}->isa('Perlito5::AST::Var') && ($self->{'obj'}->sigil() eq '$' || $self->{'obj'}->sigil() eq '@'))) {
                        return ['apply' => '[', $self->{'obj'}->emit_perl5(), $self->{'index_exp'}->emit_perl5()]
                    }
                    if (($self->{'obj'}->isa('Perlito5::AST::Apply') && $self->{'obj'}->{'code'} eq 'prefix:<%>') || ($self->{'obj'}->isa('Perlito5::AST::Var') && ($self->{'obj'}->sigil() eq '%'))) {
                        return ['apply' => '[', $self->{'obj'}->emit_perl5(), $self->{'index_exp'}->emit_perl5()]
                    }
                    if ($self->{'obj'}->isa('Perlito5::AST::Apply') && $self->{'obj'}->{'code'} eq 'prefix:<$>') {
                        return ['op' => 'infix:<->>', $self->{'obj'}->{'arguments'}->[0]->emit_perl5(), ['op' => 'circumfix:<[ ]>', $self->{'index_exp'}->emit_perl5()]]
                    }
                    return ['op' => 'infix:<->>', $self->{'obj'}->emit_perl5(), ['op' => 'circumfix:<[ ]>', $self->{'index_exp'}->emit_perl5()]]
                }
            }
            package Perlito5::AST::Lookup;
            {
                sub Perlito5::AST::Lookup::emit_perl5 {
                    my $self = $_[0];
                    if (($self->{'obj'}->isa('Perlito5::AST::Apply') && $self->{'obj'}->{'code'} eq 'prefix:<@>') || ($self->{'obj'}->isa('Perlito5::AST::Var') && ($self->{'obj'}->sigil() eq '$' || $self->{'obj'}->sigil() eq '@'))) {
                        return ['apply' => '{', $self->{'obj'}->emit_perl5(), $self->autoquote($self->{'index_exp'})->emit_perl5()]
                    }
                    if (($self->{'obj'}->isa('Perlito5::AST::Apply') && $self->{'obj'}->{'code'} eq 'prefix:<%>') || ($self->{'obj'}->isa('Perlito5::AST::Var') && ($self->{'obj'}->sigil() eq '%'))) {
                        return ['apply' => '{', $self->{'obj'}->emit_perl5(), $self->autoquote($self->{'index_exp'})->emit_perl5()]
                    }
                    if ($self->{'obj'}->isa('Perlito5::AST::Apply') && $self->{'obj'}->{'code'} eq 'prefix:<$>') {
                        return ['op' => 'infix:<->>', $self->{'obj'}->{'arguments'}->[0]->emit_perl5(), ['op' => 'circumfix:<{ }>', $self->autoquote($self->{'index_exp'})->emit_perl5()]]
                    }
                    return ['op' => 'infix:<->>', $self->{'obj'}->emit_perl5(), ['op' => 'circumfix:<{ }>', $self->autoquote($self->{'index_exp'})->emit_perl5()]]
                }
            }
            package Perlito5::AST::Var;
            {
                sub Perlito5::AST::Var::emit_perl5 {
                    my $self = $_[0];
                    my $str_name = $self->{'name'};
                    $str_name eq chr(92) && ($str_name = chr(92) . chr(92));
                    $str_name eq chr(39) && ($str_name = chr(92) . chr(39));
                    my $ns = '';
                    if ($self->{'namespace'}) {
                        $self->{'sigil'} eq '::' && return $self->{'namespace'} . '::';
                        if ($self->{'namespace'} eq 'main' && substr($self->{'name'}, 0, 1) eq '^') {
                            return $self->{'sigil'} . '{' . $self->{'name'} . '}'
                        }
                        else {
                            $ns = $self->{'namespace'} . '::'
                        }
                    }
                    my $c = substr($self->{'name'}, 0, 1);
                    if (($c ge 'a' && $c le 'z') || ($c ge 'A' && $c le 'Z') || ($c eq '_') || ($self->{'name'} eq '/')) {
                        return $self->{'sigil'} . $ns . $self->{'name'}
                    }
                    return $self->{'sigil'} . '{' . Perlito5::Perl5::escape_string($ns . $str_name) . '}'
                }
            }
            package Perlito5::AST::Call;
            {
                sub Perlito5::AST::Call::emit_perl5 {
                    my $self = $_[0];
                    my $invocant = $self->{'invocant'}->emit_perl5();
                    if ($self->{'method'} eq 'postcircumfix:<[ ]>') {
                        return ['op' => 'infix:<->>', $invocant, ['op' => 'circumfix:<[ ]>', $self->{'arguments'}->emit_perl5()]]
                    }
                    if ($self->{'method'} eq 'postcircumfix:<{ }>') {
                        return ['op' => 'infix:<->>', $invocant, ['op' => 'circumfix:<{ }>', Perlito5::AST::Lookup::->autoquote($self->{'arguments'})->emit_perl5()]]
                    }
                    my $meth = $self->{'method'};
                    if ($meth eq 'postcircumfix:<( )>') {
                        if ((ref($self->{'invocant'}) eq 'Perlito5::AST::Var' && $self->{'invocant'}->{'sigil'} eq '&') || (ref($self->{'invocant'}) eq 'Perlito5::AST::Apply' && $self->{'invocant'}->{'code'} eq 'prefix:<&>')) {
                            return ['apply' => '(', $invocant, map {
                                $_->emit_perl5()
                            } @{$self->{'arguments'}}]
                        }
                        $meth = ''
                    }
                    if (ref($meth) eq 'Perlito5::AST::Var') {
                        $meth = $meth->emit_perl5()
                    }
                    if ($meth) {
                        return ['call' => $invocant, $meth, map {
                            $_->emit_perl5()
                        } @{$self->{'arguments'}}]
                    }
                    return ['op' => 'infix:<->>', $invocant, ['op' => 'list:<,>', map {
                        $_->emit_perl5()
                    } @{$self->{'arguments'}}]]
                }
            }
            package Perlito5::AST::Apply;
            {
                sub Perlito5::AST::Apply::emit_perl5_args {
                    my $self = $_[0];
                    !$self->{'arguments'} && return ();
                    return map {
                        $_->emit_perl5()
                    } @{$self->{'arguments'}}
                }
                sub Perlito5::AST::Apply::emit_perl5 {
                    my $self = $_[0];
                    if (ref($self->{'code'})) {
                        return ['op' => 'infix:<->>', $self->{'code'}->emit_perl5(), $self->emit_perl5_args()]
                    }
                    if ($self->{'code'} eq 'infix:<=>>') {
                        return ['op' => $self->{'code'}, Perlito5::AST::Lookup::->autoquote($self->{'arguments'}->[0])->emit_perl5(), $self->{'arguments'}->[1]->emit_perl5()]
                    }
                    my $ns = '';
                    if ($self->{'namespace'}) {
                        $ns = $self->{'namespace'} . '::'
                    }
                    my $code = $ns . $self->{'code'};
                    if ($code eq 'prefix:<$>' || $code eq 'prefix:<@>' || $code eq 'prefix:<%>' || $code eq 'prefix:<&>' || $code eq 'prefix:<*>' || $code eq 'prefix:<$#>') {
                        my $arg = $self->{'arguments'}->[0];
                        if (ref($arg) eq 'Perlito5::AST::Apply' && $arg->{'code'} eq 'do') {
                            my $arg = $arg->{'arguments'}->[0];
                            if (ref($arg) eq 'Perlito5::AST::Block') {
                                return ['op' => $code, $arg->emit_perl5()]
                            }
                        }
                        $code =~ m!<([^>]+)>!;
                        return ['apply' => '{', ${1}, $arg->emit_perl5()]
                    }
                    if (($code eq 'eval' || $code eq 'do') && ref($self->{'arguments'}->[0]) eq 'Perlito5::AST::Block') {
                        return ['op' => 'prefix:<' . $code . '>', $self->{'arguments'}->[0]->emit_perl5()]
                    }
                    if ($Perlito5::Perl5::PrettyPrinter::op{$self->{'code'}}) {
                        return ['op' => $self->{'code'}, $self->emit_perl5_args()]
                    }
                    if ($self->{'code'} eq 'p5:s') {
                        return 's!' . $self->{'arguments'}->[0]->{'buf'} . '!' . $self->{'arguments'}->[1]->{'buf'} . '!' . $self->{'arguments'}->[2]->{'buf'}
                    }
                    if ($self->{'code'} eq 'p5:m') {
                        my $s;
                        if ($self->{'arguments'}->[0]->isa('Perlito5::AST::Buf')) {
                            $s = $self->{'arguments'}->[0]->{'buf'}
                        }
                        else {
                            for my $ast (@{$self->{'arguments'}->[0]->{'arguments'}}) {
                                if ($ast->isa('Perlito5::AST::Buf')) {
                                    $s .= $ast->{'buf'}
                                }
                                else {
                                    $s .= $ast->emit_perl5()
                                }
                            }
                        }
                        return 'm!' . $s . '!' . $self->{'arguments'}->[1]->{'buf'}
                    }
                    if ($self->{'code'} eq 'p5:tr') {
                        return 'tr!' . $self->{'arguments'}->[0]->{'buf'} . '!' . $self->{'arguments'}->[1]->{'buf'} . '!'
                    }
                    if ($self->{'code'} eq 'package') {
                        return ['stmt' => 'package', ['bareword' => $self->{'namespace'}]]
                    }
                    if ($code eq 'map' || $code eq 'grep' || $code eq 'sort') {
                        if ($self->{'special_arg'}) {
                            return ['op' => 'prefix:<' . $code . '>', ['block', map {
                                $_->emit_perl5()
                            } @{$self->{'special_arg'}->{'stmts'}}], ['op' => 'list:<,>', $self->emit_perl5_args()]]
                        }
                        return ['apply' => '(', $code, $self->emit_perl5_args()]
                    }
                    if ($code eq 'eval' && $Perlito5::PHASE eq 'BEGIN') {
                        return ['apply' => '(', 'eval', ['apply' => '(', 'Perlito5::CompileTime::Dumper::generate_eval_string', $self->emit_perl5_args()]]
                    }
                    if ($code eq 'readline') {
                        return ['paren' => '<', $self->emit_perl5_args()]
                    }
                    if ($self->{'bareword'} && !@{$self->{'arguments'}}) {
                        return ['bareword' => $code]
                    }
                    return ['apply' => '(', $code, $self->emit_perl5_args()]
                }
            }
            package Perlito5::AST::If;
            {
                sub Perlito5::AST::If::emit_perl5 {
                    my $self = $_[0];
                    if ($self->{'body'} && ref($self->{'body'}) ne 'Perlito5::AST::Block') {
                        return ['stmt_modifier' => $self->{'body'}->emit_perl5(), ['stmt' => 'if', $self->{'cond'}->emit_perl5()]]
                    }
                    if ($self->{'otherwise'} && ref($self->{'otherwise'}) ne 'Perlito5::AST::Block') {
                        return ['stmt_modifier' => $self->{'otherwise'}->emit_perl5(), ['stmt' => 'unless', $self->{'cond'}->emit_perl5()]]
                    }
                    my @out = (['stmt' => ['keyword' => 'if'], ['paren' => '(', $self->{'cond'}->emit_perl5()], Perlito5::Perl5::emit_perl5_block($self->{'body'}->stmts())]);
                    my $otherwise = $self->{'otherwise'};
                    while ($otherwise && @{$otherwise->{'stmts'}} == 1 && ref($otherwise->{'stmts'}->[0]) eq 'Perlito5::AST::If' && ($otherwise->{'stmts'}->[0]->{'body'} && ref($otherwise->{'stmts'}->[0]->{'body'}) eq 'Perlito5::AST::Block')) {
                        push(@out, ['stmt' => ['keyword' => 'elsif'], ['paren' => '(', $otherwise->{'stmts'}->[0]->{'cond'}->emit_perl5()], Perlito5::Perl5::emit_perl5_block($otherwise->{'stmts'}->[0]->{'body'}->{'stmts'})]);
                        $otherwise = $otherwise->{'stmts'}->[0]->{'otherwise'}
                    }
                    !($otherwise && scalar(@{$otherwise->stmts()})) && return @out;
                    push(@out, ['stmt' => ['keyword' => 'else'], Perlito5::Perl5::emit_perl5_block($otherwise->stmts())]);
                    return @out
                }
            }
            package Perlito5::AST::When;
            {
                sub Perlito5::AST::When::emit_perl5 {
                    my $self = $_[0];
                    return ['stmt' => ['keyword' => 'when'], ['paren' => '(', $self->{'cond'}->emit_perl5()], Perlito5::Perl5::emit_perl5_block($self->{'body'}->stmts())]
                }
            }
            package Perlito5::AST::While;
            {
                sub Perlito5::AST::While::emit_perl5 {
                    my $self = $_[0];
                    my @out;
                    $self->{'label'} && push(@out, ['label' => $self->{'label'}]);
                    if ($self->{'body'} && ref($self->{'body'}) ne 'Perlito5::AST::Block') {
                        return @out, ['stmt_modifier' => $self->{'body'}->emit_perl5(), ['stmt' => ['keyword' => 'while'], $self->{'cond'}->emit_perl5()]]
                    }
                    push(@out, ['stmt' => ['keyword' => 'while'], ['paren' => '(', $self->{'cond'}->emit_perl5()], Perlito5::Perl5::emit_perl5_block($self->{'body'}->stmts())]);
                    if ($self->{'continue'} && @{$self->{'continue'}->{'stmts'}}) {
                        push(@out, ['stmt' => ['keyword' => 'continue'], Perlito5::Perl5::emit_perl5_block($self->{'continue'}->{'stmts'})])
                    }
                    return @out
                }
            }
            package Perlito5::AST::For;
            {
                sub Perlito5::AST::For::emit_perl5 {
                    my $self = $_[0];
                    my @out;
                    $self->{'label'} && push(@out, ['label' => $self->{'label'}]);
                    if ($self->{'body'} && ref($self->{'body'}) ne 'Perlito5::AST::Block') {
                        return @out, ['stmt_modifier' => $self->{'body'}->emit_perl5(), ['stmt' => 'for', $self->{'cond'}->emit_perl5()]]
                    }
                    my $cond;
                    if (ref($self->{'cond'}) eq 'ARRAY') {
                        $cond = ['paren_semicolon' => '(', ($self->{'cond'}->[0] ? $self->{'cond'}->[0]->emit_perl5() : []), ($self->{'cond'}->[1] ? $self->{'cond'}->[1]->emit_perl5() : []), ($self->{'cond'}->[2] ? $self->{'cond'}->[2]->emit_perl5() : [])]
                    }
                    else {
                        $cond = ['paren' => '(', $self->{'cond'}->emit_perl5()]
                    }
                    my @sig;
                    my $sig_ast = $self->{'topic'};
                    if (!$sig_ast) {}
                    else {
                        @sig = $sig_ast->emit_perl5()
                    }
                    push(@out, ['stmt' => ['keyword' => 'for'], @sig, $cond, Perlito5::Perl5::emit_perl5_block($self->{'body'}->stmts())]);
                    if ($self->{'continue'} && @{$self->{'continue'}->{'stmts'}}) {
                        push(@out, ['stmt' => ['keyword' => 'continue'], Perlito5::Perl5::emit_perl5_block($self->{'continue'}->{'stmts'})])
                    }
                    return @out
                }
            }
            package Perlito5::AST::Decl;
            {
                sub Perlito5::AST::Decl::emit_perl5 {
                    my $self = $_[0];
                    return ['op' => 'prefix:<' . $self->{'decl'} . '>', ($self->{'type'} ? $self->{'type'} : ()), $self->{'var'}->emit_perl5()]
                }
            }
            package Perlito5::AST::Sub;
            {
                sub Perlito5::AST::Sub::emit_perl5 {
                    my $self = $_[0];
                    my @sig;
                    my @parts;
                    defined($self->{'sig'}) && push(@sig, ['paren' => '(', ['bareword' => $self->{'sig'}]]);
                    if (defined($self->{'block'})) {
                        push(@parts, Perlito5::Perl5::emit_perl5_block($self->{'block'}->{'stmts'}));
                        if ($Perlito5::PHASE eq 'BEGIN') {
                            my @captured;
                            for my $stmt (@{$self->{'block'}->{'stmts'}}) {
                                push(@captured, $stmt->get_captures())
                            }
                            my %dont_capture = map {
                                $_->{'dont'} ? ($_->{'dont'} => 1) : ()
                            } @captured;
                            my %capture = map {
                                $_->{'dont'} ? () : $dont_capture{$_->{'_id'}} ? () : ($_->{'_decl'} eq 'local' || $_->{'_decl'} eq 'global' || $_->{'_decl'} eq '') ? () : ($_->{'_id'} => $_)
                            } @captured;
                            my @captures_ast = values(%capture);
                            my @captures_perl = map {
                                ($_->{'_real_sigil'} || $_->{'sigil'}) . $_->{'name'}
                            } @captures_ast;
                            my @extra;
                            push(@extra, ['op', 'infix:<&&>', '@_', ['op', 'infix:<&&>', ['op', 'infix:<eq>', ['apply', '(', 'ref', ['apply', '[', '$_', ['number', 0]]], '"Perlito5::dump"'], ['apply', '(', 'return', ['op', 'circumfix:<{ }>', map {
                                ['op', 'infix:<=>>', chr(39) . $_ . chr(39), ['op', 'prefix:<' . chr(92) . '>', $_]]
                            } @captures_perl]]]]);
                            my $bl = shift(@{$parts[0]});
                            unshift(@{$parts[0]}, $bl, @extra)
                        }
                    }
                    !$self->{'name'} && return ['op' => 'prefix:<sub>', @sig, @parts];
                    return ['stmt' => ['keyword' => 'sub'], ['bareword' => $self->{'namespace'} . '::' . $self->{'name'}], @sig, @parts]
                }
            }
            package Perlito5::AST::Use;
            {
                sub Perlito5::AST::Use::emit_perl5 {
                    my $self = shift;
                    Perlito5::Grammar::Use::emit_time_eval($self);
                    if ($Perlito5::EMIT_USE) {
                        return ['stmt' => ['keyword' => 'use'], ['bareword' => $self->{'mod'}]]
                    }
                    else {
                        return ['comment' => '# ' . $self->{'code'} . ' ' . $self->{'mod'}]
                    }
                }
            }
            1
        }
    }
    {
        {
            package main;
            package Perlito5::Perl5::PrettyPrinter;
            # use strict
            undef();
            my %dispatch = ('stmt' => sub {
                statement(@_)
            }, 'stmt_modifier' => sub {
                statement_modifier(@_)
            }, 'block' => sub {
                block(@_)
            }, 'keyword' => sub {
                keyword(@_)
            }, 'bareword' => sub {
                bareword(@_)
            }, 'number' => sub {
                number(@_)
            }, 'op' => sub {
                op(@_)
            }, 'paren' => sub {
                paren(@_)
            }, 'paren_semicolon' => sub {
                paren_semicolon(@_)
            }, 'apply' => sub {
                apply(@_)
            }, 'call' => sub {
                call(@_)
            }, 'comment' => sub {
                comment(@_)
            }, 'label' => sub {
                label(@_)
            });
            my %pair = ('(' => ')', '[' => ']', '{' => '}', '<' => '>');
            our %op = ('prefix:<$>' => {'fix' => 'deref', 'prec' => 0, 'str' => '$'}, 'prefix:<@>' => {'fix' => 'deref', 'prec' => 0, 'str' => '@'}, 'prefix:<%>' => {'fix' => 'deref', 'prec' => 0, 'str' => '%'}, 'prefix:<&>' => {'fix' => 'deref', 'prec' => 0, 'str' => '&'}, 'prefix:<*>' => {'fix' => 'deref', 'prec' => 0, 'str' => '*'}, 'prefix:<$#>' => {'fix' => 'deref', 'prec' => 0, 'str' => '$#'}, 'circumfix:<[ ]>' => {'fix' => 'circumfix', 'prec' => 0, 'str' => '['}, 'circumfix:<{ }>' => {'fix' => 'circumfix', 'prec' => 0, 'str' => '{'}, 'circumfix:<( )>' => {'fix' => 'circumfix', 'prec' => 0, 'str' => '('}, 'infix:<->>' => {'fix' => 'infix', 'prec' => -1, 'str' => '->'}, 'prefix:<-->' => {'fix' => 'prefix', 'prec' => 1, 'str' => '--'}, 'prefix:<++>' => {'fix' => 'prefix', 'prec' => 1, 'str' => '++'}, 'postfix:<-->' => {'fix' => 'postfix', 'prec' => 1, 'str' => '--'}, 'postfix:<++>' => {'fix' => 'postfix', 'prec' => 1, 'str' => '++'}, 'infix:<**>' => {'fix' => 'infix', 'prec' => 2, 'str' => '**'}, 'prefix:<' . chr(92) . '>' => {'fix' => 'prefix', 'prec' => 3, 'str' => chr(92)}, 'prefix:<+>' => {'fix' => 'prefix', 'prec' => 3, 'str' => '+'}, 'prefix:<->' => {'fix' => 'prefix', 'prec' => 3, 'str' => '-'}, 'prefix:<~>' => {'fix' => 'prefix', 'prec' => 3, 'str' => '~'}, 'prefix:<!>' => {'fix' => 'prefix', 'prec' => 3, 'str' => '!'}, 'infix:<=~>' => {'fix' => 'infix', 'prec' => 4, 'str' => ' =~ '}, 'infix:<!~>' => {'fix' => 'infix', 'prec' => 4, 'str' => ' !~ '}, 'infix:<*>' => {'fix' => 'infix', 'prec' => 5, 'str' => ' * '}, 'infix:</>' => {'fix' => 'infix', 'prec' => 5, 'str' => ' / '}, 'infix:<%>' => {'fix' => 'infix', 'prec' => 5, 'str' => ' % '}, 'infix:<x>' => {'fix' => 'infix', 'prec' => 5, 'str' => ' x '}, 'infix:<+>' => {'fix' => 'infix', 'prec' => 6, 'str' => ' + '}, 'infix:<->' => {'fix' => 'infix', 'prec' => 6, 'str' => ' - '}, 'list:<.>' => {'fix' => 'list', 'prec' => 6, 'str' => ' . '}, 'infix:<<<>' => {'fix' => 'infix', 'prec' => 7, 'str' => ' << '}, 'infix:<>>>' => {'fix' => 'infix', 'prec' => 7, 'str' => ' >> '}, 'infix:<lt>' => {'fix' => 'infix', 'prec' => 9, 'str' => ' lt '}, 'infix:<le>' => {'fix' => 'infix', 'prec' => 9, 'str' => ' le '}, 'infix:<gt>' => {'fix' => 'infix', 'prec' => 9, 'str' => ' gt '}, 'infix:<ge>' => {'fix' => 'infix', 'prec' => 9, 'str' => ' ge '}, 'infix:<<=>' => {'fix' => 'infix', 'prec' => 9, 'str' => ' <= '}, 'infix:<>=>' => {'fix' => 'infix', 'prec' => 9, 'str' => ' >= '}, 'infix:<<>' => {'fix' => 'infix', 'prec' => 9, 'str' => ' < '}, 'infix:<>>' => {'fix' => 'infix', 'prec' => 9, 'str' => ' > '}, 'infix:<<=>>' => {'fix' => 'infix', 'prec' => 10, 'str' => ' <=> '}, 'infix:<cmp>' => {'fix' => 'infix', 'prec' => 10, 'str' => ' cmp '}, 'infix:<==>' => {'fix' => 'infix', 'prec' => 10, 'str' => ' == '}, 'infix:<!=>' => {'fix' => 'infix', 'prec' => 10, 'str' => ' != '}, 'infix:<ne>' => {'fix' => 'infix', 'prec' => 10, 'str' => ' ne '}, 'infix:<eq>' => {'fix' => 'infix', 'prec' => 10, 'str' => ' eq '}, 'infix:<&>' => {'fix' => 'infix', 'prec' => 11, 'str' => ' & '}, 'infix:<|>' => {'fix' => 'infix', 'prec' => 12, 'str' => ' | '}, 'infix:<^>' => {'fix' => 'infix', 'prec' => 12, 'str' => ' ^ '}, 'infix:<..>' => {'fix' => 'infix', 'prec' => 13, 'str' => ' .. '}, 'infix:<...>' => {'fix' => 'infix', 'prec' => 13, 'str' => ' ... '}, 'infix:<~~>' => {'fix' => 'infix', 'prec' => 13, 'str' => ' ~~ '}, 'infix:<&&>' => {'fix' => 'infix', 'prec' => 14, 'str' => ' && '}, 'infix:<||>' => {'fix' => 'infix', 'prec' => 15, 'str' => ' || '}, 'infix:<//>' => {'fix' => 'infix', 'prec' => 15, 'str' => ' // '}, 'ternary:<? :>' => {'fix' => 'ternary', 'prec' => 16}, 'infix:<=>' => {'fix' => 'infix', 'prec' => 17, 'str' => ' = '}, 'infix:<**=>' => {'fix' => 'infix', 'prec' => 17, 'str' => ' **= '}, 'infix:<+=>' => {'fix' => 'infix', 'prec' => 17, 'str' => ' += '}, 'infix:<-=>' => {'fix' => 'infix', 'prec' => 17, 'str' => ' -= '}, 'infix:<*=>' => {'fix' => 'infix', 'prec' => 17, 'str' => ' *= '}, 'infix:</=>' => {'fix' => 'infix', 'prec' => 17, 'str' => ' /= '}, 'infix:<x=>' => {'fix' => 'infix', 'prec' => 17, 'str' => ' x= '}, 'infix:<|=>' => {'fix' => 'infix', 'prec' => 17, 'str' => ' |= '}, 'infix:<&=>' => {'fix' => 'infix', 'prec' => 17, 'str' => ' &= '}, 'infix:<.=>' => {'fix' => 'infix', 'prec' => 17, 'str' => ' .= '}, 'infix:<<<=>' => {'fix' => 'infix', 'prec' => 17, 'str' => ' <<= '}, 'infix:<>>=>' => {'fix' => 'infix', 'prec' => 17, 'str' => ' >>= '}, 'infix:<%=>' => {'fix' => 'infix', 'prec' => 17, 'str' => ' %= '}, 'infix:<||=>' => {'fix' => 'infix', 'prec' => 17, 'str' => ' ||= '}, 'infix:<&&=>' => {'fix' => 'infix', 'prec' => 17, 'str' => ' &&= '}, 'infix:<^=>' => {'fix' => 'infix', 'prec' => 17, 'str' => ' ^= '}, 'infix:<//=>' => {'fix' => 'infix', 'prec' => 17, 'str' => ' //= '}, 'infix:<=>>' => {'fix' => 'infix', 'prec' => 18, 'str' => ' => '}, 'list:<,>' => {'fix' => 'list', 'prec' => 19, 'str' => ', '}, 'prefix:<not>' => {'fix' => 'prefix', 'prec' => 20, 'str' => ' not '}, 'infix:<and>' => {'fix' => 'infix', 'prec' => 21, 'str' => ' and '}, 'infix:<or>' => {'fix' => 'infix', 'prec' => 22, 'str' => ' or '}, 'infix:<xor>' => {'fix' => 'infix', 'prec' => 22, 'str' => ' xor '});
            $op{'prefix:<' . $_ . '>'} = {'fix' => 'prefix', 'prec' => 8, 'str' => $_ . ' '}
                for '-r', '-w', '-x', '-o', '-R', '-W', '-X', '-O', '-e', '-z', '-s', '-f', '-d', '-l', '-p', '-S', '-b', '-c', '-t', '-u', '-g', '-k', '-T', '-B', '-M', '-A', '-C';
            $op{'prefix:<' . $_ . '>'} = {'fix' => 'parsed', 'prec' => 15, 'str' => $_}
                for 'do', 'sub', 'my', 'our', 'state', 'local', 'eval', 'map', 'grep', 'sort';
            my %tab;
            sub Perlito5::Perl5::PrettyPrinter::tab {
                my $level = $_[0];
                $tab{$level} //= '    ' x $level
            }
            sub Perlito5::Perl5::PrettyPrinter::render {
                my($data, $level, $out) = @_;
                if (ref($data)) {
                    $dispatch{$data->[0]}->($data, $level, $out)
                }
                else {
                    push(@{$out}, $data)
                }
            }
            sub Perlito5::Perl5::PrettyPrinter::op_precedence {
                my($data) = @_;
                !ref($data) && return 0;
                $data->[0] ne 'op' && return 0;
                return $op{$data->[1]}->{'prec'} || 0
            }
            sub Perlito5::Perl5::PrettyPrinter::statement_need_semicolon {
                my($data) = @_;
                !ref($data) && return 1;
                ($data->[0] eq 'block' || $data->[0] eq 'comment' || $data->[0] eq 'label') && return 0;
                if ($data->[0] eq 'stmt') {
                    if (ref($data->[1])) {
                        my $dd = $data->[1];
                        if ($dd->[0] eq 'keyword') {
                            ref($data->[-1]) && $data->[-1]->[0] eq 'block' && return 0
                        }
                    }
                }
                return 1
            }
            sub Perlito5::Perl5::PrettyPrinter::op_render {
                my($data, $level, $out, $current_op) = @_;
                if (ref($data)) {
                    my $this_prec = op_precedence($data);
                    $this_prec && $current_op->{'prec'} && $current_op->{'prec'} < $this_prec && push(@{$out}, '(');
                    render($data, $level, $out);
                    $this_prec && $current_op->{'prec'} && $current_op->{'prec'} < $this_prec && push(@{$out}, ')')
                }
                else {
                    push(@{$out}, $data)
                }
            }
            sub Perlito5::Perl5::PrettyPrinter::op {
                my($data, $level, $out) = @_;
                my $op = $data->[1];
                my $spec = $op{$op} || die('unknown op: ' . $op);
                if ($spec->{'fix'} eq 'infix') {
                    op_render($data->[2], $level, $out, $spec);
                    push(@{$out}, $spec->{'str'});
                    op_render($data->[3], $level, $out, $spec)
                }
                elsif ($spec->{'fix'} eq 'prefix') {
                    push(@{$out}, $spec->{'str'});
                    op_render($data->[2], $level, $out, $spec)
                }
                elsif ($spec->{'fix'} eq 'postfix') {
                    op_render($data->[2], $level, $out, $spec);
                    push(@{$out}, $spec->{'str'})
                }
                elsif ($spec->{'fix'} eq 'ternary') {
                    op_render($data->[2], $level, $out, $spec);
                    push(@{$out}, ' ? ');
                    op_render($data->[3], $level, $out, $spec);
                    push(@{$out}, ' : ');
                    op_render($data->[4], $level, $out, $spec)
                }
                elsif ($spec->{'fix'} eq 'deref') {
                    push(@{$out}, $spec->{'str'});
                    op_render($data->[2], $level, $out, $spec)
                }
                elsif ($spec->{'fix'} eq 'circumfix') {
                    push(@{$out}, $spec->{'str'});
                    for my $line (2 .. $#{$data}) {
                        op_render($data->[$line], $level, $out, $spec);
                        $line != $#{$data} && push(@{$out}, ', ')
                    }
                    push(@{$out}, $pair{$spec->{'str'}})
                }
                elsif ($spec->{'fix'} eq 'list') {
                    for my $line (2 .. $#{$data}) {
                        op_render($data->[$line], $level, $out, $spec);
                        $line != $#{$data} && push(@{$out}, $spec->{'str'})
                    }
                }
                elsif ($spec->{'fix'} eq 'parsed') {
                    push(@{$out}, $spec->{'str'});
                    for my $line (2 .. $#{$data}) {
                        my $d = $data->[$line];
                        push(@{$out}, ' ');
                        render($d, $level, $out)
                    }
                }
                else {
                    die('unknown fixity: ' . $spec->{'fix'})
                }
                return 
            }
            sub Perlito5::Perl5::PrettyPrinter::call {
                my($data, $level, $out) = @_;
                my @dd = @{$data};
                shift(@dd);
                my $open = '(';
                render(shift(@dd), $level, $out);
                push(@{$out}, '->');
                my $d = $dd[0];
                render($d, $level, $out);
                $dd[0] = 'list:<,>';
                push(@{$out}, $open);
                op(['op' => @dd], $level, $out);
                push(@{$out}, $pair{$open})
            }
            sub Perlito5::Perl5::PrettyPrinter::apply {
                my($data, $level, $out) = @_;
                my @dd = @{$data};
                shift(@dd);
                my $open = shift(@dd);
                my $d = $dd[0];
                if ($d eq 'return') {
                    $open = ' '
                }
                render($d, $level, $out);
                $dd[0] = 'list:<,>';
                push(@{$out}, $open);
                op(['op' => @dd], $level, $out);
                push(@{$out}, $pair{$open})
            }
            sub Perlito5::Perl5::PrettyPrinter::paren {
                my($data, $level, $out) = @_;
                my @dd = @{$data};
                shift(@dd);
                my $open = $dd[0];
                $dd[0] = 'list:<,>';
                push(@{$out}, $open);
                op(['op' => @dd], $level, $out);
                push(@{$out}, $pair{$open})
            }
            sub Perlito5::Perl5::PrettyPrinter::paren_semicolon {
                my($data, $level, $out) = @_;
                push(@{$out}, $data->[1]);
                for my $line (2 .. $#{$data}) {
                    @{$data->[$line]} && render($data->[$line], $level, $out);
                    if ($line != $#{$data}) {
                        if (@{$data->[$line + 1]}) {
                            push(@{$out}, '; ')
                        }
                        else {
                            push(@{$out}, ';')
                        }
                    }
                }
                push(@{$out}, $pair{$data->[1]})
            }
            sub Perlito5::Perl5::PrettyPrinter::label {
                my($data, $level, $out) = @_;
                push(@{$out}, $data->[1], ':');
                return 
            }
            sub Perlito5::Perl5::PrettyPrinter::keyword {
                my($data, $level, $out) = @_;
                push(@{$out}, $data->[1]);
                return 
            }
            sub Perlito5::Perl5::PrettyPrinter::bareword {
                my($data, $level, $out) = @_;
                push(@{$out}, $data->[1]);
                return 
            }
            sub Perlito5::Perl5::PrettyPrinter::number {
                my($data, $level, $out) = @_;
                push(@{$out}, $data->[1]);
                return 
            }
            sub Perlito5::Perl5::PrettyPrinter::comment {
                my($data, $level, $out) = @_;
                push(@{$out}, $data->[1]);
                return 
            }
            sub Perlito5::Perl5::PrettyPrinter::statement {
                my($data, $level, $out) = @_;
                for my $line (1 .. $#{$data}) {
                    my $d = $data->[$line];
                    render($d, $level, $out);
                    $line != $#{$data} && push(@{$out}, ' ')
                }
            }
            sub Perlito5::Perl5::PrettyPrinter::statement_modifier {
                my($data, $level, $out) = @_;
                render($data->[1], $level, $out);
                push(@{$out}, chr(10), tab($level + 1));
                render($data->[2], $level, $out)
            }
            sub Perlito5::Perl5::PrettyPrinter::block {
                my($data, $level, $out) = @_;
                if (@{$data} == 1) {
                    push(@{$out}, '{}');
                    return 
                }
                push(@{$out}, '{', chr(10));
                $level++;
                for my $line (1 .. $#{$data}) {
                    my $d = $data->[$line];
                    push(@{$out}, tab($level));
                    render($d, $level, $out);
                    $line != $#{$data} && statement_need_semicolon($d) && push(@{$out}, ';');
                    push(@{$out}, chr(10))
                }
                $level--;
                push(@{$out}, tab($level), '}')
            }
            sub Perlito5::Perl5::PrettyPrinter::pretty_print {
                my($data, $level, $out) = @_;
                for my $line (0 .. $#{$data}) {
                    my $d = $data->[$line];
                    push(@{$out}, tab($level));
                    render($d, $level, $out);
                    $line != $#{$data} && statement_need_semicolon($d) && push(@{$out}, ';');
                    push(@{$out}, chr(10))
                }
            }
            1
        }
    }
    {
        {
            package main;
            package Perlito5::Perl5::Runtime;
            sub Perlito5::Perl5::Runtime::emit_perl5 {
                return chr(10) . 'use v5.10;' . chr(10) . 'use feature ' . chr(39) . 'say' . chr(39) . ';' . chr(10) . chr(10)
            }
            1
        }
    }
    {
        {
            package main;
            undef();
            undef();
            # use strict
            {
                {
                    package main;
                    package Perlito5::Perl6::TreeGrammar;
                    {
                        {
                            package main;
                            package Data::Dumper;
                            undef();
                            sub Data::Dumper::import {
                                my $pkg = shift;
                                my $callpkg = caller(0);
                                *{$callpkg . '::Dumper'} = \&Dumper;
                                return 
                            }
                            sub Data::Dumper::Dumper {
                                my $seen = {};
                                my $level = '    ';
                                my @out;
                                for my $i (0 .. $#_) {
                                    my $pos = '$VAR' . ($i + 1);
                                    push(@out, $pos . ' = ' . Perlito5::Dumper::_dumper($_[$i], $level, $seen, $pos) . ';' . chr(10))
                                }
                                return join('', @out)
                            }
                            1
                        }
                    }
                    # use strict
                    {
                        {
                            package main;
                            package Perlito5::TreeGrammar;
                            undef();
                            # use strict
                            my %dispatch = ('Ref' => sub {
                                Ref(@_)
                            }, 'Lookup' => sub {
                                Lookup(@_)
                            }, 'Index' => sub {
                                Index(@_)
                            }, 'Value' => sub {
                                Value(@_)
                            }, 'And' => sub {
                                And(@_)
                            }, 'Or' => sub {
                                Or(@_)
                            }, 'Not' => sub {
                                Not(@_)
                            }, 'Action' => sub {
                                Action(@_)
                            }, 'Progn' => sub {
                                Progn(@_)
                            }, 'Star' => sub {
                                Star(@_)
                            });
                            sub Perlito5::TreeGrammar::render {
                                my($rule, $node) = @_;
                                return $dispatch{$rule->[0]}->($rule, $node)
                            }
                            sub Perlito5::TreeGrammar::scan {
                                my($rule, $node) = @_;
                                $rule && render($rule, $node);
                                if (ref($node) eq 'ARRAY') {
                                    scan($rule, $_)
                                        for @{$node}
                                }
                                elsif (ref($node)) {
                                    scan($rule, $_)
                                        for values(%{$node})
                                }
                                return 
                            }
                            sub Perlito5::TreeGrammar::Action {
                                my($rule, $node) = @_;
                                $rule->[1]->($node);
                                return 1
                            }
                            sub Perlito5::TreeGrammar::Not {
                                my($rule, $node) = @_;
                                my $result;
                                render($rule->[1], $node) && return ;
                                return 1
                            }
                            sub Perlito5::TreeGrammar::Star {
                                my($rule, $node) = @_;
                                my $result;
                                while (1) {
                                    render($rule->[1], $node) || return 
                                }
                            }
                            sub Perlito5::TreeGrammar::Progn {
                                my($rule, $node) = @_;
                                my $result;
                                for $_ (@{$rule}[1 .. $#{$rule}]) {
                                    $result = render($_, $node)
                                }
                                return $result
                            }
                            sub Perlito5::TreeGrammar::And {
                                my($rule, $node) = @_;
                                my $result;
                                for $_ (@{$rule}[1 .. $#{$rule}]) {
                                    $result = render($_, $node) or return 
                                }
                                return $result
                            }
                            sub Perlito5::TreeGrammar::Or {
                                my($rule, $node) = @_;
                                my $result;
                                for $_ (@{$rule}[1 .. $#{$rule}]) {
                                    $result = render($_, $node) and return $result
                                }
                                return 
                            }
                            sub Perlito5::TreeGrammar::Ref {
                                my($rule, $node) = @_;
                                ref($node) ne $rule->[1] && return ;
                                !$rule->[2] && return 1;
                                return render($rule->[2], $node)
                            }
                            sub Perlito5::TreeGrammar::Lookup {
                                my($rule, $node) = @_;
                                (!ref($node) || ref($node) eq 'ARRAY' || !exists($node->{$rule->[1]})) && return ;
                                !$rule->[2] && return 1;
                                return render($rule->[2], $node->{$rule->[1]})
                            }
                            sub Perlito5::TreeGrammar::Index {
                                my($rule, $node) = @_;
                                (!ref($node) || ref($node) ne 'ARRAY' || !exists($node->[$rule->[1]])) && return ;
                                !$rule->[2] && return 1;
                                return render($rule->[2], $node->[$rule->[1]])
                            }
                            sub Perlito5::TreeGrammar::Value {
                                my($rule, $node) = @_;
                                (ref($node) || $node ne $rule->[1]) && return ;
                                !$rule->[2] && return 1;
                                return render($rule->[2], $node)
                            }
                            1
                        }
                    }
                    sub Perlito5::Perl6::TreeGrammar::refactor_range_operator {
                        my($class, $in) = @_;
                        Perlito5::TreeGrammar::render(['And' => ['Lookup' => 'code', ['Value' => 'infix:<..>']], ['Lookup' => 'arguments', ['And' => ['Index' => 0, ['And' => ['Ref' => 'Perlito5::AST::Int'], ['Lookup' => 'int', ['Value' => 0]]]], ['Index' => 1, ['Or' => ['And' => ['Ref' => 'Perlito5::AST::Int'], ['Action' => sub {
                            $in->{'code'} = 'p6_prefix:<^>';
                            $_[0]->{'int'}++;
                            shift(@{$in->{'arguments'}})
                        }]], ['And' => ['Ref' => 'Perlito5::AST::Apply'], ['Lookup' => 'code', ['Value' => 'prefix:<$#>']], ['Action' => sub {
                            bless($in, 'Perlito5::AST::Call');
                            delete($in->{'code'});
                            $in->{'method'} = 'keys';
                            shift(@{$in->{'arguments'}});
                            my $invocant = shift(@{$in->{'arguments'}});
                            $in->{'invocant'} = $invocant->{'arguments'}->[0]
                        }]], ['And' => ['Ref' => 'Perlito5::AST::Var'], ['Lookup' => 'sigil', ['Value' => '$#']], ['Action' => sub {
                            bless($in, 'Perlito5::AST::Call');
                            delete($in->{'code'});
                            $in->{'method'} = 'keys';
                            $in->{'arguments'} = [];
                            my $invocant = $_[0];
                            $invocant->{'sigil'} = '@';
                            $in->{'invocant'} = $invocant
                        }]]]]]]], $in)
                    }
                    sub Perlito5::Perl6::TreeGrammar::refactor_while_glob {
                        my($class, $in) = @_;
                        Perlito5::TreeGrammar::render(['Ref' => 'Perlito5::AST::While', ['Lookup' => 'cond', ['And' => ['Ref' => 'Perlito5::AST::Apply'], ['Lookup' => 'code', ['Value' => 'readline']], ['Action' => sub {
                            bless($in, 'Perlito5::AST::For')
                        }]]]], $in)
                    }
                    sub Perlito5::Perl6::TreeGrammar::refactor_sub_arguments {
                        my($class, $in) = @_;
                        my($rule, $result);
                        $rule = Perlito5::Perl6::TreeGrammar::is_sub(['Action' => sub {
                            my $sub = $_[0];
                            my $stmts;
                            my $var;
                            Perlito5::TreeGrammar::render(['Lookup' => 'block', ['Progn' => ['Action' => sub {
                                $stmts = $_[0]
                            }], ['Star' => ['Index' => 0, Perlito5::Perl6::TreeGrammar::operator_eq('infix:<=>', ['Lookup' => 'arguments', ['And' => ['Index' => 0, Perlito5::Perl6::TreeGrammar::my_var(['Action' => sub {
                                $var = $_[0]->{'var'}
                            }])], ['Index' => 1, Perlito5::Perl6::TreeGrammar::shift_arg()], ['Action' => sub {
                                push(@{$sub->{'args'}}, $var);
                                shift(@{$stmts})
                            }]]])]]]], $sub)
                        }]);
                        $result = Perlito5::TreeGrammar::scan($rule, $in)
                    }
                    sub Perlito5::Perl6::TreeGrammar::is_sub {
                        ['Ref' => 'Perlito5::AST::Sub', (@_ ? ['Progn' => @_] : ())]
                    }
                    sub Perlito5::Perl6::TreeGrammar::named_sub {
                        ['Ref' => 'Perlito5::AST::Sub', ['And' => ['Lookup' => 'name', ['Not' => ['Value' => '']]], (@_ ? ['Progn' => @_] : ())]]
                    }
                    sub Perlito5::Perl6::TreeGrammar::operator_eq {
                        my $name = shift;
                        ['Ref' => 'Perlito5::AST::Apply', ['And' => ['Lookup' => 'code', ['Value' => $name]], (@_ ? ['Progn' => @_] : ())]]
                    }
                    sub Perlito5::Perl6::TreeGrammar::my_var {
                        ['Ref' => 'Perlito5::AST::Decl', ['And' => ['Lookup' => 'decl', ['Value' => 'my']], (@_ ? ['Progn' => @_] : ())]]
                    }
                    sub Perlito5::Perl6::TreeGrammar::var_is_at {
                        ['Ref' => 'Perlito5::AST::Var', ['And' => ['Lookup' => 'sigil', ['Value' => '@']], ['Lookup' => 'name', ['Value' => '_']], (@_ ? ['Progn' => @_] : ())]]
                    }
                    sub Perlito5::Perl6::TreeGrammar::shift_arg {
                        ['Ref' => 'Perlito5::AST::Apply', ['And' => ['Lookup' => 'code', ['Value' => 'shift']], ['Or' => ['Lookup' => 'arguments', ['Not' => ['Index' => 0]]], ['Lookup' => 'arguments', ['Index' => 0, var_is_at()]]], (@_ ? ['Progn' => @_] : ())]]
                    }
                    1
                }
            }
            {
                package Perlito5::Perl6;
                sub Perlito5::Perl6::emit_perl6_block {
                    my $block = $_[0];
                    return ['block', map {
                        defined($_) && $_->emit_perl6()
                    } @{$block}]
                }
                my %safe_char = (' ' => 1, '!' => 1, '"' => 1, '#' => 1, '$' => 1, '%' => 1, '&' => 1, '(' => 1, ')' => 1, '*' => 1, '+' => 1, ',' => 1, '-' => 1, '.' => 1, '/' => 1, ':' => 1, ';' => 1, '<' => 1, '=' => 1, '>' => 1, '?' => 1, '@' => 1, '[' => 1, ']' => 1, '^' => 1, '_' => 1, '`' => 1, '{' => 1, '|' => 1, '}' => 1, '~' => 1);
                sub Perlito5::Perl6::escape_string {
                    my $s = shift;
                    my @out;
                    my $tmp = '';
                    $s eq '' && return chr(39) . chr(39);
                    for my $i (0 .. length($s) - 1) {
                        my $c = substr($s, $i, 1);
                        if (($c ge 'a' && $c le 'z') || ($c ge 'A' && $c le 'Z') || ($c ge 0 && $c le 9) || exists($safe_char{$c})) {
                            $tmp = $tmp . $c
                        }
                        else {
                            $tmp ne '' && push(@out, chr(39) . $tmp . chr(39));
                            push(@out, 'chr(' . ord($c) . ')');
                            $tmp = ''
                        }
                    }
                    $tmp ne '' && push(@out, chr(39) . $tmp . chr(39));
                    @out < 2 && return @out;
                    return ['op' => 'list:<~>', @out]
                }
            }
            package Perlito5::AST::CompUnit;
            {
                sub Perlito5::AST::CompUnit::emit_perl6 {
                    my $self = $_[0];
                    my @body = grep {
                        defined($_)
                    } @{$self->{'body'}};
                    my @out;
                    my $pkg = {'name' => 'main', 'body' => []};
                    for my $stmt (@body) {
                        if (ref($stmt) eq 'Perlito5::AST::Apply' && $stmt->{'code'} eq 'package') {
                            $Perlito5::PKG_NAME = $stmt->{'namespace'};
                            @{$pkg->{'body'}} && push(@out, ['stmt' => ['keyword' => 'class'], ['bareword' => $pkg->{'name'}], ['block' => map {
                                $_->emit_perl6()
                            } @{$pkg->{'body'}}]]);
                            $pkg = {'name' => $stmt->{'namespace'}, 'body' => []}
                        }
                        else {
                            push(@{$pkg->{'body'}}, $stmt)
                        }
                    }
                    @{$pkg->{'body'}} && push(@out, ['stmt' => ['keyword' => 'class'], ['bareword' => $pkg->{'name'}], ['block' => map {
                        $_->emit_perl6()
                    } @{$pkg->{'body'}}]]);
                    return @out
                }
                sub Perlito5::AST::CompUnit::emit_perl6_program {
                    my $comp_units = $_[0];
                    my @body = @{$comp_units};
                    my @out;
                    push(@out, ['comment' => Perlito5::Compiler::do_not_edit('#')]);
                    my $pkg = {'name' => 'main', 'body' => []};
                    for my $stmt (@body) {
                        if (ref($stmt) eq 'Perlito5::AST::Apply' && $stmt->{'code'} eq 'package') {
                            $Perlito5::PKG_NAME = $stmt->{'namespace'};
                            if (@{$pkg->{'body'}}) {
                                if ($pkg->{'name'} eq 'main') {
                                    push(@out, map {
                                        $_->emit_perl6()
                                    } @{$pkg->{'body'}})
                                }
                                else {
                                    push(@out, ['stmt' => ['keyword' => 'class'], ['bareword' => $pkg->{'name'}], ['block' => map {
                                        $_->emit_perl6()
                                    } @{$pkg->{'body'}}]])
                                }
                            }
                            $pkg = {'name' => $stmt->{'namespace'}, 'body' => []}
                        }
                        else {
                            push(@{$pkg->{'body'}}, $stmt)
                        }
                    }
                    if (@{$pkg->{'body'}}) {
                        if ($pkg->{'name'} eq 'main') {
                            push(@out, map {
                                $_->emit_perl6()
                            } @{$pkg->{'body'}})
                        }
                        else {
                            push(@out, ['stmt' => ['keyword' => 'class'], ['bareword' => $pkg->{'name'}], ['block' => map {
                                $_->emit_perl6()
                            } @{$pkg->{'body'}}]])
                        }
                    }
                    return @out
                }
            }
            package Perlito5::AST::Int;
            {
                sub Perlito5::AST::Int::emit_perl6 {
                    my $self = $_[0];
                    ['number' => $self->{'int'}]
                }
            }
            package Perlito5::AST::Num;
            {
                sub Perlito5::AST::Num::emit_perl6 {
                    my $self = $_[0];
                    ['number' => $self->{'num'}]
                }
            }
            package Perlito5::AST::Buf;
            {
                sub Perlito5::AST::Buf::emit_perl6 {
                    my $self = $_[0];
                    Perlito5::Perl6::escape_string($self->{'buf'})
                }
            }
            package Perlito5::AST::Block;
            {
                sub Perlito5::AST::Block::emit_perl6 {
                    my $self = $_[0];
                    my @out;
                    $self->{'label'} && push(@out, ['label' => $self->{'label'}]);
                    if ($self->{'name'}) {
                        push(@out, ['stmt' => ['keyword' => $self->{'name'}], Perlito5::Perl6::emit_perl6_block($self->{'stmts'})])
                    }
                    else {
                        push(@out, Perlito5::Perl6::emit_perl6_block($self->{'stmts'}))
                    }
                    if ($self->{'continue'} && @{$self->{'continue'}->{'stmts'}}) {
                        push(@out, ['stmt' => ['keyword' => 'continue'], Perlito5::Perl6::emit_perl6_block($self->{'continue'}->{'stmts'})])
                    }
                    return @out
                }
            }
            package Perlito5::AST::Index;
            {
                sub Perlito5::AST::Index::emit_perl6_index {
                    my $self = $_[0];
                    my $index = $self->{'index_exp'};
                    if ($index->isa('Perlito5::AST::Apply') && $index->{'code'} eq 'prefix:<->') {
                        my $arg = $index->{'arguments'}->[0];
                        if ($arg->isa('Perlito5::AST::Int')) {
                            return ['op' => 'infix:<->', ['bareword' => '*'], $arg->emit_perl6()]
                        }
                    }
                    return $self->{'index_exp'}->emit_perl6()
                }
                sub Perlito5::AST::Index::emit_perl6 {
                    my $self = $_[0];
                    if ($self->{'obj'}->isa('Perlito5::AST::Apply') && $self->{'obj'}->{'code'} eq 'prefix:<@>') {
                        return ['apply' => '[', $self->{'obj'}->emit_perl6(), $self->emit_perl6_index()]
                    }
                    if ($self->{'obj'}->isa('Perlito5::AST::Var') && ($self->{'obj'}->sigil() eq '$' || $self->{'obj'}->sigil() eq '@')) {
                        $self->{'obj'}->{'sigil'} = '@';
                        return ['apply' => '[', $self->{'obj'}->emit_perl6(), $self->emit_perl6_index()]
                    }
                    if ($self->{'obj'}->isa('Perlito5::AST::Apply') && $self->{'obj'}->{'code'} eq 'prefix:<$>') {
                        return ['apply' => '[', $self->{'obj'}->{'arguments'}->[0]->emit_perl6(), $self->emit_perl6_index()]
                    }
                    return ['op' => 'infix:<.>', $self->{'obj'}->emit_perl6(), ['op' => 'circumfix:<[ ]>', $self->emit_perl6_index()]]
                }
            }
            package Perlito5::AST::Lookup;
            {
                sub Perlito5::AST::Lookup::emit_perl6 {
                    my $self = $_[0];
                    if ($self->{'obj'}->isa('Perlito5::AST::Apply') && $self->{'obj'}->{'code'} eq 'prefix:<@>') {
                        $self->{'obj'}->{'sigil'} = '%';
                        return ['apply' => '{', $self->{'obj'}->emit_perl6(), $self->autoquote($self->{'index_exp'})->emit_perl6()]
                    }
                    if ($self->{'obj'}->isa('Perlito5::AST::Var') && ($self->{'obj'}->sigil() eq '$' || $self->{'obj'}->sigil() eq '@')) {
                        $self->{'obj'}->{'sigil'} = '%';
                        return ['apply' => '{', $self->{'obj'}->emit_perl6(), $self->autoquote($self->{'index_exp'})->emit_perl6()]
                    }
                    if ($self->{'obj'}->isa('Perlito5::AST::Apply') && $self->{'obj'}->{'code'} eq 'prefix:<$>') {
                        return ['apply' => '{', $self->{'obj'}->{'arguments'}->[0]->emit_perl6(), $self->autoquote($self->{'index_exp'})->emit_perl6()]
                    }
                    return ['op' => 'infix:<.>', $self->{'obj'}->emit_perl6(), ['op' => 'circumfix:<{ }>', $self->autoquote($self->{'index_exp'})->emit_perl6()]]
                }
            }
            package Perlito5::AST::Var;
            {
                sub Perlito5::AST::Var::emit_perl6 {
                    my $self = $_[0];
                    if ($self->{'sigil'} eq '$#') {
                        my $v = Perlito5::AST::Var::->new(%{$self}, 'sigil' => '@');
                        return ['op' => 'infix:<.>', $v->emit_perl6(), ['keyword' => 'end']]
                    }
                    my $str_name = $self->{'name'};
                    $str_name eq chr(92) && ($str_name = chr(92) . chr(92));
                    $str_name eq '"' && ($str_name = chr(92) . '"');
                    if ($self->{'sigil'} eq '::') {
                        if ($self->{'namespace'} eq '__PACKAGE__') {
                            return ['bareword' => '$?PACKAGE']
                        }
                        return $self->{'namespace'}
                    }
                    my $ns = '';
                    if ($self->{'namespace'}) {
                        if ($self->{'namespace'} eq 'main' && substr($self->{'name'}, 0, 1) eq '^') {
                            return $self->{'sigil'} . '{' . $self->{'name'} . '}'
                        }
                        else {
                            $ns = $self->{'namespace'} . '::'
                        }
                    }
                    my $bareword = $ns . $str_name;
                    my $c = substr($self->{'name'}, 0, 1);
                    if (($c ge 'a' && $c le 'z') || ($c ge 'A' && $c le 'Z') || ($c eq '_')) {
                        $self->{'sigil'} eq '@' && $bareword eq 'ARGV' && return '@*ARGS';
                        return $self->{'sigil'} . $bareword
                    }
                    if ($self->{'sigil'} eq '$') {
                        $bareword eq '/' && return '"' . chr(92) . 'n"';
                        $bareword eq '$' && return '$*PID';
                        $bareword eq 0 && return '$*PROGRAM_NAME';
                        $bareword eq '@' && return '$!';
                        $bareword >= 1 && return '$' . ($bareword - 1)
                    }
                    my $str = $self->{'sigil'} . '{' . chr(39) . $bareword . chr(39) . '}';
                    return $str
                }
            }
            package Perlito5::AST::Call;
            {
                sub Perlito5::AST::Call::emit_perl6 {
                    my $self = $_[0];
                    my $invocant = $self->{'invocant'}->emit_perl6();
                    if ($self->{'method'} eq 'postcircumfix:<[ ]>') {
                        return ['op' => 'infix:<.>', $invocant, ['op' => 'circumfix:<[ ]>', $self->{'arguments'}->emit_perl6()]]
                    }
                    if ($self->{'method'} eq 'postcircumfix:<{ }>') {
                        return ['op' => 'infix:<.>', $invocant, ['op' => 'circumfix:<{ }>', Perlito5::AST::Lookup::->autoquote($self->{'arguments'})->emit_perl6()]]
                    }
                    my $meth = $self->{'method'};
                    if ($meth eq 'postcircumfix:<( )>') {
                        if ((ref($self->{'invocant'}) eq 'Perlito5::AST::Var' && $self->{'invocant'}->{'sigil'} eq '&') || (ref($self->{'invocant'}) eq 'Perlito5::AST::Apply' && $self->{'invocant'}->{'code'} eq 'prefix:<&>')) {
                            return ['apply' => '(', $invocant, map {
                                $_->emit_perl6()
                            } @{$self->{'arguments'}}]
                        }
                        $meth = ''
                    }
                    if (ref($meth) eq 'Perlito5::AST::Var') {
                        $meth = $meth->emit_perl6()
                    }
                    if ($meth) {
                        return ['call' => $invocant, $meth, map {
                            $_->emit_perl6()
                        } @{$self->{'arguments'}}]
                    }
                    return ['op' => 'infix:<.>', $invocant, ['op' => 'list:<,>', map {
                        $_->emit_perl6()
                    } @{$self->{'arguments'}}]]
                }
            }
            package Perlito5::AST::Apply;
            {
                my %special_var = (chr(15) => '$*VM');
                my %op_translate = ('list:<.>' => 'list:<~>', 'infix:<.=>' => 'infix:<~=>', 'infix:<=~>' => 'infix:<~~>', 'infix:<!~>' => 'infix:<!~~>', 'infix:<cmp>' => 'infix:<leq>', 'ternary:<? :>' => 'ternary:<?? !!>', 'reverse' => 'flip');
                sub Perlito5::AST::Apply::emit_perl6_args {
                    my $self = $_[0];
                    !$self->{'arguments'} && return ();
                    return map {
                        $_->emit_perl6()
                    } @{$self->{'arguments'}}
                }
                sub Perlito5::AST::Apply::emit_perl6 {
                    my $self = $_[0];
                    my $code = $self->{'code'};
                    if (ref($code)) {
                        return ['op' => 'infix:<.>', $code->emit_perl6(), $self->emit_perl6_args()]
                    }
                    if ($code eq 'infix:<=>>') {
                        return ['op' => $code, Perlito5::AST::Lookup::->autoquote($self->{'arguments'}->[0])->emit_perl6(), $self->{'arguments'}->[1]->emit_perl6()]
                    }
                    if ($code eq 'nan' && !$self->{'namespace'}) {
                        return ['keyword' => 'NaN']
                    }
                    if ($code eq 'inf' && !$self->{'namespace'}) {
                        return ['keyword' => 'Inf']
                    }
                    if ($code eq '__PACKAGE__' && !$self->{'namespace'}) {
                        return ['bareword' => '$?PACKAGE']
                    }
                    if ($code eq 'prefix:<$#>') {
                        return ['op' => 'infix:<.>', $self->{'arguments'}->[0]->emit_perl6(), ['keyword' => 'end']]
                    }
                    if ($code eq 'scalar') {
                        my $arg = $self->{'arguments'}->[0];
                        if ($arg->isa('Perlito5::AST::Var') && $arg->{'sigil'} eq '@') {
                            return ['op' => 'infix:<.>', $arg->emit_perl6(), ['keyword' => 'elems']]
                        }
                    }
                    if (($code eq 'shift' || $code eq 'pop') && !@{$self->{'arguments'}}) {
                        return ['apply' => '(', $code, '@_']
                    }
                    if ($code eq 'readline' && ref($self->{'arguments'}->[0]) eq 'Perlito5::AST::Buf' && $self->{'arguments'}->[0]->{'buf'} eq '') {
                        return ['apply' => '(', ['keyword' => 'lines']]
                    }
                    if ($code eq 'infix:<x>') {
                        my $arg = $self->{'arguments'}->[0];
                        if (ref($arg) eq 'Perlito5::AST::Apply' && $arg->{'code'} eq 'circumfix:<( )>') {
                            $code = 'infix:<xx>'
                        }
                    }
                    if (($code eq 'print' || $code eq 'say') && !@{$self->{'arguments'}}) {
                        return ['keyword' => '.' . $code]
                    }
                    if ($code eq 'infix:<..>') {
                        Perlito5::Perl6::TreeGrammar::->refactor_range_operator($self);
                        if (ref($self) ne 'Perlito5::AST::Apply') {
                            return $self->emit_perl6()
                        }
                        $code = $self->{'code'}
                    }
                    $op_translate{$code} && ($code = $op_translate{$code});
                    if ($code eq 'prefix:<$>') {
                        my $arg = $self->{'arguments'}->[0];
                        $arg->isa('Perlito5::AST::Buf') && exists($special_var{$arg->{'buf'}}) && return $special_var{$arg->{'buf'}}
                    }
                    if ($Perlito5::Perl6::PrettyPrinter::op{$code}) {
                        return ['op' => $code, $self->emit_perl6_args()]
                    }
                    if ($code eq 'undef') {
                        if (@{$self->{'arguments'}}) {
                            die('TODO - undef(expr)')
                        }
                        else {
                            return 'Any'
                        }
                    }
                    my $ns = '';
                    if ($self->{'namespace'}) {
                        $ns = $self->{'namespace'} . '::'
                    }
                    $code = $ns . $code;
                    if ($self->{'code'} eq 'p5:s') {
                        my $modifier = $self->{'arguments'}->[2]->{'buf'};
                        $modifier && ($modifier = ':' . $modifier);
                        return 's:P5' . $modifier . '!' . $self->{'arguments'}->[0]->{'buf'} . '!' . $self->{'arguments'}->[1]->{'buf'} . '!'
                    }
                    if ($self->{'code'} eq 'p5:m') {
                        my $s;
                        if ($self->{'arguments'}->[0]->isa('Perlito5::AST::Buf')) {
                            $s = $self->{'arguments'}->[0]->{'buf'}
                        }
                        else {
                            for my $ast (@{$self->{'arguments'}->[0]->{'arguments'}}) {
                                if ($ast->isa('Perlito5::AST::Buf')) {
                                    $s .= $ast->{'buf'}
                                }
                                else {
                                    $s .= $ast->emit_perl6()
                                }
                            }
                        }
                        my $modifier = $self->{'arguments'}->[1]->{'buf'};
                        $modifier && ($modifier = ':' . $modifier);
                        return 'm:P5' . $modifier . '!' . $s . '!'
                    }
                    if ($self->{'code'} eq 'p5:tr') {
                        return 'tr!' . $self->{'arguments'}->[0]->{'buf'} . '!' . $self->{'arguments'}->[1]->{'buf'} . '!'
                    }
                    if ($self->{'code'} eq 'package') {
                        $Perlito5::PKG_NAME = $self->{'namespace'};
                        return ['stmt' => 'class', ['bareword' => $self->{'namespace'}]]
                    }
                    if ($code eq 'map' || $code eq 'grep' || $code eq 'sort') {
                        if ($self->{'special_arg'}) {
                            return ['op' => 'prefix:<' . $code . '>', ['block', map {
                                $_->emit_perl6()
                            } @{$self->{'special_arg'}->{'stmts'}}], ['op' => 'list:<,>', $self->emit_perl6_args()]]
                        }
                        return ['apply' => '(', $code, $self->emit_perl6_args()]
                    }
                    if ($self->{'bareword'} && !@{$self->{'arguments'}}) {
                        return ['bareword' => $code]
                    }
                    if ($code eq 'eval') {
                        $code = 'EVAL'
                    }
                    return ['apply' => '(', $code, $self->emit_perl6_args()]
                }
            }
            package Perlito5::AST::If;
            {
                sub Perlito5::AST::If::emit_perl6 {
                    my $self = $_[0];
                    if ($self->{'body'} && ref($self->{'body'}) ne 'Perlito5::AST::Block') {
                        return ['stmt_modifier' => $self->{'body'}->emit_perl6(), ['stmt' => 'if', $self->{'cond'}->emit_perl6()]]
                    }
                    if ($self->{'otherwise'} && ref($self->{'otherwise'}) ne 'Perlito5::AST::Block') {
                        return ['stmt_modifier' => $self->{'otherwise'}->emit_perl6(), ['stmt' => 'unless', $self->{'cond'}->emit_perl6()]]
                    }
                    my @out = (['stmt' => ['keyword' => 'if'], $self->{'cond'}->emit_perl6(), Perlito5::Perl6::emit_perl6_block($self->{'body'}->stmts())]);
                    my $otherwise = $self->{'otherwise'};
                    while ($otherwise && @{$otherwise->{'stmts'}} == 1 && ref($otherwise->{'stmts'}->[0]) eq 'Perlito5::AST::If' && ($otherwise->{'stmts'}->[0]->{'body'} && ref($otherwise->{'stmts'}->[0]->{'body'}) eq 'Perlito5::AST::Block')) {
                        push(@out, ['stmt' => ['keyword' => 'elsif'], $otherwise->{'stmts'}->[0]->{'cond'}->emit_perl6(), Perlito5::Perl6::emit_perl6_block($otherwise->{'stmts'}->[0]->{'body'}->{'stmts'})]);
                        $otherwise = $otherwise->{'stmts'}->[0]->{'otherwise'}
                    }
                    !($otherwise && scalar(@{$otherwise->stmts()})) && return @out;
                    push(@out, ['stmt' => ['keyword' => 'else'], Perlito5::Perl6::emit_perl6_block($otherwise->stmts())]);
                    return @out
                }
            }
            package Perlito5::AST::When;
            {
                sub Perlito5::AST::When::emit_perl6 {
                    my $self = $_[0];
                    return ['stmt' => ['keyword' => 'when'], $self->{'cond'}->emit_perl6(), Perlito5::Perl6::emit_perl6_block($self->{'body'}->stmts())]
                }
            }
            package Perlito5::AST::While;
            {
                sub Perlito5::AST::While::emit_perl6 {
                    my $self = $_[0];
                    Perlito5::Perl6::TreeGrammar::->refactor_while_glob($self);
                    if (ref($self) ne 'Perlito5::AST::While') {
                        return $self->emit_perl6()
                    }
                    my @out;
                    $self->{'label'} && push(@out, ['label' => $self->{'label'}]);
                    if ($self->{'body'} && ref($self->{'body'}) ne 'Perlito5::AST::Block') {
                        return @out, ['stmt_modifier' => $self->{'body'}->emit_perl6(), ['stmt' => ['keyword' => 'while'], $self->{'cond'}->emit_perl6()]]
                    }
                    push(@out, ['stmt' => ['keyword' => 'while'], $self->{'cond'}->emit_perl6(), Perlito5::Perl6::emit_perl6_block($self->{'body'}->stmts())]);
                    if ($self->{'continue'} && @{$self->{'continue'}->{'stmts'}}) {
                        push(@out, ['stmt' => ['keyword' => 'continue'], Perlito5::Perl6::emit_perl6_block($self->{'continue'}->{'stmts'})])
                    }
                    return @out
                }
            }
            package Perlito5::AST::For;
            {
                sub Perlito5::AST::For::emit_perl6 {
                    my $self = $_[0];
                    my @out;
                    $self->{'label'} && push(@out, ['label' => $self->{'label'}]);
                    if ($self->{'body'} && ref($self->{'body'}) ne 'Perlito5::AST::Block') {
                        return @out, ['stmt_modifier' => $self->{'body'}->emit_perl6(), ['stmt' => 'for', $self->{'cond'}->emit_perl6()]]
                    }
                    my $cond;
                    my $keyword;
                    if (ref($self->{'cond'}) eq 'ARRAY') {
                        $keyword = 'loop';
                        $cond = ['paren_semicolon' => '(', ($self->{'cond'}->[0] ? $self->{'cond'}->[0]->emit_perl6() : []), ($self->{'cond'}->[1] ? $self->{'cond'}->[1]->emit_perl6() : []), ($self->{'cond'}->[2] ? $self->{'cond'}->[2]->emit_perl6() : [])]
                    }
                    else {
                        $keyword = 'for';
                        $cond = $self->{'cond'}->emit_perl6()
                    }
                    my @sig;
                    my $sig_ast = $self->{'topic'};
                    if (!$sig_ast) {}
                    else {
                        ref($sig_ast) eq 'Perlito5::AST::Decl' && ($sig_ast = $sig_ast->{'var'});
                        @sig = ('->', $sig_ast->emit_perl6())
                    }
                    push(@out, ['stmt' => ['keyword' => $keyword], $cond, @sig, Perlito5::Perl6::emit_perl6_block($self->{'body'}->stmts())]);
                    if ($self->{'continue'} && @{$self->{'continue'}->{'stmts'}}) {
                        push(@out, ['stmt' => ['keyword' => 'continue'], Perlito5::Perl6::emit_perl6_block($self->{'continue'}->{'stmts'})])
                    }
                    return @out
                }
            }
            package Perlito5::AST::Decl;
            {
                sub Perlito5::AST::Decl::emit_perl6 {
                    my $self = $_[0];
                    return ['op' => 'prefix:<' . $self->{'decl'} . '>', ($self->{'type'} ? $self->{'type'} : ()), $self->{'var'}->emit_perl6()]
                }
            }
            package Perlito5::AST::Sub;
            {
                sub Perlito5::AST::Sub::emit_perl6 {
                    my $self = $_[0];
                    Perlito5::Perl6::TreeGrammar::->refactor_sub_arguments($self);
                    my @parts;
                    if ($self->{'args'}) {
                        push(@parts, ['paren' => '(', (map {
                            ['var' => $_->emit_perl6(), '?']
                        } @{$self->{'args'}}), ['var' => '*@_']])
                    }
                    else {
                        push(@parts, ['paren' => '(', ['var' => '*@_']])
                    }
                    defined($self->{'block'}) && push(@parts, Perlito5::Perl6::emit_perl6_block($self->{'block'}->{'stmts'}));
                    !$self->{'name'} && return ['op' => 'prefix:<sub>', @parts];
                    my $is_our = 1;
                    $self->{'decl'} eq 'my' && ($is_our = 0);
                    my $name = $self->{'name'};
                    if ($Perlito5::PKG_NAME ne $self->{'namespace'}) {
                        $name = $self->{'namespace'} . '::' . $name;
                        $is_our = 0
                    }
                    if ($is_our) {
                        return ['stmt' => ['keyword' => 'our'], ['keyword' => 'sub'], ['bareword' => $name], @parts]
                    }
                    else {
                        return ['stmt' => ['keyword' => 'sub'], ['bareword' => $name], @parts]
                    }
                }
            }
            package Perlito5::AST::Use;
            {
                sub Perlito5::AST::Use::emit_perl6 {
                    my $self = shift;
                    Perlito5::Grammar::Use::emit_time_eval($self);
                    return ['comment' => '# ' . $self->{'code'} . ' ' . $self->{'mod'}]
                }
            }
            1
        }
    }
    {
        {
            package main;
            package Perlito5::Perl6::PrettyPrinter;
            # use strict
            undef();
            my %dispatch = ('stmt' => sub {
                statement(@_)
            }, 'stmt_modifier' => sub {
                statement_modifier(@_)
            }, 'block' => sub {
                block(@_)
            }, 'keyword' => sub {
                keyword(@_)
            }, 'bareword' => sub {
                bareword(@_)
            }, 'number' => sub {
                number(@_)
            }, 'op' => sub {
                op(@_)
            }, 'paren' => sub {
                paren(@_)
            }, 'paren_semicolon' => sub {
                paren_semicolon(@_)
            }, 'apply' => sub {
                apply(@_)
            }, 'call' => sub {
                call(@_)
            }, 'comment' => sub {
                comment(@_)
            }, 'label' => sub {
                label(@_)
            }, 'var' => sub {
                var(@_)
            });
            my %pair = ('(' => ')', '[' => ']', '{' => '}');
            our %op = ('prefix:<$>' => {'fix' => 'deref', 'prec' => 0, 'str' => '$'}, 'prefix:<@>' => {'fix' => 'deref', 'prec' => 0, 'str' => '@'}, 'prefix:<%>' => {'fix' => 'deref', 'prec' => 0, 'str' => '%'}, 'prefix:<&>' => {'fix' => 'deref', 'prec' => 0, 'str' => '&'}, 'prefix:<*>' => {'fix' => 'deref', 'prec' => 0, 'str' => '*'}, 'prefix:<$#>' => {'fix' => 'deref', 'prec' => 0, 'str' => '$#'}, 'circumfix:<[ ]>' => {'fix' => 'circumfix', 'prec' => 0, 'str' => '['}, 'circumfix:<{ }>' => {'fix' => 'circumfix', 'prec' => 0, 'str' => '{'}, 'circumfix:<( )>' => {'fix' => 'circumfix', 'prec' => 0, 'str' => '('}, 'infix:<.>' => {'fix' => 'infix', 'prec' => -1, 'str' => '.'}, 'prefix:<-->' => {'fix' => 'prefix', 'prec' => 1, 'str' => '--'}, 'prefix:<++>' => {'fix' => 'prefix', 'prec' => 1, 'str' => '++'}, 'postfix:<-->' => {'fix' => 'postfix', 'prec' => 1, 'str' => '--'}, 'postfix:<++>' => {'fix' => 'postfix', 'prec' => 1, 'str' => '++'}, 'infix:<**>' => {'fix' => 'infix', 'prec' => 2, 'str' => '**'}, 'p6_prefix:<^>' => {'fix' => 'prefix', 'prec' => 3, 'str' => '^'}, 'prefix:<' . chr(92) . '>' => {'fix' => 'prefix', 'prec' => 3, 'str' => chr(92)}, 'prefix:<+>' => {'fix' => 'prefix', 'prec' => 3, 'str' => '+'}, 'prefix:<->' => {'fix' => 'prefix', 'prec' => 3, 'str' => '-'}, 'prefix:<~>' => {'fix' => 'prefix', 'prec' => 3, 'str' => '~'}, 'prefix:<!>' => {'fix' => 'prefix', 'prec' => 3, 'str' => '!'}, 'infix:<=~>' => {'fix' => 'infix', 'prec' => 4, 'str' => ' =~ '}, 'infix:<!~>' => {'fix' => 'infix', 'prec' => 4, 'str' => ' !~ '}, 'infix:<*>' => {'fix' => 'infix', 'prec' => 5, 'str' => ' * '}, 'infix:</>' => {'fix' => 'infix', 'prec' => 5, 'str' => ' / '}, 'infix:<%>' => {'fix' => 'infix', 'prec' => 5, 'str' => ' % '}, 'infix:<+>' => {'fix' => 'infix', 'prec' => 6, 'str' => ' + '}, 'infix:<->' => {'fix' => 'infix', 'prec' => 6, 'str' => ' - '}, 'infix:<x>' => {'fix' => 'infix', 'prec' => 8, 'str' => ' x '}, 'infix:<xx>' => {'fix' => 'infix', 'prec' => 8, 'str' => ' xx '}, 'list:<~>' => {'fix' => 'list', 'prec' => 10, 'str' => ' ~ '}, 'infix:<~>' => {'fix' => 'infix', 'prec' => 10, 'str' => ' ~ '}, 'infix:<<<>' => {'fix' => 'infix', 'prec' => 12, 'str' => ' << '}, 'infix:<>>>' => {'fix' => 'infix', 'prec' => 12, 'str' => ' >> '}, 'infix:<lt>' => {'fix' => 'infix', 'prec' => 90, 'str' => ' lt '}, 'infix:<le>' => {'fix' => 'infix', 'prec' => 90, 'str' => ' le '}, 'infix:<gt>' => {'fix' => 'infix', 'prec' => 90, 'str' => ' gt '}, 'infix:<ge>' => {'fix' => 'infix', 'prec' => 90, 'str' => ' ge '}, 'infix:<<=>' => {'fix' => 'infix', 'prec' => 90, 'str' => ' <= '}, 'infix:<>=>' => {'fix' => 'infix', 'prec' => 90, 'str' => ' >= '}, 'infix:<<>' => {'fix' => 'infix', 'prec' => 90, 'str' => ' < '}, 'infix:<>>' => {'fix' => 'infix', 'prec' => 90, 'str' => ' > '}, 'infix:<<=>>' => {'fix' => 'infix', 'prec' => 100, 'str' => ' <=> '}, 'infix:<cmp>' => {'fix' => 'infix', 'prec' => 100, 'str' => ' cmp '}, 'infix:<leq>' => {'fix' => 'infix', 'prec' => 100, 'str' => ' leq '}, 'infix:<==>' => {'fix' => 'infix', 'prec' => 100, 'str' => ' == '}, 'infix:<!=>' => {'fix' => 'infix', 'prec' => 100, 'str' => ' != '}, 'infix:<ne>' => {'fix' => 'infix', 'prec' => 100, 'str' => ' ne '}, 'infix:<eq>' => {'fix' => 'infix', 'prec' => 100, 'str' => ' eq '}, 'infix:<&>' => {'fix' => 'infix', 'prec' => 110, 'str' => ' & '}, 'infix:<|>' => {'fix' => 'infix', 'prec' => 120, 'str' => ' | '}, 'infix:<^>' => {'fix' => 'infix', 'prec' => 120, 'str' => ' ^ '}, 'infix:<..>' => {'fix' => 'infix', 'prec' => 130, 'str' => ' .. '}, 'infix:<...>' => {'fix' => 'infix', 'prec' => 130, 'str' => ' ... '}, 'infix:<~~>' => {'fix' => 'infix', 'prec' => 130, 'str' => ' ~~ '}, 'infix:<&&>' => {'fix' => 'infix', 'prec' => 140, 'str' => ' && '}, 'infix:<||>' => {'fix' => 'infix', 'prec' => 150, 'str' => ' || '}, 'infix:<//>' => {'fix' => 'infix', 'prec' => 150, 'str' => ' // '}, 'ternary:<?? !!>' => {'fix' => 'ternary', 'prec' => 160}, 'infix:<=>' => {'fix' => 'infix', 'prec' => 170, 'str' => ' = '}, 'infix:<**=>' => {'fix' => 'infix', 'prec' => 170, 'str' => ' **= '}, 'infix:<+=>' => {'fix' => 'infix', 'prec' => 170, 'str' => ' += '}, 'infix:<-=>' => {'fix' => 'infix', 'prec' => 170, 'str' => ' -= '}, 'infix:<*=>' => {'fix' => 'infix', 'prec' => 170, 'str' => ' *= '}, 'infix:</=>' => {'fix' => 'infix', 'prec' => 170, 'str' => ' /= '}, 'infix:<x=>' => {'fix' => 'infix', 'prec' => 170, 'str' => ' x= '}, 'infix:<|=>' => {'fix' => 'infix', 'prec' => 170, 'str' => ' |= '}, 'infix:<&=>' => {'fix' => 'infix', 'prec' => 170, 'str' => ' &= '}, 'infix:<.=>' => {'fix' => 'infix', 'prec' => 170, 'str' => ' .= '}, 'infix:<<<=>' => {'fix' => 'infix', 'prec' => 170, 'str' => ' <<= '}, 'infix:<>>=>' => {'fix' => 'infix', 'prec' => 170, 'str' => ' >>= '}, 'infix:<%=>' => {'fix' => 'infix', 'prec' => 170, 'str' => ' %= '}, 'infix:<||=>' => {'fix' => 'infix', 'prec' => 170, 'str' => ' ||= '}, 'infix:<&&=>' => {'fix' => 'infix', 'prec' => 170, 'str' => ' &&= '}, 'infix:<^=>' => {'fix' => 'infix', 'prec' => 170, 'str' => ' ^= '}, 'infix:<//=>' => {'fix' => 'infix', 'prec' => 170, 'str' => ' //= '}, 'infix:<~=>' => {'fix' => 'infix', 'prec' => 170, 'str' => ' ~= '}, 'infix:<=>>' => {'fix' => 'infix', 'prec' => 180, 'str' => ' => '}, 'list:<,>' => {'fix' => 'list', 'prec' => 190, 'str' => ', '}, 'infix:<:>' => {'fix' => 'infix', 'prec' => 190, 'str' => ':'}, 'prefix:<not>' => {'fix' => 'prefix', 'prec' => 200, 'str' => ' not '}, 'infix:<and>' => {'fix' => 'infix', 'prec' => 210, 'str' => ' and '}, 'infix:<or>' => {'fix' => 'infix', 'prec' => 220, 'str' => ' or '}, 'infix:<xor>' => {'fix' => 'infix', 'prec' => 220, 'str' => ' xor '});
            $op{'prefix:<' . $_ . '>'} = {'fix' => 'prefix', 'prec' => 8, 'str' => $_ . ' '}
                for '-r', '-w', '-x', '-o', '-R', '-W', '-X', '-O', '-e', '-z', '-s', '-f', '-d', '-l', '-p', '-S', '-b', '-c', '-t', '-u', '-g', '-k', '-T', '-B', '-M', '-A', '-C';
            $op{'prefix:<' . $_ . '>'} = {'fix' => 'parsed', 'prec' => 8, 'str' => $_}
                for 'do', 'sub', 'my', 'our', 'state', 'local', 'map', 'grep', 'sort';
            my %tab;
            sub Perlito5::Perl6::PrettyPrinter::tab {
                my $level = $_[0];
                $tab{$level} //= '    ' x $level
            }
            sub Perlito5::Perl6::PrettyPrinter::render {
                my($data, $level, $out) = @_;
                if (ref($data)) {
                    $dispatch{$data->[0]}->($data, $level, $out)
                }
                else {
                    push(@{$out}, $data)
                }
            }
            sub Perlito5::Perl6::PrettyPrinter::op_precedence {
                my($data) = @_;
                !ref($data) && return 0;
                $data->[0] ne 'op' && return 0;
                return $op{$data->[1]}->{'prec'} || 0
            }
            sub Perlito5::Perl6::PrettyPrinter::statement_need_semicolon {
                my($data) = @_;
                !ref($data) && return 1;
                ($data->[0] eq 'block' || $data->[0] eq 'comment' || $data->[0] eq 'label') && return 0;
                if ($data->[0] eq 'stmt') {
                    if (ref($data->[1])) {
                        my $dd = $data->[1];
                        if ($dd->[0] eq 'keyword') {
                            ref($data->[-1]) && $data->[-1]->[0] eq 'block' && return 0
                        }
                    }
                }
                return 1
            }
            sub Perlito5::Perl6::PrettyPrinter::op_render {
                my($data, $level, $out, $current_op) = @_;
                if (ref($data)) {
                    my $this_prec = op_precedence($data);
                    $this_prec && $current_op->{'prec'} && $current_op->{'prec'} < $this_prec && push(@{$out}, '(');
                    render($data, $level, $out);
                    $this_prec && $current_op->{'prec'} && $current_op->{'prec'} < $this_prec && push(@{$out}, ')')
                }
                else {
                    push(@{$out}, $data)
                }
            }
            sub Perlito5::Perl6::PrettyPrinter::op {
                my($data, $level, $out) = @_;
                my $op = $data->[1];
                my $spec = $op{$op} || die('unknown op: ' . $op);
                if ($spec->{'fix'} eq 'infix') {
                    op_render($data->[2], $level, $out, $spec);
                    push(@{$out}, $spec->{'str'});
                    op_render($data->[3], $level, $out, $spec)
                }
                elsif ($spec->{'fix'} eq 'prefix') {
                    push(@{$out}, $spec->{'str'});
                    op_render($data->[2], $level, $out, $spec)
                }
                elsif ($spec->{'fix'} eq 'postfix') {
                    op_render($data->[2], $level, $out, $spec);
                    push(@{$out}, $spec->{'str'})
                }
                elsif ($spec->{'fix'} eq 'ternary') {
                    op_render($data->[2], $level, $out, $spec);
                    push(@{$out}, ' ?? ');
                    op_render($data->[3], $level, $out, $spec);
                    push(@{$out}, ' !! ');
                    op_render($data->[4], $level, $out, $spec)
                }
                elsif ($spec->{'fix'} eq 'deref') {
                    push(@{$out}, $spec->{'str'}, '(');
                    op_render($data->[2], $level, $out, $spec);
                    push(@{$out}, ')')
                }
                elsif ($spec->{'fix'} eq 'circumfix') {
                    push(@{$out}, $spec->{'str'});
                    for my $line (2 .. $#{$data}) {
                        op_render($data->[$line], $level, $out, $spec);
                        $line != $#{$data} && push(@{$out}, ', ')
                    }
                    push(@{$out}, $pair{$spec->{'str'}})
                }
                elsif ($spec->{'fix'} eq 'list') {
                    for my $line (2 .. $#{$data}) {
                        op_render($data->[$line], $level, $out, $spec);
                        $line != $#{$data} && push(@{$out}, $spec->{'str'})
                    }
                }
                elsif ($spec->{'fix'} eq 'parsed') {
                    push(@{$out}, $spec->{'str'});
                    for my $line (2 .. $#{$data}) {
                        my $d = $data->[$line];
                        push(@{$out}, ' ');
                        render($d, $level, $out)
                    }
                }
                else {
                    die('unknown fixity: ' . $spec->{'fix'})
                }
                return 
            }
            sub Perlito5::Perl6::PrettyPrinter::call {
                my($data, $level, $out) = @_;
                my @dd = @{$data};
                shift(@dd);
                my $open = '(';
                render(shift(@dd), $level, $out);
                push(@{$out}, '.');
                my $d = $dd[0];
                render($d, $level, $out);
                if ($open eq '(' && @dd == 1) {
                    return 
                }
                $dd[0] = 'list:<,>';
                push(@{$out}, $open);
                op(['op' => @dd], $level, $out);
                push(@{$out}, $pair{$open})
            }
            sub Perlito5::Perl6::PrettyPrinter::apply {
                my($data, $level, $out) = @_;
                my @dd = @{$data};
                shift(@dd);
                my $open = shift(@dd);
                my $d = $dd[0];
                render($d, $level, $out);
                if ($open eq '(' && @dd == 1) {
                    return 
                }
                $dd[0] = 'list:<,>';
                push(@{$out}, $open);
                op(['op' => @dd], $level, $out);
                push(@{$out}, $pair{$open})
            }
            sub Perlito5::Perl6::PrettyPrinter::paren {
                my($data, $level, $out) = @_;
                my @dd = @{$data};
                shift(@dd);
                my $open = $dd[0];
                $dd[0] = 'list:<,>';
                push(@{$out}, $open);
                op(['op' => @dd], $level, $out);
                push(@{$out}, $pair{$open})
            }
            sub Perlito5::Perl6::PrettyPrinter::paren_semicolon {
                my($data, $level, $out) = @_;
                push(@{$out}, $data->[1]);
                for my $line (2 .. $#{$data}) {
                    @{$data->[$line]} && render($data->[$line], $level, $out);
                    if ($line != $#{$data}) {
                        if (@{$data->[$line + 1]}) {
                            push(@{$out}, '; ')
                        }
                        else {
                            push(@{$out}, ';')
                        }
                    }
                }
                push(@{$out}, $pair{$data->[1]})
            }
            sub Perlito5::Perl6::PrettyPrinter::var {
                my($data, $level, $out) = @_;
                push(@{$out}, @{$data}[1 .. $#{$data}]);
                return 
            }
            sub Perlito5::Perl6::PrettyPrinter::label {
                my($data, $level, $out) = @_;
                push(@{$out}, $data->[1], ':');
                return 
            }
            sub Perlito5::Perl6::PrettyPrinter::keyword {
                my($data, $level, $out) = @_;
                push(@{$out}, $data->[1]);
                return 
            }
            sub Perlito5::Perl6::PrettyPrinter::bareword {
                my($data, $level, $out) = @_;
                push(@{$out}, $data->[1]);
                return 
            }
            sub Perlito5::Perl6::PrettyPrinter::number {
                my($data, $level, $out) = @_;
                push(@{$out}, $data->[1]);
                return 
            }
            sub Perlito5::Perl6::PrettyPrinter::comment {
                my($data, $level, $out) = @_;
                push(@{$out}, $data->[1]);
                return 
            }
            sub Perlito5::Perl6::PrettyPrinter::statement {
                my($data, $level, $out) = @_;
                for my $line (1 .. $#{$data}) {
                    my $d = $data->[$line];
                    render($d, $level, $out);
                    $line != $#{$data} && push(@{$out}, ' ')
                }
            }
            sub Perlito5::Perl6::PrettyPrinter::statement_modifier {
                my($data, $level, $out) = @_;
                render($data->[1], $level, $out);
                push(@{$out}, chr(10), tab($level + 1));
                render($data->[2], $level, $out)
            }
            sub Perlito5::Perl6::PrettyPrinter::block {
                my($data, $level, $out) = @_;
                if (@{$data} == 1) {
                    push(@{$out}, '{}');
                    return 
                }
                push(@{$out}, '{', chr(10));
                $level++;
                for my $line (1 .. $#{$data}) {
                    my $d = $data->[$line];
                    push(@{$out}, tab($level));
                    render($d, $level, $out);
                    $line != $#{$data} && statement_need_semicolon($d) && push(@{$out}, ';');
                    push(@{$out}, chr(10))
                }
                $level--;
                push(@{$out}, tab($level), '}')
            }
            sub Perlito5::Perl6::PrettyPrinter::pretty_print {
                my($data, $level, $out) = @_;
                for my $line (0 .. $#{$data}) {
                    my $d = $data->[$line];
                    push(@{$out}, tab($level));
                    render($d, $level, $out);
                    $line != $#{$data} && statement_need_semicolon($d) && push(@{$out}, ';');
                    push(@{$out}, chr(10))
                }
            }
            1
        }
    }
    {
        {
            package main;
            undef();
            undef();
            package Perlito5::XS;
            {
                sub Perlito5::XS::tab {
                    my $level = shift;
                    '    ' x $level
                }
                my %safe_char = (' ' => 1, '!' => 1, '"' => 1, '#' => 1, '$' => 1, '%' => 1, '&' => 1, '(' => 1, ')' => 1, '*' => 1, '+' => 1, ',' => 1, '-' => 1, '.' => 1, '/' => 1, ':' => 1, ';' => 1, '<' => 1, '=' => 1, '>' => 1, '?' => 1, '@' => 1, '[' => 1, ']' => 1, '^' => 1, '_' => 1, '`' => 1, '{' => 1, '|' => 1, '}' => 1, '~' => 1);
                sub Perlito5::XS::escape_string {
                    my $s = shift;
                    my $tmp = '';
                    $s eq '' && return '""';
                    for my $i (0 .. length($s) - 1) {
                        my $c = substr($s, $i, 1);
                        if (($c ge 'a' && $c le 'z') || ($c ge 'A' && $c le 'Z') || ($c ge 0 && $c le 9) || exists($safe_char{$c})) {
                            $tmp = $tmp . $c
                        }
                        else {
                            $tmp .= sprintf(chr(92) . 'x%02x', ord($c))
                        }
                    }
                    return '"' . $tmp . '"'
                }
            }
            package Perlito5::AST::CompUnit;
            {
                sub Perlito5::AST::CompUnit::emit_xs {
                    my $self = $_[0];
                    my $level = $_[1];
                    my @body;
                    for $_ (@{$self->{'body'}}) {
                        if (defined($_)) {
                            push(@body, $_)
                        }
                    }
                    join(chr(10), map(Perlito5::XS::tab($level) . $_->emit_xs($level), @body)) . chr(10) . chr(10) . chr(10)
                }
                sub Perlito5::AST::CompUnit::emit_xs_program {
                    my $comp_units = $_[0];
                    my $str = Perlito5::Compiler::do_not_edit('/*') . '*/' . chr(10) . '#include "EXTERN.h"' . chr(10) . '#include "perl.h"' . chr(10) . '#include "XSUB.h"' . chr(10) . chr(10);
                    for my $comp_unit (@{$comp_units}) {
                        $str .= $comp_unit->emit_xs(0)
                    }
                    $str .= chr(10);
                    return $str
                }
            }
            package Perlito5::AST::Int;
            {
                sub Perlito5::AST::Int::emit_xs {
                    my $self = $_[0];
                    my $level = $_[1];
                    'newSViv(' . $self->{'int'} . ')'
                }
            }
            package Perlito5::AST::Num;
            {
                sub Perlito5::AST::Num::emit_xs {
                    my $self = $_[0];
                    my $level = $_[1];
                    'newSVnv(' . $self->{'num'} . ')'
                }
            }
            package Perlito5::AST::Buf;
            {
                sub Perlito5::AST::Buf::emit_xs {
                    my $self = $_[0];
                    my $level = $_[1];
                    'newSVpv(' . Perlito5::XS::escape_string($self->{'buf'}) . ', 0)'
                }
            }
            package Perlito5::AST::Block;
            {
                sub Perlito5::AST::Block::emit_xs {
                    my $self = $_[0];
                    my $level = $_[1];
                    'do {{' . chr(10) . join(';' . chr(10), map(Perlito5::XS::tab($level + 1) . $_->emit_xs($level + 1), @{$self->{'stmts'}})) . chr(10) . Perlito5::XS::tab($level) . '}}'
                }
            }
            package Perlito5::AST::Index;
            {
                sub Perlito5::AST::Index::emit_xs {
                    my $self = $_[0];
                    my $level = $_[1];
                    if ($self->{'obj'}->isa('Perlito5::AST::Var') && $self->{'obj'}->sigil() eq '$') {
                        my $v = $self->{'obj'};
                        return $v->emit_xs($level) . '[' . $self->{'index_exp'}->emit_xs($level + 1) . ']'
                    }
                    if ($self->{'obj'}->isa('Perlito5::AST::Apply') && $self->{'obj'}->{'code'} eq 'prefix:<$>') {
                        return $self->{'obj'}->{'arguments'}->[0]->emit_xs($level) . '->[' . $self->{'index_exp'}->emit_xs($level) . ']'
                    }
                    $self->{'obj'}->emit_xs($level) . '->[' . $self->{'index_exp'}->emit_xs($level + 1) . ']'
                }
            }
            package Perlito5::AST::Lookup;
            {
                sub Perlito5::AST::Lookup::emit_xs {
                    my $self = $_[0];
                    my $level = $_[1];
                    if ($self->{'obj'}->isa('Perlito5::AST::Var') && $self->{'obj'}->sigil() eq '$') {
                        my $v = $self->{'obj'};
                        return $v->emit_xs($level) . '{' . $self->autoquote($self->{'index_exp'})->emit_xs($level) . '}'
                    }
                    if ($self->{'obj'}->isa('Perlito5::AST::Apply') && $self->{'obj'}->{'code'} eq 'prefix:<$>') {
                        return $self->{'obj'}->{'arguments'}->[0]->emit_xs($level) . '->{' . $self->autoquote($self->{'index_exp'})->emit_xs($level) . '}'
                    }
                    $self->{'obj'}->emit_xs($level) . '->{' . $self->autoquote($self->{'index_exp'})->emit_xs($level) . '}'
                }
            }
            package Perlito5::AST::Var;
            {
                sub Perlito5::AST::Var::emit_xs {
                    my $self = $_[0];
                    my $level = $_[1];
                    my $str_name = $self->{'name'};
                    $str_name eq chr(92) && ($str_name = chr(92) . chr(92));
                    $str_name eq '"' && ($str_name = chr(92) . '"');
                    my $ns = '';
                    if (0 && $self->{'namespace'}) {
                        if ($self->{'namespace'} eq 'main' && substr($self->{'name'}, 0, 1) eq '^') {
                            return $self->{'sigil'} . '{' . $self->{'name'} . '}'
                        }
                        else {
                            $ns = $self->{'namespace'} . '::'
                        }
                    }
                    my $c = substr($self->{'name'}, 0, 1);
                    if (($c ge 'a' && $c le 'z') || ($c ge 'A' && $c le 'Z') || ($c eq '_')) {
                        return $self->{'name'};
                        $self->{'sigil'} = '*';
                        return $self->{'sigil'} . $ns . $self->{'name'}
                    }
                    return $self->{'sigil'} . '{' . chr(39) . $ns . $str_name . chr(39) . '}'
                }
            }
            package Perlito5::AST::Call;
            {
                sub Perlito5::AST::Call::emit_xs {
                    my $self = $_[0];
                    my $level = $_[1];
                    my $invocant = $self->{'invocant'}->emit_xs();
                    if ($self->{'method'} eq 'postcircumfix:<[ ]>') {
                        return $invocant . '->[' . $self->{'arguments'}->emit_xs($level + 1) . ']'
                    }
                    if ($self->{'method'} eq 'postcircumfix:<{ }>') {
                        return $invocant . '->{' . Perlito5::AST::Lookup::->autoquote($self->{'arguments'})->emit_xs($level) . '}'
                    }
                    my $meth = $self->{'method'};
                    if ($meth eq 'postcircumfix:<( )>') {
                        $meth = ''
                    }
                    if (ref($meth) eq 'Perlito5::AST::Var') {
                        $meth = $meth->emit_xs($level + 1)
                    }
                    $invocant . '->' . $meth . '(' . join(', ', map($_->emit_xs($level + 1), @{$self->{'arguments'}})) . ')'
                }
            }
            package Perlito5::AST::Apply;
            {
                my %op_prefix_xs = ('say' => 'say', 'keys' => 'keys', 'values' => 'values', 'prefix:<!>' => '!', 'prefix:<++>' => '++', 'prefix:<-->' => '--', 'prefix:<+>' => '+', 'prefix:<->' => '-', 'prefix:<-d>' => '-d', 'prefix:<-e>' => '-e', 'prefix:<-f>' => '-f', 'prefix:<not>' => 'not', 'prefix:<~>' => '~');
                my %op_infix_xs = ('list:<,>' => ', ', 'list:<.>' => ' . ', 'infix:<+>' => ' + ', 'infix:<->' => ' - ', 'infix:<*>' => ' * ', 'infix:</>' => ' / ', 'infix:<%>' => ' % ', 'infix:<**>' => ' ** ', 'infix:<>>' => ' > ', 'infix:<<>' => ' < ', 'infix:<>=>' => ' >= ', 'infix:<<=>' => ' <= ', 'infix:<&>' => ' & ', 'infix:<|>' => ' | ', 'infix:<^>' => ' ^ ', 'infix:<&&>' => ' && ', 'infix:<||>' => ' || ', 'infix:<and>' => ' and ', 'infix:<or>' => ' or ', 'infix:<//>' => ' // ', 'infix:<eq>' => ' eq ', 'infix:<ne>' => ' ne ', 'infix:<le>' => ' le ', 'infix:<ge>' => ' ge ', 'infix:<lt>' => ' lt ', 'infix:<gt>' => ' gt ', 'infix:<==>' => ' == ', 'infix:<!=>' => ' != ', 'infix:<=~>' => ' =~ ', 'infix:<!~>' => ' !~ ');
                sub Perlito5::AST::Apply::emit_xs {
                    my $self = $_[0];
                    my $level = $_[1];
                    my $apply = $self->op_assign();
                    if ($apply) {
                        return $apply->emit_xs($level)
                    }
                    my $ns = '';
                    if ($self->{'namespace'}) {
                        $ns = $self->{'namespace'} . '::'
                    }
                    my $code = $ns . $self->{'code'};
                    if (ref($code) ne '') {
                        return '(' . $self->{'code'}->emit_xs($level + 1) . ')->(' . join(', ', map($_->emit_xs($level + 1), @{$self->{'arguments'}})) . ')'
                    }
                    if (exists($op_infix_xs{$code})) {
                        return '(' . join($op_infix_xs{$code}, (map($_->emit_xs($level + 1), @{$self->{'arguments'}}))) . ')'
                    }
                    if (exists($op_prefix_xs{$code})) {
                        return $op_prefix_xs{$code} . '(' . join(', ', map($_->emit_xs($level + 1), @{$self->{'arguments'}})) . ')'
                    }
                    if ($self->{'code'} eq 'p5:s') {
                        return 's!' . $self->{'arguments'}->[0]->{'buf'} . '!' . $self->{'arguments'}->[1]->{'buf'} . '!' . $self->{'arguments'}->[2]
                    }
                    if ($self->{'code'} eq 'p5:m') {
                        my $s;
                        if ($self->{'arguments'}->[0]->isa('Perlito5::AST::Buf')) {
                            $s = $self->{'arguments'}->[0]->{'buf'}
                        }
                        else {
                            for my $ast (@{$self->{'arguments'}->[0]->{'arguments'}}) {
                                if ($ast->isa('Perlito5::AST::Buf')) {
                                    $s .= $ast->{'buf'}
                                }
                                else {
                                    $s .= $ast->emit_xs($level + 1)
                                }
                            }
                        }
                        return 'm!' . $s . '!' . $self->{'arguments'}->[1]
                    }
                    if ($self->{'code'} eq 'p5:tr') {
                        return 'tr!' . $self->{'arguments'}->[0]->{'buf'} . '!' . $self->{'arguments'}->[1]->{'buf'} . '!'
                    }
                    if ($code eq '__PACKAGE__') {
                        return '"' . $Perlito5::PKG_NAME . '"'
                    }
                    if ($self->{'code'} eq 'package') {
                        return 'MODULE = ' . $self->{'namespace'} . ' PACKAGE = ' . $self->{'namespace'}
                    }
                    if ($code eq 'undef') {
                        return 'undef()'
                    }
                    if ($code eq 'scalar') {
                        return 'scalar(' . ($self->{'arguments'}->[0]->emit_xs()) . ')'
                    }
                    if ($code eq 'pop') {
                        return 'pop(' . ($self->{'arguments'}->[0]->emit_xs()) . ')'
                    }
                    if ($code eq 'push') {
                        return 'push(' . ($self->{'arguments'}->[0]->emit_xs()) . ', ' . ($self->{'arguments'}->[1])->emit_xs($level + 1) . ' )'
                    }
                    if ($code eq 'shift') {
                        if ($self->{'arguments'} && @{$self->{'arguments'}}) {
                            return 'shift(' . join(' ', map($_->emit_xs($level + 1), @{$self->{'arguments'}})) . ')'
                        }
                        return 'shift()'
                    }
                    if ($code eq 'unshift') {
                        return 'unshift(' . $self->{'arguments'}->[0]->emit_xs($level + 1) . ', ' . $self->{'arguments'}->[1]->emit_xs($level + 1) . ')'
                    }
                    if ($code eq 'map') {
                        if ($self->{'special_arg'}) {
                            return 'map {' . chr(10) . join(';' . chr(10), map {
                                Perlito5::XS::tab($level + 1) . $_->emit_xs($level + 1)
                            } @{$self->{'special_arg'}->{'stmts'}}) . chr(10) . Perlito5::XS::tab($level) . '} ' . join(',', map {
                                $_->emit_xs($level + 1)
                            } @{$self->{'arguments'}})
                        }
                        my $str = shift(@{$self->{'arguments'}});
                        return 'map(' . $str->emit_xs($level + 1) . ', ' . join(',', map {
                            $_->emit_xs($level + 1)
                        } @{$self->{'arguments'}}) . ')'
                    }
                    if ($code eq 'infix:<x>') {
                        return 'join("", ' . join(' x ', map($_->emit_xs($level + 1), @{$self->{'arguments'}})) . ')'
                    }
                    if ($code eq 'infix:<=>>') {
                        return Perlito5::AST::Lookup::->autoquote($self->{'arguments'}->[0])->emit_xs($level) . ', ' . $self->{'arguments'}->[1]->emit_xs($level)
                    }
                    if ($code eq 'join') {
                        my $str = shift(@{$self->{'arguments'}});
                        return 'join(' . $str->emit_xs() . ', ' . join(',', map($_->emit_xs($level + 1), @{$self->{'arguments'}})) . ')'
                    }
                    if ($code eq 'circumfix:<[ ]>') {
                        return '[' . join(', ', map($_->emit_xs($level + 1), @{$self->{'arguments'}})) . ']'
                    }
                    if ($code eq 'circumfix:<{ }>') {
                        return '{' . join(', ', map($_->emit_xs($level + 1), @{$self->{'arguments'}})) . '}'
                    }
                    if ($code eq 'prefix:<' . chr(92) . '>') {
                        return chr(92) . join(' ', map($_->emit_xs($level + 1), @{$self->{'arguments'}})) . ''
                    }
                    if ($code eq 'prefix:<$>') {
                        return '${' . join(' ', map($_->emit_xs($level + 1), @{$self->{'arguments'}})) . '}'
                    }
                    if ($code eq 'prefix:<@>') {
                        return '@{' . join(' ', map($_->emit_xs($level + 1), @{$self->{'arguments'}})) . '}'
                    }
                    if ($code eq 'prefix:<%>') {
                        return '%{' . join(' ', map($_->emit_xs($level + 1), @{$self->{'arguments'}})) . '}'
                    }
                    if ($code eq 'prefix:<&>') {
                        return '&{' . join(' ', map($_->emit_xs($level + 1), @{$self->{'arguments'}})) . '}'
                    }
                    if ($code eq 'prefix:<$#>') {
                        return '$#{' . join(' ', map($_->emit_xs($level + 1), @{$self->{'arguments'}})) . '}'
                    }
                    if ($code eq 'postfix:<++>') {
                        return '(' . join(' ', map($_->emit_xs($level + 1), @{$self->{'arguments'}})) . ')++'
                    }
                    if ($code eq 'postfix:<-->') {
                        return '(' . join(' ', map($_->emit_xs($level + 1), @{$self->{'arguments'}})) . ')--'
                    }
                    if ($code eq 'infix:<..>') {
                        return '(' . join(' .. ', map($_->emit_xs($level + 1), @{$self->{'arguments'}})) . ')'
                    }
                    if ($code eq 'ternary:<? :>') {
                        return '(' . $self->{'arguments'}->[0]->emit_xs($level + 1) . ' ? ' . $self->{'arguments'}->[1]->emit_xs($level + 1) . ' : ' . $self->{'arguments'}->[2]->emit_xs($level + 1) . ')'
                    }
                    if ($code eq 'circumfix:<( )>') {
                        return '(' . join(', ', map($_->emit_xs($level + 1), @{$self->{'arguments'}})) . ')'
                    }
                    if ($code eq 'infix:<=>') {
                        return emit_xs_bind($self->{'arguments'}->[0], $self->{'arguments'}->[1], $level)
                    }
                    if ($code eq 'require') {
                        return 'Perlito5::Grammar::Use::require(' . $self->{'arguments'}->[0]->emit_xs($level + 1) . ')'
                    }
                    if ($code eq 'do') {
                        my $ast = Perlito5::AST::Apply::->new('code' => 'eval', 'namespace' => '', 'arguments' => [Perlito5::AST::Apply::->new('code' => 'do_file', 'namespace' => 'Perlito5::Grammar::Use', 'arguments' => $self->{'arguments'})]);
                        return $ast->emit_xs($level)
                    }
                    if ($code eq 'eval') {
                        my $arg = $self->{'arguments'}->[0];
                        my $eval;
                        if ($arg->isa('Perlito5::AST::Block')) {
                            $eval = $arg->emit_xs($level + 1)
                        }
                        else {
                            $eval = '(do { ' . 'my $m = Perlito5::Grammar::exp_stmts(' . $arg->emit_xs($level + 1, 'scalar') . ', 0);' . 'my $source; ' . '$source .= (defined $_ ? $_->emit_xs(0, "scalar") : "") . ";' . chr(92) . 'n" ' . 'for @{ Perlito5::Match::flat($m) }; ' . 'eval $source;' . '})'
                        }
                        return $eval
                    }
                    if ($code eq 'return') {
                        return 'PUSHs(' . join(', ', map($_->emit_xs($level + 1), @{$self->{'arguments'}})) . ')'
                    }
                    if ($code eq 'print') {
                        return 'puts( SvPVx_nolen( ' . join(', ', map($_->emit_xs($level + 1), @{$self->{'arguments'}})) . ') )'
                    }
                    if ($code eq 'warn') {
                        return 'warn( SvPVx_nolen( ' . join(', ', map($_->emit_xs($level + 1), @{$self->{'arguments'}})) . ') )'
                    }
                    if ($self->{'bareword'} && !@{$self->{'arguments'}}) {
                        return $code
                    }
                    $code . '(' . join(', ', map($_->emit_xs($level + 1), @{$self->{'arguments'}})) . ')'
                }
                sub Perlito5::AST::Apply::emit_xs_bind {
                    my $parameters = shift;
                    my $arguments = shift;
                    my $level = shift;
                    if ($parameters->isa('Perlito5::AST::Call')) {
                        if ($parameters->method() eq 'postcircumfix:<{ }>' || $parameters->method() eq 'postcircumfix:<[ ]>') {
                            return '(' . $parameters->emit_xs($level + 1) . ' = ' . $arguments->emit_xs($level + 1) . ')'
                        }
                    }
                    $parameters->emit_xs($level + 1) . ' = ' . $arguments->emit_xs($level + 1)
                }
            }
            package Perlito5::AST::If;
            {
                sub Perlito5::AST::If::emit_xs {
                    my $self = $_[0];
                    my $level = $_[1];
                    return 'if (' . $self->{'cond'}->emit_xs($level + 1) . ') {' . chr(10) . ($self->{'body'} ? join(';' . chr(10), map(Perlito5::XS::tab($level + 1) . $_->emit_xs($level + 1), @{$self->{'body'}->stmts()})) . chr(10) : '') . Perlito5::XS::tab($level) . '}' . ($self->{'otherwise'} && scalar(@{$self->{'otherwise'}->stmts()}) ? (chr(10) . Perlito5::XS::tab($level) . 'else {' . chr(10) . join(';' . chr(10), map(Perlito5::XS::tab($level + 1) . $_->emit_xs($level + 1), @{$self->{'otherwise'}->stmts()})) . chr(10) . Perlito5::XS::tab($level) . '}') : '')
                }
            }
            package Perlito5::AST::When;
            {
                sub Perlito5::AST::When::emit_xs {
                    my $self = $_[0];
                    my $level = $_[1];
                    return 'when (' . $self->{'cond'}->emit_xs($level + 1) . ') {' . chr(10) . ($self->{'body'} ? join(';' . chr(10), map(Perlito5::XS::tab($level + 1) . $_->emit_xs($level + 1), @{$self->{'body'}->stmts()})) . chr(10) : '') . Perlito5::XS::tab($level) . '}'
                }
            }
            package Perlito5::AST::While;
            {
                sub Perlito5::AST::While::emit_xs {
                    my $self = $_[0];
                    my $level = $_[1];
                    my $cond = $self->{'cond'};
                    'for ( ' . ($self->{'init'} ? $self->{'init'}->emit_xs($level + 1) . '; ' : '; ') . ($cond ? $cond->emit_xs($level + 1) . '; ' : '; ') . ($self->{'continue'} ? $self->{'continue'}->emit_xs($level + 1) . ' ' : ' ') . ') {' . chr(10) . join(';' . chr(10), map(Perlito5::XS::tab($level + 1) . $_->emit_xs($level + 1), @{$self->{'body'}->stmts()})) . chr(10) . Perlito5::XS::tab($level) . '}'
                }
            }
            package Perlito5::AST::For;
            {
                sub Perlito5::AST::For::emit_xs {
                    my $self = $_[0];
                    my $level = $_[1];
                    my $cond;
                    if (ref($self->{'cond'}) eq 'ARRAY') {
                        $cond = ($self->{'cond'}->[0] ? $self->{'cond'}->[0]->emit_javascript($level + 1) . '; ' : '; ') . ($self->{'cond'}->[1] ? $self->{'cond'}->[1]->emit_javascript($level + 1) . '; ' : '; ') . ($self->{'cond'}->[2] ? $self->{'cond'}->[2]->emit_javascript($level + 1) . ' ' : ' ')
                    }
                    else {
                        $cond = $self->{'cond'}->emit_xs($level + 1)
                    }
                    my $sig = '';
                    my $sig_ast = $self->{'body'}->sig();
                    if (!$sig_ast) {}
                    elsif ($sig_ast->{'decl'}) {
                        $sig = $sig_ast->{'decl'} . ' ' . $sig_ast->{'type'} . ' ' . $sig_ast->{'var'}->emit_xs($level + 1) . ' '
                    }
                    else {
                        $sig = $sig_ast->emit_xs($level + 1) . ' '
                    }
                    return 'for ' . $sig . '(' . $cond . ') {' . chr(10) . join(';' . chr(10), map(Perlito5::XS::tab($level + 1) . $_->emit_xs($level + 1), @{$self->{'body'}->stmts()})) . chr(10) . Perlito5::XS::tab($level) . '}'
                }
            }
            package Perlito5::AST::Decl;
            {
                sub Perlito5::AST::Decl::emit_xs {
                    my $self = $_[0];
                    my $level = $_[1];
                    $self->{'type'} = 'SV *';
                    my $decl = $self->{'decl'};
                    my $str = $self->{'type'} . $self->{'var'}->emit_xs($level + 1);
                    return $str
                }
            }
            package Perlito5::AST::Sub;
            {
                sub Perlito5::AST::Sub::emit_xs {
                    my $self = $_[0];
                    my $level = $_[1];
                    my $name = '';
                    $self->{'name'} && ($name = $self->{'name'} . ' ');
                    my $sig = $self->{'sig'};
                    my $i = 0;
                    'void ' . $name . '()' . chr(10) . 'PPCODE:' . chr(10) . join(';' . chr(10), map(Perlito5::XS::tab($level + 1) . $_->emit_xs($level + 1), @{$self->{'block'}})) . ';' . chr(10)
                }
            }
            package Perlito5::AST::Use;
            {
                sub Perlito5::AST::Use::emit_xs {
                    my $self = shift;
                    my $level = shift;
                    Perlito5::Grammar::Use::emit_time_eval($self);
                    return chr(10) . Perlito5::XS::tab($level) . '# ' . $self->{'code'} . ' ' . $self->{'mod'} . chr(10)
                }
            }
            1
        }
    }
    {
        {
            package main;
            undef();
            undef();
            {
                {
                    package main;
                    undef();
                    undef();
                    # use strict
                    package Perlito5::AST::CompUnit;
                    {
                        sub Perlito5::AST::CompUnit::get_captures {
                            ()
                        }
                    }
                    package Perlito5::AST::Int;
                    {
                        sub Perlito5::AST::Int::get_captures {
                            ()
                        }
                    }
                    package Perlito5::AST::Num;
                    {
                        sub Perlito5::AST::Num::get_captures {
                            ()
                        }
                    }
                    package Perlito5::AST::Buf;
                    {
                        sub Perlito5::AST::Buf::get_captures {
                            ()
                        }
                    }
                    package Perlito5::AST::Block;
                    {
                        sub Perlito5::AST::Block::get_captures {
                            my($self) = @_;
                            my @var;
                            for my $stmt (@{$self->{'stmts'}}) {
                                push(@var, $stmt->get_captures())
                            }
                            return @var
                        }
                    }
                    package Perlito5::AST::Index;
                    {
                        sub Perlito5::AST::Index::get_captures {
                            my $self = shift;
                            my @var;
                            push(@var, $self->{'obj'}->get_captures());
                            push(@var, $self->{'index_exp'}->get_captures());
                            return @var
                        }
                    }
                    package Perlito5::AST::Lookup;
                    {
                        sub Perlito5::AST::Lookup::get_captures {
                            my $self = shift;
                            my @var;
                            push(@var, $self->{'obj'}->get_captures());
                            push(@var, $self->{'index_exp'}->get_captures());
                            return @var
                        }
                    }
                    package Perlito5::AST::Var;
                    {
                        sub Perlito5::AST::Var::get_captures {
                            my $self = shift;
                            return ($self)
                        }
                    }
                    package Perlito5::AST::Decl;
                    {
                        sub Perlito5::AST::Decl::get_captures {
                            return {'dont' => $_[0]->{'var'}->{'_id'}}
                        }
                    }
                    package Perlito5::AST::Call;
                    {
                        sub Perlito5::AST::Call::get_captures {
                            my $self = shift;
                            my @var;
                            ref($self->{'method'}) && push(@var, $self->{'method'}->get_captures());
                            push(@var, $self->{'invocant'}->get_captures());
                            my $args = $self->{'arguments'};
                            if ($args) {
                                if (ref($args) eq 'ARRAY') {
                                    push(@var, map {
                                        $_->get_captures()
                                    } @{$args})
                                }
                                else {
                                    push(@var, $args->get_captures())
                                }
                            }
                            return @var
                        }
                    }
                    package Perlito5::AST::Apply;
                    {
                        sub Perlito5::AST::Apply::get_captures {
                            my $self = shift;
                            my $code = $self->{'code'};
                            my @var;
                            ref($code) && push(@var, $code->get_captures());
                            $self->{'arguments'} && push(@var, map {
                                $_->get_captures()
                            } @{$self->{'arguments'}});
                            if ($code eq 'my' || $code eq 'our' || $code eq 'state') {
                                push(@var, (map {
                                    ref($_) eq 'Perlito5::AST::Var' ? ({'dont' => $_->{'_id'}}) : ()
                                } @{$self->{'arguments'}}))
                            }
                            return @var
                        }
                    }
                    package Perlito5::AST::If;
                    {
                        sub Perlito5::AST::If::get_captures {
                            my $self = shift;
                            my @var;
                            push(@var, $self->{'cond'}->get_captures());
                            push(@var, $self->{'body'}->get_captures());
                            push(@var, $self->{'otherwise'}->get_captures());
                            return @var
                        }
                    }
                    package Perlito5::AST::When;
                    {
                        sub Perlito5::AST::When::get_captures {
                            my $self = shift;
                            my @var;
                            push(@var, $self->{'cond'}->get_captures());
                            push(@var, $self->{'body'}->get_captures());
                            return @var
                        }
                    }
                    package Perlito5::AST::While;
                    {
                        sub Perlito5::AST::While::get_captures {
                            my $self = shift;
                            my @var;
                            push(@var, $self->{'cond'}->get_captures());
                            push(@var, $self->{'body'}->get_captures());
                            return @var
                        }
                    }
                    package Perlito5::AST::For;
                    {
                        sub Perlito5::AST::For::get_captures {
                            my $self = shift;
                            my @var;
                            my $body = ref($self->{'body'}) ne 'Perlito5::AST::Block' ? [$self->{'body'}] : $self->{'body'}->{'stmts'};
                            push(@var, map {
                                $_->get_captures()
                            } grep {
                                defined($_)
                            } @{$body}, $self->{'topic'}, (ref($self->{'cond'}) eq 'ARRAY' ? @{$self->{'cond'}} : $self->{'cond'}));
                            return @var
                        }
                    }
                    package Perlito5::AST::Sub;
                    {
                        sub Perlito5::AST::Sub::get_captures {
                            $_[0]->{'block'}->get_captures()
                        }
                    }
                    package Perlito5::AST::Use;
                    {
                        sub Perlito5::AST::Use::get_captures {
                            ()
                        }
                    }
                    1
                }
            }
            undef();
            # use strict
            package Perlito5::Java;
            {
                my %label;
                my %Java_class;
                our %Java_var_name;
                my %Java_var;
                our @Java_init;
                sub Perlito5::Java::pkg {
                    Perlito5::Java::escape_string($Perlito5::PKG_NAME)
                }
                sub Perlito5::Java::get_label {
                    'tmp' . $Perlito5::ID++
                }
                sub Perlito5::Java::tab {
                    my $level = shift;
                    '    ' x $level
                }
                sub Perlito5::Java::get_java_class_info {
                    return \%Java_class
                }
                sub Perlito5::Java::get_java_var_info {
                    return \%Java_var
                }
                sub Perlito5::Java::set_java_class_defaults {
                    my($perl_package, $java_import) = @_;
                    my $Java_class = Perlito5::Java::get_java_class_info();
                    my @parts = split(m!\.!, $java_import);
                    $Java_class->{$perl_package}->{'java_type'} //= $parts[-1];
                    $Java_class->{$perl_package}->{'java_native_to_perl'} //= 'p' . $Java_class->{$perl_package}->{'java_type'};
                    $Java_class->{$perl_package}->{'java_native_to_perl'} =~ s![<>]!_!g;
                    my $perl_to_java = $perl_package;
                    $perl_to_java =~ s!::!!g;
                    $Java_class->{$perl_package}->{'perl_to_java'} //= 'to_' . $perl_to_java;
                    $Java_class->{$perl_package}->{'perl_package'} = $perl_package
                }
                sub Perlito5::Java::init_java_class {
                    my $Java_class = Perlito5::Java::get_java_class_info();
                    $Java_class->{'String'} = {'java_type' => 'String', 'java_native_to_perl' => 'PlString', 'perl_to_java' => 'toString', 'perl_package' => 'String'};
                    $Java_class->{'Long'} = {'java_type' => 'Long', 'java_native_to_perl' => 'PlInt', 'perl_to_java' => 'to_long', 'perl_package' => 'Long'};
                    $Java_class->{'Integer'} = {'java_type' => 'Integer', 'java_native_to_perl' => 'PlInt', 'perl_to_java' => 'to_long', 'perl_package' => 'Integer'};
                    $Java_class->{'Boolean'} = {'java_type' => 'Boolean', 'java_native_to_perl' => 'PlBool', 'perl_to_java' => 'to_bool', 'perl_package' => 'Boolean'};
                    $Java_class->{'Double'} = {'java_type' => 'Double', 'java_native_to_perl' => 'PlDouble', 'perl_to_java' => 'to_double', 'perl_package' => 'Double'};
                    $Java_class->{'Byte'} = {'java_type' => 'Byte', 'java_native_to_perl' => 'PlInt', 'perl_to_java' => 'to_byte', 'perl_package' => 'Byte'};
                    $Java_class->{'Short'} = {'java_type' => 'Short', 'java_native_to_perl' => 'PlInt', 'perl_to_java' => 'to_short', 'perl_package' => 'Short'};
                    $Java_class->{'Float'} = {'java_type' => 'Float', 'java_native_to_perl' => 'PlDouble', 'perl_to_java' => 'to_float', 'perl_package' => 'Float'};
                    $Java_class->{'Character'} = {'java_type' => 'Character', 'java_native_to_perl' => 'PlString', 'perl_to_java' => 'to_character', 'perl_package' => 'Character'};
                    $Java_class->{'long'} = {'java_type' => 'long', 'java_native_to_perl' => 'PlInt', 'perl_to_java' => 'to_long', 'perl_package' => 'long'};
                    $Java_class->{'int'} = {'java_type' => 'int', 'java_native_to_perl' => 'PlInt', 'perl_to_java' => 'to_long', 'perl_package' => 'int'}
                }
                our %Java_loop_label;
                sub Perlito5::Java::get_java_loop_label {
                    my $s = shift;
                    !$s && return 0;
                    exists($Java_loop_label{$s}) && return $Java_loop_label{$s};
                    my $label = $Perlito5::ID++;
                    $Java_loop_label{$s} = $label;
                    return $label
                }
                our %op_prefix_js_str = ('prefix:<-A>' => 'p5atime', 'prefix:<-C>' => 'p5ctime', 'prefix:<-M>' => 'p5mtime', 'prefix:<-d>' => 'p5is_directory', 'prefix:<-e>' => 'p5file_exists', 'prefix:<-f>' => 'p5is_file', 'prefix:<-s>' => 'p5size');
                our %op_infix_js_str = ('infix:<eq>' => ' == ', 'infix:<ne>' => ' != ', 'infix:<le>' => ' <= ', 'infix:<ge>' => ' >= ', 'infix:<lt>' => ' < ', 'infix:<gt>' => ' > ');
                our %op_to_bool = map(+($_ => 1), 'prefix:<!>', 'infix:<!=>', 'infix:<==>', 'infix:<<=>', 'infix:<>=>', 'infix:<>>', 'infix:<<>', 'infix:<eq>', 'infix:<ne>', 'infix:<ge>', 'infix:<le>', 'infix:<gt>', 'infix:<lt>', 'prefix:<not>', 'exists', 'defined');
                our %op_to_str = map(+($_ => 1), 'substr', 'join', 'list:<.>', 'chr', 'lc', 'uc', 'lcfirst', 'ucfirst', 'ref');
                our %op_to_num = map(+($_ => 1), 'length', 'index', 'rindex', 'ord', 'oct', 'infix:<->', 'infix:<+>', 'infix:<*>', 'infix:</>', 'infix:<%>', 'infix:<**>', 'infix:<|>', 'infix:<&>');
                our %native_op = ('infix:<->', '-', 'infix:<+>', '+', 'infix:<*>', '*', 'infix:</>', '/', 'infix:<!=>', '!=', 'infix:<==>', '==', 'infix:<<=>', '<=', 'infix:<>=>', '>=', 'infix:<>>', '>', 'infix:<<>', '<');
                our %native_op_to_bool = ('infix:<!=>', '!=', 'infix:<==>', '==', 'infix:<<=>', '<=', 'infix:<>=>', '>=', 'infix:<>>', '>', 'infix:<<>', '<');
                my %safe_char = (' ' => 1, '!' => 1, '#' => 1, '$' => 1, '%' => 1, '&' => 1, '(' => 1, ')' => 1, '*' => 1, '+' => 1, ',' => 1, '-' => 1, '.' => 1, '/' => 1, ':' => 1, ';' => 1, '<' => 1, '=' => 1, '>' => 1, '?' => 1, '@' => 1, '[' => 1, ']' => 1, '^' => 1, '_' => 1, '`' => 1, '{' => 1, '|' => 1, '}' => 1, '~' => 1);
                sub Perlito5::Java::escape_string {
                    my $s = shift;
                    my @out;
                    my $tmp = '';
                    $s eq '' && return '""';
                    for my $i (0 .. length($s) - 1) {
                        my $c = substr($s, $i, 1);
                        if (($c ge 'a' && $c le 'z') || ($c ge 'A' && $c le 'Z') || ($c ge 0 && $c le 9) || exists($safe_char{$c})) {
                            $tmp = $tmp . $c
                        }
                        else {
                            $tmp ne '' && push(@out, '"' . $tmp . '"');
                            push(@out, '(char)' . ord($c) . '');
                            $tmp = ''
                        }
                    }
                    $tmp ne '' && push(@out, '"' . $tmp . '"');
                    scalar(@out) > 1 && unshift(@out, '""');
                    return join(' + ', @out)
                }
                sub Perlito5::Java::is_native {
                    my $self = shift;
                    if (ref($self->{'invocant'}) eq 'Perlito5::AST::Var' && $self->{'invocant'}->{'sigil'} eq '::') {
                        my $Java_class = Perlito5::Java::get_java_class_info();
                        if (exists($Java_class->{$self->{'invocant'}->{'namespace'}})) {
                            return 1
                        }
                    }
                    if (ref($self->{'invocant'}) eq 'Perlito5::AST::Var' && $self->{'invocant'}->{'_id'}) {
                        my $id = $self->{'invocant'}->{'_id'};
                        my $Java_var = Perlito5::Java::get_java_var_info();
                        my $type = $Java_var->{$id}->{'type'} || 'PlLvalue';
                        if ($type ne 'PlLvalue') {
                            return 1
                        }
                    }
                    my $meth = $self->{'method'};
                    if ($meth =~ m!^to!) {
                        my $Java_class = Perlito5::Java::get_java_class_info();
                        for my $info (values(%{$Java_class})) {
                            if ($meth eq $info->{'perl_to_java'}) {
                                return 1
                            }
                        }
                    }
                    return 0
                }
                sub Perlito5::Java::is_native_bool {
                    my $self = shift;
                    if (is_native_args([$self])) {
                        return 1
                    }
                    my $is_apply = $self->isa('Perlito5::AST::Apply') && $self->{'arguments'} && @{$self->{'arguments'}};
                    if ($is_apply && exists($native_op_to_bool{$self->{'code'}}) && is_native_args($self->{'arguments'})) {
                        return 1
                    }
                    return 0
                }
                sub Perlito5::Java::to_native_args {
                    my $args = shift;
                    my $level = shift;
                    my $wantarray = 'scalar';
                    my $s = '';
                    my @out;
                    for my $cond (@{$args}) {
                        my $is_apply = $cond->isa('Perlito5::AST::Apply') && $cond->{'arguments'} && @{$cond->{'arguments'}};
                        if ($is_apply && $cond->code() eq 'circumfix:<( )>') {
                            push(@out, to_native_args($cond->{'arguments'}->[0], $level))
                        }
                        elsif ($is_apply && exists($native_op{$cond->code()})) {
                            push(@out, '(' . to_native_num($cond->{'arguments'}->[0], $level, $wantarray) . ' ' . $native_op{$cond->code()} . ' ' . to_native_num($cond->{'arguments'}->[1], $level, $wantarray) . ')')
                        }
                        elsif ($is_apply && exists($op_to_num{$cond->code()})) {
                            push(@out, '(' . $cond->emit_java($level, $wantarray) . ').' . ($cond->{'arguments'}->[0]->isa('Perlito5::AST::Num') || $cond->{'arguments'}->[1]->isa('Perlito5::AST::Num') ? 'to_double()' : 'to_long()'))
                        }
                        elsif ($is_apply && exists($op_to_str{$cond->code()})) {
                            push(@out, '(' . $cond->emit_java($level, $wantarray) . ').toString()')
                        }
                        elsif ($cond->isa('Perlito5::AST::Apply') && $cond->{'code'} eq 'undef') {
                            push(@out, 'null')
                        }
                        elsif ($cond->isa('Perlito5::AST::Buf')) {
                            push(@out, Perlito5::Java::escape_string($cond->{'buf'}))
                        }
                        elsif ($cond->isa('Perlito5::AST::Int')) {
                            push(@out, $cond->{'int'})
                        }
                        elsif ($cond->isa('Perlito5::AST::Num')) {
                            push(@out, $cond->{'num'})
                        }
                        else {
                            push(@out, $cond->emit_java($level, $wantarray))
                        }
                    }
                    return join(', ', @out)
                }
                sub Perlito5::Java::is_native_args {
                    my $args = shift;
                    my $wantarray = 'scalar';
                    my $s = '';
                    my @out;
                    for my $cond (@{$args}) {
                        my $is_apply = $cond->isa('Perlito5::AST::Apply') && $cond->{'arguments'} && @{$cond->{'arguments'}};
                        if ($is_apply && $cond->code() eq 'circumfix:<( )>') {
                            is_native_args($cond->{'arguments'}) || return 0
                        }
                        elsif ($is_apply && exists($native_op{$cond->code()})) {
                            is_native_args($cond->{'arguments'}) || return 0
                        }
                        elsif ($cond->isa('Perlito5::AST::Int')) {}
                        elsif ($cond->isa('Perlito5::AST::Num')) {}
                        elsif (ref($cond) eq 'Perlito5::AST::Var' && $cond->{'_id'}) {
                            my $id = $cond->{'_id'};
                            my $Java_var = Perlito5::Java::get_java_var_info();
                            my $type = $Java_var->{$id}->{'type'} || 'PlLvalue';
                            if ($type eq 'PlLvalue') {
                                return 0
                            }
                        }
                        else {
                            is_native($cond) || return 0
                        }
                    }
                    @{$args} && return 1;
                    return 0
                }
                sub Perlito5::Java::to_native_bool {
                    my $cond = shift;
                    my $level = shift;
                    my $wantarray = shift;
                    if ($cond->isa('Perlito5::AST::Apply') && $cond->code() eq 'circumfix:<( )>' && $cond->{'arguments'} && @{$cond->{'arguments'}}) {
                        return to_native_bool($cond->{'arguments'}->[0], $level, $wantarray)
                    }
                    elsif ($cond->isa('Perlito5::AST::Int')) {
                        return '(' . $cond->{'int'} . ' != 0)'
                    }
                    elsif ($cond->isa('Perlito5::AST::Num')) {
                        return '(' . $cond->{'num'} . ' != 0.0)'
                    }
                    else {
                        return to_native_args([$cond], $level)
                    }
                }
                sub Perlito5::Java::to_native_num {
                    my $cond = shift;
                    my $level = shift;
                    my $wantarray = shift;
                    if ($cond->isa('Perlito5::AST::Apply') && $cond->code() eq 'circumfix:<( )>' && $cond->{'arguments'} && @{$cond->{'arguments'}}) {
                        return to_native_num($cond->{'arguments'}->[0], $level, $wantarray)
                    }
                    elsif ($cond->isa('Perlito5::AST::Int')) {
                        return $cond->{'int'}
                    }
                    elsif ($cond->isa('Perlito5::AST::Num')) {
                        return $cond->{'num'}
                    }
                    else {
                        return to_native_args([$cond], $level)
                    }
                }
                sub Perlito5::Java::to_native_str {
                    my $cond = shift;
                    my $level = shift;
                    my $wantarray = shift;
                    if ($cond->isa('Perlito5::AST::Apply') && $cond->code() eq 'circumfix:<( )>' && $cond->{'arguments'} && @{$cond->{'arguments'}}) {
                        return to_native_str($cond->{'arguments'}->[0], $level, $wantarray)
                    }
                    if ($cond->isa('Perlito5::AST::Buf')) {
                        return Perlito5::Java::escape_string($cond->{'buf'})
                    }
                    elsif ($cond->isa('Perlito5::AST::Int')) {
                        return Perlito5::Java::escape_string($cond->{'int'})
                    }
                    elsif ($cond->isa('Perlito5::AST::Num')) {
                        return Perlito5::Java::escape_string($cond->{'num'})
                    }
                    else {
                        return $cond->emit_java($level, $wantarray) . '.toString()'
                    }
                }
                sub Perlito5::Java::to_str {
                    my $cond = shift;
                    my $level = shift;
                    my $wantarray = 'scalar';
                    if ($cond->isa('Perlito5::AST::Apply') && $cond->code() eq 'circumfix:<( )>' && $cond->{'arguments'} && @{$cond->{'arguments'}}) {
                        return to_str($cond->{'arguments'}->[0], $level)
                    }
                    if (($cond->isa('Perlito5::AST::Buf')) || ($cond->isa('Perlito5::AST::Apply') && exists($op_to_str{$cond->code()}))) {
                        return $cond->emit_java($level, $wantarray)
                    }
                    else {
                        return 'new PlString(' . $cond->emit_java($level, $wantarray) . '.toString())'
                    }
                }
                sub Perlito5::Java::to_num {
                    my $cond = shift;
                    my $level = shift;
                    my $type = shift;
                    my $wantarray = 'scalar';
                    if ($cond->isa('Perlito5::AST::Int') || $cond->isa('Perlito5::AST::Num') || ($cond->isa('Perlito5::AST::Apply') && exists($op_to_num{$cond->code()}))) {
                        return $cond->emit_java($level, $wantarray)
                    }
                    else {
                        if ($type eq 'int') {
                            return 'new PlInt(' . $cond->emit_java($level, $wantarray) . '.to_long())'
                        }
                        return 'new PlDouble(' . $cond->emit_java($level, $wantarray) . '.to_double())'
                    }
                }
                sub Perlito5::Java::to_bool {
                    my $cond = shift;
                    my $level = shift;
                    my $wantarray = 'scalar';
                    if ($cond->isa('Perlito5::AST::Apply') && $cond->code() eq 'circumfix:<( )>' && $cond->{'arguments'} && @{$cond->{'arguments'}}) {
                        return to_bool($cond->{'arguments'}->[0], $level)
                    }
                    if ($cond->isa('Perlito5::AST::Apply') && ($cond->code() eq 'infix:<&&>' || $cond->code() eq 'infix:<and>')) {
                        return '(' . to_bool($cond->{'arguments'}->[0], $level) . ' && ' . to_bool($cond->{'arguments'}->[1], $level) . ')'
                    }
                    if ($cond->isa('Perlito5::AST::Apply') && ($cond->code() eq 'infix:<||>' || $cond->code() eq 'infix:<or>')) {
                        return '(' . to_bool($cond->{'arguments'}->[0], $level) . ' || ' . to_bool($cond->{'arguments'}->[1], $level) . ')'
                    }
                    if (($cond->isa('Perlito5::AST::Int')) || ($cond->isa('Perlito5::AST::Num')) || ($cond->isa('Perlito5::AST::Apply') && exists($op_to_bool{$cond->code()}))) {
                        return $cond->emit_java($level, $wantarray) . '.to_bool()'
                    }
                    else {
                        return $cond->emit_java($level, $wantarray) . '.to_bool()'
                    }
                }
                sub Perlito5::Java::is_scalar {
                    $_[0]->isa('Perlito5::AST::Int') || $_[0]->isa('Perlito5::AST::Num') || $_[0]->isa('Perlito5::AST::Buf') || $_[0]->isa('Perlito5::AST::Sub') || ($_[0]->isa('Perlito5::AST::Var') && $_[0]->{'sigil'} eq '$') || ($_[0]->isa('Perlito5::AST::Apply') && (exists($op_to_str{$_[0]->{'code'}}) || exists($op_to_num{$_[0]->{'code'}}) || exists($op_to_bool{$_[0]->{'code'}})))
                }
                sub Perlito5::Java::to_list {
                    my $items = to_list_preprocess($_[0]);
                    my $level = $_[1];
                    return 'new PlArray(' . join(', ', map($_->emit_java($level, 'list'), @{$items})) . ')'
                }
                sub Perlito5::Java::to_list_preprocess {
                    my @items;
                    for my $item (@{$_[0]}) {
                        if ($item->isa('Perlito5::AST::Apply') && ($item->code() eq 'circumfix:<( )>' || $item->code() eq 'list:<,>' || $item->code() eq 'infix:<=>>')) {
                            if ($item->isa('Perlito5::AST::Apply') && $item->code() eq 'infix:<=>>') {
                                $item->{'arguments'}->[0] = Perlito5::AST::Lookup::->autoquote($item->{'arguments'}->[0])
                            }
                            for my $arg (@{to_list_preprocess($item->arguments())}) {
                                push(@items, $arg)
                            }
                        }
                        else {
                            push(@items, $item)
                        }
                    }
                    return \@items
                }
                sub Perlito5::Java::to_scalar {
                    my $items = to_scalar_preprocess($_[0]);
                    my $level = $_[1];
                    my $wantarray = 'scalar';
                    @{$items} ? '(' . join(', ', map($_->emit_java($level, $wantarray), @{$items})) . ')' : 'null'
                }
                sub Perlito5::Java::to_scalar_preprocess {
                    my @items;
                    for my $item (@{$_[0]}) {
                        if ($item->isa('Perlito5::AST::Apply') && ($item->code() eq 'list:<,>' || $item->code() eq 'infix:<=>>')) {
                            if ($item->isa('Perlito5::AST::Apply') && $item->code() eq 'infix:<=>>') {
                                $item->{'arguments'}->[0] = Perlito5::AST::Lookup::->autoquote($item->{'arguments'}->[0])
                            }
                            for my $arg (@{to_scalar_preprocess($item->arguments())}) {
                                push(@items, $arg)
                            }
                        }
                        else {
                            push(@items, $item)
                        }
                    }
                    return \@items
                }
                sub Perlito5::Java::to_runtime_context {
                    my $items = to_scalar_preprocess($_[0]);
                    my $level = $_[1];
                    my $wantarray = 'runtime';
                    @{$items} == 1 && is_scalar($items->[0]) && return $items->[0]->emit_java($level, $wantarray);
                    'PerlOp.context(want, ' . join(', ', map($_->emit_java($level, $wantarray), @{$items})) . ')'
                }
                sub Perlito5::Java::to_context {
                    my $wantarray = shift;
                    $wantarray eq 'list' ? 'PlCx.LIST' : $wantarray eq 'scalar' ? 'PlCx.SCALAR' : $wantarray eq 'void' ? 'PlCx.VOID' : 'want'
                }
                sub Perlito5::Java::autoquote {
                    my $index = shift;
                    my $level = shift;
                    $index = Perlito5::AST::Lookup::->autoquote($index);
                    return to_str($index, $level)
                }
                sub Perlito5::Java::emit_java_autovivify {
                    my $obj = shift;
                    my $level = shift;
                    my $type = shift;
                    if ($obj->isa('Perlito5::AST::Index') || $obj->isa('Perlito5::AST::Lookup') || $obj->isa('Perlito5::AST::Call')) {
                        return $obj->emit_java($level, 0, $type)
                    }
                    if ($obj->isa('Perlito5::AST::Apply') && $obj->code() eq 'prefix:<$>') {
                        my $arg = $obj->{'arguments'}->[0];
                        return 'get_scalarref(' . $arg->emit_java($level) . ', ' . Perlito5::Java::escape_string($Perlito5::PKG_NAME) . ', ' . Perlito5::Java::escape_string($type) . ')'
                    }
                    $obj->emit_java($level)
                }
                sub Perlito5::Java::emit_java_list_with_tabs {
                    my($level, $argument) = @_;
                    my $tab = Perlito5::Java::tab($level);
                    return map {
                        ref($_) eq 'ARRAY' ? emit_java_list_with_tabs($level + 1, $_) : $tab . $_
                    } @{$argument}
                }
                sub Perlito5::Java::emit_wrap_java {
                    my($level, @argument) = @_;
                    wantarray && return @argument;
                    my $s;
                    !ref($argument[0]) && ($s = shift(@argument));
                    return join(chr(10), ($s ? $s : ()), emit_java_list_with_tabs($level, [\@argument]))
                }
                sub Perlito5::Java::emit_wrap_statement_java {
                    my($level, $wantarray, $argument) = @_;
                    if ($wantarray eq 'void') {
                        return $argument
                    }
                    emit_wrap_java($level, $argument)
                }
                sub Perlito5::Java::emit_wrap_last_exception_java {
                    my($self, $stmts) = @_;
                    my $block_label = Perlito5::Java::get_java_loop_label($self->{'label'});
                    my $test_label = 'e.label_id != 0';
                    $block_label && ($test_label = 'e.label_id != ' . $block_label . ' && e.label_id != 0');
                    return ('try {', [@{$stmts}], '}', 'catch(PlLastException e) {', ['if (' . $test_label . ') {', ['throw e;'], '}'], '}')
                }
            }
            package Perlito5::Java::LexicalBlock;
            {
                sub Perlito5::Java::LexicalBlock::new {
                    my $class = shift;
                    bless({@_}, $class)
                }
                sub Perlito5::Java::LexicalBlock::block {
                    $_[0]->{'block'}
                }
                sub Perlito5::Java::LexicalBlock::has_decl {
                    my $self = $_[0];
                    my $type = $_[1];
                    for my $decl (@{$self->{'block'}}) {
                        (grep {
                            $_->{'decl'} eq $type
                        } $decl->emit_java_get_decl()) && return 1
                    }
                    return 0
                }
                sub Perlito5::Java::LexicalBlock::emit_return {
                    my($has_local, $local_label, $value) = @_;
                    $has_local ? 'return PerlOp.cleanup_local(' . $local_label . ', ' . $value . ')' : 'return ' . $value
                }
                sub Perlito5::Java::LexicalBlock::emit_java {
                    my($self, $level, $wantarray) = @_;
                    my $original_level = $level;
                    my $block_label = Perlito5::Java::get_java_loop_label($self->{'block_label'});
                    $block_label && ($Perlito5::THROW = 1);
                    my @block;
                    for my $stmt (@{$self->{'block'}}) {
                        if (defined($stmt)) {
                            if (ref($stmt) eq 'Perlito5::AST::Apply' && $stmt->code() eq 'undef' && !@{$stmt->{'arguments'}}) {}
                            else {
                                push(@block, $stmt)
                            }
                        }
                    }
                    if ($self->{'top_level'} && !@block) {
                        push(@block, Perlito5::AST::Apply::->new('code' => 'return', 'arguments' => []))
                    }
                    my @str;
                    my @pre;
                    my $has_local = $self->has_decl('local');
                    my $has_regex = 0;
                    if (grep {
                        $_->emit_java_has_regex()
                    } @block) {
                        $has_regex = 1
                    }
                    my $local_label = Perlito5::Java::get_label();
                    if ($has_local) {
                        push(@pre, 'int ' . $local_label . ' = PerlOp.local_length();')
                    }
                    my $create_context = $self->{'create_context'} && $self->has_decl('my');
                    my $outer_pkg = $Perlito5::PKG_NAME;
                    if ($self->{'top_level'} || $create_context) {
                        $level++
                    }
                    my $last_statement;
                    if ($wantarray ne 'void') {
                        $last_statement = pop(@block)
                    }
                    for my $decl (@block) {
                        if (ref($decl) eq 'Perlito5::AST::Apply' && $decl->code() eq 'package') {
                            $Perlito5::PKG_NAME = $decl->{'namespace'}
                        }
                        my @var_decl = $decl->emit_java_get_decl();
                        for my $arg (@var_decl) {
                            push(@str, $arg->emit_java_init($level, $wantarray))
                        }
                        if (!($decl->isa('Perlito5::AST::Decl') && ($decl->decl() eq 'my' || $decl->decl() eq 'our'))) {
                            if (($decl->isa('Perlito5::AST::Int')) || ($decl->isa('Perlito5::AST::Num')) || ($decl->isa('Perlito5::AST::Buf'))) {}
                            elsif ($decl->isa('Perlito5::AST::Apply') && !($decl->{'namespace'} eq 'Java' && $decl->{'code'} eq 'inline') && !($decl->{'code'} eq 'infix:<=>' || $decl->{'code'} eq 'print' || $decl->{'code'} eq 'say')) {
                                push(@str, 'PerlOp.statement(' . $decl->emit_java($level, 'void') . ');')
                            }
                            elsif ($decl->isa('Perlito5::AST::CompUnit') || $decl->isa('Perlito5::AST::For') || $decl->isa('Perlito5::AST::While') || $decl->isa('Perlito5::AST::If') || $decl->isa('Perlito5::AST::Block')) {
                                push(@str, $decl->emit_java($level, 'void'))
                            }
                            else {
                                push(@str, $decl->emit_java($level, 'void') . ';')
                            }
                        }
                    }
                    if ($last_statement) {
                        my @var_decl = $last_statement->emit_java_get_decl();
                        for my $arg (@var_decl) {
                            push(@str, $arg->emit_java_init($level, $wantarray))
                        }
                        if ($last_statement->isa('Perlito5::AST::For') || $last_statement->isa('Perlito5::AST::While') || $last_statement->isa('Perlito5::AST::Block') || $last_statement->isa('Perlito5::AST::Use') || $last_statement->isa('Perlito5::AST::Apply') && $last_statement->code() eq 'goto') {
                            push(@str, $last_statement->emit_java($level, 'void') . ';');
                            push(@str, emit_return($has_local, $local_label, 'PerlOp.context(want)') . ';')
                        }
                        elsif ($last_statement->isa('Perlito5::AST::If')) {
                            push(@str, $last_statement->emit_java($level, 'runtime') . '')
                        }
                        elsif ($last_statement->isa('Perlito5::AST::Apply') && $last_statement->code() eq 'return') {
                            if ($self->{'top_level'}) {
                                if (!@{$last_statement->{'arguments'}}) {
                                    push(@str, emit_return($has_local, $local_label, 'PerlOp.context(want)') . ';')
                                }
                                else {
                                    push(@str, emit_return($has_local, $local_label, $wantarray eq 'runtime' ? Perlito5::Java::to_runtime_context([$last_statement->{'arguments'}->[0]], $level + 1) : $wantarray eq 'scalar' ? Perlito5::Java::to_scalar([$last_statement->{'arguments'}->[0]], $level + 1) : $last_statement->{'arguments'}->[0]->emit_java($level, $wantarray)) . ';')
                                }
                            }
                            elsif (!@{$last_statement->{'arguments'}}) {
                                $Perlito5::THROW_RETURN = 1;
                                push(@str, 'return PerlOp.ret(PerlOp.context(want));')
                            }
                            else {
                                $Perlito5::THROW_RETURN = 1;
                                push(@str, 'return PerlOp.ret(' . Perlito5::Java::to_runtime_context([$last_statement->{'arguments'}->[0]], $level + 1) . ');')
                            }
                        }
                        else {
                            push(@str, emit_return($has_local, $local_label, $wantarray eq 'runtime' ? Perlito5::Java::to_runtime_context([$last_statement], $level + 1) : $wantarray eq 'scalar' ? Perlito5::Java::to_scalar([$last_statement], $level + 1) : $last_statement->emit_java($level, $wantarray)) . ';')
                        }
                    }
                    my $out;
                    if ($self->{'eval_block'}) {
                        return (@pre, 'try {', \@str, '}', 'catch(PlReturnException e) {', [emit_return($has_local, $local_label, 'e.ret') . ';'], '}', 'catch(PlNextException e) {', ['throw e;'], '}', 'catch(PlLastException e) {', ['throw e;'], '}', 'catch(PlRedoException e) {', ['throw e;'], '}', 'catch(PlDieException e) {', ['PlV.set("main::v_@", e.ret);', 'return PlCx.UNDEF;'], '}', 'catch(Exception e) {', ['PlV.set("main::v_@", new PlString(e.getMessage()));', 'return PlCx.UNDEF;'], '}')
                    }
                    elsif ($self->{'top_level'} && $Perlito5::THROW_RETURN) {
                        push(@pre, 'try {', [@str], '}', 'catch(PlReturnException e) {', [emit_return($has_local, $local_label, 'e.ret') . ';'], '}');
                        @str = ()
                    }
                    elsif (($Perlito5::THROW || ($self->{'continue'} && @{$self->{'continue'}->{'stmts'}} > 0)) && !$self->{'not_a_loop'}) {
                        my $redo_label = Perlito5::Java::get_label();
                        my $test_label = 'e.label_id != 0';
                        $block_label && ($test_label = 'e.label_id != ' . $block_label . ' && e.label_id != 0');
                        my @continue;
                        if ($self->{'continue'}) {
                            push(@continue, 'if (!' . $redo_label . ') {', ['try {', [Perlito5::Java::LexicalBlock::->new('block' => $self->{'continue'}->{'stmts'}, 'not_a_loop' => 1)->emit_java($level + 2, $wantarray)], '}', 'catch(PlNextException e) {', ['if (' . $test_label . ') {', ['throw e;'], '}'], '}', 'catch(PlRedoException e) {', ['if (' . $test_label . ') {', ['throw e;'], '}', $redo_label . ' = true;'], '}'], '}')
                        }
                        push(@pre, 'boolean ' . $redo_label . ';', 'do {', [$redo_label . ' = false;', 'try {', [@str], '}', 'catch(PlNextException e) {', ['if (' . $test_label . ') {', ['throw e;'], '}'], '}', 'catch(PlRedoException e) {', ['if (' . $test_label . ') {', ['throw e;'], '}', $redo_label . ' = true;'], '}', @continue], '} while (' . $redo_label . ');');
                        @str = ()
                    }
                    elsif ($has_local) {
                        push(@str, 'PerlOp.cleanup_local(' . $local_label . ', PlCx.UNDEF);')
                    }
                    $Perlito5::PKG_NAME = $outer_pkg;
                    return (@pre, @str)
                }
                sub Perlito5::Java::LexicalBlock::emit_java_has_regex {
                    ()
                }
            }
            package Perlito5::AST::CompUnit;
            {
                sub Perlito5::AST::CompUnit::emit_java {
                    my($self, $level, $wantarray) = @_;
                    return Perlito5::Java::LexicalBlock::->new('block' => $self->{'body'}, 'not_a_loop' => 1)->emit_java($level + 1, $wantarray)
                }
                sub Perlito5::AST::CompUnit::emit_java_program {
                    my($comp_units, %options) = @_;
                    $Perlito5::PKG_NAME = 'main';
                    $Perlito5::THROW = 0;
                    $Perlito5::THROW_RETURN = 0;
                    my $level = 0;
                    my $wantarray = 'void';
                    my $str;
                    $str .= Perlito5::Compiler::do_not_edit('//');
                    Perlito5::Java::init_java_class();
                    my $Java_class = Perlito5::Java::get_java_class_info();
                    for my $comp_unit (@{$comp_units}) {
                        for my $unit_stmt (@{$comp_unit->{'body'}}) {
                            if (ref($unit_stmt) eq 'Perlito5::AST::Block') {
                                my $stmt = $unit_stmt->{'stmts'} // [];
                                @{$stmt} != 2 && next;
                                ($stmt->[0] && ref($stmt->[0]) eq 'Perlito5::AST::Apply' && $stmt->[0]->{'code'} eq 'package') || next;
                                ($stmt->[1] && ref($stmt->[1]) eq 'Perlito5::AST::Apply' && ($stmt->[1]->{'code'} eq 'infix:<=>>' || $stmt->[1]->{'code'} eq 'list:<,>')) || next;
                                my $class = $stmt->[0]->{'namespace'};
                                my $args_ast = Perlito5::AST::Apply::->new('arguments' => [$stmt->[1]], 'code' => 'circumfix:<{ }>');
                                my $out = [];
                                Perlito5::Perl5::PrettyPrinter::pretty_print([$args_ast->emit_perl5()], 0, $out);
                                my $args_perl5 = join('', @{$out});
                                $Java_class->{$class} = eval($args_perl5) or die('error in arguments to generate Java class:' . chr(10) . ${'@'} . chr(10) . $args_perl5);
                                if ($Java_class->{$class}->{'import'}) {
                                    Perlito5::Java::set_java_class_defaults($class, $Java_class->{$class}->{'import'})
                                }
                                elsif ($Java_class->{$class}->{'extends'}) {
                                    my $extended = $Java_class->{$Java_class->{$class}->{'extends'}};
                                    if ($extended) {
                                        $Java_class->{$class}->{'extends_java_type'} = $extended->{'java_type'}
                                    }
                                    else {
                                        die('cannot extend class ' . chr(39) . $Java_class->{$class}->{'extends'} . chr(39) . ' because it was not declared')
                                    }
                                    my $perl_to_java = $class;
                                    $perl_to_java =~ s!::!!g;
                                    Perlito5::Java::set_java_class_defaults($class, $perl_to_java)
                                }
                                elsif ($Java_class->{$class}->{'implements'}) {
                                    my $implemented = $Java_class->{$Java_class->{$class}->{'implements'}};
                                    if ($implemented) {
                                        $Java_class->{$class}->{'implements_java_type'} = $implemented->{'java_type'}
                                    }
                                    else {
                                        die('cannot implement class ' . chr(39) . $Java_class->{$class}->{'implements'} . chr(39) . ' because it was not declared')
                                    }
                                    my $perl_to_java = $class;
                                    $perl_to_java =~ s!::!!g;
                                    Perlito5::Java::set_java_class_defaults($class, $perl_to_java)
                                }
                                else {
                                    die('missing ' . chr(39) . 'import' . chr(39) . ' argument to generate Java class')
                                }
                                $unit_stmt->{'stmts'} = []
                            }
                        }
                    }
                    my @main;
                    for my $comp_unit (@{$comp_units}) {
                        push(@main, $comp_unit->emit_java($level + 1, $wantarray))
                    }
                    if ($options{'expand_use'}) {
                        $str .= Perlito5::Java::Runtime::->emit_java('java_classes' => $Java_class, 'java_constants' => \@Perlito5::Java::Java_constants)
                    }
                    $str .= Perlito5::Java::emit_wrap_java(-1, 'class Main {', ['public static void main(String[] args) {', ['PlEnv.init(args);', 'int want = PlCx.VOID;', 'try {', [@Perlito5::Java::Java_init, @main], '}', 'catch(PlReturnException e) {', ['PlCORE.die("Can' . chr(39) . 't return outside a subroutine");'], '}', 'catch(PlNextException e) {', ['PlCORE.die("Can' . chr(39) . 't ' . chr(92) . '"next' . chr(92) . '" outside a loop block");'], '}', 'catch(PlLastException e) {', ['PlCORE.die("Can' . chr(39) . 't ' . chr(92) . '"last' . chr(92) . '" outside a loop block");'], '}', 'catch(PlRedoException e) {', ['PlCORE.die("Can' . chr(39) . 't ' . chr(92) . '"redo' . chr(92) . '" outside a loop block");'], '}'], '}'], ['public static void init() {', ['main(new String[]{});'], '}'], ['public static PlObject[] apply(String functionName, String... args) {', ['PlArray list = new PlArray(args);', 'PlObject result = PlV.get(functionName).apply(PlCx.LIST, list);', 'PlArray res = result instanceof PlArray ? (PlArray) result : new PlArray(result);', 'PlObject[] out = new PlObject[res.to_int()];', 'int i = 0;', 'for (PlObject s : res.a) {', ['out[i++] = s;'], '}', 'return out;'], '}'], ['public static PlObject[] apply(String functionName, PlObject... args) {', ['PlArray list = new PlArray(args);', 'PlObject result = PlV.get(functionName).apply(PlCx.LIST, list);', 'PlArray res = result instanceof PlArray ? (PlArray) result : new PlArray(result);', 'PlObject[] out = new PlObject[res.to_int()];', 'int i = 0;', 'for (PlObject s : res.a) {', ['out[i++] = s;'], '}', 'return out;'], '}'], '}') . chr(10);
                    return $str
                }
                sub Perlito5::AST::CompUnit::emit_java_get_decl {
                    ()
                }
                sub Perlito5::AST::CompUnit::emit_java_has_regex {
                    ()
                }
            }
            package Perlito5::AST::Int;
            {
                sub Perlito5::AST::Int::emit_java {
                    my($self, $level, $wantarray) = @_;
                    my $v = $self->{'int'};
                    if ($v > (2**63 - 1)) {
                        return 'new PlDouble(' . $v . '.0)'
                    }
                    if ($v >= -2 && $v < 0) {
                        return 'PlCx.MIN' . abs($v)
                    }
                    if ($v >= 0 && $v <= 2) {
                        return 'PlCx.INT' . abs($v)
                    }
                    'new PlInt(' . $v . 'L)'
                }
                sub Perlito5::AST::Int::emit_java_get_decl {
                    ()
                }
                sub Perlito5::AST::Int::emit_java_has_regex {
                    ()
                }
            }
            package Perlito5::AST::Num;
            {
                sub Perlito5::AST::Num::emit_java {
                    my($self, $level, $wantarray) = @_;
                    'new PlDouble(' . $self->{'num'} . ')'
                }
                sub Perlito5::AST::Num::emit_java_get_decl {
                    ()
                }
                sub Perlito5::AST::Num::emit_java_has_regex {
                    ()
                }
            }
            package Perlito5::AST::Buf;
            {
                sub Perlito5::AST::Buf::emit_java {
                    my($self, $level, $wantarray) = @_;
                    'new PlString(' . Perlito5::Java::escape_string($self->{'buf'}) . ')'
                }
                sub Perlito5::AST::Buf::emit_java_get_decl {
                    ()
                }
                sub Perlito5::AST::Buf::emit_java_has_regex {
                    ()
                }
            }
            package Perlito5::AST::Block;
            {
                sub Perlito5::AST::Block::emit_java {
                    my($self, $level, $wantarray) = @_;
                    local $Perlito5::THROW = 0;
                    my $body;
                    if ($wantarray ne 'void') {
                        $body = Perlito5::Java::LexicalBlock::->new('block' => $self->{'stmts'}, 'block_label' => $self->{'label'}, 'continue' => $self->{'continue'})
                    }
                    else {
                        $body = Perlito5::Java::LexicalBlock::->new('block' => $self->{'stmts'}, 'block_label' => $self->{'label'}, 'continue' => $self->{'continue'})
                    }
                    my $init = '';
                    if ($self->{'name'} eq 'INIT') {
                        my $tmp = 'p5pkg.main.' . Perlito5::Java::get_label();
                        $init = Perlito5::Java::tab($level + 2) . 'if (' . $tmp . ') { return }; ' . $tmp . ' = 1;' . chr(10)
                    }
                    my @str = $body->emit_java($level + 1, $wantarray);
                    if ($Perlito5::THROW) {
                        @str = Perlito5::Java::emit_wrap_last_exception_java($self, \@str)
                    }
                    return Perlito5::Java::emit_wrap_java($level, @str)
                }
                sub Perlito5::AST::Block::emit_java_get_decl {
                    ()
                }
                sub Perlito5::AST::Block::emit_java_has_regex {
                    ()
                }
            }
            package Perlito5::AST::Index;
            {
                sub Perlito5::AST::Index::emit_java {
                    my($self, $level, $wantarray, $autovivification_type) = @_;
                    my $method = $autovivification_type || 'aget';
                    $autovivification_type eq 'scalar' && ($method = 'aget_scalarref');
                    $autovivification_type eq 'array' && ($method = 'aget_arrayref');
                    $autovivification_type eq 'hash' && ($method = 'aget_hashref');
                    $autovivification_type eq 'lvalue' && ($method = 'aget_lvalue');
                    $autovivification_type eq 'local' && ($method = 'aget_lvalue_local');
                    if (($self->{'obj'}->isa('Perlito5::AST::Apply') && $self->{'obj'}->{'code'} eq 'prefix:<@>') || ($self->{'obj'}->isa('Perlito5::AST::Var') && $self->{'obj'}->sigil() eq '@') || ($self->{'obj'}->isa('Perlito5::AST::Apply') && $self->{'obj'}->code() eq 'circumfix:<( )>')) {
                        return 'p5list_slice(' . $self->{'obj'}->emit_java($level, 'list') . ', ' . Perlito5::Java::to_list([$self->{'index_exp'}], $level) . ', ' . Perlito5::Java::to_context($wantarray) . ')'
                    }
                    if (($self->{'obj'}->isa('Perlito5::AST::Apply') && $self->{'obj'}->{'code'} eq 'prefix:<%>') || ($self->{'obj'}->isa('Perlito5::AST::Var') && $self->{'obj'}->sigil() eq '%')) {
                        my $obj = $self->{'obj'};
                        $obj->{'sigil'} eq '%' && ($obj->{'sigil'} = '@');
                        $obj->{'code'} eq 'prefix:<%>' && ($obj->{'code'} = 'prefix:<@>');
                        return 'p5hash_slice(' . $self->{'obj'}->emit_java($level, 'list') . ', ' . Perlito5::Java::to_list([$self->{'index_exp'}], $level) . ', ' . Perlito5::Java::to_context($wantarray) . ')'
                    }
                    my $arg = $self->{'index_exp'};
                    my $s;
                    if ($arg->isa('Perlito5::AST::Int')) {
                        $s = $arg->{'int'}
                    }
                    else {
                        $s = $arg->emit_java($level, 'scalar')
                    }
                    return $self->emit_java_container($level) . '.' . $method . '(' . $s . ')'
                }
                sub Perlito5::AST::Index::emit_java_set {
                    my($self, $arguments, $level, $wantarray, $localize) = @_;
                    if (($self->{'obj'}->isa('Perlito5::AST::Apply') && $self->{'obj'}->{'code'} eq 'prefix:<@>') || ($self->{'obj'}->isa('Perlito5::AST::Var') && $self->{'obj'}->sigil() eq '@')) {
                        return Perlito5::Java::emit_wrap_java($level, 'var a = [];', 'var v = ' . Perlito5::Java::to_list([$self->{'index_exp'}], $level) . ';', 'var src=' . Perlito5::Java::to_list([$arguments], $level) . ';', 'var out=' . Perlito5::Java::emit_java_autovivify($self->{'obj'}, $level, 'array') . ';', 'var tmp' . ';', 'for (var i=0, l=v.length; i<l; ++i) {', ['tmp = src.aget(i);', 'out.aset(v[i], tmp);', 'a.push(tmp)'], '}', 'return a')
                    }
                    if ($localize) {
                        return $self->emit_java_container($level) . '.aget_lvalue_local(' . Perlito5::Java::autoquote($self->{'index_exp'}, $level) . ').set(' . Perlito5::Java::to_scalar([$arguments], $level + 1) . ')'
                    }
                    my $arg = $self->{'index_exp'};
                    my $s;
                    if ($arg->isa('Perlito5::AST::Int')) {
                        $s = $arg->{'int'}
                    }
                    else {
                        $s = $arg->emit_java($level, 'scalar')
                    }
                    return $self->emit_java_container($level) . '.aset(' . $s . ', ' . Perlito5::Java::to_scalar([$arguments], $level + 1) . ')'
                }
                sub Perlito5::AST::Index::emit_java_set_list {
                    my($self, $level, $list) = @_;
                    my $wantarray = 'list';
                    if (($self->{'obj'}->isa('Perlito5::AST::Apply') && $self->{'obj'}->{'code'} eq 'prefix:<@>') || ($self->{'obj'}->isa('Perlito5::AST::Var') && $self->{'obj'}->sigil() eq '@')) {
                        return Perlito5::Java::emit_wrap_java($level, 'var a = [];', 'var v = ' . Perlito5::Java::to_list([$self->{'index_exp'}], $level) . ';', 'var out=' . Perlito5::Java::emit_java_autovivify($self->{'obj'}, $level, 'array') . ';', 'var tmp' . ';', 'for (var i=0, l=v.length; i<l; ++i) {', ['tmp = ' . $list . '.shift();', 'out.aset(v[i], tmp);', 'a.push(tmp)'], '}', 'return a')
                    }
                    my $arg = $self->{'index_exp'};
                    my $s;
                    if ($arg->isa('Perlito5::AST::Int')) {
                        $s = $arg->{'int'}
                    }
                    else {
                        $s = $arg->emit_java($level, 'scalar')
                    }
                    return $self->emit_java_container($level) . '.aset(' . $s . ', ' . $list . '.shift()' . ')'
                }
                sub Perlito5::AST::Index::emit_java_container {
                    my $self = shift;
                    my $level = shift;
                    if ($self->{'obj'}->isa('Perlito5::AST::Apply') && $self->{'obj'}->{'code'} eq 'prefix:<$>') {
                        my $v = Perlito5::AST::Apply::->new(%{$self->{'obj'}}, 'code' => 'prefix:<@>');
                        return $v->emit_java($level)
                    }
                    if ($self->{'obj'}->isa('Perlito5::AST::Apply') && $self->{'obj'}->code() eq 'circumfix:<( )>') {
                        return Perlito5::Java::to_list([$self->{'obj'}], $level)
                    }
                    if ($self->{'obj'}->isa('Perlito5::AST::Var') && $self->{'obj'}->sigil() eq '$') {
                        $self->{'obj'}->{'sigil'} = '@';
                        return $self->{'obj'}->emit_java($level)
                    }
                    else {
                        return Perlito5::Java::emit_java_autovivify($self->{'obj'}, $level, 'array')
                    }
                }
                sub Perlito5::AST::Index::emit_java_get_decl {
                    ()
                }
                sub Perlito5::AST::Index::emit_java_has_regex {
                    ()
                }
            }
            package Perlito5::AST::Lookup;
            {
                sub Perlito5::AST::Lookup::emit_java {
                    my($self, $level, $wantarray, $autovivification_type) = @_;
                    my $method = $autovivification_type || 'hget';
                    $autovivification_type eq 'scalar' && ($method = 'hget_scalarref');
                    $autovivification_type eq 'array' && ($method = 'hget_arrayref');
                    $autovivification_type eq 'hash' && ($method = 'hget_hashref');
                    $autovivification_type eq 'lvalue' && ($method = 'hget_lvalue');
                    $autovivification_type eq 'local' && ($method = 'hget_lvalue_local');
                    if (($self->{'obj'}->isa('Perlito5::AST::Apply') && $self->{'obj'}->{'code'} eq 'prefix:<@>') || ($self->{'obj'}->isa('Perlito5::AST::Var') && $self->{'obj'}->sigil() eq '@')) {
                        my $v;
                        if ($self->{'obj'}->isa('Perlito5::AST::Var')) {
                            $v = $self->{'obj'}
                        }
                        $self->{'obj'}->isa('Perlito5::AST::Apply') && ($v = Perlito5::AST::Apply::->new('code' => 'prefix:<%>', 'namespace' => $self->{'obj'}->namespace(), 'arguments' => $self->{'obj'}->arguments()));
                        return $v->emit_java($level, 'list') . '.' . $method . '(' . Perlito5::Java::to_context($wantarray) . ', ' . Perlito5::Java::to_list([$self->{'index_exp'}], $level) . ')'
                    }
                    if (($self->{'obj'}->isa('Perlito5::AST::Apply') && $self->{'obj'}->{'code'} eq 'prefix:<%>') || ($self->{'obj'}->isa('Perlito5::AST::Var') && $self->{'obj'}->sigil() eq '%')) {
                        my $v;
                        if ($self->{'obj'}->isa('Perlito5::AST::Var')) {
                            $v = $self->{'obj'}
                        }
                        $self->{'obj'}->isa('Perlito5::AST::Apply') && ($v = Perlito5::AST::Apply::->new('code' => 'prefix:<%>', 'namespace' => $self->{'obj'}->namespace(), 'arguments' => $self->{'obj'}->arguments()));
                        return 'p5hash_lookup_slice(' . $v->emit_java($level, 'list') . ', ' . Perlito5::Java::to_list([$self->{'index_exp'}], $level) . ', ' . Perlito5::Java::to_context($wantarray) . ')'
                    }
                    return $self->emit_java_container($level) . '.' . $method . '(' . Perlito5::Java::autoquote($self->{'index_exp'}, $level) . ')'
                }
                sub Perlito5::AST::Lookup::emit_java_set {
                    my($self, $arguments, $level, $wantarray, $localize) = @_;
                    if (($self->{'obj'}->isa('Perlito5::AST::Apply') && $self->{'obj'}->{'code'} eq 'prefix:<@>') || ($self->{'obj'}->isa('Perlito5::AST::Var') && $self->{'obj'}->sigil() eq '@')) {
                        my $v;
                        $self->{'obj'}->isa('Perlito5::AST::Var') && ($v = $self->{'obj'});
                        $self->{'obj'}->isa('Perlito5::AST::Apply') && ($v = Perlito5::AST::Apply::->new('code' => 'prefix:<%>', 'namespace' => $self->{'obj'}->namespace(), 'arguments' => $self->{'obj'}->arguments()));
                        return $self->emit_java_container($level) . '.hset(' . Perlito5::Java::to_context($wantarray) . ', ' . Perlito5::Java::to_list([$arguments], $level) . ', ' . Perlito5::Java::to_list([$self->{'index_exp'}], $level) . ')'
                    }
                    if ($localize) {
                        return $self->emit_java_container($level) . '.hget_lvalue_local(' . Perlito5::Java::autoquote($self->{'index_exp'}, $level) . ').set(' . Perlito5::Java::to_scalar([$arguments], $level + 1) . ')'
                    }
                    return $self->emit_java_container($level) . '.hset(' . Perlito5::Java::autoquote($self->{'index_exp'}, $level) . ', ' . Perlito5::Java::to_scalar([$arguments], $level + 1) . ')'
                }
                sub Perlito5::AST::Lookup::emit_java_set_list {
                    my($self, $level, $list) = @_;
                    my $wantarray = 'list';
                    if (($self->{'obj'}->isa('Perlito5::AST::Apply') && $self->{'obj'}->{'code'} eq 'prefix:<@>') || ($self->{'obj'}->isa('Perlito5::AST::Var') && $self->{'obj'}->sigil() eq '@')) {
                        my $v;
                        $self->{'obj'}->isa('Perlito5::AST::Var') && ($v = $self->{'obj'});
                        $self->{'obj'}->isa('Perlito5::AST::Apply') && ($v = Perlito5::AST::Apply::->new('code' => 'prefix:<%>', 'namespace' => $self->{'obj'}->namespace(), 'arguments' => $self->{'obj'}->arguments()));
                        return Perlito5::Java::emit_wrap_java($level, 'var a = [];', 'var v = ' . Perlito5::Java::to_list([$self->{'index_exp'}], $level) . ';', 'var out=' . $v->emit_java($level) . ';', 'var tmp' . ';', 'for (var i=0, l=v.length; i<l; ++i)' . '{', ['tmp = ' . $list . '.shift();', 'out.hset(v[i], tmp);', 'a.push(tmp)'], '}', 'return a')
                    }
                    return $self->emit_java_container($level) . '.hset(' . Perlito5::Java::autoquote($self->{'index_exp'}, $level) . ', ' . $list . '.shift()' . ')'
                }
                sub Perlito5::AST::Lookup::emit_java_container {
                    my $self = shift;
                    my $level = shift;
                    if ($self->{'obj'}->isa('Perlito5::AST::Apply') && $self->{'obj'}->{'code'} eq 'prefix:<$>') {
                        my $v = Perlito5::AST::Apply::->new(%{$self->{'obj'}}, 'code' => 'prefix:<%>');
                        return $v->emit_java($level)
                    }
                    if ($self->{'obj'}->isa('Perlito5::AST::Var') && $self->{'obj'}->sigil() eq '$') {
                        my $v = Perlito5::AST::Var::->new(%{$self->{'obj'}}, 'sigil' => '%');
                        return $v->emit_java($level)
                    }
                    else {
                        return Perlito5::Java::emit_java_autovivify($self->{'obj'}, $level, 'hash')
                    }
                }
                sub Perlito5::AST::Lookup::emit_java_get_decl {
                    ()
                }
                sub Perlito5::AST::Lookup::emit_java_has_regex {
                    ()
                }
            }
            package Perlito5::AST::Var;
            {
                my $table = {'$' => 'v_', '@' => 'List_', '%' => 'Hash_', '&' => ''};
                sub Perlito5::AST::Var::emit_java_global {
                    my($self, $level, $wantarray, $localize) = @_;
                    my $local = $localize ? '_local' : '';
                    my $str_name = $self->{'name'};
                    my $sigil = $self->{'_real_sigil'} || $self->{'sigil'};
                    my $namespace = $self->{'namespace'} || $self->{'_namespace'};
                    if ($sigil eq '@' && $self->{'name'} eq '_' && $namespace eq 'main') {
                        my $s = 'List__';
                        if ($self->{'sigil'} eq '$#') {
                            return $s . '.end_of_array_index()'
                        }
                        if ($wantarray eq 'scalar') {
                            return $s . '.length_of_array()'
                        }
                        if ($wantarray eq 'runtime') {
                            return '(want == PlCx.LIST' . ' ? ' . $s . ' : ' . $s . '.to_long()' . ')'
                        }
                        return $s
                    }
                    if ($sigil eq '$' && $self->{'name'} > 0) {
                        return 'p5_regex_capture[' . ($self->{'name'} - 1) . ']'
                    }
                    if ($sigil eq '::') {
                        return Perlito5::Java::escape_string($namespace)
                    }
                    my $index = Perlito5::Java::escape_string($namespace . '::' . $table->{$sigil} . $str_name);
                    if ($sigil eq '$') {
                        return 'PlV.get' . $local . '(' . $index . ')'
                    }
                    if ($sigil eq '*') {}
                    if ($sigil eq '&') {}
                    if ($sigil eq '@') {
                        if ($self->{'sigil'} eq '$#') {
                            return 'PlV.array_get' . $local . '(' . $index . ').end_of_array_index()'
                        }
                        my $s = 'PlV.array_get' . $local . '(' . $index . ')';
                        if ($wantarray eq 'scalar') {
                            return $s . '.length_of_array()'
                        }
                        return $s
                    }
                    if ($sigil eq '%') {
                        return 'PlV.hash_get' . $local . '(' . $index . ')'
                    }
                    die('don' . chr(39) . 't know how to access variable ', $sigil, $self->name())
                }
                sub Perlito5::AST::Var::emit_java_global_set {
                    my($self, $arguments, $level, $wantarray, $localize) = @_;
                    my $local = $localize ? '_local' : '';
                    my $str_name = $self->{'name'};
                    my $sigil = $self->{'_real_sigil'} || $self->{'sigil'};
                    my $namespace = $self->{'namespace'} || $self->{'_namespace'};
                    if ($sigil eq '@' && $self->{'name'} eq '_' && $namespace eq 'main') {
                        my $s = 'List__';
                        if ($self->{'sigil'} eq '$#') {
                            return $s . '.set_end_of_array_index(' . Perlito5::Java::to_scalar([$arguments], $level + 1) . ')'
                        }
                        if ($wantarray eq 'scalar') {
                            return $s . '.to_long()'
                        }
                        if ($wantarray eq 'runtime') {
                            return '(want' . ' ? ' . $s . ' : ' . $s . '.to_long()' . ')'
                        }
                        return $s
                    }
                    if ($sigil eq '$' && $self->{'name'} > 0) {
                        return 'p5_regex_capture[' . ($self->{'name'} - 1) . ']'
                    }
                    if ($sigil eq '::') {
                        return Perlito5::Java::escape_string($namespace)
                    }
                    my $index = Perlito5::Java::escape_string($namespace . '::' . $table->{$sigil} . $str_name);
                    if ($sigil eq '$') {
                        return 'PlV.set' . $local . '(' . $index . ', ' . Perlito5::Java::to_scalar([$arguments], $level + 1) . ')'
                    }
                    if ($sigil eq '@') {
                        if ($self->{'sigil'} eq '$#') {
                            $self->{'sigil'} = '@';
                            return 'PlV.array_get(' . $index . ').set_end_of_array_index(' . Perlito5::Java::to_scalar([$arguments], $level + 1) . ')'
                        }
                        return 'PlV.array_set' . $local . '(' . $index . ', ' . Perlito5::Java::to_list([$arguments], $level + 1) . ')'
                    }
                    if ($sigil eq '%') {
                        return 'PlV.hash_set' . $local . '(' . $index . ', ' . Perlito5::Java::to_list([$arguments], $level + 1) . ')'
                    }
                    if ($sigil eq '*') {
                        die('don' . chr(39) . 't know how to assign to variable ', $sigil, $self->name())
                    }
                    if ($sigil eq '&') {}
                    die('don' . chr(39) . 't know how to assign to variable ', $sigil, $self->name())
                }
                sub Perlito5::AST::Var::emit_java {
                    my($self, $level, $wantarray) = @_;
                    my $sigil = $self->{'_real_sigil'} || $self->{'sigil'};
                    my $decl_type = $self->{'_decl'} || 'global';
                    if ($decl_type ne 'my' && $decl_type ne 'our') {
                        return $self->emit_java_global($level, $wantarray)
                    }
                    my $str_name = $table->{$sigil} . $self->{'name'} . '_' . $self->{'_id'};
                    exists($Perlito5::Java::Java_var_name{$self->{'_id'}}) && ($str_name = $Perlito5::Java::Java_var_name{$self->{'_id'}});
                    if ($sigil eq '@') {
                        if ($wantarray eq 'scalar') {
                            return $self->emit_java($level, 'list') . '.length_of_array()'
                        }
                        if ($wantarray eq 'runtime') {
                            return '(want == PlCx.LIST' . ' ? ' . $self->emit_java($level, 'list') . ' : ' . $self->emit_java($level, 'list') . '.length_of_array()' . ')'
                        }
                    }
                    if ($self->{'sigil'} eq '$#') {
                        return $str_name . '.end_of_array_index()'
                    }
                    return $str_name
                }
                sub Perlito5::AST::Var::emit_java_set {
                    my($self, $arguments, $level, $wantarray) = @_;
                    my $decl_type = $self->{'_decl'} || 'global';
                    if ($decl_type ne 'my' && $decl_type ne 'our') {
                        return $self->emit_java_global_set($arguments, $level, $wantarray)
                    }
                    my $open = $wantarray eq 'void' ? '' : '(';
                    my $close = $wantarray eq 'void' ? '' : ')';
                    my $sigil = $self->{'_real_sigil'} || $self->{'sigil'};
                    if ($sigil eq '$') {
                        my $id = $self->{'_id'};
                        my $Java_var = Perlito5::Java::get_java_var_info();
                        my $type = $Java_var->{$id}->{'type'} || 'PlLvalue';
                        if ($type ne 'PlLvalue') {
                            return $self->emit_java() . ' = ' . Perlito5::Java::to_native_args([$arguments])
                        }
                        return $self->emit_java() . '.set(' . Perlito5::Java::to_scalar([$arguments], $level + 1) . ')'
                    }
                    if ($sigil eq '@') {
                        if ($self->{'sigil'} eq '$#') {
                            $self->{'sigil'} = '@';
                            return $open . $self->emit_java() . '.set_end_of_array_index(' . Perlito5::Java::to_scalar([$arguments], $level + 1) . ')' . $close
                        }
                        return $self->emit_java() . '.set(' . Perlito5::Java::to_list([$arguments], $level + 1) . ')'
                    }
                    if ($sigil eq '%') {
                        return $self->emit_java() . '.set(' . Perlito5::Java::to_list([$arguments], $level + 1, 'hash') . ')'
                    }
                    if ($sigil eq '*') {
                        my $namespace = $self->{'namespace'} || $self->{'_namespace'};
                        return 'p5typeglob_set(' . Perlito5::Java::escape_string($namespace) . ', ' . Perlito5::Java::escape_string($self->{'name'}) . ', ' . Perlito5::Java::to_scalar([$arguments], $level + 1) . ')'
                    }
                    die('don' . chr(39) . 't know how to assign to variable ', $sigil, $self->name())
                }
                sub Perlito5::AST::Var::emit_java_set_list {
                    my($self, $level, $list) = @_;
                    my $sigil = $self->{'_real_sigil'} || $self->{'sigil'};
                    if ($sigil eq '$') {
                        return $self->emit_java() . '.set(' . $list . '.shift())'
                    }
                    if ($sigil eq '@') {
                        return join(';' . chr(10) . Perlito5::Java::tab($level), $self->emit_java() . ' = ' . $list, $list . ' = []')
                    }
                    if ($sigil eq '%') {
                        return join(';' . chr(10) . Perlito5::Java::tab($level), $self->emit_java() . ' = new PlHash(' . $list . ')', $list . ' = []')
                    }
                    die('don' . chr(39) . 't know how to assign to variable ', $sigil, $self->name())
                }
                sub Perlito5::AST::Var::emit_java_get_decl {
                    ()
                }
                sub Perlito5::AST::Var::emit_java_has_regex {
                    ()
                }
            }
            package Perlito5::AST::Decl;
            {
                sub Perlito5::AST::Decl::emit_java {
                    my($self, $level, $wantarray) = @_;
                    my $var = $self->{'var'};
                    my $localize = '';
                    if ($self->{'decl'} eq 'local') {
                        $localize = 'local';
                        if (ref($var) eq 'Perlito5::AST::Var') {
                            return $var->emit_java_global($level, $wantarray, $localize)
                        }
                    }
                    $var->emit_java($level, $wantarray, $localize)
                }
                sub Perlito5::AST::Decl::emit_java_init {
                    my($self, $level, $wantarray) = @_;
                    my $var = $self->{'var'};
                    my $Java_var = Perlito5::Java::get_java_var_info();
                    my $type = $self->{'type'} || 'PlLvalue';
                    my $id = $self->{'var'}->{'_id'};
                    if ($id) {
                        $Java_var->{$id} = {'id' => $id, 'type' => $type}
                    }
                    if ($self->{'decl'} eq 'local') {
                        return ''
                    }
                    if ($self->{'decl'} eq 'my') {
                        if ($self->{'var'}->sigil() eq '%') {
                            return 'PlHash ' . $self->{'var'}->emit_java() . ' = new PlHash();'
                        }
                        elsif ($self->{'var'}->sigil() eq '@') {
                            return 'PlArray ' . $self->{'var'}->emit_java() . ' = new PlArray();'
                        }
                        else {
                            my $Java_class = Perlito5::Java::get_java_class_info();
                            my $java_type = $Java_class->{$type}->{'java_type'} || 'PlLvalue';
                            if ($java_type eq 'PlLvalue') {
                                return $java_type . ' ' . $self->{'var'}->emit_java() . ' = new ' . $java_type . '();'
                            }
                            else {
                                return $java_type . ' ' . $self->{'var'}->emit_java() . ';'
                            }
                        }
                    }
                    elsif ($self->{'decl'} eq 'our') {
                        my $v = Perlito5::AST::Var::->new(%{$self->{'var'}}, '_decl' => 'my');
                        if ($self->{'var'}->sigil() eq '%') {
                            return 'PlHash ' . $v->emit_java() . ' = ' . Perlito5::AST::Var::emit_java_global($self->{'var'}) . ';'
                        }
                        elsif ($self->{'var'}->sigil() eq '@') {
                            return 'PlArray ' . $v->emit_java() . ' = ' . Perlito5::AST::Var::emit_java_global($self->{'var'}) . ';'
                        }
                        else {
                            return 'PlLvalue ' . $v->emit_java() . ' = ' . Perlito5::AST::Var::emit_java_global($self->{'var'}) . ';'
                        }
                    }
                    elsif ($self->{'decl'} eq 'state') {
                        return '// state ' . $self->{'var'}->emit_java()
                    }
                    else {
                        die('not implemented: Perlito5::AST::Decl ' . chr(39) . $self->{'decl'} . chr(39))
                    }
                }
                sub Perlito5::AST::Decl::emit_java_set {
                    my($self, $arguments, $level, $wantarray) = @_;
                    my $var = $self->{'var'};
                    my $localize = '';
                    if ($self->{'decl'} eq 'local') {
                        $localize = 'local';
                        if (ref($var) eq 'Perlito5::AST::Var') {
                            return $var->emit_java_global_set($arguments, $level, $wantarray, $localize)
                        }
                    }
                    $var->emit_java_set($arguments, $level, $wantarray, $localize)
                }
                sub Perlito5::AST::Decl::emit_java_set_list {
                    my($self, $level, $list) = @_;
                    $self->var()->emit_java_set_list($level, $list)
                }
                sub Perlito5::AST::Decl::emit_java_get_decl {
                    my $self = shift;
                    return ($self)
                }
                sub Perlito5::AST::Decl::emit_java_has_regex {
                    ()
                }
            }
            package Perlito5::AST::Call;
            {
                sub Perlito5::AST::Call::emit_java {
                    my($self, $level, $wantarray, $autovivification_type) = @_;
                    my $meth = $self->{'method'};
                    if ($meth eq 'postcircumfix:<[ ]>') {
                        my $method = $autovivification_type || 'aget';
                        $autovivification_type eq 'scalar' && ($method = 'aget_scalarref');
                        $autovivification_type eq 'array' && ($method = 'aget_arrayref');
                        $autovivification_type eq 'hash' && ($method = 'aget_hashref');
                        $autovivification_type eq 'lvalue' && ($method = 'aget_lvalue');
                        return Perlito5::Java::emit_java_autovivify($self->{'invocant'}, $level, 'array') . '.' . $method . '(' . Perlito5::Java::to_num($self->{'arguments'}, $level + 1) . ')'
                    }
                    if ($meth eq 'postcircumfix:<{ }>') {
                        my $method = $autovivification_type || 'hget';
                        $autovivification_type eq 'scalar' && ($method = 'hget_scalarref');
                        $autovivification_type eq 'array' && ($method = 'hget_arrayref');
                        $autovivification_type eq 'hash' && ($method = 'hget_hashref');
                        $autovivification_type eq 'lvalue' && ($method = 'hget_lvalue');
                        return Perlito5::Java::emit_java_autovivify($self->{'invocant'}, $level, 'hash') . '.' . $method . '(' . Perlito5::Java::autoquote($self->{'arguments'}, $level + 1, 'list') . ')'
                    }
                    if ($meth eq 'postcircumfix:<( )>') {
                        my $invocant;
                        if (ref($self->{'invocant'}) eq 'Perlito5::AST::Apply' && $self->{'invocant'}->{'code'} eq 'prefix:<&>') {
                            my $arg = $self->{'invocant'}->{'arguments'}->[0];
                            $invocant = 'p5code_lookup_by_name(' . Perlito5::Java::escape_string($Perlito5::PKG_NAME) . ', ' . $arg->emit_java($level) . ')'
                        }
                        elsif (ref($self->{'invocant'}) eq 'Perlito5::AST::Var' && $self->{'invocant'}->{'sigil'} eq '&') {
                            $invocant = 'p5pkg[' . Perlito5::Java::escape_string(($self->{'invocant'}->{'namespace'} || $Perlito5::PKG_NAME)) . '][' . Perlito5::Java::escape_string($self->{'invocant'}->{'name'}) . ']'
                        }
                        elsif (ref($self->{'invocant'}) eq 'Perlito5::AST::Var' && $self->{'invocant'}->{'sigil'} eq '::' && $self->{'invocant'}->{'namespace'} eq '__SUB__') {
                            $invocant = 'this'
                        }
                        else {
                            $invocant = $self->{'invocant'}->emit_java($level, 'scalar')
                        }
                        return $invocant . '.apply(' . Perlito5::Java::to_context($wantarray) . ', ' . Perlito5::Java::to_list($self->{'arguments'}) . ')'
                    }
                    if (ref($self->{'invocant'}) eq 'Perlito5::AST::Var' && $self->{'invocant'}->{'sigil'} eq '::') {
                        my $Java_class = Perlito5::Java::get_java_class_info();
                        if (exists($Java_class->{$self->{'invocant'}->{'namespace'}})) {
                            my $info = $Java_class->{$self->{'invocant'}->{'namespace'}};
                            if ($meth eq 'new') {
                                return 'new ' . $info->{'java_type'} . '(' . Perlito5::Java::to_native_args($self->{'arguments'}) . ')'
                            }
                            if ($self->{'_no_params'}) {
                                return $info->{'java_type'} . '.' . $meth
                            }
                            else {
                                return $info->{'java_type'} . '.' . $meth . '(' . Perlito5::Java::to_native_args($self->{'arguments'}) . ')'
                            }
                        }
                    }
                    my $invocant = $self->{'invocant'}->emit_java($level, 'scalar');
                    if (ref($self->{'invocant'}) eq 'Perlito5::AST::Var' && $self->{'invocant'}->{'_id'}) {
                        my $id = $self->{'invocant'}->{'_id'};
                        my $Java_var = Perlito5::Java::get_java_var_info();
                        my $type = $Java_var->{$id}->{'type'} || 'PlLvalue';
                        if ($type ne 'PlLvalue') {
                            if ($self->{'_no_params'}) {
                                return $invocant . '.' . $meth
                            }
                            else {
                                return $invocant . '.' . $meth . '(' . Perlito5::Java::to_native_args($self->{'arguments'}) . ')'
                            }
                        }
                    }
                    if ($meth =~ m!^to!) {
                        my $Java_class = Perlito5::Java::get_java_class_info();
                        for my $info (values(%{$Java_class})) {
                            if ($meth eq $info->{'perl_to_java'}) {
                                return $invocant . '.' . $meth . '()'
                            }
                        }
                    }
                    if (ref($meth) eq 'Perlito5::AST::Var') {
                        $meth = $meth->emit_java($level, 'scalar')
                    }
                    else {
                        $meth = Perlito5::Java::escape_string($meth)
                    }
                    return 'PerlOp.call(' . $invocant . ', ' . $meth . ', ' . Perlito5::Java::to_list($self->{'arguments'}) . ', ' . Perlito5::Java::to_context($wantarray) . ')'
                }
                sub Perlito5::AST::Call::emit_java_set {
                    my($self, $arguments, $level, $wantarray) = @_;
                    if ($self->{'method'} eq 'postcircumfix:<[ ]>') {
                        return Perlito5::Java::emit_java_autovivify($self->{'invocant'}, $level, 'array') . '.aset(' . Perlito5::Java::to_num($self->{'arguments'}, $level + 1) . ', ' . Perlito5::Java::to_scalar([$arguments], $level + 1) . ')'
                    }
                    if ($self->{'method'} eq 'postcircumfix:<{ }>') {
                        return Perlito5::Java::emit_java_autovivify($self->{'invocant'}, $level, 'hash') . '.hset(' . Perlito5::Java::autoquote($self->{'arguments'}, $level + 1, 'list') . ', ' . Perlito5::Java::to_scalar([$arguments], $level + 1) . ')'
                    }
                    die('don' . chr(39) . 't know how to assign to method ', $self->{'method'})
                }
                sub Perlito5::AST::Call::emit_java_set_list {
                    my($self, $level, $list) = @_;
                    if ($self->{'method'} eq 'postcircumfix:<[ ]>') {
                        return Perlito5::Java::emit_java_autovivify($self->{'invocant'}, $level, 'array') . '.aset(' . Perlito5::Java::to_num($self->{'arguments'}, $level + 1) . ', ' . $list . '.shift()' . ')'
                    }
                    if ($self->{'method'} eq 'postcircumfix:<{ }>') {
                        return Perlito5::Java::emit_java_autovivify($self->{'invocant'}, $level, 'hash') . '.hset(' . Perlito5::Java::autoquote($self->{'arguments'}, $level + 1, 'list') . ', ' . $list . '.shift()' . ')'
                    }
                    die('don' . chr(39) . 't know how to assign to method ', $self->{'method'})
                }
                sub Perlito5::AST::Call::emit_java_get_decl {
                    ()
                }
                sub Perlito5::AST::Call::emit_java_has_regex {
                    ()
                }
            }
            package Perlito5::AST::Apply;
            {
                sub Perlito5::AST::Apply::emit_qr_java {
                    my($regex, $modifier, $level) = @_;
                    if ($modifier->{'buf'} eq '' && ref($regex) eq 'Perlito5::AST::Var' && $regex->{'sigil'} eq '$') {
                        return $regex->emit_java($level)
                    }
                    my %flags = map {
                        $_ => 1
                    } split(m!!, $modifier->{'buf'});
                    my $flag_string = join(' | ', ($flags{'i'} ? 'Pattern.CASE_INSENSITIVE' : ()), ($flags{'x'} ? 'Pattern.COMMENTS' : ()), ($flags{'m'} ? 'Pattern.MULTILINE' : ()), ($flags{'s'} ? 'Pattern.DOTALL' : ())) || 0;
                    my $s = 'new PlRegex(' . Perlito5::Java::to_str($regex) . ', ' . $flag_string . ')';
                    if (ref($regex) eq 'Perlito5::AST::Buf') {
                        my $label = Perlito5::Java::get_label();
                        push(@Perlito5::Java::Java_constants, 'public static final PlRegex ' . $label . ' = ' . $s . ';');
                        return 'PlCx.' . $label
                    }
                    return $s
                }
                sub Perlito5::AST::Apply::emit_regex_java {
                    my $op = shift;
                    my $var = shift;
                    my $regex = shift;
                    my $level = shift;
                    my $wantarray = shift;
                    if ($regex->isa('Perlito5::AST::Var')) {
                        $regex = {'code' => 'p5:m', 'arguments' => [$regex, '']}
                    }
                    my $str;
                    my $code = $regex->{'code'};
                    my $regex_args = $regex->{'arguments'};
                    if ($code eq 'p5:s') {
                        my $replace = $regex_args->[1];
                        my $modifier = $regex_args->[2]->{'buf'};
                        if (ref($replace) eq 'Perlito5::AST::Block') {
                            $replace = Perlito5::AST::Apply::->new('code' => 'do', 'arguments' => [$replace]);
                            $modifier =~ s!e!!g
                        }
                        $str = 'PerlOp.replace(' . $var->emit_java() . ', ' . emit_qr_java($regex_args->[0], $modifier, $level) . ', ' . $replace->emit_java() . ', ' . Perlito5::Java::to_context($wantarray) . ')'
                    }
                    elsif ($code eq 'p5:m') {
                        $str = 'PerlOp.match(' . $var->emit_java() . ', ' . emit_qr_java($regex_args->[0], $regex_args->[1], $level) . ', ' . Perlito5::Java::to_context($wantarray) . ')'
                    }
                    elsif ($code eq 'p5:tr') {
                        $str = Perlito5::Java::emit_wrap_java($level + 1, 'var tmp = p5tr(' . $var->emit_java() . ', ' . $regex_args->[0]->emit_java() . ', ' . $regex_args->[1]->emit_java() . ', ' . Perlito5::Java::escape_string($regex_args->[2]->{'buf'}) . ', ' . Perlito5::Java::to_context($wantarray) . ');', $var->emit_java() . ' = tmp[0];', 'return tmp[1];')
                    }
                    else {
                        die('Error: regex emitter - unknown operator ' . $code)
                    }
                    if ($op eq '=~') {
                        return $str
                    }
                    if ($op eq '!~') {
                        return '!(' . $str . ')'
                    }
                    die('Error: regex emitter')
                }
                sub Perlito5::AST::Apply::emit_java_set {
                    my($self, $arguments, $level, $wantarray) = @_;
                    my $code = $self->{'code'};
                    if ($code eq 'prefix:<$>') {
                        return Perlito5::Java::emit_java_autovivify($self->{'arguments'}->[0], $level + 1, 'scalar') . '.scalar_deref_set(' . Perlito5::Java::to_scalar([$arguments], $level + 1) . ')'
                    }
                    if ($code eq 'prefix:<@>') {
                        return Perlito5::Java::emit_java_autovivify($self->{'arguments'}->[0], $level + 1, 'array') . '.array_deref_set(' . Perlito5::Java::to_list([$arguments], $level + 1) . ')'
                    }
                    if ($code eq 'prefix:<%>') {
                        return Perlito5::Java::emit_java_autovivify($self->{'arguments'}->[0], $level + 1, 'hash') . '.hash_deref_set(' . Perlito5::Java::to_list([$arguments], $level + 1) . ')'
                    }
                    if ($code eq 'prefix:<*>') {
                        return 'PlCORE.die("prefix:<*> not implemented")';
                        return 'p5typeglob_deref_set(' . Perlito5::Java::to_scalar($self->{'arguments'}, $level + 1) . ', ' . Perlito5::Java::to_scalar([$arguments], $level + 1) . ', ' . Perlito5::Java::escape_string($Perlito5::PKG_NAME) . ')'
                    }
                    my $open = $wantarray eq 'void' ? '' : '(';
                    my $close = $wantarray eq 'void' ? '' : ')';
                    $open . $self->emit_java($level + 1) . ' = ' . $arguments->emit_java($level + 1) . $close
                }
                my %emit_js = ('infix:<=~>' => sub {
                    my($self, $level, $wantarray) = @_;
                    emit_regex_java('=~', $self->{'arguments'}->[0], $self->{'arguments'}->[1], $level, $wantarray)
                }, 'infix:<!~>' => sub {
                    my($self, $level, $wantarray) = @_;
                    emit_regex_java('!~', $self->{'arguments'}->[0], $self->{'arguments'}->[1], $level, $wantarray)
                }, 'p5:s' => sub {
                    my($self, $level, $wantarray) = @_;
                    emit_regex_java('=~', $self->{'arguments'}->[3], $self, $level, $wantarray)
                }, 'p5:m' => sub {
                    my($self, $level, $wantarray) = @_;
                    emit_regex_java('=~', $self->{'arguments'}->[2], $self, $level, $wantarray)
                }, 'p5:tr' => sub {
                    my($self, $level, $wantarray) = @_;
                    emit_regex_java('=~', $self->{'arguments'}->[3], $self, $level, $wantarray)
                }, 'p5:qr' => sub {
                    my($self, $level, $wantarray) = @_;
                    return emit_qr_java($self->{'arguments'}->[0], $self->{'arguments'}->[1], $level)
                }, '__PACKAGE__' => sub {
                    my($self, $level, $wantarray) = @_;
                    Perlito5::Java::escape_string($Perlito5::PKG_NAME)
                }, '__SUB__' => sub {
                    my($self, $level, $wantarray) = @_;
                    $Perlito5::AST::Sub::SUB_REF // 'this'
                }, 'wantarray' => sub {
                    my($self, $level, $wantarray) = @_;
                    '(want == PlCx.VOID ? PlCx.UNDEF : new PlInt(want-1))'
                }, 'package' => sub {
                    ''
                }, 'uc' => sub {
                    my($self, $level, $wantarray) = @_;
                    'new PlString(' . $self->{'arguments'}->[0]->emit_java($level, 'scalar') . '.toString().toUpperCase())'
                }, 'lc' => sub {
                    my($self, $level, $wantarray) = @_;
                    'new PlString(' . $self->{'arguments'}->[0]->emit_java($level, 'scalar') . '.toString().toLowerCase())'
                }, 'ucfirst' => sub {
                    my($self, $level, $wantarray) = @_;
                    $self->{'arguments'}->[0]->emit_java($level, 'scalar') . '.ucfirst()'
                }, 'lcfirst' => sub {
                    my($self, $level, $wantarray) = @_;
                    $self->{'arguments'}->[0]->emit_java($level, 'scalar') . '.lcfirst()'
                }, 'quotemeta' => sub {
                    my($self, $level, $wantarray) = @_;
                    $self->{'arguments'}->[0]->emit_java($level, 'scalar') . '.quotemeta()'
                }, 'index' => sub {
                    my($self, $level, $wantarray) = @_;
                    'new PlInt(' . $self->{'arguments'}->[0]->emit_java($level, 'scalar') . '.toString().indexOf(' . $self->{'arguments'}->[1]->emit_java($level, 'scalar') . '.toString()))'
                }, 'rindex' => sub {
                    my($self, $level, $wantarray) = @_;
                    if ($self->{'arguments'}->[2]) {
                        'new PlInt(' . $self->{'arguments'}->[0]->emit_java($level, 'scalar') . '.toString().lastIndexOf(' . $self->{'arguments'}->[1]->emit_java($level, 'scalar') . '.toString(), ' . $self->{'arguments'}->[2]->emit_java($level, 'scalar') . '.to_int()))'
                    }
                    else {
                        'new PlInt(' . $self->{'arguments'}->[0]->emit_java($level, 'scalar') . '.toString().lastIndexOf(' . $self->{'arguments'}->[1]->emit_java($level, 'scalar') . '.toString()))'
                    }
                }, 'ord' => sub {
                    my($self, $level, $wantarray) = @_;
                    'PerlOp.ord(' . Perlito5::Java::to_str($self->{'arguments'}->[0], $level) . ')'
                }, 'chr' => sub {
                    my($self, $level, $wantarray) = @_;
                    'new PlString((char)' . $self->{'arguments'}->[0]->emit_java($level, 'scalar') . '.to_long())'
                }, 'int' => sub {
                    my($self, $level, $wantarray) = @_;
                    'new PlInt(' . $self->{'arguments'}->[0]->emit_java($level, 'scalar') . '.to_long())'
                }, 'rand' => sub {
                    my($self, $level, $wantarray) = @_;
                    'PerlOp.rand(' . ($self->{'arguments'}->[0] ? $self->{'arguments'}->[0]->emit_java($level, 'scalar') . '.to_double()' : '1.0') . ')'
                }, 'srand' => sub {
                    my($self, $level, $wantarray) = @_;
                    'PerlOp.srand(' . ($self->{'arguments'}->[0] ? $self->{'arguments'}->[0]->emit_java($level, 'scalar') . '.to_long()' : '') . ')'
                }, (map {
                    my $op = $_;
                    ($op => sub {
                        my($self, $level, $wantarray) = @_;
                        $self->{'arguments'}->[0]->emit_java($level, 'scalar') . '.' . $op . '()'
                    })
                } 'abs', 'sqrt', 'cos', 'sin', 'exp', 'log'), 'infix:<%>' => sub {
                    my($self, $level, $wantarray) = @_;
                    'new PlInt(' . $self->{'arguments'}->[0]->emit_java($level, 'scalar') . '.to_long() % ' . $self->{'arguments'}->[1]->emit_java($level, 'scalar') . '.to_long())'
                }, 'infix:<>>>' => sub {
                    my($self, $level, $wantarray) = @_;
                    'new PlInt(' . $self->{'arguments'}->[0]->emit_java($level, 'scalar') . '.to_long() >>> ' . $self->{'arguments'}->[1]->emit_java($level, 'scalar') . '.to_long())'
                }, 'infix:<<<>' => sub {
                    my($self, $level, $wantarray) = @_;
                    'new PlInt(' . $self->{'arguments'}->[0]->emit_java($level, 'scalar') . '.to_long() << ' . $self->{'arguments'}->[1]->emit_java($level, 'scalar') . '.to_long())'
                }, 'infix:<^>' => sub {
                    my($self, $level, $wantarray) = @_;
                    'new PlInt(' . $self->{'arguments'}->[0]->emit_java($level, 'scalar') . '.to_long() ^ ' . $self->{'arguments'}->[1]->emit_java($level, 'scalar') . '.to_long())'
                }, 'infix:<&>' => sub {
                    my($self, $level, $wantarray) = @_;
                    'new PlInt(' . $self->{'arguments'}->[0]->emit_java($level, 'scalar') . '.to_long() & ' . $self->{'arguments'}->[1]->emit_java($level, 'scalar') . '.to_long())'
                }, 'infix:<|>' => sub {
                    my($self, $level, $wantarray) = @_;
                    'new PlInt(' . $self->{'arguments'}->[0]->emit_java($level, 'scalar') . '.to_long() | ' . $self->{'arguments'}->[1]->emit_java($level, 'scalar') . '.to_long())'
                }, 'infix:<+>' => sub {
                    my($self, $level, $wantarray) = @_;
                    $self->{'arguments'}->[0]->emit_java($level, 'scalar') . '.add(' . $self->{'arguments'}->[1]->emit_java($level, 'scalar') . ')'
                }, 'infix:<->' => sub {
                    my($self, $level, $wantarray) = @_;
                    $self->{'arguments'}->[0]->emit_java($level, 'scalar') . '.sub(' . $self->{'arguments'}->[1]->emit_java($level, 'scalar') . ')'
                }, 'infix:<*>' => sub {
                    my($self, $level, $wantarray) = @_;
                    $self->{'arguments'}->[0]->emit_java($level, 'scalar') . '.mul(' . $self->{'arguments'}->[1]->emit_java($level, 'scalar') . ')'
                }, 'infix:</>' => sub {
                    my($self, $level, $wantarray) = @_;
                    $self->{'arguments'}->[0]->emit_java($level, 'scalar') . '.div(' . $self->{'arguments'}->[1]->emit_java($level, 'scalar') . ')'
                }, 'infix:<==>' => sub {
                    my($self, $level, $wantarray) = @_;
                    $self->{'arguments'}->[0]->emit_java($level, 'scalar') . '.num_eq(' . $self->{'arguments'}->[1]->emit_java($level, 'scalar') . ')'
                }, 'infix:<!=>' => sub {
                    my($self, $level, $wantarray) = @_;
                    $self->{'arguments'}->[0]->emit_java($level, 'scalar') . '.num_ne(' . $self->{'arguments'}->[1]->emit_java($level, 'scalar') . ')'
                }, 'infix:<>>' => sub {
                    my($self, $level, $wantarray) = @_;
                    $self->{'arguments'}->[0]->emit_java($level, 'scalar') . '.num_gt(' . $self->{'arguments'}->[1]->emit_java($level, 'scalar') . ')'
                }, 'infix:<>=>' => sub {
                    my($self, $level, $wantarray) = @_;
                    $self->{'arguments'}->[0]->emit_java($level, 'scalar') . '.num_ge(' . $self->{'arguments'}->[1]->emit_java($level, 'scalar') . ')'
                }, 'infix:<<>' => sub {
                    my($self, $level, $wantarray) = @_;
                    $self->{'arguments'}->[0]->emit_java($level, 'scalar') . '.num_lt(' . $self->{'arguments'}->[1]->emit_java($level, 'scalar') . ')'
                }, 'infix:<<=>' => sub {
                    my($self, $level, $wantarray) = @_;
                    $self->{'arguments'}->[0]->emit_java($level, 'scalar') . '.num_le(' . $self->{'arguments'}->[1]->emit_java($level, 'scalar') . ')'
                }, 'infix:<eq>' => sub {
                    my($self, $level, $wantarray) = @_;
                    $self->{'arguments'}->[0]->emit_java($level, 'scalar') . '.str_eq(' . $self->{'arguments'}->[1]->emit_java($level, 'scalar') . ')'
                }, 'infix:<ne>' => sub {
                    my($self, $level, $wantarray) = @_;
                    $self->{'arguments'}->[0]->emit_java($level, 'scalar') . '.str_ne(' . $self->{'arguments'}->[1]->emit_java($level, 'scalar') . ')'
                }, 'infix:<gt>' => sub {
                    my($self, $level, $wantarray) = @_;
                    $self->{'arguments'}->[0]->emit_java($level, 'scalar') . '.str_gt(' . $self->{'arguments'}->[1]->emit_java($level, 'scalar') . ')'
                }, 'infix:<ge>' => sub {
                    my($self, $level, $wantarray) = @_;
                    $self->{'arguments'}->[0]->emit_java($level, 'scalar') . '.str_ge(' . $self->{'arguments'}->[1]->emit_java($level, 'scalar') . ')'
                }, 'infix:<lt>' => sub {
                    my($self, $level, $wantarray) = @_;
                    $self->{'arguments'}->[0]->emit_java($level, 'scalar') . '.str_lt(' . $self->{'arguments'}->[1]->emit_java($level, 'scalar') . ')'
                }, 'infix:<le>' => sub {
                    my($self, $level, $wantarray) = @_;
                    $self->{'arguments'}->[0]->emit_java($level, 'scalar') . '.str_le(' . $self->{'arguments'}->[1]->emit_java($level, 'scalar') . ')'
                }, 'infix:<~~>' => sub {
                    my($self, $level, $wantarray) = @_;
                    my $arg0 = $self->{'arguments'}->[0];
                    my $arg1 = $self->{'arguments'}->[1];
                    'PerlOp.smartmatch_scalar(' . $arg0->emit_java($level, 'scalar') . ', ' . $arg1->emit_java($level, 'scalar') . ')'
                }, 'infix:<&&>' => sub {
                    my($self, $level, $wantarray) = @_;
                    if ($wantarray eq 'void') {
                        return Perlito5::Java::to_bool($self->{'arguments'}->[0], $level) . ' ? ' . $self->{'arguments'}->[1]->emit_java($level, 'scalar') . ' : PlCx.UNDEF'
                    }
                    'PerlOp.and1(' . $self->{'arguments'}->[0]->emit_java($level, 'scalar') . ') ? ' . $self->{'arguments'}->[1]->emit_java($level, 'scalar') . ' : PerlOp.and3()'
                }, 'infix:<and>' => sub {
                    my($self, $level, $wantarray) = @_;
                    if ($wantarray eq 'void') {
                        return Perlito5::Java::to_bool($self->{'arguments'}->[0], $level) . ' ? ' . $self->{'arguments'}->[1]->emit_java($level, 'scalar') . ' : PlCx.UNDEF'
                    }
                    'PerlOp.and1(' . $self->{'arguments'}->[0]->emit_java($level, 'scalar') . ') ? ' . $self->{'arguments'}->[1]->emit_java($level, 'scalar') . ' : PerlOp.and3()'
                }, 'infix:<||>' => sub {
                    my($self, $level, $wantarray) = @_;
                    if ($wantarray eq 'void') {
                        return Perlito5::Java::to_bool($self->{'arguments'}->[0], $level) . ' ? ' . ' PlCx.UNDEF : ' . $self->{'arguments'}->[1]->emit_java($level, 'scalar')
                    }
                    'PerlOp.or1(' . $self->{'arguments'}->[0]->emit_java($level, 'scalar') . ') ? PerlOp.or2() : ' . $self->{'arguments'}->[1]->emit_java($level, 'scalar') . ''
                }, 'infix:<or>' => sub {
                    my($self, $level, $wantarray) = @_;
                    if ($wantarray eq 'void') {
                        return Perlito5::Java::to_bool($self->{'arguments'}->[0], $level) . ' ? ' . ' PlCx.UNDEF : ' . $self->{'arguments'}->[1]->emit_java($level, 'scalar')
                    }
                    'PerlOp.or1(' . $self->{'arguments'}->[0]->emit_java($level, 'scalar') . ') ? PerlOp.or2() : ' . $self->{'arguments'}->[1]->emit_java($level, 'scalar') . ''
                }, 'infix:<xor>' => sub {
                    my($self, $level, $wantarray) = @_;
                    '( ' . Perlito5::Java::to_bool($self->{'arguments'}->[0], $level) . ' ? new PlBool(!' . Perlito5::Java::to_bool($self->{'arguments'}->[1], $level) . ') : ' . ($self->{'arguments'}->[1])->emit_java($level, $wantarray) . ')'
                }, 'infix:<=>>' => sub {
                    my($self, $level, $wantarray) = @_;
                    Perlito5::AST::Lookup::->autoquote($self->{'arguments'}->[0])->emit_java($level) . ', ' . $self->{'arguments'}->[1]->emit_java($level)
                }, 'infix:<cmp>' => sub {
                    my($self, $level, $wantarray) = @_;
                    $self->{'arguments'}->[0]->emit_java($level, 'scalar') . '.str_cmp(' . $self->{'arguments'}->[1]->emit_java($level, 'scalar') . ')'
                }, 'infix:<<=>>' => sub {
                    my($self, $level, $wantarray) = @_;
                    $self->{'arguments'}->[0]->emit_java($level, 'scalar') . '.num_cmp(' . $self->{'arguments'}->[1]->emit_java($level, 'scalar') . ')'
                }, 'infix:<**>' => sub {
                    my($self, $level, $wantarray) = @_;
                    $self->{'arguments'}->[0]->emit_java($level, 'scalar') . '.pow(' . $self->{'arguments'}->[1]->emit_java($level, 'scalar') . ')'
                }, 'atan2' => sub {
                    my($self, $level, $wantarray) = @_;
                    $self->{'arguments'}->[0]->emit_java($level, 'scalar') . '.atan2(' . $self->{'arguments'}->[1]->emit_java($level, 'scalar') . ')'
                }, 'prefix:<!>' => sub {
                    my $self = shift;
                    my $level = shift;
                    'new PlBool(!(' . Perlito5::Java::to_bool($self->{'arguments'}->[0], $level) . '))'
                }, 'prefix:<not>' => sub {
                    my $self = shift;
                    my $level = shift;
                    my $arg = pop(@{$self->{'arguments'}});
                    if (!$arg) {
                        return 'PlCx.TRUE'
                    }
                    'new PlBool(!( ' . Perlito5::Java::to_bool($arg, $level) . '))'
                }, 'prefix:<~>' => sub {
                    my $self = $_[0];
                    'new PlInt(~' . Perlito5::Java::to_num($self->{'arguments'}->[0]) . '.to_long())'
                }, 'prefix:<->' => sub {
                    my($self, $level, $wantarray) = @_;
                    my $arg = $self->{'arguments'}->[0];
                    if ($arg->isa('Perlito5::AST::Int')) {
                        $arg->{'int'} = -$arg->{'int'};
                        return $arg->emit_java($level, 'scalar')
                    }
                    if ($arg->isa('Perlito5::AST::Num')) {
                        $arg->{'num'} = -$arg->{'num'};
                        return $arg->emit_java($level, 'scalar')
                    }
                    $arg->emit_java($level, 'scalar') . '.neg()'
                }, 'prefix:<+>' => sub {
                    my($self, $level, $wantarray) = @_;
                    $self->{'arguments'}->[0]->emit_java($level, $wantarray)
                }, 'require' => sub {
                    my($self, $level, $wantarray) = @_;
                    my $arg = $self->{'arguments'}->[0];
                    if ($arg->{'is_version_string'}) {
                        return 'p5pkg["Perlito5"]["test_perl_version"]([' . Perlito5::Java::to_str($self->{'arguments'}->[0]) . '], ' . Perlito5::Java::to_context($wantarray) . ')'
                    }
                    'p5pkg["Perlito5::Grammar::Use"]["require"]([' . Perlito5::Java::to_str($self->{'arguments'}->[0]) . ', ' . ($self->{'arguments'}->[0]->{'bareword'} ? 1 : 0) . '], ' . Perlito5::Java::to_context($wantarray) . ')'
                }, 'select' => sub {
                    my($self, $level, $wantarray) = @_;
                    'p5pkg["CORE"]["select"]([' . ($self->{'arguments'}->[0]->{'bareword'} ? Perlito5::Java::to_str($self->{'arguments'}->[0]) : $self->{'arguments'}->[0]->emit_java($level, 'scalar')) . '])'
                }, 'prefix:<$>' => sub {
                    my($self, $level, $wantarray) = @_;
                    my $arg = $self->{'arguments'}->[0];
                    return $arg->emit_java($level) . '.scalar_deref()'
                }, 'prefix:<@>' => sub {
                    my($self, $level, $wantarray) = @_;
                    my $arg = $self->{'arguments'}->[0];
                    my $s = Perlito5::Java::emit_java_autovivify($arg, $level, 'array') . '.array_deref()';
                    return $wantarray eq 'scalar' ? $s . '.scalar()' : $s
                }, 'prefix:<$#>' => sub {
                    my($self, $level, $wantarray) = @_;
                    my $arg = $self->{'arguments'}->[0];
                    return Perlito5::Java::emit_java_autovivify($arg, $level, 'array') . '.array_deref().end_of_array_index()'
                }, 'prefix:<%>' => sub {
                    my($self, $level, $wantarray) = @_;
                    my $arg = $self->{'arguments'}->[0];
                    return Perlito5::Java::emit_java_autovivify($arg, $level, 'hash') . '.hash_deref()'
                }, 'prefix:<&>' => sub {
                    my($self, $level, $wantarray) = @_;
                    my $arg = $self->{'arguments'}->[0];
                    'p5code_lookup_by_name(' . Perlito5::Java::escape_string($Perlito5::PKG_NAME) . ', ' . $arg->emit_java($level) . ')([])'
                }, 'circumfix:<[ ]>' => sub {
                    my($self, $level, $wantarray) = @_;
                    'new PlArrayRef(' . Perlito5::Java::to_list($self->{'arguments'}) . ')'
                }, 'circumfix:<{ }>' => sub {
                    my($self, $level, $wantarray) = @_;
                    '(new PlHashRef(new PlHash(' . Perlito5::Java::to_list($self->{'arguments'}, $level) . ')))'
                }, 'prefix:<' . chr(92) . '>' => sub {
                    my($self, $level, $wantarray) = @_;
                    my $arg = $self->{'arguments'}->[0];
                    if ($arg->isa('Perlito5::AST::Apply')) {
                        if ($arg->{'code'} eq 'prefix:<@>') {
                            return 'new PlArrayRef(' . $arg->emit_java($level) . ')'
                        }
                        if ($arg->{'code'} eq 'prefix:<%>') {
                            return 'new PlHashRef(' . $arg->emit_java($level) . ')'
                        }
                        if ($arg->{'code'} eq 'circumfix:<( )>') {
                            return 'p5_list_of_refs(' . Perlito5::Java::to_list($arg->{'arguments'}) . ')'
                        }
                        if ($arg->{'code'} eq 'prefix:<&>') {
                            return 'p5code_lookup_by_name(' . Perlito5::Java::escape_string($Perlito5::PKG_NAME) . ', ' . $arg->{'arguments'}->[0]->emit_java($level) . ')'
                        }
                    }
                    if ($arg->isa('Perlito5::AST::Var')) {
                        if ($arg->sigil() eq '@') {
                            return 'new PlArrayRef(' . $arg->emit_java($level) . ')'
                        }
                        if ($arg->sigil() eq '%') {
                            return '(new PlHashRef(' . $arg->emit_java($level) . '))'
                        }
                        if ($arg->sigil() eq '*') {
                            return '(new PlGlobRef(' . $arg->emit_java($level) . '))'
                        }
                        if ($arg->sigil() eq '&') {
                            if ($arg->{'namespace'}) {
                                return 'p5pkg[' . Perlito5::Java::escape_string($arg->{'namespace'}) . '].' . $arg->{'name'}
                            }
                            else {
                                return Perlito5::Java::pkg() . '.' . $arg->{'name'}
                            }
                        }
                    }
                    return '(new PlLvalueRef(' . $arg->emit_java($level) . '))'
                }, 'postfix:<++>' => sub {
                    my($self, $level, $wantarray) = @_;
                    my $arg = $self->{'arguments'}->[0];
                    $arg->emit_java($level, 'scalar', 'lvalue') . '.post_incr()'
                }, 'postfix:<-->' => sub {
                    my($self, $level, $wantarray) = @_;
                    my $arg = $self->{'arguments'}->[0];
                    $arg->emit_java($level, 'scalar', 'lvalue') . '.post_decr()'
                }, 'prefix:<++>' => sub {
                    my($self, $level, $wantarray) = @_;
                    my $arg = $self->{'arguments'}->[0];
                    $arg->emit_java($level, 'scalar', 'lvalue') . '.pre_incr()'
                }, 'prefix:<-->' => sub {
                    my($self, $level, $wantarray) = @_;
                    my $arg = $self->{'arguments'}->[0];
                    $arg->emit_java($level, 'scalar', 'lvalue') . '.pre_decr()'
                }, 'infix:<x>' => sub {
                    my($self, $level, $wantarray) = @_;
                    my $arg = $self->{'arguments'}->[0];
                    if (ref($arg) eq 'Perlito5::AST::Apply' && ($arg->{'code'} eq 'circumfix:<( )>' || $arg->{'code'} eq 'list:<,>')) {
                        return 'PerlOp.list_replicate(' . Perlito5::Java::to_list([$self->{'arguments'}->[0]], $level) . ', ' . Perlito5::Java::to_num($self->{'arguments'}->[1], $level) . ', ' . Perlito5::Java::to_context($wantarray) . ')'
                    }
                    'PerlOp.string_replicate(' . Perlito5::Java::to_str($self->{'arguments'}->[0], $level) . ',' . Perlito5::Java::to_num($self->{'arguments'}->[1], $level) . ')'
                }, 'list:<.>' => sub {
                    my($self, $level, $wantarray) = @_;
                    'new PlString(' . join(' + ', map(Perlito5::Java::to_native_str($_, $level, 'scalar'), @{$self->{'arguments'}})) . ')'
                }, 'list:<,>' => sub {
                    my($self, $level, $wantarray) = @_;
                    Perlito5::Java::to_list($self->{'arguments'})
                }, 'infix:<..>' => sub {
                    my($self, $level, $wantarray) = @_;
                    return 'PerlOp.range(' . $self->{'arguments'}->[0]->emit_java($level) . ', ' . $self->{'arguments'}->[1]->emit_java($level) . ', ' . Perlito5::Java::to_context($wantarray) . ', ' . '"' . Perlito5::Java::get_label() . '"' . ', ' . 0 . ')'
                }, 'infix:<...>' => sub {
                    my($self, $level, $wantarray) = @_;
                    return 'PerlOp.range(' . $self->{'arguments'}->[0]->emit_java($level) . ', ' . $self->{'arguments'}->[1]->emit_java($level) . ', ' . Perlito5::Java::to_context($wantarray) . ', ' . '"' . Perlito5::Java::get_label() . '"' . ', ' . 1 . ')'
                }, 'delete' => sub {
                    my($self, $level, $wantarray) = @_;
                    my $arg = $self->{'arguments'}->[0];
                    if ($arg->isa('Perlito5::AST::Lookup')) {
                        my $v = $arg->obj();
                        if ($v->isa('Perlito5::AST::Var') && ($v->sigil() eq '$' || $v->sigil() eq '@')) {
                            return $v->emit_java($level, $wantarray) . '.delete(' . Perlito5::Java::to_context($wantarray) . ', ' . $arg->autoquote($arg->{'index_exp'})->emit_java($level) . ')'
                        }
                        return $v->emit_java($level, $wantarray, 'hash') . '.delete(' . $arg->autoquote($arg->{'index_exp'})->emit_java($level) . ')'
                    }
                    if ($arg->isa('Perlito5::AST::Index')) {
                        my $v = $arg->obj();
                        if ($v->isa('Perlito5::AST::Var') && ($v->sigil() eq '$' || $v->sigil() eq '@')) {
                            return $v->emit_java($level, $wantarray) . '.delete(' . Perlito5::Java::to_context($wantarray) . ', ' . $arg->{'index_exp'}->emit_java($level) . ')'
                        }
                        return $v->emit_java($level, $wantarray, 'array') . '.delete(' . $arg->{'index_exp'}->emit_java($level) . ')'
                    }
                    if ($arg->isa('Perlito5::AST::Call')) {
                        if ($arg->method() eq 'postcircumfix:<{ }>') {
                            return $arg->invocant()->emit_java($level, $wantarray, 'hash') . '.delete(' . Perlito5::AST::Lookup::->autoquote($arg->{'arguments'})->emit_java($level) . ')'
                        }
                        if ($arg->method() eq 'postcircumfix:<[ ]>') {
                            return $arg->invocant()->emit_java($level, $wantarray, 'array') . '.delete(' . $arg->{'arguments'}->emit_java($level) . ')'
                        }
                    }
                    if ($arg->isa('Perlito5::AST::Var') && $arg->sigil() eq '&') {
                        die('TODO delete &code')
                    }
                    if ($arg->isa('Perlito5::AST::Apply') && $arg->{'code'} eq 'prefix:<&>') {
                        die('TODO delete &$code')
                    }
                }, 'scalar' => sub {
                    my($self, $level, $wantarray) = @_;
                    Perlito5::Java::to_scalar($self->{'arguments'}, $level + 1)
                }, 'ternary:<? :>' => sub {
                    my($self, $level, $wantarray) = @_;
                    '( ' . Perlito5::Java::to_bool($self->{'arguments'}->[0], $level) . ' ? ' . ($self->{'arguments'}->[1])->emit_java($level, $wantarray) . ' : ' . ($self->{'arguments'}->[2])->emit_java($level, $wantarray) . ')'
                }, 'my' => sub {
                    my($self, $level, $wantarray) = @_;
                    'PerlOp.context(' . join(', ', Perlito5::Java::to_context($wantarray), map($_->emit_java($level, $wantarray), @{$self->{'arguments'}})) . ')'
                }, 'our' => sub {
                    my($self, $level, $wantarray) = @_;
                    'PerlOp.context(' . join(', ', Perlito5::Java::to_context($wantarray), map($_->emit_java($level, $wantarray), @{$self->{'arguments'}})) . ')'
                }, 'local' => sub {
                    my($self, $level, $wantarray) = @_;
                    'PerlOp.context(' . join(', ', Perlito5::Java::to_context($wantarray), map($_->emit_java($level, $wantarray), @{$self->{'arguments'}})) . ')'
                }, 'circumfix:<( )>' => sub {
                    my($self, $level, $wantarray) = @_;
                    'PerlOp.context(' . join(', ', Perlito5::Java::to_context($wantarray), map($_->emit_java($level, $wantarray), @{$self->{'arguments'}})) . ')'
                }, 'infix:<=>' => sub {
                    my($self, $level, $wantarray) = @_;
                    my $parameters = $self->{'arguments'}->[0];
                    my $arguments = $self->{'arguments'}->[1];
                    if ($parameters->isa('Perlito5::AST::Apply') && ($parameters->code() eq 'my' || $parameters->code() eq 'local' || $parameters->code() eq 'circumfix:<( )>')) {
                        if ($wantarray eq 'void') {
                            my $tmp = Perlito5::Java::get_label();
                            return join(';' . chr(10) . Perlito5::Java::tab($level), 'PlArray ' . $tmp . ' = ' . Perlito5::Java::to_list([$arguments], $level + 1), (map($_->emit_java_set_list($level, $tmp), @{$parameters->arguments()})))
                        }
                        my $tmp = Perlito5::Java::get_label();
                        my $tmp2 = Perlito5::Java::get_label();
                        return Perlito5::Java::emit_wrap_java($level, 'PlArray ' . $tmp . ' = ' . Perlito5::Java::to_list([$arguments], $level + 1) . ';', 'PlArray ' . $tmp2 . ' = ' . $tmp . '.slice(0);', (map($_->emit_java_set_list($level + 1, $tmp) . ';', @{$parameters->arguments()})), 'return ' . $tmp2)
                    }
                    return $parameters->emit_java_set($arguments, $level + 1, $wantarray)
                }, 'break' => sub {
                    my($self, $level, $wantarray) = @_;
                    $Perlito5::THROW = 1;
                    die('TODO - break() not implemented')
                }, 'next' => sub {
                    my($self, $level, $wantarray) = @_;
                    $Perlito5::THROW = 1;
                    my $label = Perlito5::Java::get_java_loop_label($self->{'arguments'}->[0]->{'code'});
                    if ($label == 0) {
                        return 'PerlOp.next()'
                    }
                    'PerlOp.next(' . $label . ')'
                }, 'last' => sub {
                    my($self, $level, $wantarray) = @_;
                    $Perlito5::THROW = 1;
                    my $label = Perlito5::Java::get_java_loop_label($self->{'arguments'}->[0]->{'code'});
                    if ($label == 0) {
                        return 'PerlOp.last()'
                    }
                    'PerlOp.last(' . $label . ')'
                }, 'redo' => sub {
                    my($self, $level, $wantarray) = @_;
                    $Perlito5::THROW = 1;
                    my $label = Perlito5::Java::get_java_loop_label($self->{'arguments'}->[0]->{'code'});
                    'PerlOp.redo(' . $label . ')'
                }, 'return' => sub {
                    my($self, $level, $wantarray) = @_;
                    $Perlito5::THROW_RETURN = 1;
                    if (!@{$self->{'arguments'}}) {
                        return 'PerlOp.ret(PerlOp.context(want))'
                    }
                    'PerlOp.ret(' . Perlito5::Java::to_runtime_context($self->{'arguments'}, $level + 1) . ')'
                }, 'goto' => sub {
                    my($self, $level, $wantarray) = @_;
                    $Perlito5::THROW = 1;
                    die('TODO - goto() not implemented')
                }, 'caller' => sub {
                    my($self, $level, $wantarray) = @_;
                    return 'PerlOp.caller(' . Perlito5::Java::to_context($wantarray) . ', ' . $self->{'arguments'}->[0]->emit_java($level) . ')'
                }, 'do' => sub {
                    my($self, $level, $wantarray) = @_;
                    my $arg = $self->{'arguments'}->[0];
                    if ($arg->isa('Perlito5::AST::Block')) {
                        my $ast = Perlito5::AST::Call::->new('method' => 'postcircumfix:<( )>', 'invocant' => Perlito5::AST::Sub::->new('block' => $arg, 'attributes' => [], '_do_block' => 1), 'arguments' => []);
                        return $ast->emit_java($level + 1, $wantarray)
                    }
                    my $tmp_strict = $Perlito5::STRICT;
                    $Perlito5::STRICT = 0;
                    my $ast = Perlito5::AST::Apply::->new('code' => 'eval', 'namespace' => '', 'arguments' => [Perlito5::AST::Apply::->new('code' => 'do_file', 'namespace' => 'Perlito5::Grammar::Use', 'arguments' => $self->{'arguments'})], '_scope' => Perlito5::Grammar::Scope::->new_base_scope());
                    my $js = $ast->emit_java($level, $wantarray);
                    $Perlito5::STRICT = $tmp_strict;
                    return $js
                }, 'eval' => sub {
                    my($self, $level, $wantarray) = @_;
                    my $arg = $self->{'arguments'}->[0];
                    my $eval;
                    if ($arg->isa('Perlito5::AST::Block')) {
                        my $ast = Perlito5::AST::Call::->new('method' => 'postcircumfix:<( )>', 'invocant' => Perlito5::AST::Sub::->new('block' => $arg, 'attributes' => [], '_eval_block' => 1), 'arguments' => []);
                        return $ast->emit_java($level + 1, $wantarray)
                    }
                    else {
                        die('Java eval string not yet implemented')
                    }
                    my $context = Perlito5::Java::to_context($wantarray);
                    Perlito5::Java::emit_wrap_java($level, ($context eq 'p5want' ? () : 'var want = ' . $context . ';'), 'var r;', 'p5pkg["main"]["v_@"] = "";', 'var p5strict = p5pkg["Perlito5"]["v_STRICT"];', 'p5pkg["Perlito5"]["v_STRICT"] = ' . $Perlito5::STRICT . ';', 'try {', ['r = ' . $eval . ''], '}', 'catch(err) {', ['if ( err instanceof p5_error || err instanceof Error ) {', ['p5pkg["main"]["v_@"] = err;', 'if (p5str(p5pkg["main"]["v_@"]).substr(-1, 1) != "' . chr(92) . 'n") {', ['try {' . '', ['p5pkg["main"]["v_@"] = p5pkg["main"]["v_@"] + "' . chr(92) . 'n" + err.stack + "' . chr(92) . 'n";'], '}', 'catch(err) { }'], '}'], '}', 'else {', ['return(err);'], '}'], '}', 'p5pkg["Perlito5"]["v_STRICT"] = p5strict;', 'return r;')
                }, 'length' => sub {
                    my($self, $level, $wantarray) = @_;
                    my $arg = shift(@{$self->{'arguments'}});
                    return Perlito5::Java::to_str($arg) . '.length(' . ')'
                }, 'substr' => sub {
                    my($self, $level, $wantarray) = @_;
                    my $arg = shift(@{$self->{'arguments'}});
                    return Perlito5::Java::to_str($arg) . '.substr(' . join(', ', map($_->emit_java($level, 'scalar'), @{$self->{'arguments'}})) . ')'
                }, 'undef' => sub {
                    my($self, $level, $wantarray) = @_;
                    if ($self->{'arguments'} && @{$self->{'arguments'}}) {
                        my $arg = $self->{'arguments'}->[0];
                        if (ref($arg) eq 'Perlito5::AST::Var' && $arg->{'sigil'} eq '&') {
                            return '(delete p5pkg[' . Perlito5::Java::escape_string(($arg->{'namespace'} || $Perlito5::PKG_NAME)) . '][' . Perlito5::Java::escape_string($arg->{'name'}) . '])'
                        }
                        $self->{'arguments'} = [];
                        return $arg->emit_java_set($self, $level, $wantarray)
                    }
                    return 'PlCx.UNDEF'
                }, 'defined' => sub {
                    my($self, $level, $wantarray) = @_;
                    my $arg = $self->{'arguments'}->[0];
                    my $invocant;
                    if (ref($arg) eq 'Perlito5::AST::Apply' && $arg->{'code'} eq 'prefix:<&>') {
                        my $arg2 = $arg->{'arguments'}->[0];
                        $invocant = 'p5code_lookup_by_name(' . Perlito5::Java::escape_string($Perlito5::PKG_NAME) . ', ' . $arg2->emit_java($level) . ')'
                    }
                    elsif (ref($arg) eq 'Perlito5::AST::Var' && $arg->{'sigil'} eq '&') {
                        $invocant = 'p5pkg[' . Perlito5::Java::escape_string(($arg->{'namespace'} || $Perlito5::PKG_NAME)) . '][' . Perlito5::Java::escape_string($arg->{'name'}) . ']'
                    }
                    else {
                        $invocant = $arg->emit_java($level, 'scalar')
                    }
                    'new PlBool(!' . $invocant . '.is_undef())'
                }, 'shift' => sub {
                    my($self, $level, $wantarray) = @_;
                    if ($self->{'arguments'} && @{$self->{'arguments'}}) {
                        return $self->{'arguments'}->[0]->emit_java($level) . '.shift()'
                    }
                    return 'List__.shift()'
                }, 'pop' => sub {
                    my($self, $level, $wantarray) = @_;
                    if ($self->{'arguments'} && @{$self->{'arguments'}}) {
                        return $self->{'arguments'}->[0]->emit_java($level) . '.pop()'
                    }
                    return 'List__.pop()'
                }, 'unshift' => sub {
                    my($self, $level, $wantarray) = @_;
                    my @arguments = @{$self->{'arguments'}};
                    my $v = shift(@arguments);
                    return $v->emit_java($level) . '.unshift(' . Perlito5::Java::to_list(\@arguments) . ')'
                }, 'push' => sub {
                    my($self, $level, $wantarray) = @_;
                    my @arguments = @{$self->{'arguments'}};
                    my $v = shift(@arguments);
                    return $v->emit_java($level) . '.push(' . Perlito5::Java::to_list(\@arguments) . ')'
                }, 'time' => sub {
                    my($self, $level, $wantarray) = @_;
                    'PlCORE.time(' . Perlito5::Java::to_context($wantarray) . ', ' . Perlito5::Java::to_list($self->{'arguments'}) . ')'
                }, 'sleep' => sub {
                    my($self, $level, $wantarray) = @_;
                    'PlCORE.sleep(' . Perlito5::Java::to_context($wantarray) . ', ' . Perlito5::Java::to_list($self->{'arguments'}) . ')'
                }, 'ref' => sub {
                    my($self, $level, $wantarray) = @_;
                    'PlCORE.ref(' . Perlito5::Java::to_context($wantarray) . ', ' . Perlito5::Java::to_list($self->{'arguments'}) . ')'
                }, 'exit' => sub {
                    my($self, $level, $wantarray) = @_;
                    'PlCORE.exit(' . Perlito5::Java::to_context($wantarray) . ', ' . Perlito5::Java::to_list($self->{'arguments'}) . ')'
                }, 'warn' => sub {
                    my($self, $level, $wantarray) = @_;
                    'PlCORE.warn(' . Perlito5::Java::to_context($wantarray) . ', ' . Perlito5::Java::to_list($self->{'arguments'}) . ')'
                }, 'die' => sub {
                    my($self, $level, $wantarray) = @_;
                    'PlCORE.die(' . Perlito5::Java::to_context($wantarray) . ', ' . Perlito5::Java::to_list($self->{'arguments'}) . ')'
                }, 'system' => sub {
                    my($self, $level, $wantarray) = @_;
                    'PlCORE.system(' . Perlito5::Java::to_context($wantarray) . ', ' . Perlito5::Java::to_list($self->{'arguments'}) . ')'
                }, 'qx' => sub {
                    my($self, $level, $wantarray) = @_;
                    'PlCORE.qx(' . Perlito5::Java::to_context($wantarray) . ', ' . Perlito5::Java::to_list($self->{'arguments'}) . ')'
                }, 'tie' => sub {
                    my($self, $level, $wantarray) = @_;
                    my @arguments = @{$self->{'arguments'}};
                    my $v = shift(@arguments);
                    my $meth;
                    if ($v->isa('Perlito5::AST::Var') && $v->sigil() eq '%') {
                        $meth = 'hash'
                    }
                    elsif ($v->isa('Perlito5::AST::Var') && $v->sigil() eq '@') {
                        $meth = 'array'
                    }
                    elsif ($v->isa('Perlito5::AST::Var') && $v->sigil() eq '$') {
                        $meth = 'scalar'
                    }
                    else {
                        die('tie ' . chr(39), ref($v), chr(39) . ' not implemented')
                    }
                    return 'p5tie_' . $meth . '(' . $v->emit_java($level) . ', ' . Perlito5::Java::to_list(\@arguments) . ')'
                }, 'untie' => sub {
                    my($self, $level, $wantarray) = @_;
                    my @arguments = @{$self->{'arguments'}};
                    my $v = shift(@arguments);
                    my $meth;
                    if ($v->isa('Perlito5::AST::Var') && $v->sigil() eq '%') {
                        $meth = 'hash'
                    }
                    elsif ($v->isa('Perlito5::AST::Var') && $v->sigil() eq '@') {
                        $meth = 'array'
                    }
                    elsif ($v->isa('Perlito5::AST::Var') && $v->sigil() eq '$') {
                        $meth = 'scalar'
                    }
                    else {
                        die('tie ' . chr(39), ref($v), chr(39) . ' not implemented')
                    }
                    return 'p5untie_' . $meth . '(' . $v->emit_java($level) . ')'
                }, 'print' => sub {
                    my($self, $level, $wantarray) = @_;
                    my @in = @{$self->{'arguments'}};
                    my $fun;
                    if ($self->{'special_arg'}) {
                        $fun = $self->{'special_arg'}->emit_java($level)
                    }
                    else {
                        $fun = 'PlCx.STDOUT'
                    }
                    my $list = Perlito5::Java::to_list(\@in);
                    'PlCORE.print(' . Perlito5::Java::to_context($wantarray) . ', ' . $fun . ', ' . $list . ')'
                }, 'say' => sub {
                    my($self, $level, $wantarray) = @_;
                    my @in = @{$self->{'arguments'}};
                    my $fun;
                    if ($self->{'special_arg'}) {
                        $fun = $self->{'special_arg'}->emit_java($level)
                    }
                    else {
                        $fun = 'PlCx.STDOUT'
                    }
                    my $list = Perlito5::Java::to_list(\@in);
                    'PlCORE.say(' . Perlito5::Java::to_context($wantarray) . ', ' . $fun . ', ' . $list . ')'
                }, 'printf' => sub {
                    my($self, $level, $wantarray) = @_;
                    my @in = @{$self->{'arguments'}};
                    my $fun;
                    if ($self->{'special_arg'}) {
                        $fun = $self->{'special_arg'}->emit_java($level)
                    }
                    else {
                        $fun = 'PlCx.STDOUT'
                    }
                    my $list = Perlito5::Java::to_list(\@in);
                    'PlCORE.printf(' . Perlito5::Java::to_context($wantarray) . ', ' . $fun . ', ' . $list . ')'
                }, 'hex' => sub {
                    my($self, $level, $wantarray) = @_;
                    'PlCORE.hex(' . Perlito5::Java::to_context($wantarray) . ', ' . $self->{'arguments'}->[0]->emit_java($level) . ')'
                }, 'oct' => sub {
                    my($self, $level, $wantarray) = @_;
                    'PlCORE.oct(' . Perlito5::Java::to_context($wantarray) . ', ' . $self->{'arguments'}->[0]->emit_java($level) . ')'
                }, 'crypt' => sub {
                    my($self, $level, $wantarray) = @_;
                    'PlCORE.crypt(' . Perlito5::Java::to_context($wantarray) . ', ' . Perlito5::Java::to_list($self->{'arguments'}) . ')'
                }, 'join' => sub {
                    my($self, $level, $wantarray) = @_;
                    'PlCORE.join(' . Perlito5::Java::to_context($wantarray) . ', ' . Perlito5::Java::to_list($self->{'arguments'}) . ')'
                }, 'reverse' => sub {
                    my($self, $level, $wantarray) = @_;
                    'PlCORE.reverse(' . Perlito5::Java::to_context($wantarray) . ', ' . Perlito5::Java::to_list($self->{'arguments'}) . ')'
                }, 'values' => sub {
                    my($self, $level, $wantarray) = @_;
                    'PlCORE.values(' . Perlito5::Java::to_context($wantarray) . ', ' . $self->{'arguments'}->[0]->emit_java($level) . ')'
                }, 'keys' => sub {
                    my($self, $level, $wantarray) = @_;
                    'PlCORE.keys(' . Perlito5::Java::to_context($wantarray) . ', ' . $self->{'arguments'}->[0]->emit_java($level) . ')'
                }, 'each' => sub {
                    my($self, $level, $wantarray) = @_;
                    'PlCORE.each(' . Perlito5::Java::to_context($wantarray) . ', ' . $self->{'arguments'}->[0]->emit_java($level) . ')'
                }, 'close' => sub {
                    my($self, $level, $wantarray) = @_;
                    my @in = @{$self->{'arguments'}};
                    my $fun = shift(@in);
                    'p5pkg["Perlito5::IO"].close(' . $fun->emit_java($level) . ', [])'
                }, 'open' => sub {
                    my($self, $level, $wantarray) = @_;
                    my @in = @{$self->{'arguments'}};
                    my $fun = shift(@in);
                    if (ref($fun) ne 'Perlito5::AST::Apply') {
                        return Perlito5::Java::emit_wrap_java($level, $fun->emit_java($level) . ' = CORE.bless([ {file_handle : {id : null}}, "GLOB" ]);', 'return CORE.open(' . Perlito5::Java::to_list($self->{'arguments'}, $level) . ')')
                    }
                    else {
                        $Perlito5::STRICT = 0;
                        return 'CORE.open(' . Perlito5::Java::to_list($self->{'arguments'}, $level) . ')'
                    }
                }, 'chomp' => sub {
                    my($self, $level, $wantarray) = @_;
                    'PlCORE.chomp(' . Perlito5::Java::to_context($wantarray) . ', ' . $self->{'arguments'}->[0]->emit_java($level) . ')'
                }, 'chop' => sub {
                    my($self, $level, $wantarray) = @_;
                    'PlCORE.chop(' . Perlito5::Java::to_context($wantarray) . ', ' . $self->{'arguments'}->[0]->emit_java($level) . ')'
                }, 'read' => sub {
                    my($self, $level, $wantarray) = @_;
                    my @in = @{$self->{'arguments'}};
                    my $fun = shift(@in);
                    my $scalar = shift(@in);
                    my $length = shift(@in);
                    return Perlito5::Java::emit_wrap_java($level, 'var r = p5pkg["Perlito5::IO"].read(' . $fun->emit_java($level) . ', [' . $length->emit_java($level) . ']);', $scalar->emit_java($level) . ' = r[1];', 'return r[0]')
                }, 'readline' => sub {
                    my($self, $level, $wantarray) = @_;
                    my @in = @{$self->{'arguments'}};
                    my $fun = shift(@in) || bless({'arguments' => [], 'bareword' => 1, 'code' => 'ARGV', 'namespace' => ''}, 'Perlito5::AST::Apply');
                    return 'CORE.readline([' . $fun->emit_java($level) . '])'
                }, 'map' => sub {
                    my($self, $level, $wantarray) = @_;
                    my @in = @{$self->{'arguments'}};
                    my $fun;
                    if ($self->{'special_arg'}) {
                        $fun = $self->{'special_arg'}
                    }
                    else {
                        $fun = shift(@in)
                    }
                    my $list = Perlito5::Java::to_list(\@in);
                    if (ref($fun) eq 'Perlito5::AST::Block') {
                        $fun = $fun->{'stmts'}
                    }
                    else {
                        $fun = [$fun]
                    }
                    my $sub = Perlito5::AST::Sub::->new('block' => Perlito5::AST::Block::->new('stmts' => $fun));
                    'PerlOp.map(' . $sub->emit_java($level + 1) . ', ' . $list . ', ' . Perlito5::Java::to_context($wantarray) . ')'
                }, 'grep' => sub {
                    my($self, $level, $wantarray) = @_;
                    my @in = @{$self->{'arguments'}};
                    my $fun;
                    if ($self->{'special_arg'}) {
                        $fun = $self->{'special_arg'}
                    }
                    else {
                        $fun = shift(@in)
                    }
                    my $list = Perlito5::Java::to_list(\@in);
                    if (ref($fun) eq 'Perlito5::AST::Block') {
                        $fun = $fun->{'stmts'}
                    }
                    else {
                        $fun = [$fun]
                    }
                    my $sub = Perlito5::AST::Sub::->new('block' => Perlito5::AST::Block::->new('stmts' => $fun));
                    'PerlOp.grep(' . $sub->emit_java($level + 1) . ', ' . $list . ', ' . Perlito5::Java::to_context($wantarray) . ')'
                }, 'bless' => sub {
                    my($self, $level, $wantarray) = @_;
                    my @in = @{$self->{'arguments'}};
                    my $ref = shift(@in);
                    my $class = shift(@in);
                    return $ref->emit_java($level, 'scalar') . '.bless(' . $class->emit_java($level, 'scalar') . ')'
                }, 'sort' => sub {
                    my($self, $level, $wantarray) = @_;
                    my @in = @{$self->{'arguments'}};
                    my $fun;
                    my $list;
                    if ($self->{'special_arg'}) {
                        $fun = $self->{'special_arg'}
                    }
                    elsif (ref($in[0]) eq 'Perlito5::AST::Block') {
                        $fun = shift(@in)
                    }
                    if (ref($fun) eq 'Perlito5::AST::Block') {
                        $fun = $fun->{'stmts'}
                    }
                    else {
                        die('TODO: sort without block not implemented yet')
                    }
                    $list = Perlito5::Java::to_list(\@in);
                    my $sub = Perlito5::AST::Sub::->new('block' => Perlito5::AST::Block::->new('stmts' => $fun));
                    'PerlOp.sort(' . $sub->emit_java($level + 1) . ', ' . $list . ', ' . Perlito5::Java::to_context($wantarray) . ', ' . Perlito5::Java::pkg . ')'
                }, 'infix:<//>' => sub {
                    my($self, $level, $wantarray) = @_;
                    'PerlOp.defined_or1(' . $self->{'arguments'}->[0]->emit_java($level, 'scalar') . ') ? PerlOp.defined_or2() : ' . $self->{'arguments'}->[1]->emit_java($level, 'scalar') . ''
                }, 'exists' => sub {
                    my($self, $level, $wantarray) = @_;
                    my $arg = $self->{'arguments'}->[0];
                    if ($arg->isa('Perlito5::AST::Lookup')) {
                        my $v = $arg->obj();
                        if ($v->isa('Perlito5::AST::Var') && $v->sigil() eq '$') {
                            return $v->emit_java($level, $wantarray) . '.exists(' . $arg->autoquote($arg->{'index_exp'})->emit_java($level) . ')'
                        }
                        return $v->emit_java($level, $wantarray, 'hash') . '.exists(' . $arg->autoquote($arg->{'index_exp'})->emit_java($level) . ')'
                    }
                    if ($arg->isa('Perlito5::AST::Index')) {
                        my $v = $arg->obj();
                        if ($v->isa('Perlito5::AST::Var') && $v->sigil() eq '$') {
                            return $v->emit_java($level, $wantarray) . '.exists(' . $arg->{'index_exp'}->emit_java($level) . ')'
                        }
                        return $v->emit_java($level, $wantarray, 'array') . '.exists(' . $arg->{'index_exp'}->emit_java($level) . ')'
                    }
                    if ($arg->isa('Perlito5::AST::Call')) {
                        if ($arg->method() eq 'postcircumfix:<{ }>') {
                            return $arg->invocant()->emit_java($level, $wantarray, 'hash') . '.exists(' . Perlito5::AST::Lookup::->autoquote($arg->{'arguments'})->emit_java($level) . ')'
                        }
                        if ($arg->method() eq 'postcircumfix:<[ ]>') {
                            return $arg->invocant()->emit_java($level, $wantarray, 'array') . '.exists(' . $arg->{'arguments'}->emit_java($level) . ')'
                        }
                    }
                    if ($arg->isa('Perlito5::AST::Var') && $arg->sigil() eq '&') {
                        my $name = $arg->{'name'};
                        my $namespace = $arg->{'namespace'} || $Perlito5::PKG_NAME;
                        return 'p5pkg[' . Perlito5::Java::escape_string($namespace) . '].hasOwnProperty(' . Perlito5::Java::escape_string($name) . ')'
                    }
                    if ($arg->isa('Perlito5::AST::Apply') && $arg->{'code'} eq 'prefix:<&>') {
                        my $arg2 = $arg->{'arguments'}->[0];
                        return 'p5sub_exists(' . Perlito5::Java::to_str($arg2) . ', ' . Perlito5::Java::escape_string($Perlito5::PKG_NAME) . ')'
                    }
                }, 'prototype' => sub {
                    my($self, $level, $wantarray) = @_;
                    my $arg = $self->{'arguments'}->[0];
                    return 'p5sub_prototype(' . $arg->emit_java() . ', ' . Perlito5::Java::escape_string($Perlito5::PKG_NAME) . ')'
                }, 'split' => sub {
                    my($self, $level, $wantarray) = @_;
                    my @js;
                    my $arg = $self->{'arguments'}->[0];
                    if ($arg && $arg->isa('Perlito5::AST::Apply') && $arg->{'code'} eq 'p5:m') {
                        push(@js, 'new RegExp(' . $arg->{'arguments'}->[0]->emit_java() . ', ' . Perlito5::Java::escape_string($arg->{'arguments'}->[1]->{'buf'}) . ')');
                        shift(@{$self->{'arguments'}})
                    }
                    return 'CORE.split(' . '[' . join(', ', @js, map($_->emit_java(), @{$self->{'arguments'}})) . '], ' . Perlito5::Java::to_context($wantarray) . ')'
                });
                sub Perlito5::AST::Apply::emit_java {
                    my($self, $level, $wantarray) = @_;
                    my $apply = $self->op_assign();
                    if ($apply) {
                        return $apply->emit_java($level)
                    }
                    my $apply = $self->op_auto();
                    if ($apply) {
                        return $apply->emit_java($level)
                    }
                    my $code = $self->{'code'};
                    if (ref($code) ne '') {
                        my @args = ();
                        push(@args, $_->emit_java())
                            for @{$self->{'arguments'}};
                        return $self->{'code'}->emit_java($level) . '.apply(' . join(',', @args) . ')'
                    }
                    exists($emit_js{$code}) && return $emit_js{$code}->($self, $level, $wantarray);
                    if (exists($Perlito5::Java::op_prefix_js_str{$code})) {
                        return $Perlito5::Java::op_prefix_js_str{$code} . '(' . Perlito5::Java::to_str($self->{'arguments'}->[0]) . ')'
                    }
                    if ($self->{'namespace'}) {
                        if ($self->{'namespace'} eq 'Java' && $code eq 'inline') {
                            if ($self->{'arguments'}->[0]->isa('Perlito5::AST::Buf')) {
                                return $self->{'arguments'}->[0]->{'buf'}
                            }
                            else {
                                die('Java::inline needs a string constant')
                            }
                        }
                        $code = 'PlV.get(' . Perlito5::Java::escape_string($self->{'namespace'} . '::' . $code) . ')'
                    }
                    else {
                        $code = 'PlV.get(' . Perlito5::Java::escape_string($Perlito5::PKG_NAME . '::' . $code) . ')'
                    }
                    my $sig;
                    my $may_need_autoload;
                    {
                        my $name = $self->{'code'};
                        my $namespace = $self->{'namespace'} || $Perlito5::PKG_NAME;
                        my $effective_name = $namespace . '::' . $self->{'code'};
                        if (exists($Perlito5::PROTO->{$effective_name})) {
                            $sig = $Perlito5::PROTO->{$effective_name}
                        }
                        elsif ((!$self->{'namespace'} || $namespace eq 'CORE') && exists($Perlito5::CORE_PROTO->{'CORE::' . $name})) {
                            $effective_name = 'CORE::' . $name;
                            $sig = $Perlito5::CORE_PROTO->{$effective_name}
                        }
                        else {
                            if ($self->{'bareword'}) {
                                if ($Perlito5::STRICT) {
                                    die('Bareword ' . Perlito5::Java::escape_string($name) . ' not allowed while "strict subs" in use')
                                }
                                return Perlito5::Java::escape_string(($self->{'namespace'} ? $self->{'namespace'} . '::' : '') . $name)
                            }
                            $may_need_autoload = 1
                        }
                        (exists($self->{'proto'})) && ($sig = $self->{'proto'})
                    }
                    if ($sig) {
                        my @out = ();
                        my @in = @{$self->{'arguments'} || []};
                        my $optional = 0;
                        while (length($sig)) {
                            my $c = substr($sig, 0, 1);
                            if ($c eq ';') {
                                $optional = 1
                            }
                            elsif ($c eq '$' || $c eq '_') {
                                (@in || !$optional) && push(@out, shift(@in)->emit_java($level + 1, 'scalar'))
                            }
                            elsif ($c eq '@') {
                                (@in || !$optional) && push(@out, Perlito5::Java::to_list(\@in, $level + 1));
                                @in = ()
                            }
                            elsif ($c eq '&') {
                                push(@out, shift(@in)->emit_java($level + 1, 'scalar'))
                            }
                            elsif ($c eq '*') {
                                if (@in || !$optional) {
                                    my $arg = shift(@in);
                                    if ($arg->{'bareword'}) {
                                        push(@out, Perlito5::Java::escape_string($arg->{'code'}))
                                    }
                                    else {
                                        push(@out, $arg->emit_java($level + 1, 'scalar'))
                                    }
                                }
                            }
                            elsif ($c eq chr(92)) {
                                if (substr($sig, 0, 2) eq chr(92) . '$') {
                                    $sig = substr($sig, 1);
                                    (@in || !$optional) && push(@out, shift(@in)->emit_java($level + 1, 'scalar'))
                                }
                                elsif (substr($sig, 0, 2) eq chr(92) . '@' || substr($sig, 0, 2) eq chr(92) . '%') {
                                    $sig = substr($sig, 1);
                                    (@in || !$optional) && push(@out, shift(@in)->emit_java($level + 1, 'list'))
                                }
                                elsif (substr($sig, 0, 5) eq chr(92) . '[@%]') {
                                    $sig = substr($sig, 4);
                                    (@in || !$optional) && push(@out, shift(@in)->emit_java($level + 1, 'list'))
                                }
                                elsif (substr($sig, 0, 6) eq chr(92) . '[$@%]') {
                                    $sig = substr($sig, 5);
                                    (@in || !$optional) && push(@out, shift(@in)->emit_java($level + 1, 'list'))
                                }
                            }
                            $sig = substr($sig, 1)
                        }
                        return $code . '.apply(' . Perlito5::Java::to_context($wantarray) . ', PlArray.construct_list_of_aliases(' . join(', ', @out) . ')' . ')'
                    }
                    my $items = Perlito5::Java::to_list_preprocess($self->{'arguments'});
                    my $arg_code = 'PlArray.construct_list_of_aliases(' . join(', ', map($_->emit_java($level, 'list'), @{$items})) . ')';
                    $code . '.apply(' . Perlito5::Java::to_context($wantarray) . ', ' . $arg_code . ')'
                }
                sub Perlito5::AST::Apply::emit_java_set_list {
                    my($self, $level, $list) = @_;
                    if ($self->code() eq 'undef') {
                        return $list . '.shift()'
                    }
                    if ($self->code() eq 'prefix:<$>') {
                        return Perlito5::Java::emit_java_autovivify($self->{'arguments'}->[0], $level + 1, 'scalar') . '.scalar_deref_set(' . $list->emit_java($level + 1, 'scalar') . ')'
                    }
                    die('not implemented: assign to ', $self->code())
                }
                sub Perlito5::AST::Apply::emit_java_get_decl {
                    my $self = shift;
                    my $code = $self->{'code'};
                    if ($code eq 'my' || $code eq 'our' || $code eq 'state' || $code eq 'local') {
                        return (map {
                            ref($_) eq 'Perlito5::AST::Var' ? Perlito5::AST::Decl::->new('decl' => $code, 'type' => '', 'var' => $_) : ()
                        } @{$self->{'arguments'}})
                    }
                    if ($code ne 'do' && $code ne 'eval') {
                        $self->{'arguments'} && return (map(+($_->emit_java_get_decl()), @{$self->{'arguments'}}))
                    }
                    return ()
                }
                sub Perlito5::AST::Apply::emit_java_has_regex {
                    my $self = shift;
                    my $code = $self->{'code'};
                    if ($code eq 'p5:m' || $code eq 'p5:s' || $code eq 'infix:<=~>' || $code eq 'infix:<!~>') {
                        return 1
                    }
                    return ()
                }
            }
            package Perlito5::AST::If;
            {
                sub Perlito5::AST::If::emit_java {
                    my($self, $level, $wantarray) = @_;
                    my $cond = $self->{'cond'};
                    my @str;
                    my $old_level = $level;
                    if ($cond) {
                        my @var_decl = $cond->emit_java_get_decl();
                        for my $arg (@var_decl) {
                            $level = $old_level + 1;
                            push(@str, $arg->emit_java_init($level, $wantarray))
                        }
                    }
                    my $body = ref($self->{'body'}) ne 'Perlito5::AST::Block' ? $self->{'body'} : (!@{$self->{'body'}->stmts()}) ? undef : $wantarray ne 'void' ? Perlito5::Java::LexicalBlock::->new('block' => $self->{'body'}->stmts(), 'not_a_loop' => 1) : Perlito5::Java::LexicalBlock::->new('block' => $self->{'body'}->stmts(), 'create_context' => 1, 'not_a_loop' => 1);
                    my $otherwise = ref($self->{'otherwise'}) ne 'Perlito5::AST::Block' ? $self->{'otherwise'} : (!@{$self->{'otherwise'}->stmts()}) ? undef : $wantarray ne 'void' ? Perlito5::Java::LexicalBlock::->new('block' => $self->{'otherwise'}->stmts(), 'not_a_loop' => 1) : Perlito5::Java::LexicalBlock::->new('block' => $self->{'otherwise'}->stmts(), 'create_context' => 1, 'not_a_loop' => 1);
                    push(@str, 'if (' . Perlito5::Java::to_bool($cond, $level + 1) . ') {');
                    if ($body) {
                        push(@str, [$body->emit_java($level + 1, $wantarray)])
                    }
                    push(@str, '}');
                    if ($otherwise) {
                        if (@{$otherwise->{'block'}} == 1 && ref($otherwise->{'block'}->[0]) eq 'Perlito5::AST::If') {
                            push(@str, 'else', [$otherwise->{'block'}->[0]->emit_java($level, $wantarray)])
                        }
                        else {
                            push(@str, 'else {', [$otherwise->emit_java($level + 1, $wantarray)], '}')
                        }
                    }
                    return Perlito5::Java::emit_wrap_java($level, @str)
                }
                sub Perlito5::AST::If::emit_java_get_decl {
                    ()
                }
                sub Perlito5::AST::If::emit_java_has_regex {
                    ()
                }
            }
            package Perlito5::AST::When;
            {
                sub Perlito5::AST::When::emit_java {
                    my($self, $level, $wantarray) = @_;
                    my $cond = $self->{'cond'};
                    my @str;
                    my $old_level = $level;
                    if ($cond) {
                        my @var_decl = $cond->emit_java_get_decl();
                        for my $arg (@var_decl) {
                            $level = $old_level + 1;
                            push(@str, $arg->emit_java_init($level, $wantarray))
                        }
                    }
                    $cond = Perlito5::AST::Apply::->new('arguments' => [Perlito5::AST::Var::->new('name' => '_', 'namespace' => 'main', 'sigil' => '$'), $cond], 'code' => 'infix:<~~>', 'namespace' => '');
                    my $next = Perlito5::AST::Apply::->new('arguments' => [], 'bareword' => 1, 'code' => 'next', 'namespace' => '');
                    my $body = ref($self->{'body'}) ne 'Perlito5::AST::Block' ? Perlito5::Java::LexicalBlock::->new('block' => [$self->{'body'}], 'not_a_loop' => 1) : (!@{$self->{'body'}->stmts()}) ? undef : $wantarray ne 'void' ? Perlito5::Java::LexicalBlock::->new('block' => $self->{'body'}->stmts(), 'not_a_loop' => 1) : Perlito5::Java::LexicalBlock::->new('block' => $self->{'body'}->stmts(), 'create_context' => 1, 'not_a_loop' => 1);
                    push(@{$body->{'block'}}, $next);
                    push(@str, 'if (' . Perlito5::Java::to_bool($cond, $level + 1) . ') {');
                    if ($body) {
                        push(@str, [$body->emit_java($level + 1, $wantarray)])
                    }
                    push(@str, '}');
                    return Perlito5::Java::emit_wrap_java($level, @str)
                }
                sub Perlito5::AST::When::emit_java_get_decl {
                    ()
                }
                sub Perlito5::AST::When::emit_java_has_regex {
                    ()
                }
            }
            package Perlito5::AST::While;
            {
                sub Perlito5::AST::While::emit_java {
                    my($self, $level, $wantarray) = @_;
                    my $cond = $self->{'cond'};
                    my @str;
                    my $old_level = $level;
                    if ($cond) {
                        my @var_decl = $cond->emit_java_get_decl();
                        for my $arg (@var_decl) {
                            $level = $old_level + 1;
                            push(@str, $arg->emit_java_init($level, $wantarray))
                        }
                    }
                    my $expression;
                    if (Perlito5::Java::is_native_bool($cond)) {
                        $expression = Perlito5::Java::to_native_bool($cond, $level + 1)
                    }
                    else {
                        $expression = Perlito5::Java::to_bool($cond, $level + 1)
                    }
                    if (ref($self->{'body'}) eq 'Perlito5::AST::Apply' && $self->{'body'}->{'code'} eq 'do') {
                        push(@str, 'do {', [Perlito5::Java::LexicalBlock::->new('block' => $self->{'body'}->{'arguments'}->[0]->{'stmts'}, 'not_a_loop' => 1)->emit_java($level + 2, $wantarray)], '}', 'while (' . $expression . ');')
                    }
                    else {
                        local $Perlito5::THROW = 0;
                        my $body = ref($self->{'body'}) ne 'Perlito5::AST::Block' ? [$self->{'body'}] : $self->{'body'}->{'stmts'};
                        push(@str, 'while (' . $expression . ') {', [Perlito5::Java::LexicalBlock::->new('block' => $body, 'block_label' => $self->{'label'}, 'continue' => $self->{'continue'})->emit_java($level + 2, $wantarray)], '}');
                        if ($Perlito5::THROW) {
                            @str = Perlito5::Java::emit_wrap_last_exception_java($self, \@str)
                        }
                    }
                    return Perlito5::Java::emit_wrap_java($level, @str)
                }
                sub Perlito5::AST::While::emit_java_get_decl {
                    ()
                }
                sub Perlito5::AST::While::emit_java_has_regex {
                    ()
                }
            }
            package Perlito5::AST::For;
            {
                sub Perlito5::AST::For::emit_java {
                    my($self, $level, $wantarray) = @_;
                    local $Perlito5::THROW = 0;
                    my $body = ref($self->{'body'}) ne 'Perlito5::AST::Block' ? [$self->{'body'}] : $self->{'body'}->{'stmts'};
                    my @str;
                    my $cond = ref($self->{'cond'}) eq 'ARRAY' ? $self->{'cond'} : [$self->{'cond'}];
                    for my $expr (@{$cond}, $self->{'topic'}) {
                        if ($expr) {
                            my @var_decl = $expr->emit_java_get_decl();
                            for my $arg (@var_decl) {
                                push(@str, $arg->emit_java_init($level, $wantarray))
                            }
                        }
                    }
                    if (ref($self->{'cond'}) eq 'ARRAY') {
                        push(@str, 'for ( ' . ($self->{'cond'}->[0] ? $self->{'cond'}->[0]->emit_java($level + 1) . '; ' : '; ') . ($self->{'cond'}->[1] ? Perlito5::Java::to_bool($self->{'cond'}->[1], $level + 1) . '; ' : '; ') . ($self->{'cond'}->[2] ? $self->{'cond'}->[2]->emit_java($level + 1) . ' ' : '') . ') {', [(Perlito5::Java::LexicalBlock::->new('block' => $body, 'block_label' => $self->{'label'}))->emit_java($level + 2, $wantarray)], '}')
                    }
                    else {
                        my $cond = Perlito5::Java::to_list([$self->{'cond'}], $level + 1);
                        my $topic = $self->{'topic'};
                        my $local_label = Perlito5::Java::get_label();
                        my $decl = '';
                        my $v = $topic;
                        if ($v->{'decl'}) {
                            $decl = $v->{'decl'};
                            $v = $v->{'var'}
                        }
                        else {
                            $decl = $v->{'_decl'} || 'global'
                        }
                        my $namespace = $v->{'namespace'} || $v->{'_namespace'} || $Perlito5::PKG_NAME;
                        my $s;
                        if ($decl eq 'my' || $decl eq 'state') {
                            push(@str, 'for (PlObject ' . $local_label . ' : ' . $cond . '.a) {', [$v->emit_java($level + 1) . '.set(' . $local_label . ');', Perlito5::Java::LexicalBlock::->new('block' => $body, 'block_label' => $self->{'label'}, 'continue' => $self->{'continue'})->emit_java($level + 2, $wantarray)], '}')
                        }
                        else {
                            push(@str, 'for (PlObject ' . $local_label . ' : ' . $cond . '.a) {', [$v->emit_java($level + 1) . '.set(' . $local_label . ');', Perlito5::Java::LexicalBlock::->new('block' => $body, 'block_label' => $self->{'label'}, 'continue' => $self->{'continue'})->emit_java($level + 2, $wantarray)], '}')
                        }
                    }
                    if ($Perlito5::THROW) {
                        @str = Perlito5::Java::emit_wrap_last_exception_java($self, \@str)
                    }
                    return Perlito5::Java::emit_wrap_java($level, @str)
                }
                sub Perlito5::AST::For::emit_java_get_decl {
                    ()
                }
                sub Perlito5::AST::For::emit_java_has_regex {
                    ()
                }
            }
            package Perlito5::AST::Sub;
            {
                sub Perlito5::AST::Sub::emit_java {
                    my($self, $level, $wantarray) = @_;
                    my $prototype = defined($self->{'sig'}) ? 'new PlString(' . Perlito5::Java::escape_string($self->{'sig'}) . ')' : 'PlCx.UNDEF';
                    my $sub_ref = Perlito5::Java::get_label();
                    local $Perlito5::AST::Sub::SUB_REF = $sub_ref;
                    my $block = Perlito5::Java::LexicalBlock::->new('block' => $self->{'block'}->{'stmts'});
                    my @captured;
                    for my $stmt (@{$self->{'block'}->{'stmts'}}) {
                        push(@captured, $stmt->get_captures())
                    }
                    my %dont_capture = map {
                        $_->{'dont'} ? ($_->{'dont'} => 1) : ()
                    } @captured;
                    my %capture = map {
                        $_->{'dont'} ? () : $dont_capture{$_->{'_id'}} ? () : ($_->{'_decl'} eq 'local' || $_->{'_decl'} eq 'global' || $_->{'_decl'} eq '') ? () : ($_->{'_id'} => $_)
                    } @captured;
                    my @captures_ast = map {
                        $capture{$_}
                    } sort {
                        $a cmp $b
                    } keys(%capture);
                    my @captures_java = map {
                        $_->emit_java($level, 'list')
                    } @captures_ast;
                    local %Perlito5::Java::Java_var_name;
                    my $i = 0;
                    for $_ (@captures_ast) {
                        $Perlito5::Java::Java_var_name{$_->{'_id'}} = 'this.env[' . $i . ']';
                        $i++
                    }
                    my @js_block;
                    if ($self->{'_do_block'}) {
                        @js_block = $block->emit_java($level + 3, $wantarray)
                    }
                    elsif ($self->{'_eval_block'}) {
                        $block->{'top_level'} = 1;
                        $block->{'eval_block'} = 1;
                        my $outer_throw = $Perlito5::THROW_RETURN;
                        $Perlito5::THROW_RETURN = 0;
                        @js_block = $block->emit_java($level + 3, 'runtime'), $Perlito5::THROW_RETURN = $outer_throw
                    }
                    else {
                        $block->{'top_level'} = 1;
                        my $outer_throw = $Perlito5::THROW_RETURN;
                        $Perlito5::THROW_RETURN = 0;
                        @js_block = $block->emit_java($level + 3, 'runtime');
                        $Perlito5::THROW_RETURN = $outer_throw
                    }
                    my $s = Perlito5::Java::emit_wrap_java($level, 'new PlClosure(' . $prototype . ', new PlObject[]{ ' . join(', ', @captures_java) . ' } ) {', ['public PlObject apply(int want, PlArray List__) {', \@js_block, '}'], '}');
                    if ($self->{'name'}) {
                        return 'PlV.set(' . Perlito5::Java::escape_string($self->{'namespace'} . '::' . $self->{'name'}) . ', ' . $s . ')'
                    }
                    else {
                        return $s
                    }
                }
                sub Perlito5::AST::Sub::emit_java_get_decl {
                    ()
                }
                sub Perlito5::AST::Sub::emit_java_has_regex {
                    ()
                }
            }
            package Perlito5::AST::Use;
            {
                sub Perlito5::AST::Use::emit_java {
                    my($self, $level, $wantarray) = @_;
                    Perlito5::Grammar::Use::emit_time_eval($self);
                    if ($wantarray ne 'void') {
                        return 'PlCx.UNDEF'
                    }
                    else {
                        return '// ' . $self->{'code'} . ' ' . $self->{'mod'} . chr(10)
                    }
                }
                sub Perlito5::AST::Use::emit_java_get_decl {
                    ()
                }
                sub Perlito5::AST::Use::emit_java_has_regex {
                    ()
                }
            }
            1
        }
    }
    {
        {
            package main;
            undef();
            package Perlito5::Java::Runtime;
            sub Perlito5::Java::Runtime::emit_java_extends {
                my($class, $java_classes) = @_;
                my @out;
                if ($class->{'extends'}) {
                    push(@out, 'class ' . $class->{'java_type'} . ' extends ' . $class->{'extends_java_type'} . ' {')
                }
                else {
                    push(@out, 'class ' . $class->{'java_type'} . ' implements ' . $class->{'implements_java_type'} . ' {')
                }
                $class->{'Java::inline'} && push(@out, $class->{'Java::inline'});
                while (@{$class->{'variables'}}) {
                    my $method = shift(@{$class->{'variables'}});
                    my $data = shift(@{$class->{'variables'}})
                }
                while (@{$class->{'methods'}}) {
                    my $method = shift(@{$class->{'methods'}});
                    my $data = shift(@{$class->{'methods'}});
                    my $decl = $data->{'decl'};
                    my $code = $data->{'code'} or die('Java extends: missing ' . chr(39) . 'code' . chr(39) . ' argument in method ' . chr(39) . $method . chr(39));
                    my $return = $data->{'return'} or die('Java extends: missing ' . chr(39) . 'return' . chr(39) . ' argument in method ' . chr(39) . $method . chr(39));
                    my @args;
                    my $var = 0;
                    for my $arg (@{$data->{'args'}}) {
                        my $type = $java_classes->{$arg};
                        push(@args, $type->{'java_type'} . ' param' . $var);
                        $var++
                    }
                    my @java_decl = @{$decl};
                    my $return_type = $return;
                    if ($return ne 'void') {
                        my $type = $java_classes->{$return};
                        $return_type = $type->{'java_type'}
                    }
                    my $throws = '';
                    if ($data->{'throws'}) {
                        $throws = 'throws ' . join(${'"'}, @{$data->{'throws'}})
                    }
                    push(@out, '    ' . join(${'"'}, @java_decl) . ' ' . $return_type . ' ' . $method . '(' . join(', ', @args) . ') ' . $throws . ' {');
                    @args = ();
                    if (grep {
                        $_ eq 'static'
                    } @{$decl}) {
                        push(@args, 'new PlString("' . $class->{'perl_package'} . '")')
                    }
                    else {
                        push(@args, 'new ' . $class->{'java_native_to_perl'} . '(this)')
                    }
                    $var = 0;
                    for my $arg (@{$data->{'args'}}) {
                        my $type = $java_classes->{$arg};
                        push(@args, 'new ' . $type->{'java_native_to_perl'} . '(param' . $var . ')');
                        $var++
                    }
                    push(@out, '        PlObject[] res = Main.apply("' . $code . '", ' . join(', ', @args) . ');');
                    if ($return eq 'void') {
                        push(@out, '        return;')
                    }
                    else {
                        my $type = $java_classes->{$return} or die('Java class ' . chr(39) . $return . chr(39) . ' is not imported');
                        push(@out, '        return res[0].' . $type->{'perl_to_java'} . '();')
                    }
                    push(@out, '    }')
                }
                push(@out, '}' . chr(10));
                return join(chr(10), @out)
            }
            sub Perlito5::Java::Runtime::emit_java {
                my($self, %args) = @_;
                my %java_classes = %{$args{'java_classes'} // {}};
                my %number_binop = ('add' => {'op' => '+', 'returns' => 'PlInt', 'num_returns' => 'PlDouble'}, 'sub' => {'op' => '-', 'returns' => 'PlInt', 'num_returns' => 'PlDouble'}, 'mul' => {'op' => '*', 'returns' => 'PlInt', 'num_returns' => 'PlDouble'}, 'div' => {'op' => '/', 'returns' => 'PlDouble', 'num_returns' => 'PlDouble'}, 'num_eq' => {'op' => '==', 'returns' => 'PlBool', 'num_returns' => 'PlBool'}, 'num_ne' => {'op' => '!=', 'returns' => 'PlBool', 'num_returns' => 'PlBool'}, 'num_lt' => {'op' => '<', 'returns' => 'PlBool', 'num_returns' => 'PlBool'}, 'num_le' => {'op' => '<=', 'returns' => 'PlBool', 'num_returns' => 'PlBool'}, 'num_gt' => {'op' => '>', 'returns' => 'PlBool', 'num_returns' => 'PlBool'}, 'num_ge' => {'op' => '>=', 'returns' => 'PlBool', 'num_returns' => 'PlBool'});
                my %string_binop = ('str_eq' => {'op' => '== 0', 'returns' => 'PlBool'}, 'str_ne' => {'op' => '!= 0', 'returns' => 'PlBool'}, 'str_lt' => {'op' => '< 0', 'returns' => 'PlBool'}, 'str_le' => {'op' => '<= 0', 'returns' => 'PlBool'}, 'str_gt' => {'op' => '> 0', 'returns' => 'PlBool'}, 'str_ge' => {'op' => '>= 0', 'returns' => 'PlBool'});
                my %native_to_perl = ('int' => 'PlInt', 'double' => 'PlDouble', 'boolean' => 'PlBool', 'String' => 'PlString');
                for $_ (values(%java_classes)) {
                    $native_to_perl{$_->{'java_type'}} = $_->{'java_native_to_perl'}
                }
                return '// start Perl-Java runtime' . chr(10) . '// this is generated code - see: lib/Perlito5/Java/Runtime.pm' . chr(10) . chr(10) . 'import java.lang.Math;' . chr(10) . 'import java.lang.System;' . chr(10) . 'import java.util.*;' . chr(10) . 'import java.io.*;' . chr(10) . 'import java.util.regex.Pattern;' . chr(10) . 'import java.util.regex.Matcher;' . chr(10) . 'import java.util.concurrent.TimeUnit;' . chr(10) . join('', (map {
                    my $class = $java_classes{$_};
                    $class->{'import'} ? 'import ' . $class->{'import'} . ';' . chr(10) : ()
                } sort {
                    $a cmp $b
                } keys(%java_classes))) . join('', (map {
                    my $class = $java_classes{$_};
                    $class->{'extends'} || $class->{'implements'} ? emit_java_extends($class, \%java_classes) : ()
                } sort {
                    $a cmp $b
                } keys(%java_classes))) . 'class PlControlException extends RuntimeException {' . chr(10) . '}' . chr(10) . 'class PlNextException    extends PlControlException {' . chr(10) . '    public int label_id;' . chr(10) . chr(10) . '    public PlNextException(int i) {' . chr(10) . '        this.label_id = i;' . chr(10) . '    }' . chr(10) . '}' . chr(10) . 'class PlLastException    extends PlControlException {' . chr(10) . '    public int label_id;' . chr(10) . chr(10) . '    public PlLastException(int i) {' . chr(10) . '        this.label_id = i;' . chr(10) . '    }' . chr(10) . '}' . chr(10) . 'class PlRedoException    extends PlControlException {' . chr(10) . '    public int label_id;' . chr(10) . chr(10) . '    public PlRedoException(int i) {' . chr(10) . '        this.label_id = i;' . chr(10) . '    }' . chr(10) . '}' . chr(10) . 'class PlReturnException  extends PlControlException {' . chr(10) . '    public PlObject ret;' . chr(10) . chr(10) . '    public PlReturnException(PlObject ret) {' . chr(10) . '        this.ret = ret;' . chr(10) . '    }' . chr(10) . '}' . chr(10) . 'class PlDieException  extends PlControlException {' . chr(10) . '    public PlObject ret;' . chr(10) . chr(10) . '    public PlDieException(PlObject ret) {' . chr(10) . '        this.ret = ret;' . chr(10) . '    }' . chr(10) . '    public String getMessage() {' . chr(10) . '        return this.ret.toString();' . chr(10) . '    }' . chr(10) . '}' . chr(10) . 'class PlCx {' . chr(10) . '    public static final int     VOID   = 0;' . chr(10) . '    public static final int     SCALAR = 1;' . chr(10) . '    public static final int     LIST   = 2;' . chr(10) . '    public static final PlUndef  UNDEF  = new PlUndef();' . chr(10) . '    public static final PlBool   TRUE   = new PlBool(true);' . chr(10) . '    public static final PlBool   FALSE  = new PlBool(false);' . chr(10) . '    public static final PlString STDOUT = new PlString("STDOUT");' . chr(10) . '    public static final PlString STDERR = new PlString("STDERR");' . chr(10) . '    public static final PlString STDIN  = new PlString("STDIN");' . chr(10) . '    public static final PlString DIED   = new PlString("Died");' . chr(10) . '    public static final PlString EMPTY  = new PlString("");' . chr(10) . '    public static final String  ARGV   = "main::List_ARGV";' . chr(10) . '    public static final String  ENV    = "main::Hash_ENV";' . chr(10) . '    public static final PlNextException NEXT = new PlNextException(0);' . chr(10) . '    public static final PlLastException LAST = new PlLastException(0);' . chr(10) . chr(10) . '    ' . join(chr(10) . '    ', map {
                    'public static final PlInt ' . ($_ < 0 ? 'MIN' : 'INT') . abs($_) . ' = new PlInt(' . $_ . ');'
                } (-2 .. 2)) . chr(10) . '    ' . join(chr(10) . '    ', @{$args{'java_constants'} // []}) . chr(10) . '}' . chr(10) . '/****************************************************************************' . chr(10) . ' * Java-based implementation of the unix crypt(3) command' . chr(10) . ' *' . chr(10) . ' * Based upon C source code written by Eric Young, eay@psych.uq.oz.au' . chr(10) . ' * Java conversion by John F. Dumas, jdumas@zgs.com' . chr(10) . ' *' . chr(10) . ' * Found at http://locutus.kingwoodcable.com/jfd/crypt.html' . chr(10) . ' * Found at http://cseweb.ucsd.edu/classes/sp12/cse130-a/static/pa5/Crypt.java' . chr(10) . ' * Minor optimizations by Wes Biggs, wes@cacas.org' . chr(10) . ' *' . chr(10) . ' * Eric' . chr(39) . 's original code is licensed under the BSD license.  As this is' . chr(10) . ' * derivative, the same license applies.' . chr(10) . ' *' . chr(10) . ' * Note: Crypt.class is much smaller when compiled with javac -O' . chr(10) . ' ****************************************************************************/' . chr(10) . chr(10) . 'class PlCrypt {' . chr(10) . '  private PlCrypt() {} // defined so class can' . chr(39) . 't be instantiated.' . chr(10) . chr(10) . '  private static final int ITERATIONS = 16;' . chr(10) . chr(10) . '  private static final boolean shifts2[] = {' . chr(10) . '    false, false, true, true, true, true, true, true,' . chr(10) . '    false, true,  true, true, true, true, true, false' . chr(10) . '  };' . chr(10) . chr(10) . '  private static final int skb[][] = {' . chr(10) . '    {' . chr(10) . '      /* for C bits (numbered as per FIPS 46) 1 2 3 4 5 6 */' . chr(10) . '      0x00000000, 0x00000010, 0x20000000, 0x20000010, ' . chr(10) . '      0x00010000, 0x00010010, 0x20010000, 0x20010010, ' . chr(10) . '      0x00000800, 0x00000810, 0x20000800, 0x20000810, ' . chr(10) . '      0x00010800, 0x00010810, 0x20010800, 0x20010810, ' . chr(10) . '      0x00000020, 0x00000030, 0x20000020, 0x20000030, ' . chr(10) . '      0x00010020, 0x00010030, 0x20010020, 0x20010030, ' . chr(10) . '      0x00000820, 0x00000830, 0x20000820, 0x20000830, ' . chr(10) . '      0x00010820, 0x00010830, 0x20010820, 0x20010830, ' . chr(10) . '      0x00080000, 0x00080010, 0x20080000, 0x20080010, ' . chr(10) . '      0x00090000, 0x00090010, 0x20090000, 0x20090010, ' . chr(10) . '      0x00080800, 0x00080810, 0x20080800, 0x20080810, ' . chr(10) . '      0x00090800, 0x00090810, 0x20090800, 0x20090810, ' . chr(10) . '      0x00080020, 0x00080030, 0x20080020, 0x20080030, ' . chr(10) . '      0x00090020, 0x00090030, 0x20090020, 0x20090030, ' . chr(10) . '      0x00080820, 0x00080830, 0x20080820, 0x20080830, ' . chr(10) . '      0x00090820, 0x00090830, 0x20090820, 0x20090830, ' . chr(10) . '    },' . chr(10) . '    {' . chr(10) . '      /* for C bits (numbered as per FIPS 46) 7 8 10 11 12 13 */' . chr(10) . '      0x00000000, 0x02000000, 0x00002000, 0x02002000, ' . chr(10) . '      0x00200000, 0x02200000, 0x00202000, 0x02202000, ' . chr(10) . '      0x00000004, 0x02000004, 0x00002004, 0x02002004, ' . chr(10) . '      0x00200004, 0x02200004, 0x00202004, 0x02202004, ' . chr(10) . '      0x00000400, 0x02000400, 0x00002400, 0x02002400, ' . chr(10) . '      0x00200400, 0x02200400, 0x00202400, 0x02202400, ' . chr(10) . '      0x00000404, 0x02000404, 0x00002404, 0x02002404, ' . chr(10) . '      0x00200404, 0x02200404, 0x00202404, 0x02202404, ' . chr(10) . '      0x10000000, 0x12000000, 0x10002000, 0x12002000, ' . chr(10) . '      0x10200000, 0x12200000, 0x10202000, 0x12202000, ' . chr(10) . '      0x10000004, 0x12000004, 0x10002004, 0x12002004, ' . chr(10) . '      0x10200004, 0x12200004, 0x10202004, 0x12202004, ' . chr(10) . '      0x10000400, 0x12000400, 0x10002400, 0x12002400, ' . chr(10) . '      0x10200400, 0x12200400, 0x10202400, 0x12202400, ' . chr(10) . '      0x10000404, 0x12000404, 0x10002404, 0x12002404, ' . chr(10) . '      0x10200404, 0x12200404, 0x10202404, 0x12202404, ' . chr(10) . '    },' . chr(10) . '    {' . chr(10) . '      /* for C bits (numbered as per FIPS 46) 14 15 16 17 19 20 */' . chr(10) . '      0x00000000, 0x00000001, 0x00040000, 0x00040001, ' . chr(10) . '      0x01000000, 0x01000001, 0x01040000, 0x01040001, ' . chr(10) . '      0x00000002, 0x00000003, 0x00040002, 0x00040003, ' . chr(10) . '      0x01000002, 0x01000003, 0x01040002, 0x01040003, ' . chr(10) . '      0x00000200, 0x00000201, 0x00040200, 0x00040201, ' . chr(10) . '      0x01000200, 0x01000201, 0x01040200, 0x01040201, ' . chr(10) . '      0x00000202, 0x00000203, 0x00040202, 0x00040203, ' . chr(10) . '      0x01000202, 0x01000203, 0x01040202, 0x01040203, ' . chr(10) . '      0x08000000, 0x08000001, 0x08040000, 0x08040001, ' . chr(10) . '      0x09000000, 0x09000001, 0x09040000, 0x09040001, ' . chr(10) . '      0x08000002, 0x08000003, 0x08040002, 0x08040003, ' . chr(10) . '      0x09000002, 0x09000003, 0x09040002, 0x09040003, ' . chr(10) . '      0x08000200, 0x08000201, 0x08040200, 0x08040201, ' . chr(10) . '      0x09000200, 0x09000201, 0x09040200, 0x09040201, ' . chr(10) . '      0x08000202, 0x08000203, 0x08040202, 0x08040203, ' . chr(10) . '      0x09000202, 0x09000203, 0x09040202, 0x09040203, ' . chr(10) . '    },' . chr(10) . '    {' . chr(10) . '      /* for C bits (numbered as per FIPS 46) 21 23 24 26 27 28 */' . chr(10) . '      0x00000000, 0x00100000, 0x00000100, 0x00100100, ' . chr(10) . '      0x00000008, 0x00100008, 0x00000108, 0x00100108, ' . chr(10) . '      0x00001000, 0x00101000, 0x00001100, 0x00101100, ' . chr(10) . '      0x00001008, 0x00101008, 0x00001108, 0x00101108, ' . chr(10) . '      0x04000000, 0x04100000, 0x04000100, 0x04100100, ' . chr(10) . '      0x04000008, 0x04100008, 0x04000108, 0x04100108, ' . chr(10) . '      0x04001000, 0x04101000, 0x04001100, 0x04101100, ' . chr(10) . '      0x04001008, 0x04101008, 0x04001108, 0x04101108, ' . chr(10) . '      0x00020000, 0x00120000, 0x00020100, 0x00120100, ' . chr(10) . '      0x00020008, 0x00120008, 0x00020108, 0x00120108, ' . chr(10) . '      0x00021000, 0x00121000, 0x00021100, 0x00121100, ' . chr(10) . '      0x00021008, 0x00121008, 0x00021108, 0x00121108, ' . chr(10) . '      0x04020000, 0x04120000, 0x04020100, 0x04120100, ' . chr(10) . '      0x04020008, 0x04120008, 0x04020108, 0x04120108, ' . chr(10) . '      0x04021000, 0x04121000, 0x04021100, 0x04121100, ' . chr(10) . '      0x04021008, 0x04121008, 0x04021108, 0x04121108, ' . chr(10) . '    },' . chr(10) . '    {' . chr(10) . '      /* for D bits (numbered as per FIPS 46) 1 2 3 4 5 6 */' . chr(10) . '      0x00000000, 0x10000000, 0x00010000, 0x10010000, ' . chr(10) . '      0x00000004, 0x10000004, 0x00010004, 0x10010004, ' . chr(10) . '      0x20000000, 0x30000000, 0x20010000, 0x30010000, ' . chr(10) . '      0x20000004, 0x30000004, 0x20010004, 0x30010004, ' . chr(10) . '      0x00100000, 0x10100000, 0x00110000, 0x10110000, ' . chr(10) . '      0x00100004, 0x10100004, 0x00110004, 0x10110004, ' . chr(10) . '      0x20100000, 0x30100000, 0x20110000, 0x30110000, ' . chr(10) . '      0x20100004, 0x30100004, 0x20110004, 0x30110004, ' . chr(10) . '      0x00001000, 0x10001000, 0x00011000, 0x10011000, ' . chr(10) . '      0x00001004, 0x10001004, 0x00011004, 0x10011004, ' . chr(10) . '      0x20001000, 0x30001000, 0x20011000, 0x30011000, ' . chr(10) . '      0x20001004, 0x30001004, 0x20011004, 0x30011004, ' . chr(10) . '      0x00101000, 0x10101000, 0x00111000, 0x10111000, ' . chr(10) . '      0x00101004, 0x10101004, 0x00111004, 0x10111004, ' . chr(10) . '      0x20101000, 0x30101000, 0x20111000, 0x30111000, ' . chr(10) . '      0x20101004, 0x30101004, 0x20111004, 0x30111004, ' . chr(10) . '    },' . chr(10) . '    {' . chr(10) . '      /* for D bits (numbered as per FIPS 46) 8 9 11 12 13 14 */' . chr(10) . '      0x00000000, 0x08000000, 0x00000008, 0x08000008, ' . chr(10) . '      0x00000400, 0x08000400, 0x00000408, 0x08000408, ' . chr(10) . '      0x00020000, 0x08020000, 0x00020008, 0x08020008, ' . chr(10) . '      0x00020400, 0x08020400, 0x00020408, 0x08020408, ' . chr(10) . '      0x00000001, 0x08000001, 0x00000009, 0x08000009, ' . chr(10) . '      0x00000401, 0x08000401, 0x00000409, 0x08000409, ' . chr(10) . '      0x00020001, 0x08020001, 0x00020009, 0x08020009, ' . chr(10) . '      0x00020401, 0x08020401, 0x00020409, 0x08020409, ' . chr(10) . '      0x02000000, 0x0A000000, 0x02000008, 0x0A000008, ' . chr(10) . '      0x02000400, 0x0A000400, 0x02000408, 0x0A000408, ' . chr(10) . '      0x02020000, 0x0A020000, 0x02020008, 0x0A020008, ' . chr(10) . '      0x02020400, 0x0A020400, 0x02020408, 0x0A020408, ' . chr(10) . '      0x02000001, 0x0A000001, 0x02000009, 0x0A000009, ' . chr(10) . '      0x02000401, 0x0A000401, 0x02000409, 0x0A000409, ' . chr(10) . '      0x02020001, 0x0A020001, 0x02020009, 0x0A020009, ' . chr(10) . '      0x02020401, 0x0A020401, 0x02020409, 0x0A020409, ' . chr(10) . '    },' . chr(10) . '    {' . chr(10) . '      /* for D bits (numbered as per FIPS 46) 16 17 18 19 20 21 */' . chr(10) . '      0x00000000, 0x00000100, 0x00080000, 0x00080100, ' . chr(10) . '      0x01000000, 0x01000100, 0x01080000, 0x01080100, ' . chr(10) . '      0x00000010, 0x00000110, 0x00080010, 0x00080110, ' . chr(10) . '      0x01000010, 0x01000110, 0x01080010, 0x01080110, ' . chr(10) . '      0x00200000, 0x00200100, 0x00280000, 0x00280100, ' . chr(10) . '      0x01200000, 0x01200100, 0x01280000, 0x01280100, ' . chr(10) . '      0x00200010, 0x00200110, 0x00280010, 0x00280110, ' . chr(10) . '      0x01200010, 0x01200110, 0x01280010, 0x01280110, ' . chr(10) . '      0x00000200, 0x00000300, 0x00080200, 0x00080300, ' . chr(10) . '      0x01000200, 0x01000300, 0x01080200, 0x01080300, ' . chr(10) . '      0x00000210, 0x00000310, 0x00080210, 0x00080310, ' . chr(10) . '      0x01000210, 0x01000310, 0x01080210, 0x01080310, ' . chr(10) . '      0x00200200, 0x00200300, 0x00280200, 0x00280300, ' . chr(10) . '      0x01200200, 0x01200300, 0x01280200, 0x01280300, ' . chr(10) . '      0x00200210, 0x00200310, 0x00280210, 0x00280310, ' . chr(10) . '      0x01200210, 0x01200310, 0x01280210, 0x01280310, ' . chr(10) . '    },' . chr(10) . '    {' . chr(10) . '      /* for D bits (numbered as per FIPS 46) 22 23 24 25 27 28 */' . chr(10) . '      0x00000000, 0x04000000, 0x00040000, 0x04040000, ' . chr(10) . '      0x00000002, 0x04000002, 0x00040002, 0x04040002, ' . chr(10) . '      0x00002000, 0x04002000, 0x00042000, 0x04042000, ' . chr(10) . '      0x00002002, 0x04002002, 0x00042002, 0x04042002, ' . chr(10) . '      0x00000020, 0x04000020, 0x00040020, 0x04040020, ' . chr(10) . '      0x00000022, 0x04000022, 0x00040022, 0x04040022, ' . chr(10) . '      0x00002020, 0x04002020, 0x00042020, 0x04042020, ' . chr(10) . '      0x00002022, 0x04002022, 0x00042022, 0x04042022, ' . chr(10) . '      0x00000800, 0x04000800, 0x00040800, 0x04040800, ' . chr(10) . '      0x00000802, 0x04000802, 0x00040802, 0x04040802, ' . chr(10) . '      0x00002800, 0x04002800, 0x00042800, 0x04042800, ' . chr(10) . '      0x00002802, 0x04002802, 0x00042802, 0x04042802, ' . chr(10) . '      0x00000820, 0x04000820, 0x00040820, 0x04040820, ' . chr(10) . '      0x00000822, 0x04000822, 0x00040822, 0x04040822, ' . chr(10) . '      0x00002820, 0x04002820, 0x00042820, 0x04042820, ' . chr(10) . '      0x00002822, 0x04002822, 0x00042822, 0x04042822, ' . chr(10) . '    }' . chr(10) . '  };' . chr(10) . '  ' . chr(10) . '  private static final int SPtrans[][] = {' . chr(10) . '    {' . chr(10) . '      /* nibble 0 */' . chr(10) . '      0x00820200, 0x00020000, 0x80800000, 0x80820200,' . chr(10) . '      0x00800000, 0x80020200, 0x80020000, 0x80800000,' . chr(10) . '      0x80020200, 0x00820200, 0x00820000, 0x80000200,' . chr(10) . '      0x80800200, 0x00800000, 0x00000000, 0x80020000,' . chr(10) . '      0x00020000, 0x80000000, 0x00800200, 0x00020200,' . chr(10) . '      0x80820200, 0x00820000, 0x80000200, 0x00800200,' . chr(10) . '      0x80000000, 0x00000200, 0x00020200, 0x80820000,' . chr(10) . '      0x00000200, 0x80800200, 0x80820000, 0x00000000,' . chr(10) . '      0x00000000, 0x80820200, 0x00800200, 0x80020000,' . chr(10) . '      0x00820200, 0x00020000, 0x80000200, 0x00800200,' . chr(10) . '      0x80820000, 0x00000200, 0x00020200, 0x80800000,' . chr(10) . '      0x80020200, 0x80000000, 0x80800000, 0x00820000,' . chr(10) . '      0x80820200, 0x00020200, 0x00820000, 0x80800200,' . chr(10) . '      0x00800000, 0x80000200, 0x80020000, 0x00000000,' . chr(10) . '      0x00020000, 0x00800000, 0x80800200, 0x00820200,' . chr(10) . '      0x80000000, 0x80820000, 0x00000200, 0x80020200,' . chr(10) . '    },' . chr(10) . '    {' . chr(10) . '      /* nibble 1 */' . chr(10) . '      0x10042004, 0x00000000, 0x00042000, 0x10040000,' . chr(10) . '      0x10000004, 0x00002004, 0x10002000, 0x00042000,' . chr(10) . '      0x00002000, 0x10040004, 0x00000004, 0x10002000,' . chr(10) . '      0x00040004, 0x10042000, 0x10040000, 0x00000004,' . chr(10) . '      0x00040000, 0x10002004, 0x10040004, 0x00002000,' . chr(10) . '      0x00042004, 0x10000000, 0x00000000, 0x00040004,' . chr(10) . '      0x10002004, 0x00042004, 0x10042000, 0x10000004,' . chr(10) . '      0x10000000, 0x00040000, 0x00002004, 0x10042004,' . chr(10) . '      0x00040004, 0x10042000, 0x10002000, 0x00042004,' . chr(10) . '      0x10042004, 0x00040004, 0x10000004, 0x00000000,' . chr(10) . '      0x10000000, 0x00002004, 0x00040000, 0x10040004,' . chr(10) . '      0x00002000, 0x10000000, 0x00042004, 0x10002004,' . chr(10) . '      0x10042000, 0x00002000, 0x00000000, 0x10000004,' . chr(10) . '      0x00000004, 0x10042004, 0x00042000, 0x10040000,' . chr(10) . '      0x10040004, 0x00040000, 0x00002004, 0x10002000,' . chr(10) . '      0x10002004, 0x00000004, 0x10040000, 0x00042000,' . chr(10) . '    },' . chr(10) . '    {' . chr(10) . '      /* nibble 2 */' . chr(10) . '      0x41000000, 0x01010040, 0x00000040, 0x41000040,' . chr(10) . '      0x40010000, 0x01000000, 0x41000040, 0x00010040,' . chr(10) . '      0x01000040, 0x00010000, 0x01010000, 0x40000000,' . chr(10) . '      0x41010040, 0x40000040, 0x40000000, 0x41010000,' . chr(10) . '      0x00000000, 0x40010000, 0x01010040, 0x00000040,' . chr(10) . '      0x40000040, 0x41010040, 0x00010000, 0x41000000,' . chr(10) . '      0x41010000, 0x01000040, 0x40010040, 0x01010000,' . chr(10) . '      0x00010040, 0x00000000, 0x01000000, 0x40010040,' . chr(10) . '      0x01010040, 0x00000040, 0x40000000, 0x00010000,' . chr(10) . '      0x40000040, 0x40010000, 0x01010000, 0x41000040,' . chr(10) . '      0x00000000, 0x01010040, 0x00010040, 0x41010000,' . chr(10) . '      0x40010000, 0x01000000, 0x41010040, 0x40000000,' . chr(10) . '      0x40010040, 0x41000000, 0x01000000, 0x41010040,' . chr(10) . '      0x00010000, 0x01000040, 0x41000040, 0x00010040,' . chr(10) . '      0x01000040, 0x00000000, 0x41010000, 0x40000040,' . chr(10) . '      0x41000000, 0x40010040, 0x00000040, 0x01010000,' . chr(10) . '    },' . chr(10) . '    {' . chr(10) . '      /* nibble 3 */' . chr(10) . '      0x00100402, 0x04000400, 0x00000002, 0x04100402,' . chr(10) . '      0x00000000, 0x04100000, 0x04000402, 0x00100002,' . chr(10) . '      0x04100400, 0x04000002, 0x04000000, 0x00000402,' . chr(10) . '      0x04000002, 0x00100402, 0x00100000, 0x04000000,' . chr(10) . '      0x04100002, 0x00100400, 0x00000400, 0x00000002,' . chr(10) . '      0x00100400, 0x04000402, 0x04100000, 0x00000400,' . chr(10) . '      0x00000402, 0x00000000, 0x00100002, 0x04100400,' . chr(10) . '      0x04000400, 0x04100002, 0x04100402, 0x00100000,' . chr(10) . '      0x04100002, 0x00000402, 0x00100000, 0x04000002,' . chr(10) . '      0x00100400, 0x04000400, 0x00000002, 0x04100000,' . chr(10) . '      0x04000402, 0x00000000, 0x00000400, 0x00100002,' . chr(10) . '      0x00000000, 0x04100002, 0x04100400, 0x00000400,' . chr(10) . '      0x04000000, 0x04100402, 0x00100402, 0x00100000,' . chr(10) . '      0x04100402, 0x00000002, 0x04000400, 0x00100402,' . chr(10) . '      0x00100002, 0x00100400, 0x04100000, 0x04000402,' . chr(10) . '      0x00000402, 0x04000000, 0x04000002, 0x04100400,' . chr(10) . '    },' . chr(10) . '    {' . chr(10) . '      /* nibble 4 */' . chr(10) . '      0x02000000, 0x00004000, 0x00000100, 0x02004108,' . chr(10) . '      0x02004008, 0x02000100, 0x00004108, 0x02004000,' . chr(10) . '      0x00004000, 0x00000008, 0x02000008, 0x00004100,' . chr(10) . '      0x02000108, 0x02004008, 0x02004100, 0x00000000,' . chr(10) . '      0x00004100, 0x02000000, 0x00004008, 0x00000108,' . chr(10) . '      0x02000100, 0x00004108, 0x00000000, 0x02000008,' . chr(10) . '      0x00000008, 0x02000108, 0x02004108, 0x00004008,' . chr(10) . '      0x02004000, 0x00000100, 0x00000108, 0x02004100,' . chr(10) . '      0x02004100, 0x02000108, 0x00004008, 0x02004000,' . chr(10) . '      0x00004000, 0x00000008, 0x02000008, 0x02000100,' . chr(10) . '      0x02000000, 0x00004100, 0x02004108, 0x00000000,' . chr(10) . '      0x00004108, 0x02000000, 0x00000100, 0x00004008,' . chr(10) . '      0x02000108, 0x00000100, 0x00000000, 0x02004108,' . chr(10) . '      0x02004008, 0x02004100, 0x00000108, 0x00004000,' . chr(10) . '      0x00004100, 0x02004008, 0x02000100, 0x00000108,' . chr(10) . '      0x00000008, 0x00004108, 0x02004000, 0x02000008,' . chr(10) . '    },' . chr(10) . '    {' . chr(10) . '      /* nibble 5 */' . chr(10) . '      0x20000010, 0x00080010, 0x00000000, 0x20080800,' . chr(10) . '      0x00080010, 0x00000800, 0x20000810, 0x00080000,' . chr(10) . '      0x00000810, 0x20080810, 0x00080800, 0x20000000,' . chr(10) . '      0x20000800, 0x20000010, 0x20080000, 0x00080810,' . chr(10) . '      0x00080000, 0x20000810, 0x20080010, 0x00000000,' . chr(10) . '      0x00000800, 0x00000010, 0x20080800, 0x20080010,' . chr(10) . '      0x20080810, 0x20080000, 0x20000000, 0x00000810,' . chr(10) . '      0x00000010, 0x00080800, 0x00080810, 0x20000800,' . chr(10) . '      0x00000810, 0x20000000, 0x20000800, 0x00080810,' . chr(10) . '      0x20080800, 0x00080010, 0x00000000, 0x20000800,' . chr(10) . '      0x20000000, 0x00000800, 0x20080010, 0x00080000,' . chr(10) . '      0x00080010, 0x20080810, 0x00080800, 0x00000010,' . chr(10) . '      0x20080810, 0x00080800, 0x00080000, 0x20000810,' . chr(10) . '      0x20000010, 0x20080000, 0x00080810, 0x00000000,' . chr(10) . '      0x00000800, 0x20000010, 0x20000810, 0x20080800,' . chr(10) . '      0x20080000, 0x00000810, 0x00000010, 0x20080010,' . chr(10) . '    },' . chr(10) . '    {' . chr(10) . '      /* nibble 6 */' . chr(10) . '      0x00001000, 0x00000080, 0x00400080, 0x00400001,' . chr(10) . '      0x00401081, 0x00001001, 0x00001080, 0x00000000,' . chr(10) . '      0x00400000, 0x00400081, 0x00000081, 0x00401000,' . chr(10) . '      0x00000001, 0x00401080, 0x00401000, 0x00000081,' . chr(10) . '      0x00400081, 0x00001000, 0x00001001, 0x00401081,' . chr(10) . '      0x00000000, 0x00400080, 0x00400001, 0x00001080,' . chr(10) . '      0x00401001, 0x00001081, 0x00401080, 0x00000001,' . chr(10) . '      0x00001081, 0x00401001, 0x00000080, 0x00400000,' . chr(10) . '      0x00001081, 0x00401000, 0x00401001, 0x00000081,' . chr(10) . '      0x00001000, 0x00000080, 0x00400000, 0x00401001,' . chr(10) . '      0x00400081, 0x00001081, 0x00001080, 0x00000000,' . chr(10) . '      0x00000080, 0x00400001, 0x00000001, 0x00400080,' . chr(10) . '      0x00000000, 0x00400081, 0x00400080, 0x00001080,' . chr(10) . '      0x00000081, 0x00001000, 0x00401081, 0x00400000,' . chr(10) . '      0x00401080, 0x00000001, 0x00001001, 0x00401081,' . chr(10) . '      0x00400001, 0x00401080, 0x00401000, 0x00001001,' . chr(10) . '    },' . chr(10) . '    {' . chr(10) . '      /* nibble 7 */' . chr(10) . '      0x08200020, 0x08208000, 0x00008020, 0x00000000,' . chr(10) . '      0x08008000, 0x00200020, 0x08200000, 0x08208020,' . chr(10) . '      0x00000020, 0x08000000, 0x00208000, 0x00008020,' . chr(10) . '      0x00208020, 0x08008020, 0x08000020, 0x08200000,' . chr(10) . '      0x00008000, 0x00208020, 0x00200020, 0x08008000,' . chr(10) . '      0x08208020, 0x08000020, 0x00000000, 0x00208000,' . chr(10) . '      0x08000000, 0x00200000, 0x08008020, 0x08200020,' . chr(10) . '      0x00200000, 0x00008000, 0x08208000, 0x00000020,' . chr(10) . '      0x00200000, 0x00008000, 0x08000020, 0x08208020,' . chr(10) . '      0x00008020, 0x08000000, 0x00000000, 0x00208000,' . chr(10) . '      0x08200020, 0x08008020, 0x08008000, 0x00200020,' . chr(10) . '      0x08208000, 0x00000020, 0x00200020, 0x08008000,' . chr(10) . '      0x08208020, 0x00200000, 0x08200000, 0x08000020,' . chr(10) . '      0x00208000, 0x00008020, 0x08008020, 0x08200000,' . chr(10) . '      0x00000020, 0x08208000, 0x00208020, 0x00000000,' . chr(10) . '      0x08000000, 0x08200020, 0x00008000, 0x00208020' . chr(10) . '    }' . chr(10) . '  };' . chr(10) . '  ' . chr(10) . '  private static final int byteToUnsigned(byte b) {' . chr(10) . '    int value = (int) b;' . chr(10) . '    return (value >= 0) ? value : value + 256;' . chr(10) . '  }' . chr(10) . chr(10) . '  private static int fourBytesToInt(byte b[], int offset) {' . chr(10) . '    return byteToUnsigned(b[offset++]) ' . chr(10) . '      | (byteToUnsigned(b[offset++]) <<  8) ' . chr(10) . '      | (byteToUnsigned(b[offset++]) << 16) ' . chr(10) . '      | (byteToUnsigned(b[offset]) << 24);' . chr(10) . '  }' . chr(10) . chr(10) . '  private static final void intToFourBytes(int iValue, byte b[], int offset) {' . chr(10) . '    b[offset++] = (byte)((iValue)        & 0xff);' . chr(10) . '    b[offset++] = (byte)((iValue >>> 8 ) & 0xff);' . chr(10) . '    b[offset++] = (byte)((iValue >>> 16) & 0xff);' . chr(10) . '    b[offset] = (byte)((iValue >>> 24) & 0xff);' . chr(10) . '  }' . chr(10) . '  ' . chr(10) . '  private static final void PERM_OP(int a, int b, int n, int m, int results[]) {' . chr(10) . '    int t;' . chr(10) . chr(10) . '    t = ((a >>> n) ^ b) & m;' . chr(10) . '    a ^= t << n;' . chr(10) . '    b ^= t;' . chr(10) . chr(10) . '    results[0] = a;' . chr(10) . '    results[1] = b;' . chr(10) . '  }' . chr(10) . chr(10) . '  private static final int HPERM_OP(int a, int n, int m) {' . chr(10) . '    int t;' . chr(10) . '    ' . chr(10) . '    t = ((a << (16 - n)) ^ a) & m;' . chr(10) . '    a = a ^ t ^ (t >>> (16 - n));' . chr(10) . '    ' . chr(10) . '    return a;' . chr(10) . '  }' . chr(10) . chr(10) . '  private static int [] des_set_key(byte key[]) {' . chr(10) . '    int schedule[] = new int [ITERATIONS * 2];' . chr(10) . '    ' . chr(10) . '    int c = fourBytesToInt(key, 0);' . chr(10) . '    int d = fourBytesToInt(key, 4);' . chr(10) . '    ' . chr(10) . '    int results[] = new int[2];' . chr(10) . chr(10) . '    PERM_OP(d, c, 4, 0x0f0f0f0f, results);' . chr(10) . '    d = results[0]; c = results[1];' . chr(10) . '    ' . chr(10) . '    c = HPERM_OP(c, -2, 0xcccc0000);' . chr(10) . '    d = HPERM_OP(d, -2, 0xcccc0000);' . chr(10) . '    ' . chr(10) . '    PERM_OP(d, c, 1, 0x55555555, results);' . chr(10) . '    d = results[0]; c = results[1];' . chr(10) . '    ' . chr(10) . '    PERM_OP(c, d, 8, 0x00ff00ff, results);' . chr(10) . '    c = results[0]; d = results[1];' . chr(10) . '    ' . chr(10) . '    PERM_OP(d, c, 1, 0x55555555, results);' . chr(10) . '    d = results[0]; c = results[1];' . chr(10) . '    ' . chr(10) . '    d = (((d & 0x000000ff) <<  16) |  (d & 0x0000ff00)     |' . chr(10) . '     ((d & 0x00ff0000) >>> 16) | ((c & 0xf0000000) >>> 4));' . chr(10) . '    c &= 0x0fffffff;' . chr(10) . '    ' . chr(10) . '    int s, t;' . chr(10) . '    int j = 0;' . chr(10) . '    ' . chr(10) . '    for(int i = 0; i < ITERATIONS; i ++) {' . chr(10) . '      if(shifts2[i]) {' . chr(10) . '    c = (c >>> 2) | (c << 26);' . chr(10) . '    d = (d >>> 2) | (d << 26);' . chr(10) . '      } else {' . chr(10) . '    c = (c >>> 1) | (c << 27);' . chr(10) . '    d = (d >>> 1) | (d << 27);' . chr(10) . '      }' . chr(10) . '      ' . chr(10) . '      c &= 0x0fffffff;' . chr(10) . '      d &= 0x0fffffff;' . chr(10) . '      ' . chr(10) . '      s = skb[0][ (c       ) & 0x3f                       ]|' . chr(10) . '    skb[1][((c >>>  6) & 0x03) | ((c >>>  7) & 0x3c)]|' . chr(10) . '    skb[2][((c >>> 13) & 0x0f) | ((c >>> 14) & 0x30)]|' . chr(10) . '    skb[3][((c >>> 20) & 0x01) | ((c >>> 21) & 0x06) |' . chr(10) . '                   ((c >>> 22) & 0x38)];' . chr(10) . chr(10) . '      t = skb[4][ (d     )  & 0x3f                       ]|' . chr(10) . '    skb[5][((d >>> 7) & 0x03) | ((d >>>  8) & 0x3c)]|' . chr(10) . '    skb[6][ (d >>>15) & 0x3f                       ]|' . chr(10) . '    skb[7][((d >>>21) & 0x0f) | ((d >>> 22) & 0x30)];' . chr(10) . '      ' . chr(10) . '      schedule[j++] = ((t <<  16) | (s & 0x0000ffff)) & 0xffffffff;' . chr(10) . '      s             = ((s >>> 16) | (t & 0xffff0000));' . chr(10) . '      ' . chr(10) . '      s             = (s << 4) | (s >>> 28);' . chr(10) . '      schedule[j++] = s & 0xffffffff;' . chr(10) . '    }' . chr(10) . '    return schedule;' . chr(10) . '  }' . chr(10) . chr(10) . '  private static final int D_ENCRYPT(int L, int R, int S, int E0, int E1, int s[]) {' . chr(10) . '    int t, u, v;' . chr(10) . '    ' . chr(10) . '    v = R ^ (R >>> 16);' . chr(10) . '    u = v & E0;' . chr(10) . '    v = v & E1;' . chr(10) . '    u = (u ^ (u << 16)) ^ R ^ s[S];' . chr(10) . '    t = (v ^ (v << 16)) ^ R ^ s[S + 1];' . chr(10) . '    t = (t >>> 4) | (t << 28);' . chr(10) . '    ' . chr(10) . '    L ^= SPtrans[1][(t       ) & 0x3f] |' . chr(10) . '      SPtrans[3][(t >>>  8) & 0x3f] |' . chr(10) . '      SPtrans[5][(t >>> 16) & 0x3f] |' . chr(10) . '      SPtrans[7][(t >>> 24) & 0x3f] |' . chr(10) . '      SPtrans[0][(u       ) & 0x3f] |' . chr(10) . '      SPtrans[2][(u >>>  8) & 0x3f] |' . chr(10) . '      SPtrans[4][(u >>> 16) & 0x3f] |' . chr(10) . '      SPtrans[6][(u >>> 24) & 0x3f];' . chr(10) . chr(10) . '    return L;' . chr(10) . '  }' . chr(10) . '  ' . chr(10) . '  private static final int [] body(int schedule[], int Eswap0, int Eswap1) {' . chr(10) . '    int left = 0;' . chr(10) . '    int right = 0;' . chr(10) . '    int t     = 0;' . chr(10) . chr(10) . '    for (int j = 0; j < 25; j ++) {' . chr(10) . '      for (int i = 0; i < ITERATIONS * 2; i += 4) {' . chr(10) . '    left  = D_ENCRYPT(left,  right, i,     Eswap0, Eswap1, schedule);' . chr(10) . '    right = D_ENCRYPT(right, left,  i + 2, Eswap0, Eswap1, schedule);' . chr(10) . '      }' . chr(10) . '      t     = left; ' . chr(10) . '      left  = right; ' . chr(10) . '      right = t;' . chr(10) . '    }' . chr(10) . '    ' . chr(10) . '    t = right;' . chr(10) . chr(10) . '    right = (left >>> 1) | (left << 31);' . chr(10) . '    left  = (t    >>> 1) | (t    << 31);' . chr(10) . '    ' . chr(10) . '    left  &= 0xffffffff;' . chr(10) . '    right &= 0xffffffff;' . chr(10) . chr(10) . '    int results[] = new int[2];' . chr(10) . chr(10) . '    PERM_OP(right, left, 1, 0x55555555, results); ' . chr(10) . '    right = results[0]; left = results[1];' . chr(10) . '    ' . chr(10) . '    PERM_OP(left, right, 8, 0x00ff00ff, results); ' . chr(10) . '    left = results[0]; right = results[1];' . chr(10) . chr(10) . '    PERM_OP(right, left, 2, 0x33333333, results); ' . chr(10) . '    right = results[0]; left = results[1];' . chr(10) . '    ' . chr(10) . '    PERM_OP(left, right, 16, 0x0000ffff, results);' . chr(10) . '    left = results[0]; right = results[1];' . chr(10) . '    ' . chr(10) . '    PERM_OP(right, left, 4, 0x0f0f0f0f, results);' . chr(10) . '    right = results[0]; left = results[1];' . chr(10) . '    ' . chr(10) . '    int out[] = new int[2];' . chr(10) . '    ' . chr(10) . '    out[0] = left; ' . chr(10) . '    out[1] = right;' . chr(10) . '    ' . chr(10) . '    return out;' . chr(10) . '  }' . chr(10) . chr(10) . '  public static final String alphabet = "./0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";' . chr(10) . chr(10) . '  public static final String crypt(String salt, String original) {' . chr(10) . '    // wwb -- Should do some sanity checks: salt needs to be 2 chars, in alpha.' . chr(10) . '    while(salt.length() < 2)' . chr(10) . '      salt += "A";' . chr(10) . chr(10) . '    char[] buffer = new char [13];' . chr(10) . chr(10) . '    char charZero = salt.charAt(0);' . chr(10) . '    char charOne  = salt.charAt(1);' . chr(10) . '    ' . chr(10) . '    buffer[0] = charZero;' . chr(10) . '    buffer[1] = charOne;' . chr(10) . chr(10) . '    int Eswap0 = alphabet.indexOf(charZero);' . chr(10) . '    int Eswap1 = alphabet.indexOf(charOne) << 4;' . chr(10) . '    byte key[] = new byte[8];' . chr(10) . '    ' . chr(10) . '    for(int i = 0; i < key.length; i ++)' . chr(10) . '      key[i] = (byte)0;' . chr(10) . '    ' . chr(10) . '    for(int i = 0; i < key.length && i < original.length(); i ++)' . chr(10) . '      key[i] = (byte) (((int) original.charAt(i)) << 1);' . chr(10) . chr(10) . '    int schedule[] = des_set_key(key);' . chr(10) . '    int out[]      = body(schedule, Eswap0, Eswap1);' . chr(10) . '    ' . chr(10) . '    byte b[] = new byte[9];' . chr(10) . '    ' . chr(10) . '    intToFourBytes(out[0], b, 0);' . chr(10) . '    intToFourBytes(out[1], b, 4);' . chr(10) . '    b[8] = 0;' . chr(10) . chr(10) . '    for(int i = 2, y = 0, u = 0x80; i < 13; i ++) {' . chr(10) . '      for(int j = 0, c = 0; j < 6; j ++) {' . chr(10) . '    c <<= 1;' . chr(10) . chr(10) . '    if(((int)b[y] & u) != 0)' . chr(10) . '      c |= 1;' . chr(10) . chr(10) . '    u >>>= 1;' . chr(10) . '    ' . chr(10) . '    if (u == 0) {' . chr(10) . '      y++;' . chr(10) . '      u = 0x80;' . chr(10) . '    }' . chr(10) . '    buffer[i] = alphabet.charAt(c);' . chr(10) . '      }' . chr(10) . '    }' . chr(10) . '    return new String(buffer);' . chr(10) . '  }' . chr(10) . '}' . chr(10) . 'class PlCORE {' . chr(10) . '    public static final PlObject print(int want, PlObject filehandle, PlArray List__) {' . chr(10) . '        // TODO - write to filehandle' . chr(10) . '        for (int i = 0; i < List__.to_int(); i++) {' . chr(10) . '            System.out.print(List__.aget(i).toString());' . chr(10) . '        }' . chr(10) . '        return PlCx.INT1;' . chr(10) . '    }' . chr(10) . '    public static final PlObject say(int want, PlObject filehandle, PlArray List__) {' . chr(10) . '        // TODO - write to filehandle' . chr(10) . '        for (int i = 0; i < List__.to_int(); i++) {' . chr(10) . '            System.out.print(List__.aget(i).toString());' . chr(10) . '        }' . chr(10) . '        System.out.println("");' . chr(10) . '        return PlCx.INT1;' . chr(10) . '    }' . chr(10) . '    public static final PlObject say(String s) {' . chr(10) . '        // say() shortcut' . chr(10) . '        return PlCORE.say(PlCx.VOID, PlCx.STDOUT, new PlArray(new PlString(s)));' . chr(10) . '    }' . chr(10) . '    public static final PlObject exit(int want, PlArray List__) {' . chr(10) . '        int arg = List__.aget(0).to_int();' . chr(10) . '        System.exit(arg);' . chr(10) . '        return PlCx.UNDEF;' . chr(10) . '    }' . chr(10) . '    public static final PlObject warn(int want, PlArray List__) {' . chr(10) . '        for (int i = 0; i < List__.to_int(); i++) {' . chr(10) . '            System.err.print(List__.aget(i).toString());' . chr(10) . '        }' . chr(10) . '        System.err.println("");' . chr(10) . '        return PlCx.INT1;' . chr(10) . '    }' . chr(10) . '    public static final PlObject die(int want, PlArray List__) {' . chr(10) . '        PlObject arg = List__.aget(0);' . chr(10) . '        if (arg.is_undef() || (arg.is_string() && arg.toString() == "")) {' . chr(10) . '            throw new PlDieException(PlCx.DIED);' . chr(10) . '        }' . chr(10) . '        if (List__.to_int() == 1) {' . chr(10) . '            throw new PlDieException(arg);' . chr(10) . '        }' . chr(10) . '        StringBuilder sb = new StringBuilder();' . chr(10) . '        for (int i = 0; i < List__.to_int(); i++) {' . chr(10) . '            String item = List__.aget(i).toString();' . chr(10) . '            sb.append(item);' . chr(10) . '        }' . chr(10) . '        throw new PlDieException(new PlString(sb.toString()));' . chr(10) . '    }' . chr(10) . '    public static final PlObject die(String s) {' . chr(10) . '        // die() shortcut' . chr(10) . '        return PlCORE.die(PlCx.VOID, new PlArray(new PlString(s)));' . chr(10) . '    }' . chr(10) . '    public static final PlString ref(int want, PlArray List__) {' . chr(10) . '        return List__.aget(0).ref();' . chr(10) . '    }' . chr(10) . '    public static final PlObject values(int want, PlObject List__) {' . chr(10) . '        return want == PlCx.LIST ? List__.values() : List__.values().scalar();' . chr(10) . '    }' . chr(10) . '    public static final PlObject keys(int want, PlObject List__) {' . chr(10) . '        return want == PlCx.LIST ? List__.keys() : List__.keys().scalar();' . chr(10) . '    }' . chr(10) . '    public static final PlObject each(int want, PlObject List__) {' . chr(10) . '        return want == PlCx.LIST ? List__.each() : List__.each().aget(0);' . chr(10) . '    }' . chr(10) . '    public static final PlObject chomp(int want, PlObject Object__) {' . chr(10) . '        String sep = PlV.get("main::v_/").toString();' . chr(10) . '        int sepSize = sep.length();' . chr(10) . '        int result = 0;' . chr(10) . '        String toChomp = Object__.toString();' . chr(10) . '        if(toChomp.substring(toChomp.length() - sepSize, toChomp.length()).equals(sep)) {' . chr(10) . '            toChomp = toChomp.substring(0, toChomp.length() - sepSize);' . chr(10) . '            result += sepSize;' . chr(10) . '        }' . chr(10) . chr(10) . '        Object__.set(new PlString(toChomp));' . chr(10) . '            ' . chr(10) . '        return new PlInt(result);' . chr(10) . '    }' . chr(10) . '    public static final PlObject chomp(int want, PlArray List__) {' . chr(10) . '        int result = 0;' . chr(10) . '        for(int i = 0; i < List__.to_int(); ++i) {' . chr(10) . '            PlObject item = List__.aget_lvalue(i);' . chr(10) . '            result += chomp(want, item).to_int();' . chr(10) . '        }' . chr(10) . chr(10) . '        return new PlInt(result);' . chr(10) . '    }' . chr(10) . '    public static final PlString chop(int want, PlObject Object__) {' . chr(10) . '        String str = Object__.toString();' . chr(10) . '        String returnValue = "";' . chr(10) . '        if (str.length() > 0) {' . chr(10) . '            returnValue = str.substring(str.length() -1);' . chr(10) . '            Object__.set(new PlString(str.substring(0, str.length()-1)));' . chr(10) . '        }' . chr(10) . chr(10) . '        return new PlString(returnValue);' . chr(10) . '    }' . chr(10) . '    public static final PlObject chop(int want, PlArray List__) {' . chr(10) . '        PlString result = PlCx.EMPTY;' . chr(10) . '        for(int i = 0; i < List__.to_int(); ++i) {' . chr(10) . '            PlObject item = List__.aget_lvalue(i);' . chr(10) . '            result = chop(want, item);' . chr(10) . '        }' . chr(10) . chr(10) . '        return result;' . chr(10) . '    }' . chr(10) . '    public static final PlObject scalar(int want, PlArray List__) {' . chr(10) . '        if (List__.to_int() == 0) {' . chr(10) . '            return PlCx.UNDEF;' . chr(10) . '        }' . chr(10) . '        return List__.aget(-1).scalar();' . chr(10) . '    }' . chr(10) . '    public static final PlObject hex(int want, PlObject List__) {' . chr(10) . '        String s = List__.toString();' . chr(10) . '        if(s.startsWith("0x") || s.startsWith("0X")) {' . chr(10) . '            s = s.substring(2);' . chr(10) . '        }' . chr(10) . '        try {' . chr(10) . '            return new PlInt(Long.parseLong(s, 16));' . chr(10) . '        } catch (java.lang.NumberFormatException e) {' . chr(10) . '            return new PlInt(0);' . chr(10) . '        }' . chr(10) . '    }' . chr(10) . '    public static final PlObject oct(int want, PlObject List__) {' . chr(10) . chr(9) . '    String valueTobeCoverted = List__.toString();' . chr(10) . chr(9) . '    try {' . chr(10) . chr(9) . '    ' . chr(9) . 'if (valueTobeCoverted.startsWith("0x") || valueTobeCoverted.startsWith("0X")) {' . chr(10) . chr(9) . '    ' . chr(9) . chr(9) . 'return new PlInt(Long.parseLong(valueTobeCoverted.substring(2), 16));' . chr(10) . chr(9) . '    ' . chr(9) . '} else if (valueTobeCoverted.startsWith("0b") || valueTobeCoverted.startsWith("0B")) {' . chr(10) . chr(9) . '    ' . chr(9) . chr(9) . 'return new PlInt(Long.parseLong(valueTobeCoverted.substring(2), 2));' . chr(10) . chr(9) . '    ' . chr(9) . '} else {' . chr(10) . chr(9) . '    ' . chr(9) . chr(9) . 'return new PlInt(Long.parseLong(valueTobeCoverted, 8));' . chr(10) . chr(9) . '    ' . chr(9) . '}' . chr(10) . chr(9) . '    } catch (NumberFormatException n) {' . chr(10) . chr(9) . '    ' . chr(9) . chr(10) . chr(9) . '    } catch (Exception e) {' . chr(10) . chr(9) . '    ' . chr(9) . '// result = e.getMessage();' . chr(10) . chr(9) . '    }' . chr(10) . chr(9) . '    return new PlInt(0);' . chr(10) . '    }' . chr(10) . '    public static final PlObject crypt(int want, PlArray List__) {' . chr(10) . '        if(List__.to_int() < 2) {' . chr(10) . '            die("Not enough arguments for crypt");' . chr(10) . '        }' . chr(10) . '        if(List__.to_int() > 2) {' . chr(10) . '            die("Too many arguments for crypt");' . chr(10) . '        }' . chr(10) . '        String plainText = List__.shift().toString();' . chr(10) . '        String salt = List__.shift().toString();' . chr(10) . chr(10) . '        while(salt.length() < 2) {' . chr(10) . '            salt = salt.concat(".");' . chr(10) . '        }' . chr(10) . '        ' . chr(10) . '        return new PlString(PlCrypt.crypt(salt, plainText));' . chr(10) . '    }' . chr(10) . '    public static final PlObject join(int want, PlArray List__) {' . chr(10) . '        String s = List__.shift().toString();' . chr(10) . '        StringBuilder sb = new StringBuilder();' . chr(10) . '        boolean first = true;' . chr(10) . '        for (int i = 0; i < List__.to_int(); i++) {' . chr(10) . '            String item = List__.aget(i).toString();' . chr(10) . '            if (first)' . chr(10) . '                first = false;' . chr(10) . '            else' . chr(10) . '                sb.append(s);' . chr(10) . '            sb.append(item);' . chr(10) . '        }' . chr(10) . '        return new PlString(sb.toString());' . chr(10) . '    }' . chr(10) . '    public static final PlObject reverse(int want, PlArray List__) {' . chr(10) . '        if (want == PlCx.LIST) {' . chr(10) . '            PlArray ret = new PlArray(List__);' . chr(10) . '            Collections.reverse(ret.a);' . chr(10) . '            return ret;' . chr(10) . '        }' . chr(10) . '        StringBuilder sb = new StringBuilder();' . chr(10) . '        for (int i = 0; i < List__.to_int(); i++) {' . chr(10) . '            sb.append( List__.aget(i).toString() );' . chr(10) . '        }' . chr(10) . '        return new PlString(sb.reverse().toString());' . chr(10) . '    }' . chr(10) . '    public static final PlObject time(int want, PlArray List__) {' . chr(10) . '        return new PlInt( (long)Math.floor(System.currentTimeMillis() * 0.001 + 0.5));' . chr(10) . '    }' . chr(10) . '    public static final PlObject sleep(int want, PlArray List__) {' . chr(10) . '        long s = (new Double(List__.shift().to_double() * 1000)).longValue();' . chr(10) . '        try {' . chr(10) . '            TimeUnit.MILLISECONDS.sleep(s);' . chr(10) . '        } catch (InterruptedException e) {' . chr(10) . '            //Handle exception' . chr(10) . '        }' . chr(10) . '        return new PlDouble(s / 1000.0);' . chr(10) . '    }' . chr(10) . '    public static final PlObject system(int want, PlArray List__) {' . chr(10) . '        // TODO - see perldoc -f system' . chr(10) . '        try {' . chr(10) . '            String[] args = new String[List__.to_int()];' . chr(10) . '            int i = 0;' . chr(10) . '            for (PlObject s : List__.a) {' . chr(10) . '                args[i++] = s.toString();' . chr(10) . '            }' . chr(10) . '            String s = null;' . chr(10) . '            Process p = Runtime.getRuntime().exec(args);' . chr(10) . '            // BufferedReader stdInput = new BufferedReader(new InputStreamReader(p.getInputStream()));' . chr(10) . '            // BufferedReader stdError = new BufferedReader(new InputStreamReader(p.getErrorStream()));' . chr(10) . '            // System.out.println("STDOUT' . chr(92) . 'n");' . chr(10) . '            // while ((s = stdInput.readLine()) != null) {' . chr(10) . '            //     System.out.println("  " + s);' . chr(10) . '            // }' . chr(10) . '            // System.out.println("STDERR' . chr(92) . 'n");' . chr(10) . '            // while ((s = stdError.readLine()) != null) {' . chr(10) . '            //     System.out.println("  " + s);' . chr(10) . '            // }' . chr(10) . '            return PlCx.INT0;' . chr(10) . '        }' . chr(10) . '        catch (IOException e) {' . chr(10) . '            // System.out.println("IOexception: ");' . chr(10) . '            // e.printStackTrace();' . chr(10) . '            return PlCx.MIN1;' . chr(10) . '        }' . chr(10) . '    }' . chr(10) . '    public static final PlObject qx(int want, PlArray List__) {' . chr(10) . '        // TODO - see perldoc -f qx' . chr(10) . '        try {' . chr(10) . '            String[] args = new String[List__.to_int()];' . chr(10) . '            int i = 0;' . chr(10) . '            for (PlObject s : List__.a) {' . chr(10) . '                args[i++] = s.toString();' . chr(10) . '            }' . chr(10) . '            PlArray res = new PlArray();' . chr(10) . '            String s = null;' . chr(10) . '            Process p = Runtime.getRuntime().exec(args);' . chr(10) . '            BufferedReader stdInput = new BufferedReader(new InputStreamReader(p.getInputStream()));' . chr(10) . '            System.out.println("STDOUT' . chr(92) . 'n");' . chr(10) . '            while ((s = stdInput.readLine()) != null) {' . chr(10) . '                // System.out.println("  " + s);' . chr(10) . '                res.push(s + "' . chr(92) . 'n");' . chr(10) . '            }' . chr(10) . '            // BufferedReader stdError = new BufferedReader(new InputStreamReader(p.getErrorStream()));' . chr(10) . '            // System.out.println("STDERR' . chr(92) . 'n");' . chr(10) . '            // while ((s = stdError.readLine()) != null) {' . chr(10) . '            //     System.out.println("  " + s);' . chr(10) . '            // }' . chr(10) . '            if (want == PlCx.LIST) {' . chr(10) . '                return res;' . chr(10) . '            }' . chr(10) . '            res.unshift(PlCx.EMPTY);' . chr(10) . '            return join(want, res);' . chr(10) . '        }' . chr(10) . '        catch (IOException e) {' . chr(10) . '            // System.out.println("IOexception: ");' . chr(10) . '            // e.printStackTrace();' . chr(10) . '            return PlCx.UNDEF;' . chr(10) . '        }' . chr(10) . '    }' . chr(10) . '}' . chr(10) . 'class PerlCompare implements Comparator<PlObject> {' . chr(10) . '    public PlClosure sorter;' . chr(10) . '    public PlLvalue v_a;' . chr(10) . '    public PlLvalue v_b;' . chr(10) . '    public PerlCompare (PlClosure sorter, PlLvalue a, PlLvalue b) {' . chr(10) . '        this.sorter = sorter;' . chr(10) . '        this.v_a = a;' . chr(10) . '        this.v_b = b;' . chr(10) . '    }' . chr(10) . '    public int compare (PlObject a, PlObject b) {' . chr(10) . '        v_a.set(a);' . chr(10) . '        v_b.set(b);' . chr(10) . '        return this.sorter.apply( PlCx.SCALAR, new PlArray() ).to_int();' . chr(10) . '    }' . chr(10) . '}' . chr(10) . 'class PerlOp {' . chr(10) . '    // PerlOp implements operators: && ||' . chr(10) . '    //      and auxiliary functions' . chr(10) . '    //' . chr(10) . '    // note: ' . chr(39) . '+' . chr(39) . ' add() and ' . chr(39) . '-' . chr(39) . ' sub() are PlObject methods, not implemented here.' . chr(10) . '    //' . chr(10) . '    // TODO - see Perlito5/Javascript2/Runtime.pm for more operator implementations' . chr(10) . '    // TODO - ' . chr(39) . 'boolean_stack' . chr(39) . ' should be reset when an exception happens' . chr(10) . chr(10) . '    private static ArrayList<PlObject> boolean_stack = new ArrayList<PlObject>();' . chr(10) . '    private static PlArray local_stack = new PlArray();' . chr(10) . '    private static Random random = new Random();' . chr(10) . chr(10) . '    // objects' . chr(10) . '    // coderef methods can be called on ANY invocant' . chr(10) . '    //  $m = sub {...};' . chr(10) . '    //  $a->$m' . chr(10) . '    public static final PlObject call( PlObject invocant, PlObject method, PlArray args, int context ) {' . chr(10) . '        if ( method.is_coderef() ) {' . chr(10) . '            args.unshift(invocant);' . chr(10) . '            return method.apply(context, args);' . chr(10) . '        }' . chr(10) . '        else if ( method.is_lvalue() ) {' . chr(10) . '            return call( invocant, method.get(), args, context );' . chr(10) . '        }' . chr(10) . '        else {' . chr(10) . '            return call( invocant, method.toString(), args, context );' . chr(10) . '        }' . chr(10) . '    }' . chr(10) . '    public static final PlObject call( String invocant, PlObject method, PlArray args, int context ) {' . chr(10) . '        if ( method.is_coderef() ) {' . chr(10) . '            args.unshift( new PlString(invocant) );' . chr(10) . '            return method.apply(context, args);' . chr(10) . '        }' . chr(10) . '        else if ( method.is_lvalue() ) {' . chr(10) . '            return call( invocant, method.get(), args, context );' . chr(10) . '        }' . chr(10) . '        else {' . chr(10) . '            return call( invocant, method.toString(), args, context );' . chr(10) . '        }' . chr(10) . '    }' . chr(10) . '    // Intermediate calls, which have to be dispatched properly' . chr(10) . '    public static final PlObject call( PlObject invocant, String method, PlArray args, int context ) {' . chr(10) . '        if ( invocant.is_undef() ) {' . chr(10) . '            PlCORE.die( "Can' . chr(39) . 't call method ' . chr(92) . '"" + method' . chr(10) . '                + "' . chr(92) . '" on an undefined value" );' . chr(10) . '            return PlCx.UNDEF;' . chr(10) . '        }' . chr(10) . chr(10) . '        if ( invocant.is_lvalue() ) {' . chr(10) . '            invocant = invocant.get();' . chr(10) . '        }' . chr(10) . chr(10) . '        PlClass pClass = invocant.blessed();' . chr(10) . chr(10) . '        if ( pClass == null ) {' . chr(10) . '            PlCORE.die( "Can' . chr(39) . 't call method ' . chr(92) . '"" + method' . chr(10) . '                + "' . chr(92) . '" on unblessed reference" );' . chr(10) . '            return PlCx.UNDEF;' . chr(10) . '        }' . chr(10) . '        else {' . chr(10) . '            return call( pClass.className().toString(), method, args, context );' . chr(10) . '        }' . chr(10) . '    }' . chr(10) . '    public static final PlObject call( String invocant, String method, PlArray args, int context ) {' . chr(10) . '        if ( invocant.equals("") ) {' . chr(10) . '            PlCORE.die( "Can' . chr(39) . 't call method ' . chr(92) . '"" + method' . chr(10) . '                + "' . chr(92) . '" on an undefined value" );' . chr(10) . '            return PlCx.UNDEF;' . chr(10) . '        }' . chr(10) . chr(10) . '        PlObject methodCode = PlV.get(invocant + "::" + method);' . chr(10) . chr(10) . '        if (methodCode.is_undef()) {' . chr(10) . '            PlCORE.die( "Can' . chr(39) . 't locate object method ' . chr(92) . '"" + method' . chr(10) . '                + "' . chr(92) . '" via package ' . chr(92) . '"" + invocant' . chr(10) . '                + "' . chr(92) . '" (perhaps you forgot to load ' . chr(92) . '"" + invocant + "' . chr(92) . '"?" );' . chr(10) . '            return PlCx.UNDEF;' . chr(10) . '        }' . chr(10) . chr(10) . '        args.unshift( new PlString(invocant) );' . chr(10) . '        return methodCode.apply(context, args);' . chr(10) . '    }' . chr(10) . chr(10) . '    // local()' . chr(10) . '    public static final PlObject push_local(PlHash container, String index) {' . chr(10) . '        local_stack.a.add(container);' . chr(10) . '        local_stack.a.add(new PlString(index));' . chr(10) . '        PlLvalue empty = new PlLvalue();' . chr(10) . '        local_stack.a.add(container.hget_lvalue(index));' . chr(10) . '        container.h.put(index, empty);' . chr(10) . '        return empty;' . chr(10) . '    }' . chr(10) . '    public static final PlObject push_local(PlArray container, int index) {' . chr(10) . '        local_stack.a.add(container);' . chr(10) . '        local_stack.a.add(new PlInt(index));' . chr(10) . '        PlLvalue empty = new PlLvalue();' . chr(10) . '        local_stack.a.add(container.aget_lvalue(index));' . chr(10) . '        container.aset(index, empty);' . chr(10) . '        return empty;' . chr(10) . '    }' . chr(10) . '    public static final int local_length() {' . chr(10) . '        return local_stack.to_int();' . chr(10) . '    }' . chr(10) . '    public static final PlObject cleanup_local(int pos, PlObject ret) {' . chr(10) . '        while (local_stack.to_int() > pos) {' . chr(10) . '            PlLvalue lvalue    = (PlLvalue)local_stack.pop();' . chr(10) . '            PlObject index     = local_stack.pop();' . chr(10) . '            PlObject container = local_stack.pop();' . chr(10) . '            if (container.is_array()) {' . chr(10) . '                ((PlArray)container).a.set(index.to_int(), lvalue);' . chr(10) . '            }' . chr(10) . '            else {' . chr(10) . '                ((PlHash)container).h.put(index.toString(), lvalue);' . chr(10) . '            }' . chr(10) . '        }' . chr(10) . '        return ret;' . chr(10) . '    }' . chr(10) . chr(10) . '    // context()' . chr(10) . '    //      - handles run-time scalar/list/void context in expression results' . chr(10) . '    public static final PlObject context(int want, PlObject arg) {' . chr(10) . '        if (want == PlCx.LIST) {' . chr(10) . '            return arg;' . chr(10) . '        }' . chr(10) . '        return arg.scalar();' . chr(10) . '    }' . chr(10) . '    public static final PlObject context(int want) {' . chr(10) . '        if (want == PlCx.LIST) {' . chr(10) . '            return new PlArray();' . chr(10) . '        }' . chr(10) . '        return PlCx.UNDEF;' . chr(10) . '    }' . chr(10) . '    public static final PlObject context(int want, PlObject... args) {' . chr(10) . '        if (want == PlCx.LIST) {' . chr(10) . '            return new PlArray(args);' . chr(10) . '        }' . chr(10) . '        return args[args.length-1].scalar();' . chr(10) . '    }' . chr(10) . chr(10) . '    // statement()' . chr(10) . '    //      - workaround for "Error: not a statement"' . chr(10) . '    //      - this is the compile-time version of context(null, arg)' . chr(10) . '    public static final void statement(PlObject arg) { }' . chr(10) . '    public static final void statement() { }' . chr(10) . chr(10) . '    // control-flow exceptions' . chr(10) . '    public static final PlObject next() {' . chr(10) . '        throw PlCx.NEXT;' . chr(10) . '    }' . chr(10) . '    public static final PlObject next(int label_id) {' . chr(10) . '        throw new PlNextException(label_id);' . chr(10) . '    }' . chr(10) . '    public static final PlObject last() {' . chr(10) . '        throw PlCx.LAST;' . chr(10) . '    }' . chr(10) . '    public static final PlObject last(int label_id) {' . chr(10) . '        throw new PlLastException(label_id);' . chr(10) . '    }' . chr(10) . '    public static final PlObject redo(int label_id) {' . chr(10) . '        throw new PlRedoException(label_id);' . chr(10) . '    }' . chr(10) . '    public static final PlObject ret(PlObject ret) {' . chr(10) . '        throw new PlReturnException(ret);' . chr(10) . '    }' . chr(10) . chr(10) . '    public static final PlObject caller(int ctx, PlObject s) {' . chr(10) . '        int item = s.to_int();' . chr(10) . '        PlCORE.die("caller() not implemented");' . chr(10) . '        return null;' . chr(10) . '    }' . chr(10) . chr(10) . '    public static final PlObject srand() {' . chr(10) . '        random = new Random();' . chr(10) . '        return PlCx.UNDEF;' . chr(10) . '    }' . chr(10) . '    public static final PlObject srand(int s) {' . chr(10) . '        random = new Random(s);' . chr(10) . '        return new PlInt(s);' . chr(10) . '    }' . chr(10) . chr(10) . '    public static final PlObject rand(double s) {' . chr(10) . '        if (s == 0.0) {' . chr(10) . '            s = 1.0;' . chr(10) . '        }' . chr(10) . '        return new PlDouble(s * random.nextDouble());' . chr(10) . '    }' . chr(10) . chr(10) . '    public static final long[] range(PlObject _start, PlObject _end, int ctx, String var, int ignore) {' . chr(10) . '        if (ctx == PlCx.LIST) {' . chr(10) . '            long start = _start.to_long(),' . chr(10) . '                 end   = _end.to_long();' . chr(10) . '            int size = Math.max(0, (int)(end - start + 1));' . chr(10) . '            long[] ret = new long[size];' . chr(10) . '            for (int i = 0; i < size; ++i) {' . chr(10) . '                ret[i] = start + i;' . chr(10) . '            }' . chr(10) . '            return ret;' . chr(10) . '        }' . chr(10) . '        PlCORE.die("Range not implemented for context " + ctx);' . chr(10) . '        return null;' . chr(10) . '    }' . chr(10) . chr(10) . '    public static final PlObject smartmatch_scalar(PlObject arg0, PlObject arg1) {' . chr(10) . '        if (arg1.is_undef()) {' . chr(10) . '            return arg0.is_undef() ? PlCx.TRUE : PlCx.FALSE;' . chr(10) . '        }' . chr(10) . '        if (arg1.is_string()) {' . chr(10) . '            return arg0.str_eq(arg1);' . chr(10) . '        }' . chr(10) . '        if (arg1.is_num() || arg1.is_int()) {' . chr(10) . '            return arg0.num_eq(arg1);' . chr(10) . '        }' . chr(10) . '        return PlCORE.die(PlCx.VOID, new PlArray(new PlString("Not implemented: smartmatch operator with argument type ' . chr(39) . '"), PlCORE.ref(PlCx.SCALAR, new PlArray(arg1)), new PlString("' . chr(39) . '")));' . chr(10) . '    }' . chr(10) . chr(10) . '    // and1(x) ? y : and3()' . chr(10) . '    public static final boolean and1(PlObject arg1) {' . chr(10) . '        if (arg1.to_bool()) {' . chr(10) . '            return true;' . chr(10) . '        }' . chr(10) . '        else {' . chr(10) . '            boolean_stack.add(0, arg1);' . chr(10) . '            return false;' . chr(10) . '        }' . chr(10) . '    }' . chr(10) . '    public static final PlObject and3() {' . chr(10) . '        return boolean_stack.remove(0);' . chr(10) . '    }' . chr(10) . chr(10) . '    // or1(x) ? or2() : y' . chr(10) . '    public static final boolean or1(PlObject arg1) {' . chr(10) . '        if (arg1.to_bool()) {' . chr(10) . '            boolean_stack.add(0, arg1);' . chr(10) . '            return true;' . chr(10) . '        }' . chr(10) . '        else {' . chr(10) . '            return false;' . chr(10) . '        }' . chr(10) . '    }' . chr(10) . '    public static final PlObject or2() {' . chr(10) . '        return boolean_stack.remove(0);' . chr(10) . '    }' . chr(10) . chr(10) . '    // defined_or1(x) ? defined_or2() : y' . chr(10) . '    public static final boolean defined_or1(PlObject arg1) {' . chr(10) . '        if (!arg1.is_undef()) {' . chr(10) . '            boolean_stack.add(0, arg1);' . chr(10) . '            return true;' . chr(10) . '        }' . chr(10) . '        else {' . chr(10) . '            return false;' . chr(10) . '        }' . chr(10) . '    }' . chr(10) . '    public static final PlObject defined_or2() {' . chr(10) . '        return boolean_stack.remove(0);' . chr(10) . '    }' . chr(10) . chr(10) . '    public static final PlInt ord(PlString s) {' . chr(10) . '        String item = s.toString();' . chr(10) . '        return new PlInt(item.length() > 0 ? Character.codePointAt(item, 0) : 0);' . chr(10) . '    }' . chr(10) . chr(10) . '    public static final PlString string_replicate(PlObject s, PlObject c) {' . chr(10) . '        int count = c.to_int();' . chr(10) . '        if ( count < 1 ) {' . chr(10) . '            return new PlString("");' . chr(10) . '        }' . chr(10) . '        else {' . chr(10) . '            String raw_s = s.toString();' . chr(10) . '            StringBuilder sb = new StringBuilder();' . chr(10) . '            for (int i = 0; i < count; i++) {' . chr(10) . '                sb.append(raw_s);' . chr(10) . '            }' . chr(10) . '            return new PlString(sb.toString());' . chr(10) . '        }' . chr(10) . '    }' . chr(10) . '    public static final PlObject list_replicate(PlArray o, PlObject c, int wantarray) {' . chr(10) . '        int count = c.to_int();' . chr(10) . '        PlArray a = new PlArray();' . chr(10) . '        if (count > 0) {' . chr(10) . '            for (int i = 0; i < count; i++) {' . chr(10) . '                a.push( o );' . chr(10) . '            }' . chr(10) . '        }' . chr(10) . '        return (wantarray == PlCx.LIST ) ? a : a.length_of_array();' . chr(10) . '    }' . chr(10) . '    public static final PlObject grep(PlClosure c, PlArray a, int wantarray) {' . chr(10) . '        PlArray ret = new PlArray();' . chr(10) . '        int size = a.to_int();' . chr(10) . '        PlLvalue v__ref = (PlLvalue)PlV.get("main::v__");' . chr(10) . '        PlObject v__val = v__ref.get();' . chr(10) . '        for (int i = 0; i < size; i++) {' . chr(10) . '            boolean result;' . chr(10) . '            PlObject temp = a.aget(i);' . chr(10) . '            v__ref.set(temp);' . chr(10) . '            result = c.apply(PlCx.SCALAR, new PlArray()).to_bool();' . chr(10) . '            if (result) {' . chr(10) . '                ret.push(temp);' . chr(10) . '            }' . chr(10) . '        }' . chr(10) . '        v__ref.set(v__val);' . chr(10) . '        return (wantarray == PlCx.LIST ) ? ret : ret.length_of_array();' . chr(10) . '    }' . chr(10) . '    public static final PlObject map(PlClosure c, PlArray a, int wantarray) {' . chr(10) . '        PlArray ret = new PlArray();' . chr(10) . '        int size = a.to_int();' . chr(10) . '        PlLvalue v__ref = (PlLvalue)PlV.get("main::v__");' . chr(10) . '        PlObject v__val = v__ref.get();' . chr(10) . '        for (int i = 0; i < size; i++) {' . chr(10) . '            v__ref.set(a.aget(i));' . chr(10) . '            ret.push(c.apply(PlCx.LIST, new PlArray()));' . chr(10) . '        }' . chr(10) . '        v__ref.set(v__val);' . chr(10) . '        return (wantarray == PlCx.LIST ) ? ret : ret.length_of_array();' . chr(10) . '    }' . chr(10) . '    public static final PlObject sort(PlClosure c, PlArray a, int wantarray, String pckg) {' . chr(10) . '        PlArray ret = new PlArray(a);' . chr(10) . '        int size = a.to_int();' . chr(10) . '        PlLvalue v_a_ref = (PlLvalue)PlV.get(pckg + "::v_a");' . chr(10) . '        PlLvalue v_b_ref = (PlLvalue)PlV.get(pckg + "::v_b");' . chr(10) . '        PerlCompare comp = new PerlCompare(c, v_a_ref, v_b_ref);' . chr(10) . '        PlObject v_a_val = v_a_ref.get();' . chr(10) . '        PlObject v_b_val = v_b_ref.get();' . chr(10) . '        Collections.sort(ret.a, comp);' . chr(10) . '        v_a_ref.set(v_a_val);' . chr(10) . '        v_b_ref.set(v_b_val);' . chr(10) . '        return (wantarray == PlCx.LIST ) ? ret : ret.length_of_array();' . chr(10) . '    }' . chr(10) . chr(10) . '    private static String double_escape(String s) {' . chr(10) . '        // add double escapes: ' . chr(92) . chr(92) . 'w instead of ' . chr(92) . 'w' . chr(10) . '        return s.replace("' . chr(92) . chr(92) . '", "' . chr(92) . chr(92) . chr(92) . chr(92) . '");' . chr(10) . '    }' . chr(10) . chr(10) . '    private static int _character_class_escape(int offset, String s, StringBuilder sb, int length) {' . chr(10) . '        // [ ... ]' . chr(10) . '        int offset3 = offset;' . chr(10) . '        for ( ; offset3 < length; ) {' . chr(10) . '            final int c3 = s.codePointAt(offset3);' . chr(10) . '            switch (c3) {' . chr(10) . '                case ' . chr(39) . ']' . chr(39) . ':' . chr(10) . '                    sb.append(Character.toChars(c3));' . chr(10) . '                    return offset3;' . chr(10) . '                case ' . chr(39) . ' ' . chr(39) . ':' . chr(10) . '                    sb.append("' . chr(92) . chr(92) . ' ");   // make this space a "token", even inside /x' . chr(10) . '                    break;' . chr(10) . '                default:' . chr(10) . '                    sb.append(Character.toChars(c3));' . chr(10) . '                    break;' . chr(10) . '            }' . chr(10) . '            offset3++;' . chr(10) . '        }' . chr(10) . '        return offset3;' . chr(10) . '    }' . chr(10) . chr(10) . '    public static String character_class_escape(String s) {' . chr(10) . '        // escape spaces in character classes' . chr(10) . '        final int length = s.length();' . chr(10) . '        StringBuilder sb = new StringBuilder();' . chr(10) . '        for (int offset = 0; offset < length; ) {' . chr(10) . '            final int c = s.codePointAt(offset);' . chr(10) . '            switch (c) {' . chr(10) . '                case ' . chr(39) . chr(92) . chr(92) . chr(39) . ':  // escape - ' . chr(92) . '[' . chr(10) . '                            sb.append(Character.toChars(c));' . chr(10) . '                            if (offset < length) {' . chr(10) . '                                offset++;' . chr(10) . '                                int c2 = s.codePointAt(offset);' . chr(10) . '                                sb.append(Character.toChars(c2));' . chr(10) . '                            }' . chr(10) . '                            break;' . chr(10) . '                case ' . chr(39) . '[' . chr(39) . ':   // character class' . chr(10) . '                            sb.append(Character.toChars(c));' . chr(10) . '                            offset++;' . chr(10) . '                            offset = _character_class_escape(offset, s, sb, length);' . chr(10) . '                            break;' . chr(10) . '                default:    // normal char' . chr(10) . '                            sb.append(Character.toChars(c));' . chr(10) . '                            break;' . chr(10) . '            }' . chr(10) . '            offset++;' . chr(10) . '        }' . chr(10) . '        return sb.toString();' . chr(10) . '    }' . chr(10) . chr(10) . '    public static final PlObject match(PlObject s, PlRegex pat, int want) {' . chr(10) . '        if (want != PlCx.LIST) {' . chr(10) . '            return pat.p.matcher(s.toString()).find() ? PlCx.TRUE : PlCx.FALSE;' . chr(10) . '        }' . chr(10) . '        PlArray ret = new PlArray();' . chr(10) . '        Matcher matcher = pat.p.matcher(s.toString());' . chr(10) . '        while (matcher.find()) {' . chr(10) . '            for (int i = 1; i <= matcher.groupCount(); i++) {' . chr(10) . '                ret.push(matcher.group(i));' . chr(10) . '            }' . chr(10) . '        }' . chr(10) . '        return ret;' . chr(10) . '    }' . chr(10) . '    public static final PlObject match(PlObject s, PlLvalue pat, int want) {' . chr(10) . '        return match(s, pat.get(), want);' . chr(10) . '    }' . chr(10) . '    public static final PlObject match(PlObject s, PlObject pat, int want) {' . chr(10) . '        // TODO - cache the compiled pattern' . chr(10) . '        return match(s, new PlRegex(pat, 0), want);' . chr(10) . '    }' . chr(10) . chr(10) . '    public static final PlObject replace(PlLvalue s, PlRegex pat, PlObject rep, int want) {' . chr(10) . '        if (want != PlCx.LIST) {' . chr(10) . '            return s.set(new PlString(pat.p.matcher(s.toString()).replaceAll(double_escape(rep.toString()))));' . chr(10) . '        }' . chr(10) . '        PlCORE.die("not implemented string replace in list context");' . chr(10) . '        return s;' . chr(10) . '    }' . chr(10) . '    public static final PlObject replace(PlObject s, PlObject pat, PlObject rep, int want) {' . chr(10) . '        // TODO - cache the compiled pattern' . chr(10) . '        return replace(s, new PlRegex(pat, 0), rep, want);' . chr(10) . '    }' . chr(10) . chr(10) . '}' . chr(10) . 'class PlV {' . chr(10) . '    // PlV implements namespaces and global variables' . chr(10) . '    //' . chr(10) . '    // TODO - import CORE subroutines in new namespaces, if needed' . chr(10) . '    // TODO - cache lookups in lexical variables (see PlClosure implementation)' . chr(10) . chr(10) . '    public static final PlHash var = new PlHash();' . chr(10) . chr(10) . '    public static final PlLvalue get(String name) {' . chr(10) . '        return (PlLvalue)var.hget_lvalue(name);' . chr(10) . '    }' . chr(10) . '    public static final PlLvalue get_local(String name) {' . chr(10) . '        return (PlLvalue)var.hget_lvalue_local(name);' . chr(10) . '    }' . chr(10) . '    public static final PlObject set(String name, PlObject v) {' . chr(10) . '        return var.hset(name, v);' . chr(10) . '    }' . chr(10) . '    public static final PlObject set_local(String name, PlObject v) {' . chr(10) . '        return var.hget_lvalue_local(name).set(v);' . chr(10) . '    }' . chr(10) . chr(10) . '    public static final PlHash hash_get(String name) {' . chr(10) . '        return (PlHash)var.hget_hashref(name).get();' . chr(10) . '    }' . chr(10) . '    public static final PlHash hash_get_local(String name) {' . chr(10) . '        return (PlHash)var.hget_lvalue_local(name).get_hashref().get();' . chr(10) . '    }' . chr(10) . '    public static final PlObject hash_set(String name, PlObject v) {' . chr(10) . '        return var.hget_hashref(name).hash_deref_set(v);' . chr(10) . '    }' . chr(10) . '    public static final PlObject hash_set_local(String name, PlObject v) {' . chr(10) . '        return var.hget_lvalue_local(name).get_hashref().hash_deref_set(v);' . chr(10) . '    }' . chr(10) . chr(10) . '    public static final PlArray array_get(String name) {' . chr(10) . '        return (PlArray)var.hget_arrayref(name).get();' . chr(10) . '    }' . chr(10) . '    public static final PlArray array_get_local(String name) {' . chr(10) . '        return (PlArray)var.hget_lvalue_local(name).get_arrayref().get();' . chr(10) . '    }' . chr(10) . '    public static final PlObject array_set(String name, PlObject v) {' . chr(10) . '        return var.hget_arrayref(name).array_deref_set(v);' . chr(10) . '    }' . chr(10) . '    public static final PlObject array_set_local(String name, PlObject v) {' . chr(10) . '        return var.hget_lvalue_local(name).get_arrayref().array_deref_set(v);' . chr(10) . '    }' . chr(10) . '}' . chr(10) . 'class PlEnv {' . chr(10) . '    public static final void init(String[] args) {' . chr(10) . '        PlV.array_set(PlCx.ARGV, new PlArray(args));               // args is String[]' . chr(10) . '        PlV.hash_set(PlCx.ENV,   new PlArray(System.getenv()));    // env  is Map<String, String>' . chr(10) . '        PlV.set("main::v_" + (char)34, new PlString(" "));         // $" = " "' . chr(10) . '        PlV.set("main::v_/", new PlString("' . chr(92) . 'n"));                  // $/ = "' . chr(92) . 'n"' . chr(10) . '    }' . chr(10) . '}' . chr(10) . 'class PlObject {' . chr(10) . '    public static final PlString REF = new PlString("");' . chr(10) . chr(10) . '    public PlObject() {' . chr(10) . '    }' . chr(10) . join('', (map {
                    my $class = $java_classes{$_};
                    my $java_class_name = $class->{'java_type'};
                    my $perl_to_java = $class->{'perl_to_java'};
                    $class->{'import'} || $class->{'extends'} || $class->{'implements'} ? '    public ' . $java_class_name . ' ' . $perl_to_java . '() {' . chr(10) . '        PlCORE.die("error .' . $perl_to_java . '!");' . chr(10) . '        return null;' . chr(10) . '    }' . chr(10) : ()
                } sort {
                    $a cmp $b
                } keys(%java_classes))) . '    // public String toString() {' . chr(10) . '    //     return this.toString();' . chr(10) . '    // }' . chr(10) . '    public int to_int() {' . chr(10) . '        long v = this.to_long();' . chr(10) . '        if (v > Integer.MAX_VALUE || v < Integer.MIN_VALUE) {' . chr(10) . '            PlCORE.die("numeric overflow converting to int");' . chr(10) . '        }' . chr(10) . '        return (int)v;' . chr(10) . '    }' . chr(10) . '    public byte to_byte() {' . chr(10) . '        long v = this.to_long();' . chr(10) . '        if (v > Byte.MAX_VALUE || v < Byte.MIN_VALUE) {' . chr(10) . '            PlCORE.die("numeric overflow converting to byte");' . chr(10) . '        }' . chr(10) . '        return (byte)v;' . chr(10) . '    }' . chr(10) . '    public short to_short() {' . chr(10) . '        long v = this.to_long();' . chr(10) . '        if (v > Short.MAX_VALUE || v < Short.MIN_VALUE) {' . chr(10) . '            PlCORE.die("numeric overflow converting to short");' . chr(10) . '        }' . chr(10) . '        return (short)v;' . chr(10) . '    }' . chr(10) . '    public float to_float() {' . chr(10) . '        double v = this.to_double();' . chr(10) . '        return (float)v;' . chr(10) . '    }' . chr(10) . '    public long to_long() {' . chr(10) . '        PlCORE.die("error .to_long!");' . chr(10) . '        return 0;' . chr(10) . '    }' . chr(10) . '    public PlObject end_of_array_index() {' . chr(10) . '        return PlCORE.die("Not an ARRAY reference");' . chr(10) . '    }' . chr(10) . '    public double to_double() {' . chr(10) . '        PlCORE.die("error .to_double!");' . chr(10) . '        return 0.0;' . chr(10) . '    }' . chr(10) . '    public boolean to_bool() {' . chr(10) . '        PlCORE.die("error .to_bool!");' . chr(10) . '        return true;' . chr(10) . '    }' . chr(10) . '    public boolean is_undef() {' . chr(10) . '        return false;' . chr(10) . '    }' . chr(10) . '    public PlObject apply(int want, PlArray List__) {' . chr(10) . '        // $ perl -e ' . chr(39) . ' $a = 5; $a->() ' . chr(39) . chr(10) . '        // Undefined subroutine &main::5 called' . chr(10) . '        PlCORE.die("subroutine call error");' . chr(10) . '        return this;' . chr(10) . '    }' . chr(10) . chr(10) . '    public PlObject length() {' . chr(10) . '        return new PlInt(this.toString().length());' . chr(10) . '    }' . chr(10) . '    public PlObject get_arrayref() {' . chr(10) . '        return PlCORE.die("Not an ARRAY reference");' . chr(10) . '    }' . chr(10) . chr(10) . '    public PlObject shift() {' . chr(10) . '        return PlCORE.die("Not an ARRAY reference");' . chr(10) . '    }' . chr(10) . chr(10) . '    public PlObject get_hashref() {' . chr(10) . '        return PlCORE.die("Not a HASH reference");' . chr(10) . '    }' . chr(10) . chr(10) . '    public PlObject hget_scalarref(PlObject i) {' . chr(10) . '        PlCORE.die("Not a SCALAR reference");' . chr(10) . '        return this;' . chr(10) . '    }' . chr(10) . '    public PlObject hget_scalarref(String i) {' . chr(10) . '        PlCORE.die("Not a SCALAR reference");' . chr(10) . '        return this;' . chr(10) . '    }' . chr(10) . '    public PlObject scalar_deref_set(PlObject v) {' . chr(10) . '        PlCORE.die("Not a SCALAR reference");' . chr(10) . '        return this;' . chr(10) . '    }' . chr(10) . '    public PlObject aget_lvalue(int pos) {' . chr(10) . '        return PlCORE.die("Not an ARRAY reference");' . chr(10) . '    }' . chr(10) . '    public PlObject aget_scalarref(PlObject i) {' . chr(10) . '        PlCORE.die("Not a SCALAR reference");' . chr(10) . '        return this;' . chr(10) . '    }' . chr(10) . '    public PlObject aget_scalarref(int i) {' . chr(10) . '        PlCORE.die("Not a SCALAR reference");' . chr(10) . '        return this;' . chr(10) . '    }' . chr(10) . chr(10) . '    public PlObject array_deref() {' . chr(10) . '        PlCORE.die("Not an ARRAY reference");' . chr(10) . '        return this;' . chr(10) . '    }' . chr(10) . '    public PlObject array_deref_set(PlObject i) {' . chr(10) . '        PlCORE.die("Not an ARRAY reference");' . chr(10) . '        return this;' . chr(10) . '    }' . chr(10) . chr(10) . '    public PlObject hget_arrayref(PlObject i) {' . chr(10) . '        PlCORE.die("Not a HASH reference");' . chr(10) . '        return this;' . chr(10) . '    }' . chr(10) . '    public PlObject hget_arrayref(String i) {' . chr(10) . '        PlCORE.die("Not a HASH reference");' . chr(10) . '        return this;' . chr(10) . '    }' . chr(10) . '    public PlObject hget_hashref(PlObject i) {' . chr(10) . '        PlCORE.die("Not a HASH reference");' . chr(10) . '        return this;' . chr(10) . '    }' . chr(10) . '    public PlObject hget_hashref(String i) {' . chr(10) . '        PlCORE.die("Not a HASH reference");' . chr(10) . '        return this;' . chr(10) . '    }' . chr(10) . chr(10) . '    public PlObject aget_arrayref(PlObject i) {' . chr(10) . '        PlCORE.die("Not an ARRAY reference");' . chr(10) . '        return this;' . chr(10) . '    }' . chr(10) . '    public PlObject aget_arrayref(int i) {' . chr(10) . '        PlCORE.die("Not an ARRAY reference");' . chr(10) . '        return this;' . chr(10) . '    }' . chr(10) . '    public PlObject aget_hashref(PlObject i) {' . chr(10) . '        PlCORE.die("Not an ARRAY reference");' . chr(10) . '        return this;' . chr(10) . '    }' . chr(10) . '    public PlObject aget_hashref(int i) {' . chr(10) . '        PlCORE.die("Not an ARRAY reference");' . chr(10) . '        return this;' . chr(10) . '    }' . chr(10) . chr(10) . '    public PlObject hash_deref() {' . chr(10) . '        PlCORE.die("Not a HASH reference");' . chr(10) . '        return this;' . chr(10) . '    }' . chr(10) . '    public PlObject hash_deref_set(PlObject i) {' . chr(10) . '        PlCORE.die("Not a HASH reference");' . chr(10) . '        return this;' . chr(10) . '    }' . chr(10) . chr(10) . '    public PlObject hget(PlObject i) {' . chr(10) . '        PlCORE.die("Not a HASH reference");' . chr(10) . '        return this;' . chr(10) . '    }' . chr(10) . '    public PlObject hget(String i) {' . chr(10) . '        PlCORE.die("Not a HASH reference");' . chr(10) . '        return this;' . chr(10) . '    }' . chr(10) . '    public PlObject hget_lvalue(PlObject i) {' . chr(10) . '        PlCORE.die("Not a HASH reference");' . chr(10) . '        return this;' . chr(10) . '    }' . chr(10) . '    public PlObject hget_lvalue(String i) {' . chr(10) . '        PlCORE.die("Not a HASH reference");' . chr(10) . '        return this;' . chr(10) . '    }' . chr(10) . '    public PlObject hget_lvalue_local(PlObject i) {' . chr(10) . '        PlCORE.die("Not a HASH reference");' . chr(10) . '        return this;' . chr(10) . '    }' . chr(10) . '    public PlObject hget_lvalue_local(String i) {' . chr(10) . '        PlCORE.die("Not a HASH reference");' . chr(10) . '        return this;' . chr(10) . '    }' . chr(10) . chr(10) . '    public PlObject hset(PlObject s, PlObject v) {' . chr(10) . '        PlCORE.die("Not a HASH reference");' . chr(10) . '        return this;' . chr(10) . '    }' . chr(10) . '    public PlObject hset(String s, PlObject v) {' . chr(10) . '        PlCORE.die("Not a HASH reference");' . chr(10) . '        return this;' . chr(10) . '    }' . chr(10) . chr(10) . '    public PlObject aget(PlObject i) {' . chr(10) . '        PlCORE.die("Not an ARRAY reference");' . chr(10) . '        return this;' . chr(10) . '    }' . chr(10) . '    public PlObject aget(int i) {' . chr(10) . '        PlCORE.die("Not an ARRAY reference");' . chr(10) . '        return this;' . chr(10) . '    }' . chr(10) . '    public PlObject aset(int i, PlObject v) {' . chr(10) . '        PlCORE.die("Not an ARRAY reference");' . chr(10) . '        return this;' . chr(10) . '    }' . chr(10) . '    public PlObject aset(PlObject i, PlObject v) {' . chr(10) . '        PlCORE.die("Not an ARRAY reference");' . chr(10) . '        return this;' . chr(10) . '    }' . chr(10) . '    public PlObject to_array() {' . chr(10) . '        PlCORE.die("Not an ARRAY reference");' . chr(10) . '        return this;' . chr(10) . '    }' . chr(10) . '    public PlObject length_of_array() {' . chr(10) . '        PlCORE.die("Not an ARRAY reference");' . chr(10) . '        return this;' . chr(10) . '    }' . chr(10) . '    public PlObject values() {' . chr(10) . '        PlCORE.die("Type of argument to values on reference must be unblessed hashref or arrayref");' . chr(10) . '        return this;' . chr(10) . '    }' . chr(10) . '    public PlObject keys() {' . chr(10) . '        PlCORE.die("Type of argument to keys on reference must be unblessed hashref or arrayref");' . chr(10) . '        return this;' . chr(10) . '    }' . chr(10) . '    public PlObject each() {' . chr(10) . '        PlCORE.die("Type of argument to each on reference must be unblessed hashref or arrayref");' . chr(10) . '        return this;' . chr(10) . '    }' . chr(10) . '    public PlObject exists(PlObject i) {' . chr(10) . '        PlCORE.die("exists argument is not a HASH or ARRAY element or a subroutine");' . chr(10) . '        return this;' . chr(10) . '    }' . chr(10) . '    public PlObject delete(PlObject i) {' . chr(10) . '        PlCORE.die("delete argument is not a HASH or ARRAY element or slice");' . chr(10) . '        return this;' . chr(10) . '    }' . chr(10) . '    public PlObject set(PlObject o) {' . chr(10) . '        PlCORE.die("Modification of a read-only value attempted");' . chr(10) . '        return this;' . chr(10) . '    }' . chr(10) . '    public PlObject get() {' . chr(10) . '        PlCORE.die("error .get!");' . chr(10) . '        return this;' . chr(10) . '    }' . chr(10) . '    public boolean is_int() {' . chr(10) . '        return false;' . chr(10) . '    }' . chr(10) . '    public boolean is_num() {' . chr(10) . '        return false;' . chr(10) . '    }' . chr(10) . '    public boolean is_string() {' . chr(10) . '        return false;' . chr(10) . '    }' . chr(10) . '    public boolean is_bool() {' . chr(10) . '        return false;' . chr(10) . '    }' . chr(10) . '    public boolean is_hash() {' . chr(10) . '        return false;' . chr(10) . '    }' . chr(10) . '    public boolean is_array() {' . chr(10) . '        return false;' . chr(10) . '    }' . chr(10) . '    public boolean is_lvalue() {' . chr(10) . '        return false;' . chr(10) . '    }' . chr(10) . '    public boolean is_ref() {' . chr(10) . '        return false;' . chr(10) . '    }' . chr(10) . '    public boolean is_scalarref() {' . chr(10) . '        return false;' . chr(10) . '    }' . chr(10) . '    public boolean is_arrayref() {' . chr(10) . '        return false;' . chr(10) . '    }' . chr(10) . '    public boolean is_hashref() {' . chr(10) . '        return false;' . chr(10) . '    }' . chr(10) . '    public boolean is_coderef() {' . chr(10) . '        return false;' . chr(10) . '    }' . chr(10) . '    public PlString ref() {' . chr(10) . chr(9) . chr(9) . 'return REF;' . chr(10) . '    }' . chr(10) . '    public PlObject _decr() {' . chr(10) . '        // --$x' . chr(10) . '        return PlCx.MIN1;' . chr(10) . '    }' . chr(10) . '    public PlObject _incr() {' . chr(10) . '        // ++$x' . chr(10) . '        return PlCx.INT1;' . chr(10) . '    }' . chr(10) . '    public PlObject neg() {' . chr(10) . '        return new PlInt(-this.to_long());' . chr(10) . '    }' . chr(10) . '    public PlObject abs() {' . chr(10) . '        long c = this.to_long();' . chr(10) . '        return new PlInt(c < 0 ? -c : c);' . chr(10) . '    }' . chr(10) . chr(10) . '    public PlObject sqrt() { return new PlDouble(Math.sqrt(this.to_double())); }' . chr(10) . '    public PlObject cos()  { return new PlDouble(Math.cos(this.to_double())); }' . chr(10) . '    public PlObject sin()  { return new PlDouble(Math.sin(this.to_double())); }' . chr(10) . '    public PlObject exp()  { return new PlDouble(Math.exp(this.to_double())); }' . chr(10) . '    public PlObject log()  { return new PlDouble(Math.log(this.to_double())); }' . chr(10) . '    public PlObject pow(PlObject arg)    { return new PlDouble(Math.pow(this.to_double(), arg.to_double())); }' . chr(10) . '    public PlObject atan2(PlObject arg)  { return new PlDouble(Math.atan2(this.to_double(), arg.to_double())); }' . chr(10) . chr(10) . '    public PlObject pre_decr() {' . chr(10) . '        // --$x' . chr(10) . '        PlCORE.die("Can' . chr(39) . 't modify constant item in predecrement (--)");' . chr(10) . '        return this;' . chr(10) . '    }' . chr(10) . '    public PlObject post_decr() {' . chr(10) . '        // $x--' . chr(10) . '        PlCORE.die("Can' . chr(39) . 't modify constant item in postdecrement (--)");' . chr(10) . '        return this;' . chr(10) . '    }' . chr(10) . '    public PlObject pre_incr() {' . chr(10) . '        // ++$x' . chr(10) . '        PlCORE.die("Can' . chr(39) . 't modify constant item in preincrement (++)");' . chr(10) . '        return this;' . chr(10) . '    }' . chr(10) . '    public PlObject post_incr() {' . chr(10) . '        // $x++' . chr(10) . '        PlCORE.die("Can' . chr(39) . 't modify constant item in postincrement (++)");' . chr(10) . '        return this;' . chr(10) . '    }' . chr(10) . chr(10) . '    public PlObject lcfirst() {' . chr(10) . '        String s = this.toString();' . chr(10) . '        int len = s.length();' . chr(10) . '        if (len == 0) {' . chr(10) . '            return new PlString(s);' . chr(10) . '        }' . chr(10) . '        if (len == 1) {' . chr(10) . '            return new PlString(s.toLowerCase());' . chr(10) . '        }' . chr(10) . '        return new PlString( s.substring(0,1).toLowerCase() + s.substring(1) );' . chr(10) . '    }' . chr(10) . '    public PlObject ucfirst() {' . chr(10) . '        String s = this.toString();' . chr(10) . '        int len = s.length();' . chr(10) . '        if (len == 0) {' . chr(10) . '            return new PlString(s);' . chr(10) . '        }' . chr(10) . '        if (len == 1) {' . chr(10) . '            return new PlString(s.toUpperCase());' . chr(10) . '        }' . chr(10) . '        return new PlString( s.substring(0,1).toUpperCase() + s.substring(1) );' . chr(10) . '    }' . chr(10) . '    public PlObject quotemeta() {' . chr(10) . '        String s = this.toString();' . chr(10) . '        return new PlString(Matcher.quoteReplacement(s));' . chr(10) . '    }' . chr(10) . chr(10) . '    public PlObject substr(PlObject offset) {' . chr(10) . '        // substr EXPR,OFFSET' . chr(10) . '        String s = this.toString();' . chr(10) . '        int ofs = offset.to_int();' . chr(10) . '        if (ofs < 0) {' . chr(10) . '            ofs = s.length() + ofs;' . chr(10) . '        }' . chr(10) . '        if (ofs < 0) {' . chr(10) . '            ofs = 0;' . chr(10) . '        }' . chr(10) . '        if (ofs >= s.length()) {' . chr(10) . '            return PlCx.UNDEF;' . chr(10) . '        }' . chr(10) . '        return new PlString(s.substring(ofs));' . chr(10) . '    }' . chr(10) . '    public PlObject substr(PlObject offset, PlObject length) {' . chr(10) . '        // substr EXPR,OFFSET,LENGTH' . chr(10) . '        String s = this.toString();' . chr(10) . '        int ofs = offset.to_int();' . chr(10) . '        int len = length.to_int();' . chr(10) . '        if (ofs < 0) {' . chr(10) . '            ofs = s.length() + ofs;' . chr(10) . '        }' . chr(10) . '        if (ofs >= s.length()) {' . chr(10) . '            return PlCx.UNDEF;' . chr(10) . '        }' . chr(10) . chr(10) . '        if (len < 0) {' . chr(10) . '            len = s.length() + len;' . chr(10) . '        }' . chr(10) . '        else {' . chr(10) . '            len = ofs + len;' . chr(10) . '        }' . chr(10) . chr(10) . '        if (len >= s.length()) {' . chr(10) . '            len = s.length();' . chr(10) . '        }' . chr(10) . '        if (len <= 0) {' . chr(10) . '            return PlCx.UNDEF;' . chr(10) . '        }' . chr(10) . '        if (ofs < 0) {' . chr(10) . '            ofs = 0;' . chr(10) . '        }' . chr(10) . '        return new PlString(s.substring(ofs, len));' . chr(10) . '    }' . chr(10) . '    public PlObject substr(PlObject offset, PlObject length, PlObject replacement) {' . chr(10) . '        // substr EXPR,OFFSET,LENGTH,REPLACEMENT' . chr(10) . '        PlCORE.die("TODO substr EXPR,OFFSET,LENGTH,REPLACEMENT");' . chr(10) . '        return this;' . chr(10) . '    }' . chr(10) . '    public PlObject bless(PlString className) {' . chr(10) . chr(9) . chr(9) . 'PlCORE.die("Can' . chr(39) . 't bless non-reference value");' . chr(10) . chr(9) . chr(9) . 'return this;' . chr(10) . '    }' . chr(10) . '    public PlClass blessed() {' . chr(10) . chr(9) . chr(9) . 'return null;' . chr(10) . '    }' . chr(10) . '    public PlObject scalar() {' . chr(10) . '        return this;' . chr(10) . '    }' . chr(10) . '    public PlObject str_cmp(PlObject b) {' . chr(10) . '        int c = this.toString().compareTo(b.toString());' . chr(10) . '        return new PlInt(c == 0 ? c : c < 0 ? -1 : 1);' . chr(10) . '    }' . chr(10) . '    public PlObject num_cmp(PlObject b) {' . chr(10) . '        return b.num_cmp2(this);' . chr(10) . '    }' . chr(10) . '    public PlObject num_cmp2(PlObject b) {' . chr(10) . '        Long blong = new Long(b.to_long());' . chr(10) . '        int c = blong.compareTo(this.to_long());' . chr(10) . '        return new PlInt(c == 0 ? c : c < 0 ? -1 : 1);' . chr(10) . '    }' . chr(10) . (join('', map {
                    my $perl = $_;
                    my $native = $number_binop{$perl}->{'op'};
                    my $returns = $number_binop{$perl}->{'returns'};
                    '    public PlObject ' . $perl . '(PlObject s) {' . chr(10) . '        return s.' . $perl . '2(this);' . chr(10) . '    }' . chr(10) . ($returns eq 'PlDouble' ? '    public PlObject ' . $perl . '2(PlObject s) {' . chr(10) . '        return new ' . $returns . '( s.to_double() ' . $native . ' this.to_double() );' . chr(10) . '    }' . chr(10) : '    public PlObject ' . $perl . '2(PlObject s) {' . chr(10) . '        return new ' . $returns . '( s.to_long() ' . $native . ' this.to_long() );' . chr(10) . '    }' . chr(10))
                } sort {
                    $a cmp $b
                } keys(%number_binop))) . (join('', map {
                    my $perl = $_;
                    my $native = $string_binop{$perl}->{'op'};
                    my $returns = $string_binop{$perl}->{'returns'};
                    '    public PlObject ' . $perl . '(PlObject b) {' . chr(10) . '        return new ' . $returns . '(this.toString().compareTo(b.toString()) ' . $native . ');' . chr(10) . '    }' . chr(10)
                } sort {
                    $a cmp $b
                } keys(%string_binop))) . '}' . chr(10) . 'class PlReference extends PlObject {' . chr(10) . '    public static final PlString REF = new PlString("REF");' . chr(10) . chr(9) . 'public PlClass bless;' . chr(10) . chr(10) . '    public boolean is_ref() {' . chr(10) . '        return true;' . chr(10) . '    }' . chr(10) . '    public PlReference bless(PlString className) {' . chr(10) . '        this.bless = new PlClass(className);' . chr(10) . '        return this;' . chr(10) . '    }' . chr(10) . '    public PlClass blessed() {' . chr(10) . chr(9) . chr(9) . 'return this.bless;' . chr(10) . '    }' . chr(10) . chr(10) . chr(9) . 'public PlString ref() {' . chr(10) . chr(9) . chr(9) . 'if ( this.bless == null ) {' . chr(10) . chr(9) . chr(9) . chr(9) . 'return REF;' . chr(10) . chr(9) . chr(9) . '}' . chr(10) . chr(9) . chr(9) . 'else {' . chr(10) . chr(9) . chr(9) . chr(9) . 'return this.bless.className();' . chr(10) . chr(9) . chr(9) . '}' . chr(10) . chr(9) . '}' . chr(10) . chr(10) . '    public String toString() {' . chr(10) . '        return this.ref().toString() + "(0x" + Integer.toHexString(this.hashCode()) + ")";' . chr(10) . '    }' . chr(10) . '}' . chr(10) . 'class PlRegex extends PlReference {' . chr(10) . '    public Pattern p;' . chr(10) . '    public String  original_string;' . chr(10) . '    // public Matcher m;' . chr(10) . '    public static final PlString REF = new PlString("Regexp");' . chr(10) . chr(10) . '    public PlRegex(String p, int flags) {' . chr(10) . '        this.original_string = p;' . chr(10) . '        this.p = Pattern.compile(PerlOp.character_class_escape(this.original_string), flags);' . chr(10) . '    }' . chr(10) . '    public PlRegex(PlObject p, int flags) {' . chr(10) . '        this.original_string = p.toString();' . chr(10) . '        this.p = Pattern.compile(PerlOp.character_class_escape(this.original_string), flags);' . chr(10) . '    }' . chr(10) . '    public String toString() {' . chr(10) . '        // TODO - show flags' . chr(10) . '        return this.original_string;' . chr(10) . '    }' . chr(10) . '}' . chr(10) . 'class PlClosure extends PlReference implements Runnable {' . chr(10) . '    public PlObject[] env;       // new PlObject[]{ v1, v2, v3 }' . chr(10) . '    public PlObject prototype;    // ' . chr(39) . '$$$' . chr(39) . chr(10) . '    public static final PlString REF = new PlString("CODE");' . chr(10) . chr(10) . '    public PlClosure(PlObject prototype, PlObject[] env) {' . chr(10) . '        this.prototype = prototype;' . chr(10) . '        this.env = env;' . chr(10) . '    }' . chr(10) . '    // Note: apply() is inherited from PlObject' . chr(10) . '    public PlObject apply(int want, PlArray List__) {' . chr(10) . '        PlCORE.die("it looks like you have a closure without a block");' . chr(10) . '        return this;' . chr(10) . '    }' . chr(10) . '    public void run() {' . chr(10) . '        // run as a thread' . chr(10) . '        this.apply(PlCx.VOID, new PlArray());' . chr(10) . '    }' . chr(10) . chr(9) . 'public PlString ref() {' . chr(10) . chr(9) . chr(9) . 'if ( this.bless == null ) {' . chr(10) . chr(9) . chr(9) . chr(9) . 'return REF;' . chr(10) . chr(9) . chr(9) . '}' . chr(10) . chr(9) . chr(9) . 'else {' . chr(10) . chr(9) . chr(9) . chr(9) . 'return this.bless.className();' . chr(10) . chr(9) . chr(9) . '}' . chr(10) . chr(9) . '}' . chr(10) . '    public boolean is_coderef() {' . chr(10) . '        return true;' . chr(10) . '    }' . chr(10) . '}' . chr(10) . 'class PlLvalueRef extends PlReference {' . chr(10) . '    private PlObject o;' . chr(10) . '    public static final PlString REF = new PlString("SCALAR");' . chr(10) . chr(10) . chr(9) . 'public PlString ref() {' . chr(10) . chr(9) . chr(9) . 'if ( this.bless == null ) {' . chr(10) . chr(9) . chr(9) . chr(9) . 'return REF;' . chr(10) . chr(9) . chr(9) . '}' . chr(10) . chr(9) . chr(9) . 'else {' . chr(10) . chr(9) . chr(9) . chr(9) . 'return this.bless.className();' . chr(10) . chr(9) . chr(9) . '}' . chr(10) . chr(9) . '}' . chr(10) . '    public String toString() {' . chr(10) . '        int id = System.identityHashCode(this.o);' . chr(10) . '        return this.ref().toString() + "(0x" + Integer.toHexString(id) + ")";' . chr(10) . '    }' . chr(10) . '    public PlLvalueRef(PlLvalue o) {' . chr(10) . '        this.o = o;' . chr(10) . '    }' . chr(10) . '    public PlLvalueRef(PlObject o) {' . chr(10) . '        this.o = o;' . chr(10) . '    }' . chr(10) . '    public PlObject scalar_deref_set(PlObject v) {' . chr(10) . '        return this.o.set(v);' . chr(10) . '    }' . chr(10) . '    public boolean is_scalarref() {' . chr(10) . '        return true;' . chr(10) . '    }' . chr(10) . '    public PlObject get() {' . chr(10) . '        return this.o;' . chr(10) . '    }' . chr(10) . '}' . chr(10) . 'class PlArrayRef extends PlArray {' . chr(10) . '    public static final PlString REF = new PlString("ARRAY");' . chr(10) . chr(9) . 'public PlClass bless;' . chr(10) . chr(10) . '    public String toString() {' . chr(10) . '        int id = System.identityHashCode(this.a);' . chr(10) . '        return this.ref().toString() + "(0x" + Integer.toHexString(id) + ")";' . chr(10) . '    }' . chr(10) . '    public PlArrayRef() {' . chr(10) . '        this.each_iterator = 0;' . chr(10) . '        this.a = new ArrayList<PlObject>();' . chr(10) . '    }' . chr(10) . '    public PlArrayRef(PlArray o) {' . chr(10) . '        this.a = o.a;' . chr(10) . '        this.each_iterator = o.each_iterator;' . chr(10) . '    }' . chr(10) . '    public PlObject set(PlArray o) {' . chr(10) . '        this.a = o.a;' . chr(10) . '        this.each_iterator = o.each_iterator;' . chr(10) . '        return o;' . chr(10) . '    }' . chr(10) . '    public PlObject get() {' . chr(10) . '        PlArray o = new PlArray();' . chr(10) . '        o.a = this.a;' . chr(10) . '        return o;' . chr(10) . '    }' . chr(10) . '    public PlObject array_deref() {' . chr(10) . '        PlArray o = new PlArray();' . chr(10) . '        o.a = this.a;' . chr(10) . '        return o;' . chr(10) . '    }' . chr(10) . '    public PlObject array_deref_set(PlObject v) {' . chr(10) . '        super.set(v);' . chr(10) . '        return v;' . chr(10) . '    }' . chr(10) . '    public boolean is_array() {' . chr(10) . '        return false;' . chr(10) . '    }' . chr(10) . '    public boolean is_ref() {' . chr(10) . '        return true;' . chr(10) . '    }' . chr(10) . '    public boolean is_arrayref() {' . chr(10) . '        return true;' . chr(10) . '    }' . chr(10) . '    public PlObject scalar() {' . chr(10) . '        return this;' . chr(10) . '    }' . chr(10) . '    public PlArrayRef bless(PlString className) {' . chr(10) . '        this.bless = new PlClass(className);' . chr(10) . '        return this;' . chr(10) . '    }' . chr(10) . '    public PlClass blessed() {' . chr(10) . chr(9) . chr(9) . 'return this.bless;' . chr(10) . '    }' . chr(10) . chr(9) . 'public PlString ref() {' . chr(10) . chr(9) . chr(9) . 'if ( this.bless == null ) {' . chr(10) . chr(9) . chr(9) . chr(9) . 'return REF;' . chr(10) . chr(9) . chr(9) . '}' . chr(10) . chr(9) . chr(9) . 'else {' . chr(10) . chr(9) . chr(9) . chr(9) . 'return this.bless.className();' . chr(10) . chr(9) . chr(9) . '}' . chr(10) . chr(9) . '}' . chr(10) . '}' . chr(10) . 'class PlHashRef extends PlHash {' . chr(10) . '    public static final PlString REF = new PlString("HASH");' . chr(10) . chr(9) . 'public PlClass bless;' . chr(10) . chr(10) . '    public String toString() {' . chr(10) . '        int id = System.identityHashCode(this.h);' . chr(10) . '        return this.ref().toString() + "(0x" + Integer.toHexString(id) + ")";' . chr(10) . '    }' . chr(10) . '    public PlHashRef() {' . chr(10) . '        this.h = new HashMap<String, PlObject>();' . chr(10) . '        this.each_iterator = null;' . chr(10) . '    }' . chr(10) . '    public PlHashRef(PlHash o) {' . chr(10) . '        this.h = o.h;' . chr(10) . '        this.each_iterator = o.each_iterator;' . chr(10) . '    }' . chr(10) . '    public PlObject set(PlHash o) {' . chr(10) . '        this.h = o.h;' . chr(10) . '        this.each_iterator = o.each_iterator;' . chr(10) . '        return o;' . chr(10) . '    }' . chr(10) . '    public PlObject get() {' . chr(10) . '        PlHash o = new PlHash();' . chr(10) . '        o.h = this.h;' . chr(10) . '        return o;' . chr(10) . '    }' . chr(10) . '    public PlObject hash_deref() {' . chr(10) . '        PlHash o = new PlHash();' . chr(10) . '        o.h = this.h;' . chr(10) . '        return o;' . chr(10) . '    }' . chr(10) . '    public PlObject hash_deref_set(PlObject v) {' . chr(10) . '        super.set(v);' . chr(10) . '        return v;' . chr(10) . '    }' . chr(10) . '    public boolean is_hash() {' . chr(10) . '        return false;' . chr(10) . '    }' . chr(10) . '    public boolean is_ref() {' . chr(10) . '        return true;' . chr(10) . '    }' . chr(10) . '    public boolean is_hashref() {' . chr(10) . '        return true;' . chr(10) . '    }' . chr(10) . '    public PlObject scalar() {' . chr(10) . '        return this;' . chr(10) . '    }' . chr(10) . '    public PlHashRef bless(PlString className) {' . chr(10) . '        this.bless = new PlClass(className);' . chr(10) . '        return this;' . chr(10) . '    }' . chr(10) . '    public PlClass blessed() {' . chr(10) . chr(9) . chr(9) . 'return this.bless;' . chr(10) . '    }' . chr(10) . '    public PlString ref() {' . chr(10) . chr(9) . chr(9) . 'if ( this.bless == null ) {' . chr(10) . chr(9) . chr(9) . chr(9) . 'return REF;' . chr(10) . chr(9) . chr(9) . '}' . chr(10) . chr(9) . chr(9) . 'else {' . chr(10) . chr(9) . chr(9) . chr(9) . 'return this.bless.className();' . chr(10) . chr(9) . chr(9) . '}' . chr(10) . chr(9) . '}' . chr(10) . '}' . chr(10) . 'class PlClass {' . chr(10) . chr(9) . 'public static PlHash classes = new PlHash();' . chr(10) . chr(9) . 'public PlString className;' . chr(10) . chr(10) . chr(9) . 'public PlClass (PlString blessing) {' . chr(10) . chr(9) . chr(9) . 'this.className = blessing;' . chr(10) . chr(9) . chr(9) . 'if (classes.exists(className) == null) {' . chr(10) . chr(9) . chr(9) . chr(9) . 'classes.hset(className, className);' . chr(10) . chr(9) . chr(9) . '}' . chr(10) . chr(9) . '}' . chr(10) . chr(9) . 'public PlString className() {' . chr(10) . chr(9) . chr(9) . 'return this.className;' . chr(10) . chr(9) . '}' . chr(10) . '    public boolean is_undef() {' . chr(10) . '        return this.className == null;' . chr(10) . '    }' . chr(10) . '}' . chr(10) . 'class PlLvalue extends PlObject {' . chr(10) . '    private PlObject o;' . chr(10) . chr(10) . '    // Note: several versions of PlLvalue()' . chr(10) . '    public PlLvalue() {' . chr(10) . '        this.o = PlCx.UNDEF;' . chr(10) . '    }' . chr(10) . '    public PlLvalue(PlObject o) {' . chr(10) . '        this.o = o;' . chr(10) . '    }' . chr(10) . '    public PlLvalue(PlLvalue o) {' . chr(10) . '        this.o = o.get();' . chr(10) . '    }' . chr(10) . '    public PlLvalue(PlArray o) {' . chr(10) . '        // $a = @x' . chr(10) . '        this.o = o.scalar();' . chr(10) . '    }' . chr(10) . '    public PlLvalue(PlHash o) {' . chr(10) . '        // $a = %x' . chr(10) . '        this.o = o.scalar();' . chr(10) . '    }' . chr(10) . '    public PlObject get() {' . chr(10) . '        return this.o;' . chr(10) . '    }' . chr(10) . '    public PlObject get_scalarref() {' . chr(10) . '        if (this.o.is_undef()) {' . chr(10) . '            PlLvalueRef ar = new PlLvalueRef(new PlLvalue());' . chr(10) . '            this.o = ar;' . chr(10) . '            return ar;' . chr(10) . '        }' . chr(10) . '        else if (this.o.is_scalarref()) {' . chr(10) . '            return this.o;' . chr(10) . '        }' . chr(10) . '        // Modification of a read-only value attempted' . chr(10) . '        return this.o;' . chr(10) . '    }' . chr(10) . '    public PlObject get_arrayref() {' . chr(10) . '        if (this.o.is_undef()) {' . chr(10) . '            PlArrayRef ar = new PlArrayRef();' . chr(10) . '            this.o = ar;' . chr(10) . '            return ar;' . chr(10) . '        }' . chr(10) . '        else if (this.o.is_arrayref()) {' . chr(10) . '            return this.o;' . chr(10) . '        }' . chr(10) . '        return PlCORE.die("Not an ARRAY reference");' . chr(10) . '    }' . chr(10) . '    public PlObject get_hashref() {' . chr(10) . '        if (this.o.is_undef()) {' . chr(10) . '            PlHashRef hr = new PlHashRef();' . chr(10) . '            this.o = hr;' . chr(10) . '            return this.o;' . chr(10) . '        }' . chr(10) . '        else if (this.o.is_hashref()) {' . chr(10) . '            return this.o;' . chr(10) . '        }' . chr(10) . '        return PlCORE.die("Not a HASH reference");' . chr(10) . '    }' . chr(10) . '    public PlObject aget(PlObject i) {' . chr(10) . '        return this.o.aget(i);' . chr(10) . '    }' . chr(10) . '    public PlObject aget(int i) {' . chr(10) . '        return this.o.aget(i);' . chr(10) . '    }' . chr(10) . chr(10) . '    public PlObject aget_scalarref(PlObject i) {' . chr(10) . '        if (this.o.is_undef()) {' . chr(10) . '            this.o = new PlArrayRef();' . chr(10) . '        }' . chr(10) . '        return this.o.aget_scalarref(i);' . chr(10) . '    }' . chr(10) . '    public PlObject aget_arrayref(PlObject i) {' . chr(10) . '        if (this.o.is_undef()) {' . chr(10) . '            this.o = new PlArrayRef();' . chr(10) . '        }' . chr(10) . '        return this.o.aget_arrayref(i);' . chr(10) . '    }' . chr(10) . '    public PlObject aget_hashref(PlObject i) {' . chr(10) . '        if (this.o.is_undef()) {' . chr(10) . '            this.o = new PlArrayRef();' . chr(10) . '        }' . chr(10) . '        return this.o.aget_hashref(i);' . chr(10) . '    }' . chr(10) . chr(10) . '    public PlObject aset(int i, PlObject v) {' . chr(10) . '        return this.o.aset(i, v);' . chr(10) . '    }' . chr(10) . '    public PlObject aset(PlObject i, PlObject v) {' . chr(10) . '        return this.o.aset(i, v);' . chr(10) . '    }' . chr(10) . '    public PlObject hget(PlObject i) {' . chr(10) . '        return this.o.hget(i);' . chr(10) . '    }' . chr(10) . '    public PlObject hget(String i) {' . chr(10) . '        return this.o.hget(i);' . chr(10) . '    }' . chr(10) . chr(10) . '    public PlObject hget_scalarref(PlObject i) {' . chr(10) . '        if (this.o.is_undef()) {' . chr(10) . '            this.o = new PlHashRef();' . chr(10) . '        }' . chr(10) . '        return this.o.hget_scalarref(i);' . chr(10) . '    }' . chr(10) . '    public PlObject hget_arrayref(PlObject i) {' . chr(10) . '        if (this.o.is_undef()) {' . chr(10) . '            this.o = new PlHashRef();' . chr(10) . '        }' . chr(10) . '        return this.o.hget_arrayref(i);' . chr(10) . '    }' . chr(10) . '    public PlObject hget_hashref(PlObject i) {' . chr(10) . '        if (this.o.is_undef()) {' . chr(10) . '            this.o = new PlHashRef();' . chr(10) . '        }' . chr(10) . '        return this.o.hget_hashref(i);' . chr(10) . '    }' . chr(10) . chr(10) . '    public PlObject hset(PlObject s, PlObject v) {' . chr(10) . '        return this.o.hset(s, v);' . chr(10) . '    }' . chr(10) . '    public PlObject hset(String s, PlObject v) {' . chr(10) . '        return this.o.hset(s, v);' . chr(10) . '    }' . chr(10) . chr(10) . '    public PlObject scalar_deref() {' . chr(10) . '        return this.get_scalarref().get();' . chr(10) . '    }' . chr(10) . '    public PlObject scalar_deref_set(PlObject v) {' . chr(10) . '        return this.get_scalarref().scalar_deref_set(v);' . chr(10) . '    }' . chr(10) . chr(10) . '    public PlObject array_deref() {' . chr(10) . '        // @$x doesn' . chr(39) . 't autovivify' . chr(10) . '        if (this.o.is_undef()) {' . chr(10) . '            return new PlArray();' . chr(10) . '        }' . chr(10) . '        else if (this.o.is_arrayref()) {' . chr(10) . '            return this.o.get();' . chr(10) . '        }' . chr(10) . '        return PlCORE.die("Not an ARRAY reference");' . chr(10) . '    }' . chr(10) . '    public PlObject array_deref_set(PlObject v) {' . chr(10) . '        // @$x = ...' . chr(10) . '        if (this.o.is_undef()) {' . chr(10) . '            this.o = new PlArrayRef();' . chr(10) . '            return this.o.array_deref_set(v);' . chr(10) . '        }' . chr(10) . '        else if (this.o.is_arrayref()) {' . chr(10) . '            return this.o.array_deref_set(v);' . chr(10) . '        }' . chr(10) . '        return PlCORE.die("Not an ARRAY reference");' . chr(10) . '    }' . chr(10) . chr(10) . '    public PlObject hash_deref() {' . chr(10) . '        // %$x doesn' . chr(39) . 't autovivify' . chr(10) . '        if (this.o.is_undef()) {' . chr(10) . '            return new PlHash();' . chr(10) . '        }' . chr(10) . '        else if (this.o.is_hashref()) {' . chr(10) . '            return this.o.get();' . chr(10) . '        }' . chr(10) . '        return PlCORE.die("Not a HASH reference");' . chr(10) . '    }' . chr(10) . '    public PlObject hash_deref_set(PlObject v) {' . chr(10) . '        // %$x = ...' . chr(10) . '        if (this.o.is_undef()) {' . chr(10) . '            this.o = new PlHashRef();' . chr(10) . '            return this.o.hash_deref_set(v);' . chr(10) . '        }' . chr(10) . '        else if (this.o.is_hashref()) {' . chr(10) . '            return this.o.hash_deref_set(v);' . chr(10) . '        }' . chr(10) . '        return PlCORE.die("Not a HASH reference");' . chr(10) . '    }' . chr(10) . '    public PlObject apply(int want, PlArray List__) {' . chr(10) . '        return this.o.apply(want, List__);' . chr(10) . '    }' . chr(10) . chr(10) . '    // Note: several versions of set()' . chr(10) . '    public PlObject set(PlObject o) {' . chr(10) . '        if (o == null) {' . chr(10) . '            o = PlCx.UNDEF;' . chr(10) . '        }' . chr(10) . '        this.o = o;' . chr(10) . '        return this;' . chr(10) . '    }' . chr(10) . '    public PlObject set(PlLvalue o) {' . chr(10) . '        this.o = o.get();' . chr(10) . '        return this;' . chr(10) . '    }' . chr(10) . '    public PlObject set(PlArray o) {' . chr(10) . '        // $a = @x' . chr(10) . '        this.o = o.scalar();' . chr(10) . '        return this;' . chr(10) . '    }' . chr(10) . '    public PlObject set(PlHash o) {' . chr(10) . '        // $a = %x' . chr(10) . '        this.o = o.scalar();' . chr(10) . '        return this;' . chr(10) . '    }' . chr(10) . (join('', map {
                    my $native = $_;
                    my $perl = $native_to_perl{$native};
                    $native && $perl ? '    public PlObject set(' . $native . ' s) {' . chr(10) . '        this.o = new ' . $perl . '(s);' . chr(10) . '        return this;' . chr(10) . '    }' . chr(10) : ()
                } sort {
                    $a cmp $b
                } keys(%native_to_perl))) . '    public PlObject exists(PlObject a) {' . chr(10) . '        return this.o.exists(a);' . chr(10) . '    }' . chr(10) . '    public PlObject delete(PlObject a) {' . chr(10) . '        return this.o.delete(a);' . chr(10) . '    }' . chr(10) . '    public String toString() {' . chr(10) . '        return this.o.toString();' . chr(10) . '    }' . chr(10) . '    public long to_long() {' . chr(10) . '        return this.o.to_long();' . chr(10) . '    }' . chr(10) . '    public double to_double() {' . chr(10) . '        return this.o.to_double();' . chr(10) . '    }' . chr(10) . '    public boolean to_bool() {' . chr(10) . '        return this.o.to_bool();' . chr(10) . '    }' . chr(10) . '    public PlObject num_cmp(PlObject b) {' . chr(10) . '        return this.o.num_cmp(b);' . chr(10) . '    }' . chr(10) . '    public PlObject num_cmp2(PlObject b) {' . chr(10) . '        return b.num_cmp(this.o);' . chr(10) . '    }' . chr(10) . (join('', map {
                    my $perl = $_;
                    my $native = $number_binop{$perl}->{'op'};
                    '    public PlObject ' . $perl . '(PlObject s) {' . chr(10) . '        return this.o.' . $perl . '(s);' . chr(10) . '    }' . chr(10) . '    public PlObject ' . $perl . '2(PlObject s) {' . chr(10) . '        return s.' . $perl . '(this.o);' . chr(10) . '    }' . chr(10)
                } sort {
                    $a cmp $b
                } keys(%number_binop))) . '    public boolean is_int() {' . chr(10) . '        return this.o.is_int();' . chr(10) . '    }' . chr(10) . '    public boolean is_num() {' . chr(10) . '        return this.o.is_num();' . chr(10) . '    }' . chr(10) . '    public boolean is_string() {' . chr(10) . '        return this.o.is_string();' . chr(10) . '    }' . chr(10) . '    public boolean is_bool() {' . chr(10) . '        return this.o.is_bool();' . chr(10) . '    }' . chr(10) . '    public boolean is_undef() {' . chr(10) . '        return this.o.is_undef();' . chr(10) . '    }' . chr(10) . '    public boolean is_lvalue() {' . chr(10) . '        return true;' . chr(10) . '    }' . chr(10) . '    public boolean is_coderef() {' . chr(10) . '        return this.o.is_coderef();' . chr(10) . '    }' . chr(10) . chr(10) . '    public PlObject pre_decr() {' . chr(10) . '        // --$x' . chr(10) . '        this.o = this.o._decr();' . chr(10) . '        return this.o;' . chr(10) . '    }' . chr(10) . '    public PlObject post_decr() {' . chr(10) . '        // $x--' . chr(10) . '        PlObject res = this.o;' . chr(10) . '        this.o = this.o._decr();' . chr(10) . '        return res;' . chr(10) . '    }' . chr(10) . '    public PlObject pre_incr() {' . chr(10) . '        // ++$x' . chr(10) . '        this.o = this.o._incr();' . chr(10) . '        return this.o;' . chr(10) . '    }' . chr(10) . '    public PlObject post_incr() {' . chr(10) . '        // $x++' . chr(10) . '        PlObject res = this.o;' . chr(10) . '        this.o = this.o._incr();' . chr(10) . '        return res;' . chr(10) . '    }' . chr(10) . '    public PlObject neg() {' . chr(10) . '        return this.o.neg();' . chr(10) . '    }' . chr(10) . '    public PlObject abs() {' . chr(10) . '        return this.o.abs();' . chr(10) . '    }' . chr(10) . '    public PlObject scalar() {' . chr(10) . '        return this.o;' . chr(10) . '    }' . chr(10) . '    public PlObject bless(PlString className) {' . chr(10) . '        return this.o.bless(className);' . chr(10) . '    }' . chr(10) . '    public PlClass blessed() {' . chr(10) . chr(9) . chr(9) . 'return this.o.blessed();' . chr(10) . '    }' . chr(10) . '    public PlString ref() {' . chr(10) . '        return this.o.ref();' . chr(10) . '    }' . chr(10) . join('', (map {
                    my $class = $java_classes{$_};
                    my $java_class_name = $class->{'java_type'};
                    my $perl_to_java = $class->{'perl_to_java'};
                    $class->{'import'} || $class->{'extends'} || $class->{'implements'} ? '    public ' . $java_class_name . ' ' . $perl_to_java . '() {' . chr(10) . '        return this.o.' . $perl_to_java . '();' . chr(10) . '    }' . chr(10) : ()
                } sort {
                    $a cmp $b
                } keys(%java_classes))) . '}' . chr(10) . 'class PlArray extends PlObject {' . chr(10) . '    public ArrayList<PlObject> a;' . chr(10) . '    public int each_iterator;' . chr(10) . '    public PlArray( ArrayList<PlObject> a ) {' . chr(10) . '        this.each_iterator = 0;' . chr(10) . '        this.a = a;' . chr(10) . '    }' . chr(10) . '    public PlArray() {' . chr(10) . '        this.each_iterator = 0;' . chr(10) . '        this.a = new ArrayList<PlObject>();' . chr(10) . '    }' . chr(10) . '    public PlArray(PlObject... args) {' . chr(10) . '        ArrayList<PlObject> aa = new ArrayList<PlObject>();' . chr(10) . '        for (PlObject s : args) {' . chr(10) . '            if (s.is_hash()) {' . chr(10) . '                // @x = %x;' . chr(10) . '                s = s.to_array();' . chr(10) . '            }' . chr(10) . '            if (s.is_array()) {' . chr(10) . '                // @x = ( @x, @y );' . chr(10) . '                for (int i = 0; i < s.to_long(); i++) {' . chr(10) . '                    aa.add(s.aget(i));' . chr(10) . '                }' . chr(10) . '            }' . chr(10) . '            else if (s.is_lvalue()) {' . chr(10) . '                aa.add(s.get());' . chr(10) . '            }' . chr(10) . '            else {' . chr(10) . '                aa.add(s);' . chr(10) . '            }' . chr(10) . '        }' . chr(10) . '        this.each_iterator = 0;' . chr(10) . '        this.a = aa;' . chr(10) . '    }' . chr(10) . '    public static PlArray construct_list_of_aliases(PlObject... args) {' . chr(10) . '        ArrayList<PlObject> aa = new ArrayList<PlObject>();' . chr(10) . '        for (PlObject s : args) {' . chr(10) . '            if (s.is_hash()) {' . chr(10) . '                // @x = %x;' . chr(10) . '                s = s.to_array();' . chr(10) . '            }' . chr(10) . '            if (s.is_array()) {' . chr(10) . '                // @x = ( @x, @y );' . chr(10) . '                for (int i = 0; i < s.to_long(); i++) {' . chr(10) . '                    aa.add(s.aget_lvalue(i));' . chr(10) . '                }' . chr(10) . '            }' . chr(10) . '            else {' . chr(10) . '                aa.add(s);  // store lvalue as-is' . chr(10) . '            }' . chr(10) . '        }' . chr(10) . '        PlArray result = new PlArray();' . chr(10) . '        result.a = aa;' . chr(10) . '        return result;' . chr(10) . '    }' . chr(10) . chr(10) . '    public PlObject set(PlObject s) {' . chr(10) . '        this.a.clear();' . chr(10) . '        if (s.is_hash()) {' . chr(10) . '            // @x = %x;' . chr(10) . '            s = s.to_array();' . chr(10) . '        }' . chr(10) . '        if (s.is_array()) {' . chr(10) . '            // @x = ( @x, @y );' . chr(10) . '            for (int i = 0; i < s.to_long(); i++) {' . chr(10) . '                this.a.add(s.aget(i));' . chr(10) . '            }' . chr(10) . '        }' . chr(10) . '        else {' . chr(10) . '            this.a.add(s);' . chr(10) . '        }' . chr(10) . '        this.each_iterator = 0;' . chr(10) . '        return this;' . chr(10) . '    }' . chr(10) . '    public PlObject set(byte[] bs) {' . chr(10) . '        this.a.clear();' . chr(10) . '        // @x = byte[] native;' . chr(10) . '        for(byte b : bs){' . chr(10) . '            int i = b;' . chr(10) . '            this.a.add(new PlInt(i));' . chr(10) . '        }' . chr(10) . '        this.each_iterator = 0;' . chr(10) . '        return this;' . chr(10) . '    }' . chr(10) . '    public PlArray(byte[] bs) {' . chr(10) . '        PlArray aa = new PlArray();' . chr(10) . '        aa.set(bs);' . chr(10) . '        this.each_iterator = aa.each_iterator;' . chr(10) . '        this.a = aa.a;' . chr(10) . '    }' . chr(10) . chr(10) . '    public PlObject set(long[] longs) {' . chr(10) . '        this.a.clear();' . chr(10) . '        // @x = long[] native;' . chr(10) . '        for(long i : longs){' . chr(10) . '            this.a.add(new PlInt(i));' . chr(10) . '        }' . chr(10) . '        this.each_iterator = 0;' . chr(10) . '        return this;' . chr(10) . '    }' . chr(10) . '    public PlArray(long[] longs) {' . chr(10) . '        PlArray aa = new PlArray();' . chr(10) . '        aa.set(longs);' . chr(10) . '        this.each_iterator = aa.each_iterator;' . chr(10) . '        this.a = aa.a;' . chr(10) . '    }' . chr(10) . chr(10) . '    public PlObject set(int[] ints) {' . chr(10) . '        this.a.clear();' . chr(10) . '        // @x = int[] native;' . chr(10) . '        for(int i : ints){' . chr(10) . '            this.a.add(new PlInt(i));' . chr(10) . '        }' . chr(10) . '        this.each_iterator = 0;' . chr(10) . '        return this;' . chr(10) . '    }' . chr(10) . '    public PlArray(int[] ints) {' . chr(10) . '        PlArray aa = new PlArray();' . chr(10) . '        aa.set(ints);' . chr(10) . '        this.each_iterator = aa.each_iterator;' . chr(10) . '        this.a = aa.a;' . chr(10) . '    }' . chr(10) . '    public PlObject set(String[] strings) {' . chr(10) . '        this.a.clear();' . chr(10) . '        for (String s : strings) {' . chr(10) . '            this.a.add(new PlString(s));' . chr(10) . '        }' . chr(10) . '        this.each_iterator = 0;' . chr(10) . '        return this;' . chr(10) . '    }' . chr(10) . '    public PlArray(String[] strings) {' . chr(10) . '        PlArray arr = new PlArray();' . chr(10) . '        arr.set(strings);' . chr(10) . '        this.each_iterator = arr.each_iterator;' . chr(10) . '        this.a = arr.a;' . chr(10) . '    }' . chr(10) . chr(10) . '    public PlObject set(Map<String, String> env) {' . chr(10) . '        this.a.clear();' . chr(10) . '        for (String envName : env.keySet()) {' . chr(10) . '            this.a.add(new PlString(envName));' . chr(10) . '            this.a.add(new PlString(env.get(envName)));' . chr(10) . '        }' . chr(10) . '        this.each_iterator = 0;' . chr(10) . '        return this;' . chr(10) . '    }' . chr(10) . '    public PlArray(Map<String, String> strings) {' . chr(10) . '        PlArray arr = new PlArray();' . chr(10) . '        arr.set(strings);' . chr(10) . '        this.each_iterator = arr.each_iterator;' . chr(10) . '        this.a = arr.a;' . chr(10) . '    }' . chr(10) . chr(10) . '    // TODO - Double[]' . chr(10) . join('', (map {
                    my $class = $java_classes{$_};
                    my $java_class_name = $class->{'java_type'};
                    my $perl_to_java = $class->{'perl_to_java'};
                    my $perl_package = $class->{'perl_package'};
                    my $java_native_to_perl = $class->{'java_native_to_perl'};
                    $class->{'import'} || $class->{'extends'} || $class->{'implements'} ? '    public PlObject set(' . $java_class_name . '[] stuffs) {' . chr(10) . '        this.a.clear();' . chr(10) . '        // @x = ' . $java_class_name . '[] native;' . chr(10) . '        for(' . $java_class_name . ' i : stuffs){' . chr(10) . '            this.a.add(new ' . $java_native_to_perl . '(i));' . chr(10) . '        }' . chr(10) . '        this.each_iterator = 0;' . chr(10) . '        return this;' . chr(10) . '    }' . chr(10) . '    public PlArray(' . $java_class_name . '[] stuffs) {' . chr(10) . '        PlArray aa = new PlArray();' . chr(10) . '        aa.set(stuffs);' . chr(10) . '        this.each_iterator = aa.each_iterator;' . chr(10) . '        this.a = aa.a;' . chr(10) . '    }' . chr(10) : ()
                } sort {
                    $a cmp $b
                } keys(%java_classes))) . '    public PlObject aget(PlObject i) {' . chr(10) . '        int pos  = i.to_int();' . chr(10) . '        if (pos < 0) {' . chr(10) . '            pos = this.a.size() + pos;' . chr(10) . '        }' . chr(10) . '        if (pos < 0 || pos >= this.a.size()) {' . chr(10) . '            return PlCx.UNDEF;' . chr(10) . '        }' . chr(10) . '        return this.a.get(pos);' . chr(10) . '    }' . chr(10) . '    public PlObject aget(int i) {' . chr(10) . '        int pos  = i;' . chr(10) . '        if (pos < 0) {' . chr(10) . '            pos = this.a.size() + pos;' . chr(10) . '        }' . chr(10) . '        if (pos < 0 || pos >= this.a.size()) {' . chr(10) . '            return PlCx.UNDEF;' . chr(10) . '        }' . chr(10) . '        return this.a.get(pos);' . chr(10) . '    }' . chr(10) . '    public PlObject aget_lvalue(int pos) {' . chr(10) . '        int size = this.a.size();' . chr(10) . '        if (pos < 0) {' . chr(10) . '            pos = size + pos;' . chr(10) . '        }' . chr(10) . '        if (size <= pos) {' . chr(10) . '            while (size < pos) {' . chr(10) . '                this.a.add( PlCx.UNDEF );' . chr(10) . '                size++;' . chr(10) . '            }' . chr(10) . '            PlLvalue a = new PlLvalue();' . chr(10) . '            this.a.add(a);' . chr(10) . '            return a;' . chr(10) . '        }' . chr(10) . '        PlObject o = this.a.get(pos);' . chr(10) . '        if (o == null) {' . chr(10) . '            PlLvalue a = new PlLvalue();' . chr(10) . '            this.a.set(pos, a);' . chr(10) . '            return a;' . chr(10) . '        }' . chr(10) . '        else if (o.is_lvalue()) {' . chr(10) . '            return o;' . chr(10) . '        }' . chr(10) . '        PlLvalue a = new PlLvalue(o);' . chr(10) . '        this.a.set(pos, a);' . chr(10) . '        return a;' . chr(10) . '    }' . chr(10) . '    public PlObject aget_lvalue(PlObject i) {' . chr(10) . '        return this.aget_lvalue(i.to_int());' . chr(10) . '    }' . chr(10) . '    public PlObject aget_lvalue_local(PlObject i) {' . chr(10) . '        return this.aget_lvalue_local(i.to_int());' . chr(10) . '    }' . chr(10) . '    public PlObject aget_lvalue_local(int i) {' . chr(10) . '        return PerlOp.push_local(this, i);' . chr(10) . '    }' . chr(10) . chr(10) . '    public PlObject get_scalar(PlObject i) {' . chr(10) . '        // $$x' . chr(10) . '        PlObject o = this.aget(i);' . chr(10) . '        if (o.is_undef()) {' . chr(10) . '            PlLvalue a = new PlLvalue();' . chr(10) . '            this.aset(i, new PlLvalueRef(a));' . chr(10) . '            return a;' . chr(10) . '        }' . chr(10) . '        else if (o.is_scalarref()) {' . chr(10) . '            return o.get();' . chr(10) . '        }' . chr(10) . '        // Modification of a read-only value attempted' . chr(10) . '        // return PlCORE.die("Not an SCALAR reference");' . chr(10) . '        return o;' . chr(10) . '    }' . chr(10) . '    public PlObject aget_scalarref(PlObject i) {' . chr(10) . '        PlObject o = this.aget(i);' . chr(10) . '        if (o.is_undef()) {' . chr(10) . '            PlLvalueRef ar = new PlLvalueRef(new PlLvalue());' . chr(10) . '            this.aset(i, ar);' . chr(10) . '            return ar;' . chr(10) . '        }' . chr(10) . '        else if (o.is_scalarref()) {' . chr(10) . '            return o;' . chr(10) . '        }' . chr(10) . '        return PlCORE.die("Not a SCALAR reference");' . chr(10) . '    }' . chr(10) . '    public PlObject aget_scalarref(int i) {' . chr(10) . '        PlObject o = this.aget(i);' . chr(10) . '        if (o.is_undef()) {' . chr(10) . '            PlLvalueRef ar = new PlLvalueRef(new PlLvalue());' . chr(10) . '            this.aset(i, ar);' . chr(10) . '            return ar;' . chr(10) . '        }' . chr(10) . '        else if (o.is_scalarref()) {' . chr(10) . '            return o;' . chr(10) . '        }' . chr(10) . '        return PlCORE.die("Not a SCALAR reference");' . chr(10) . '    }' . chr(10) . chr(10) . '    public PlObject aget_arrayref(PlObject i) {' . chr(10) . '        PlObject o = this.aget(i);' . chr(10) . '        if (o.is_undef()) {' . chr(10) . '            PlArrayRef ar = new PlArrayRef();' . chr(10) . '            this.aset(i, ar);' . chr(10) . '            return ar;' . chr(10) . '        }' . chr(10) . '        else if (o.is_arrayref()) {' . chr(10) . '            return o;' . chr(10) . '        }' . chr(10) . '        return PlCORE.die("Not an ARRAY reference");' . chr(10) . '    }' . chr(10) . '    public PlObject aget_arrayref(int i) {' . chr(10) . '        PlObject o = this.aget(i);' . chr(10) . '        if (o.is_undef()) {' . chr(10) . '            PlArrayRef ar = new PlArrayRef();' . chr(10) . '            this.aset(i, ar);' . chr(10) . '            return ar;' . chr(10) . '        }' . chr(10) . '        else if (o.is_arrayref()) {' . chr(10) . '            return o;' . chr(10) . '        }' . chr(10) . '        return PlCORE.die("Not an ARRAY reference");' . chr(10) . '    }' . chr(10) . chr(10) . '    public PlObject aget_hashref(PlObject i) {' . chr(10) . '        PlObject o = this.aget(i);' . chr(10) . '        if (o.is_undef()) {' . chr(10) . '            PlHashRef hr = new PlHashRef();' . chr(10) . '            this.aset(i, hr);' . chr(10) . '            return hr;' . chr(10) . '        }' . chr(10) . '        else if (o.is_hashref()) {' . chr(10) . '            return o;' . chr(10) . '        }' . chr(10) . '        return PlCORE.die("Not a HASH reference");' . chr(10) . '    }' . chr(10) . '    public PlObject aget_hashref(int i) {' . chr(10) . '        PlObject o = this.aget(i);' . chr(10) . '        if (o.is_undef()) {' . chr(10) . '            PlHashRef hr = new PlHashRef();' . chr(10) . '            this.aset(i, hr);' . chr(10) . '            return hr;' . chr(10) . '        }' . chr(10) . '        else if (o.is_hashref()) {' . chr(10) . '            return o;' . chr(10) . '        }' . chr(10) . '        return PlCORE.die("Not a HASH reference");' . chr(10) . '    }' . chr(10) . chr(10) . '    public PlObject get_hash(int i) {' . chr(10) . '        PlObject o = this.aget(i);' . chr(10) . '        if (o.is_undef()) {' . chr(10) . '            PlHashRef hr = new PlHashRef();' . chr(10) . '            this.aset(i, hr);' . chr(10) . '            return hr;' . chr(10) . '        }' . chr(10) . '        else if (o.is_hashref()) {' . chr(10) . '            return o;' . chr(10) . '        }' . chr(10) . '        return PlCORE.die("Not a HASH reference");' . chr(10) . '    }' . chr(10) . chr(10) . '    // Note: multiple versions of set()' . chr(10) . '    public PlObject aset(PlObject i, PlObject v) {' . chr(10) . '        int size = this.a.size();' . chr(10) . '        int pos  = i.to_int();' . chr(10) . '        if (pos < 0) {' . chr(10) . '            pos = size + pos;' . chr(10) . '        }' . chr(10) . '        if (size <= pos) {' . chr(10) . '            while (size < pos) {' . chr(10) . '                this.a.add( PlCx.UNDEF );' . chr(10) . '                size++;' . chr(10) . '            }' . chr(10) . '            this.a.add(v.scalar());' . chr(10) . '            return v;' . chr(10) . '        }' . chr(10) . '        this.a.set(pos, v.scalar());' . chr(10) . '        return v;' . chr(10) . '    }' . chr(10) . '    public PlObject aset(int i, PlObject v) {' . chr(10) . '        int size = this.a.size();' . chr(10) . '        int pos  = i;' . chr(10) . '        if (pos < 0) {' . chr(10) . '            pos = size + pos;' . chr(10) . '        }' . chr(10) . '        if (size <= pos) {' . chr(10) . '            while (size < pos) {' . chr(10) . '                this.a.add( PlCx.UNDEF );' . chr(10) . '                size++;' . chr(10) . '            }' . chr(10) . '            this.a.add(v.scalar());' . chr(10) . '            return v;' . chr(10) . '        }' . chr(10) . '        this.a.set(pos, v.scalar());' . chr(10) . '        return v;' . chr(10) . '    }' . chr(10) . '    public PlObject aset(PlObject i, PlLvalue v) {' . chr(10) . '        int size = this.a.size();' . chr(10) . '        int pos  = i.to_int();' . chr(10) . '        if (pos < 0) {' . chr(10) . '            pos = size + pos;' . chr(10) . '        }' . chr(10) . '        if (size <= pos) {' . chr(10) . '            while (size < pos) {' . chr(10) . '                this.a.add( PlCx.UNDEF );' . chr(10) . '                size++;' . chr(10) . '            }' . chr(10) . '            this.a.add(v.scalar());' . chr(10) . '            return v;' . chr(10) . '        }' . chr(10) . '        this.a.set(pos, v.get());' . chr(10) . '        return v;' . chr(10) . '    }' . chr(10) . '    public PlObject aset(int i, PlLvalue v) {' . chr(10) . '        int size = this.a.size();' . chr(10) . '        int pos  = i;' . chr(10) . '        if (pos < 0) {' . chr(10) . '            pos = size + pos;' . chr(10) . '        }' . chr(10) . '        if (size <= pos) {' . chr(10) . '            while (size < pos) {' . chr(10) . '                this.a.add( PlCx.UNDEF );' . chr(10) . '                size++;' . chr(10) . '            }' . chr(10) . '            this.a.add(v.scalar());' . chr(10) . '            return v;' . chr(10) . '        }' . chr(10) . '        this.a.set(pos, v.get());' . chr(10) . '        return v;' . chr(10) . '    }' . chr(10) . (join('', map {
                    my $native = $_;
                    my $perl = $native_to_perl{$native};
                    $native && $perl ? '    public PlObject aset(PlObject i, ' . $native . ' s) {' . chr(10) . '        return this.aset(i, new ' . $perl . '(s));' . chr(10) . '    }' . chr(10) . '    public PlObject aset(int i, ' . $native . ' s) {' . chr(10) . '        return this.aset(i, new ' . $perl . '(s));' . chr(10) . '    }' . chr(10) . '    public PlObject push(' . $native . ' s) {' . chr(10) . '        this.a.add(new ' . $perl . '(s));' . chr(10) . '        return this.length_of_array();' . chr(10) . '    }' . chr(10) : ()
                } sort {
                    $a cmp $b
                } keys(%native_to_perl))) . chr(10) . '    // Note: multiple versions of push()' . chr(10) . '    public PlObject push(PlObject v) {' . chr(10) . '        if (v.is_array()) {' . chr(10) . '            return this.push( (PlArray)v );' . chr(10) . '        }' . chr(10) . '        this.a.add(v.scalar());' . chr(10) . '        return this.length_of_array();' . chr(10) . '    }' . chr(10) . '    public PlObject push(PlLvalue v) {' . chr(10) . '        this.a.add(v.get());' . chr(10) . '        return this.length_of_array();' . chr(10) . '    }' . chr(10) . '    public PlObject push(PlArray args) {' . chr(10) . '        for (int i = 0; i < args.to_int(); i++) {' . chr(10) . '            PlObject s = args.aget(i);' . chr(10) . '            if (s.is_hash()) {' . chr(10) . '                // @x = %x;' . chr(10) . '                s = s.to_array();' . chr(10) . '            }' . chr(10) . '            if (s.is_array()) {' . chr(10) . '                this.push(s);' . chr(10) . '            }' . chr(10) . '            else {' . chr(10) . '                this.a.add(s);' . chr(10) . '            }' . chr(10) . '        }' . chr(10) . '        return this.length_of_array();' . chr(10) . '    }' . chr(10) . chr(10) . '    // Note: multiple versions of unshift()' . chr(10) . '    public PlObject unshift(PlObject v) {' . chr(10) . '        if (v.is_array()) {' . chr(10) . '            return this.unshift( (PlArray)v );' . chr(10) . '        }' . chr(10) . '        this.a.add(0, v.scalar());' . chr(10) . '        return this.length_of_array();' . chr(10) . '    }' . chr(10) . '    public PlObject unshift(PlLvalue v) {' . chr(10) . '        this.a.add(0, v.get());' . chr(10) . '        return this.length_of_array();' . chr(10) . '    }' . chr(10) . '    public PlObject unshift(PlArray args) {' . chr(10) . '        for (int i = args.to_int() - 1; i >= 0; i--) {' . chr(10) . '            PlObject s = args.aget(i);' . chr(10) . '            if (s.is_hash()) {' . chr(10) . '                // @x = %x;' . chr(10) . '                s = s.to_array();' . chr(10) . '            }' . chr(10) . '            if (s.is_array()) {' . chr(10) . '                this.unshift(s);' . chr(10) . '            }' . chr(10) . '            else {' . chr(10) . '                this.a.add(0, s);' . chr(10) . '            }' . chr(10) . '        }' . chr(10) . '        return this.length_of_array();' . chr(10) . '    }' . chr(10) . chr(10) . '    public PlObject pop() {' . chr(10) . '        int size = this.a.size() - 1;' . chr(10) . '        if (size >= 0) {' . chr(10) . '            return this.a.remove(size);' . chr(10) . '        }' . chr(10) . '        else {' . chr(10) . '            return PlCx.UNDEF;' . chr(10) . '        }' . chr(10) . '    }' . chr(10) . '    public PlObject shift() {' . chr(10) . '        int size = this.a.size();' . chr(10) . '        if (size > 0) {' . chr(10) . '            return this.a.remove(0);' . chr(10) . '        }' . chr(10) . '        else {' . chr(10) . '            return PlCx.UNDEF;' . chr(10) . '        }' . chr(10) . '    }' . chr(10) . '    public PlObject exists(PlObject i) {' . chr(10) . '        PlCORE.die("TODO - array exists");' . chr(10) . '        return this;' . chr(10) . '    }' . chr(10) . '    public PlObject delete(PlObject i) {' . chr(10) . '        PlCORE.die("TODO - array delete");' . chr(10) . '        return this;' . chr(10) . '    }' . chr(10) . '    public PlObject values() {' . chr(10) . '        // return a copy' . chr(10) . '        return new PlArray(this);' . chr(10) . '    }' . chr(10) . '    public PlObject keys() {' . chr(10) . '        PlArray aa = new PlArray();' . chr(10) . '        int size = this.a.size();' . chr(10) . '        for (int i = 0; i < size; i++) {' . chr(10) . '            aa.push(new PlInt(i));' . chr(10) . '        }' . chr(10) . '        return aa;' . chr(10) . '    }' . chr(10) . '    public PlObject each() {' . chr(10) . '        PlArray aa = new PlArray();' . chr(10) . '        int size = this.a.size();' . chr(10) . '        if (this.each_iterator < size) {' . chr(10) . '            aa.push(new PlInt(this.each_iterator));' . chr(10) . '            aa.push(this.aget(this.each_iterator));' . chr(10) . '            this.each_iterator++;' . chr(10) . '        }' . chr(10) . '        else {' . chr(10) . '            // return empty list' . chr(10) . '            this.each_iterator = 0;' . chr(10) . '        }' . chr(10) . '        return aa;' . chr(10) . '    }' . chr(10) . '    public String toString() {' . chr(10) . '        StringBuilder sb = new StringBuilder();' . chr(10) . '        int size = this.a.size();' . chr(10) . '        for (int i = 0; i < size; i++) {' . chr(10) . '            String item = this.a.get(i).toString();' . chr(10) . '            sb.append(item);' . chr(10) . '        }' . chr(10) . '        return sb.toString();' . chr(10) . '    }' . chr(10) . '    public long to_long() {' . chr(10) . '        return this.a.size();' . chr(10) . '    }' . chr(10) . '    public int to_int() {' . chr(10) . '        return this.a.size();' . chr(10) . '    }' . chr(10) . '    public PlObject length_of_array() {' . chr(10) . '        return new PlInt(this.a.size());' . chr(10) . '    }' . chr(10) . '    public PlObject end_of_array_index() {' . chr(10) . '        return new PlInt(this.a.size() - 1);' . chr(10) . '    }' . chr(10) . '    public double to_double() {' . chr(10) . '        return 0.0 + this.to_long();' . chr(10) . '    }' . chr(10) . '    public boolean to_bool() {' . chr(10) . '        return (this.a.size() > 0);' . chr(10) . '    }' . chr(10) . '    public boolean is_int() {' . chr(10) . '        return false;' . chr(10) . '    }' . chr(10) . '    public boolean is_num() {' . chr(10) . '        return false;' . chr(10) . '    }' . chr(10) . '    public boolean is_string() {' . chr(10) . '        return false;' . chr(10) . '    }' . chr(10) . '    public boolean is_bool() {' . chr(10) . '        return false;' . chr(10) . '    }' . chr(10) . '    public boolean is_array() {' . chr(10) . '        return true;' . chr(10) . '    }' . chr(10) . '    public PlObject scalar() {' . chr(10) . '        return this.length_of_array();' . chr(10) . '    }' . chr(10) . '}' . chr(10) . 'class PlHash extends PlObject {' . chr(10) . '    public HashMap<String, PlObject> h;' . chr(10) . '    public Iterator<Map.Entry<String, PlObject>> each_iterator;' . chr(10) . chr(10) . '    public PlHash() {' . chr(10) . '        this.each_iterator = null;' . chr(10) . '        this.h = new HashMap<String, PlObject>();' . chr(10) . '    }' . chr(10) . '    public PlHash(PlObject... args) {' . chr(10) . '        PlHash hh = new PlHash();' . chr(10) . '        int args_size = args.length;' . chr(10) . '        for (int i = 0; i < args_size; i++) {' . chr(10) . '            PlObject s = args[i];' . chr(10) . '            if (s.is_hash()) {' . chr(10) . '                // @x = %x;' . chr(10) . '                s = s.to_array();' . chr(10) . '            }' . chr(10) . '            if (s.is_array()) {' . chr(10) . '                // %x = ( @x, @y );' . chr(10) . '                int array_size = s.to_int();' . chr(10) . '                for (int j = 0; j < array_size; j++) {' . chr(10) . '                    PlObject key = s.aget(j);' . chr(10) . '                    j++;' . chr(10) . '                    PlObject value;' . chr(10) . '                    if ( j >= array_size ) {' . chr(10) . '                        // TODO - emit warning about odd number of arguments' . chr(10) . '                        value = PlCx.UNDEF;' . chr(10) . '                    }' . chr(10) . '                    else {' . chr(10) . '                        value = s.aget(j);' . chr(10) . '                    }' . chr(10) . '                    hh.hset(key, value);' . chr(10) . '                }' . chr(10) . '            }' . chr(10) . '            else {' . chr(10) . '                i++;' . chr(10) . '                PlObject value;' . chr(10) . '                if ( i >= args_size ) {' . chr(10) . '                    // TODO - emit warning about odd number of arguments' . chr(10) . '                    value = PlCx.UNDEF;' . chr(10) . '                }' . chr(10) . '                else {' . chr(10) . '                    value = args[i];' . chr(10) . '                }' . chr(10) . '                hh.hset(s, value);' . chr(10) . '            }' . chr(10) . '        }' . chr(10) . '        this.each_iterator = null;' . chr(10) . '        this.h = hh.to_HashMap();' . chr(10) . '    }' . chr(10) . '    private HashMap<String, PlObject> to_HashMap() {' . chr(10) . '        return this.h;' . chr(10) . '    }' . chr(10) . '    public PlObject set(PlObject s) {' . chr(10) . '        this.h.clear();' . chr(10) . '        if (s.is_hash()) {' . chr(10) . '            // @x = %x;' . chr(10) . '            s = s.to_array();' . chr(10) . '        }' . chr(10) . '        if (s.is_array()) {' . chr(10) . '            // %x = ( @x, @y );' . chr(10) . '            int array_size = s.to_int();' . chr(10) . '            for (int j = 0; j < array_size; j++) {' . chr(10) . '                PlObject key = s.aget(j);' . chr(10) . '                j++;' . chr(10) . '                PlObject value;' . chr(10) . '                if ( j >= array_size ) {' . chr(10) . '                    // TODO - emit warning about odd number of arguments' . chr(10) . '                    value = PlCx.UNDEF;' . chr(10) . '                }' . chr(10) . '                else {' . chr(10) . '                    value = s.aget(j);' . chr(10) . '                }' . chr(10) . '                this.hset(key, value);' . chr(10) . '            }' . chr(10) . '        }' . chr(10) . '        else {' . chr(10) . '            // TODO - emit warning about odd number of arguments' . chr(10) . '            this.hset(s, PlCx.UNDEF);' . chr(10) . '        }' . chr(10) . '        this.each_iterator = null;' . chr(10) . '        return this;' . chr(10) . '    }' . chr(10) . chr(10) . '    public PlObject to_array() {' . chr(10) . '        PlArray aa = new PlArray();' . chr(10) . '        for (Map.Entry<String, PlObject> entry : this.h.entrySet()) {' . chr(10) . '            String key = entry.getKey();' . chr(10) . '            PlObject value = entry.getValue();' . chr(10) . '            aa.push(new PlString(key));' . chr(10) . '            aa.push(value);' . chr(10) . '        }' . chr(10) . '        return aa;' . chr(10) . '    }' . chr(10) . chr(10) . '    public PlObject hget(PlObject i) {' . chr(10) . '        PlObject o = this.h.get(i.toString());' . chr(10) . '        if (o == null) {' . chr(10) . '            return PlCx.UNDEF;' . chr(10) . '        }' . chr(10) . '        return o;' . chr(10) . '    }' . chr(10) . '    public PlObject hget(String i) {' . chr(10) . '        PlObject o = this.h.get(i);' . chr(10) . '        if (o == null) {' . chr(10) . '            return PlCx.UNDEF;' . chr(10) . '        }' . chr(10) . '        return o;' . chr(10) . '    }' . chr(10) . '    public PlObject hget(int want, PlArray a) {' . chr(10) . '        PlArray aa = new PlArray();' . chr(10) . chr(10) . '        for (int i = 0; i < a.to_int(); i++) {' . chr(10) . '            PlObject r = this.hget(a.aget(i));' . chr(10) . '            aa.push(r);' . chr(10) . '        }' . chr(10) . '        if (want == PlCx.LIST) {' . chr(10) . '            return aa;' . chr(10) . '        }' . chr(10) . '        return aa.pop();' . chr(10) . '    }' . chr(10) . chr(10) . '    public PlObject hget_lvalue(PlObject i) {' . chr(10) . '        PlObject o = this.h.get(i.toString());' . chr(10) . '        if (o == null) {' . chr(10) . '            PlLvalue a = new PlLvalue();' . chr(10) . '            this.h.put(i.toString(), a);' . chr(10) . '            return a;' . chr(10) . '        }' . chr(10) . '        else if (o.is_lvalue()) {' . chr(10) . '            return o;' . chr(10) . '        }' . chr(10) . '        PlLvalue a = new PlLvalue(o);' . chr(10) . '        this.h.put(i.toString(), a);' . chr(10) . '        return a;' . chr(10) . '    }' . chr(10) . '    public PlObject hget_lvalue(String i) {' . chr(10) . '        PlObject o = this.h.get(i);' . chr(10) . '        if (o == null) {' . chr(10) . '            PlLvalue a = new PlLvalue();' . chr(10) . '            this.h.put(i, a);' . chr(10) . '            return a;' . chr(10) . '        }' . chr(10) . '        else if (o.is_lvalue()) {' . chr(10) . '            return o;' . chr(10) . '        }' . chr(10) . '        PlLvalue a = new PlLvalue(o);' . chr(10) . '        this.h.put(i, a);' . chr(10) . '        return a;' . chr(10) . '    }' . chr(10) . '    public PlObject hget_lvalue_local(PlObject i) {' . chr(10) . '        return this.hget_lvalue_local(i.toString());' . chr(10) . '    }' . chr(10) . '    public PlObject hget_lvalue_local(String i) {' . chr(10) . '        return PerlOp.push_local(this, i);' . chr(10) . '    }' . chr(10) . chr(10) . '    public PlObject get_scalar(PlObject i) {' . chr(10) . '        // $$x' . chr(10) . '        PlObject o = this.hget(i);' . chr(10) . '        if (o.is_undef()) {' . chr(10) . '            PlLvalue a = new PlLvalue();' . chr(10) . '            this.hset(i, new PlLvalueRef(a));' . chr(10) . '            return a;' . chr(10) . '        }' . chr(10) . '        else if (o.is_scalarref()) {' . chr(10) . '            return o.get();' . chr(10) . '        }' . chr(10) . '        // Modification of a read-only value attempted' . chr(10) . '        // return PlCORE.die("Not an SCALAR reference");' . chr(10) . '        return o;' . chr(10) . '    }' . chr(10) . chr(10) . '    public PlObject hget_scalarref(PlObject i) {' . chr(10) . '        PlObject o = this.hget(i);' . chr(10) . '        if (o.is_undef()) {' . chr(10) . '            PlLvalueRef ar = new PlLvalueRef(new PlLvalue());' . chr(10) . '            this.hset(i, ar);' . chr(10) . '            return ar;' . chr(10) . '        }' . chr(10) . '        else if (o.is_scalarref()) {' . chr(10) . '            return o;' . chr(10) . '        }' . chr(10) . '        // Modification of a read-only value attempted' . chr(10) . '        return o;' . chr(10) . '    }' . chr(10) . '    public PlObject hget_scalarref(String i) {' . chr(10) . '        PlObject o = this.hget(i);' . chr(10) . '        if (o.is_undef()) {' . chr(10) . '            PlLvalueRef ar = new PlLvalueRef(new PlLvalue());' . chr(10) . '            this.hset(i, ar);' . chr(10) . '            return ar;' . chr(10) . '        }' . chr(10) . '        else if (o.is_scalarref()) {' . chr(10) . '            return o;' . chr(10) . '        }' . chr(10) . '        // Modification of a read-only value attempted' . chr(10) . '        return o;' . chr(10) . '    }' . chr(10) . chr(10) . '    public PlObject hget_arrayref(PlObject i) {' . chr(10) . '        PlObject o = this.hget(i);' . chr(10) . '        if (o.is_undef()) {' . chr(10) . '            PlArrayRef ar = new PlArrayRef();' . chr(10) . '            this.hset(i, ar);' . chr(10) . '            return ar;' . chr(10) . '        }' . chr(10) . '        else if (o.is_arrayref()) {' . chr(10) . '            return o;' . chr(10) . '        }' . chr(10) . '        return PlCORE.die("Not an ARRAY reference");' . chr(10) . '    }' . chr(10) . '    public PlObject hget_arrayref(String i) {' . chr(10) . '        PlObject o = this.hget(i);' . chr(10) . '        if (o.is_undef()) {' . chr(10) . '            PlArrayRef ar = new PlArrayRef();' . chr(10) . '            this.hset(i, ar);' . chr(10) . '            return ar;' . chr(10) . '        }' . chr(10) . '        else if (o.is_arrayref()) {' . chr(10) . '            return o;' . chr(10) . '        }' . chr(10) . '        return PlCORE.die("Not an ARRAY reference");' . chr(10) . '    }' . chr(10) . chr(10) . '    public PlObject hget_hashref(PlObject i) {' . chr(10) . '        PlObject o = this.hget(i);' . chr(10) . '        if (o.is_undef()) {' . chr(10) . '            PlHashRef hr = new PlHashRef();' . chr(10) . '            this.hset(i, hr);' . chr(10) . '            return hr;' . chr(10) . '        }' . chr(10) . '        else if (o.is_hashref()) {' . chr(10) . '            return o;' . chr(10) . '        }' . chr(10) . '        return PlCORE.die("Not a HASH reference");' . chr(10) . '    }' . chr(10) . '    public PlObject hget_hashref(String i) {' . chr(10) . '        PlObject o = this.hget(i);' . chr(10) . '        if (o.is_undef()) {' . chr(10) . '            PlHashRef hr = new PlHashRef();' . chr(10) . '            this.hset(i, hr);' . chr(10) . '            return hr;' . chr(10) . '        }' . chr(10) . '        else if (o.is_hashref()) {' . chr(10) . '            return o;' . chr(10) . '        }' . chr(10) . '        return PlCORE.die("Not a HASH reference");' . chr(10) . '    }' . chr(10) . chr(10) . '    // Note: multiple versions of set()' . chr(10) . '    public PlObject hset(PlObject s, PlObject v) {' . chr(10) . '        String key = s.toString();' . chr(10) . '        PlObject value = v.scalar();' . chr(10) . '        PlObject o = this.h.get(key);' . chr(10) . '        if (o != null && o.is_lvalue()) {' . chr(10) . '            o.set(value);' . chr(10) . '        }' . chr(10) . '        else {' . chr(10) . '            this.h.put(key, value);' . chr(10) . '        }' . chr(10) . '        return v;' . chr(10) . '    }' . chr(10) . '    public PlObject hset(String key, PlObject v) {' . chr(10) . '        PlObject value = v.scalar();' . chr(10) . '        PlObject o = this.h.get(key);' . chr(10) . '        if (o != null && o.is_lvalue()) {' . chr(10) . '            o.set(value);' . chr(10) . '        }' . chr(10) . '        else {' . chr(10) . '            this.h.put(key, value);' . chr(10) . '        }' . chr(10) . '        return v;' . chr(10) . '    }' . chr(10) . '    public PlObject hset(PlObject s, PlLvalue v) {' . chr(10) . '        return this.hset(s, v.get());' . chr(10) . '    }' . chr(10) . '    public PlObject hset(String s, PlLvalue v) {' . chr(10) . '        return this.hset(s, v.get());' . chr(10) . '    }' . chr(10) . '    public PlObject hset(int want, PlArray s, PlArray v) {' . chr(10) . '        PlArray aa = new PlArray();' . chr(10) . chr(10) . '        for (int i = 0; i < v.to_int(); i++){' . chr(10) . '            aa.push(this.hset(v.aget(i), s.aget(i)));' . chr(10) . '        };' . chr(10) . '        if (want == PlCx.LIST) {' . chr(10) . '            return aa;' . chr(10) . '        }' . chr(10) . '        return aa.pop();' . chr(10) . '    }' . chr(10) . '    public PlObject exists(PlObject i) {' . chr(10) . '        return this.h.containsKey(i.toString()) ? PlCx.TRUE : PlCx.FALSE;' . chr(10) . '    }' . chr(10) . '    public PlObject delete(PlObject i) {' . chr(10) . '        PlObject r = this.h.remove(i.toString());' . chr(10) . '        if (r == null) {' . chr(10) . '            return PlCx.UNDEF;' . chr(10) . '        }' . chr(10) . '        return r;' . chr(10) . '    }' . chr(10) . '    public PlObject delete(int want, PlArray a) {' . chr(10) . '        PlArray aa = new PlArray();' . chr(10) . chr(10) . '        for (int i = 0; i < a.to_int(); i++) {' . chr(10) . '            PlObject r = this.delete(a.aget(i));' . chr(10) . '            aa.push(r);' . chr(10) . '        }' . chr(10) . '        if (want == PlCx.LIST) {' . chr(10) . '            return aa;' . chr(10) . '        }' . chr(10) . '        return aa.pop();' . chr(10) . '    }' . chr(10) . '    public PlObject delete(int want, PlString a) {' . chr(10) . '        PlArray aa = new PlArray();' . chr(10) . '        aa.push(a);' . chr(10) . '        return delete(want, aa);' . chr(10) . '    }' . chr(10) . '    public PlObject values() {' . chr(10) . '        PlArray aa = new PlArray();' . chr(10) . '        for (Map.Entry<String, PlObject> entry : this.h.entrySet()) {' . chr(10) . '            PlObject value = entry.getValue();' . chr(10) . '            aa.push(value);' . chr(10) . '        }' . chr(10) . '        return aa;' . chr(10) . '    }' . chr(10) . '    public PlObject keys() {' . chr(10) . '        PlArray aa = new PlArray();' . chr(10) . '        for (Map.Entry<String, PlObject> entry : this.h.entrySet()) {' . chr(10) . '            String key = entry.getKey();' . chr(10) . '            aa.push(new PlString(key));' . chr(10) . '        }' . chr(10) . '        return aa;' . chr(10) . '    }' . chr(10) . '    public PlObject each() {' . chr(10) . '        if (this.each_iterator == null) {' . chr(10) . '            this.each_iterator = this.h.entrySet().iterator();' . chr(10) . '        }' . chr(10) . '        PlArray aa = new PlArray();' . chr(10) . '        if (this.each_iterator.hasNext()) {' . chr(10) . '            Map.Entry<String, PlObject> entry = this.each_iterator.next();' . chr(10) . '            String key = entry.getKey();' . chr(10) . '            aa.push(new PlString(key));' . chr(10) . '            PlObject value = entry.getValue();' . chr(10) . '            aa.push(value);' . chr(10) . '        }' . chr(10) . '        else {' . chr(10) . '             // return empty list' . chr(10) . '             this.each_iterator = null;' . chr(10) . '        }' . chr(10) . '        return aa;' . chr(10) . '    }' . chr(10) . (join('', map {
                    my $native = $_;
                    my $perl = $native_to_perl{$native};
                    $native && $perl ? '    public PlObject hset(PlObject s, ' . $native . ' v) {' . chr(10) . '        return this.hset(s, new ' . $perl . '(v));' . chr(10) . '    }' . chr(10) . '    public PlObject hset(String s, ' . $native . ' v) {' . chr(10) . '        return this.hset(s, new ' . $perl . '(v));' . chr(10) . '    }' . chr(10) : ()
                } sort {
                    $a cmp $b
                } keys(%native_to_perl))) . chr(10) . '    public String toString() {' . chr(10) . '        // TODO' . chr(10) . '        return "" + this.hashCode();' . chr(10) . '    }' . chr(10) . '    public long to_long() {' . chr(10) . '        // TODO' . chr(10) . '        return this.hashCode();' . chr(10) . '    }' . chr(10) . '    public double to_double() {' . chr(10) . '        return 0.0 + this.to_long();' . chr(10) . '    }' . chr(10) . '    public boolean to_bool() {' . chr(10) . '        return true;' . chr(10) . '    }' . chr(10) . '    public boolean is_int() {' . chr(10) . '        return false;' . chr(10) . '    }' . chr(10) . '    public boolean is_num() {' . chr(10) . '        return false;' . chr(10) . '    }' . chr(10) . '    public boolean is_string() {' . chr(10) . '        return false;' . chr(10) . '    }' . chr(10) . '    public boolean is_bool() {' . chr(10) . '        return false;' . chr(10) . '    }' . chr(10) . '    public boolean is_hash() {' . chr(10) . '        return true;' . chr(10) . '    }' . chr(10) . '    public PlObject scalar() {' . chr(10) . '        return new PlString(this.toString());' . chr(10) . '    }' . chr(10) . '}' . chr(10) . 'class PlUndef extends PlObject {' . chr(10) . '    public PlUndef() {' . chr(10) . '    }' . chr(10) . '    public PlObject apply(int want, PlArray List__) {' . chr(10) . '        // $a->()' . chr(10) . '        PlCORE.die("Can' . chr(39) . 't use an undefined value as a subroutine reference");' . chr(10) . '        return this;' . chr(10) . '    }' . chr(10) . '    public PlObject length() {' . chr(10) . '        return PlCx.UNDEF;' . chr(10) . '    }' . chr(10) . '    public long to_long() {' . chr(10) . '        return 0;' . chr(10) . '    }' . chr(10) . '    public double to_double() {' . chr(10) . '        return 0.0;' . chr(10) . '    }' . chr(10) . '    public String toString() {' . chr(10) . '        return "";' . chr(10) . '    }' . chr(10) . '    public boolean to_bool() {' . chr(10) . '        return false;' . chr(10) . '    }' . chr(10) . '    public boolean is_bool() {' . chr(10) . '        return false;' . chr(10) . '    }' . chr(10) . '    public boolean is_undef() {' . chr(10) . '        return true;' . chr(10) . '    }' . chr(10) . '}' . chr(10) . 'class PlBool extends PlObject {' . chr(10) . '    private boolean i;' . chr(10) . '    public PlBool(boolean i) {' . chr(10) . '        this.i = i;' . chr(10) . '    }' . chr(10) . '    public long to_long() {' . chr(10) . '        if (this.i) {' . chr(10) . '            return 1;' . chr(10) . '        }' . chr(10) . '        else {' . chr(10) . '            return 0;' . chr(10) . '        }' . chr(10) . '    }' . chr(10) . '    public double to_double() {' . chr(10) . '        if (this.i) {' . chr(10) . '            return 1.0;' . chr(10) . '        }' . chr(10) . '        else {' . chr(10) . '            return 0.0;' . chr(10) . '        }' . chr(10) . '    }' . chr(10) . '    public String toString() {' . chr(10) . '        if (this.i) {' . chr(10) . '            return "1";' . chr(10) . '        }' . chr(10) . '        else {' . chr(10) . '            return "";' . chr(10) . '        }' . chr(10) . '    }' . chr(10) . '    public boolean to_bool() {' . chr(10) . '        return this.i;' . chr(10) . '    }' . chr(10) . '    public boolean is_bool() {' . chr(10) . '        return true;' . chr(10) . '    }' . chr(10) . '    public PlObject _decr() {' . chr(10) . '        // --$x' . chr(10) . '        if (i) {' . chr(10) . '            return PlCx.INT0;' . chr(10) . '        }' . chr(10) . '        else {' . chr(10) . '            return PlCx.MIN1;' . chr(10) . '        }' . chr(10) . '    }' . chr(10) . '    public PlObject _incr() {' . chr(10) . '        // ++$x' . chr(10) . '        if (i) {' . chr(10) . '            return new PlInt(2);' . chr(10) . '        }' . chr(10) . '        else {' . chr(10) . '            return PlCx.INT1;' . chr(10) . '        }' . chr(10) . '    }' . chr(10) . '    public PlObject neg() {' . chr(10) . '        if (i) {' . chr(10) . '            return PlCx.MIN1;' . chr(10) . '        }' . chr(10) . '        else {' . chr(10) . '            return PlCx.INT0;' . chr(10) . '        }' . chr(10) . '    }' . chr(10) . '}' . chr(10) . 'class PlInt extends PlObject {' . chr(10) . '    private long i;' . chr(10) . '    public PlInt(long i) {' . chr(10) . '        this.i = i;' . chr(10) . '    }' . chr(10) . '    public PlInt(int i) {' . chr(10) . '        this.i = (long)i;' . chr(10) . '    }' . chr(10) . '    public long to_long() {' . chr(10) . '        return this.i;' . chr(10) . '    }' . chr(10) . '    public double to_double() {' . chr(10) . '        return (double)(this.i);' . chr(10) . '    }' . chr(10) . '    public String toString() {' . chr(10) . '        return "" + this.i;' . chr(10) . '    }' . chr(10) . '    public boolean to_bool() {' . chr(10) . '        return this.i != 0;' . chr(10) . '    }' . chr(10) . '    public boolean is_int() {' . chr(10) . '        return true;' . chr(10) . '    }' . chr(10) . '    public PlObject _decr() {' . chr(10) . '        // --$x' . chr(10) . '        return new PlInt(i-1);' . chr(10) . '    }' . chr(10) . '    public PlObject _incr() {' . chr(10) . '        // ++$x' . chr(10) . '        return new PlInt(i+1);' . chr(10) . '    }' . chr(10) . '    public PlObject neg() {' . chr(10) . '        return new PlInt(-i);' . chr(10) . '    }' . chr(10) . '}' . chr(10) . 'class PlDouble extends PlObject {' . chr(10) . '    private double i;' . chr(10) . '    public PlDouble(double i) {' . chr(10) . '        this.i = i;' . chr(10) . '    }' . chr(10) . '    public long to_long() {' . chr(10) . '        return (long)(this.i);' . chr(10) . '    }' . chr(10) . '    public double to_double() {' . chr(10) . '        return this.i;' . chr(10) . '    }' . chr(10) . '    public String toString() {' . chr(10) . '        String s = "" + this.i;' . chr(10) . '        final int length = s.length();' . chr(10) . '        final int dot = s.indexOf(' . chr(39) . '.' . chr(39) . ');' . chr(10) . '        if (dot == -1) {' . chr(10) . '            return s;' . chr(10) . '        }' . chr(10) . '        for (int i = dot + 1; i < length; ++i) {' . chr(10) . '            if (s.charAt(i) != ' . chr(39) . '0' . chr(39) . ') {' . chr(10) . '                return s;' . chr(10) . '            }' . chr(10) . '        }' . chr(10) . '        return s.substring(0, dot);' . chr(10) . '    }' . chr(10) . '    public boolean to_bool() {' . chr(10) . '        return this.i != 0.0;' . chr(10) . '    }' . chr(10) . '    public PlObject _decr() {' . chr(10) . '        // --$x' . chr(10) . '        return new PlDouble(i-1);' . chr(10) . '    }' . chr(10) . '    public PlObject _incr() {' . chr(10) . '        // ++$x' . chr(10) . '        return new PlDouble(i+1);' . chr(10) . '    }' . chr(10) . '    public PlObject neg() {' . chr(10) . '        return new PlDouble(-i);' . chr(10) . '    }' . chr(10) . '    public PlObject abs() {' . chr(10) . '        return new PlDouble(i < 0.0 ? -i : i);' . chr(10) . '    }' . chr(10) . '    public PlObject num_cmp(PlObject b) {' . chr(10) . '        int c = new Double(this.i).compareTo(b.to_double());' . chr(10) . '        return new PlInt(c == 0 ? c : c < 0 ? -1 : 1);' . chr(10) . '    }' . chr(10) . '    public PlObject num_cmp2(PlObject b) {' . chr(10) . '        int c = new Double(b.to_double()).compareTo(this.i);' . chr(10) . '        return new PlInt(c == 0 ? c : c < 0 ? -1 : 1);' . chr(10) . '    }' . chr(10) . (join('', map {
                    my $perl = $_;
                    my $native = $number_binop{$perl}->{'op'};
                    my $returns = $number_binop{$perl}->{'num_returns'};
                    '    public PlObject ' . $perl . '(PlObject s) {' . chr(10) . '        // num - int, num - num' . chr(10) . '        return new ' . $returns . '( this.i ' . $native . ' s.to_double() );' . chr(10) . '    }' . chr(10) . '    public PlObject ' . $perl . '2(PlObject s) {' . chr(10) . '        // int - num' . chr(10) . '        return new ' . $returns . '( s.to_double() ' . $native . ' this.i );' . chr(10) . '    }' . chr(10)
                } sort {
                    $a cmp $b
                } keys(%number_binop))) . '    public boolean is_num() {' . chr(10) . '        return true;' . chr(10) . '    }' . chr(10) . '}' . chr(10) . 'class PlString extends PlObject {' . chr(10) . '    private java.lang.String s;' . chr(10) . '    private PlObject numericValue;' . chr(10) . '    private boolean hasValue;' . chr(10) . chr(10) . '    public PlString(String s) {' . chr(10) . '        this.s = s;' . chr(10) . '    }' . chr(10) . '    public PlString(char s) {' . chr(10) . '        this.s = "" + s;' . chr(10) . '    }' . chr(10) . '    public PlObject parse() {' . chr(10) . '        if (!hasValue) {' . chr(10) . '            hasValue = true;' . chr(10) . '            numericValue = this._parse();' . chr(10) . '        }' . chr(10) . '        return numericValue;' . chr(10) . '    }' . chr(10) . '    private PlObject _parse_exp(int length, int signal, int offset, int next) {' . chr(10) . '        // 123.45E^^^' . chr(10) . '        int offset3 = next;' . chr(10) . '        for ( ; offset3 < length; ) {' . chr(10) . '            final int c3 = s.codePointAt(offset3);' . chr(10) . '            switch (c3) {' . chr(10) . '                case ' . chr(39) . '+' . chr(39) . ': case ' . chr(39) . '-' . chr(39) . ':' . chr(10) . '                    // TODO' . chr(10) . '                    break;' . chr(10) . '                case ' . chr(39) . '0' . chr(39) . ': case ' . chr(39) . '1' . chr(39) . ': case ' . chr(39) . '2' . chr(39) . ': case ' . chr(39) . '3' . chr(39) . ': case ' . chr(39) . '4' . chr(39) . ':' . chr(10) . '                case ' . chr(39) . '5' . chr(39) . ': case ' . chr(39) . '6' . chr(39) . ': case ' . chr(39) . '7' . chr(39) . ': case ' . chr(39) . '8' . chr(39) . ': case ' . chr(39) . '9' . chr(39) . ':' . chr(10) . '                    break;' . chr(10) . '                default:    // invalid' . chr(10) . '                    return new PlDouble(Double.parseDouble(this.s.substring(0, offset3)));' . chr(10) . '            }' . chr(10) . '            offset3++;' . chr(10) . '        }' . chr(10) . '        return new PlDouble(Double.parseDouble(this.s.substring(0, offset3)));' . chr(10) . '    }' . chr(10) . '    private PlObject _parse_dot(int length, int signal, int offset, int next) {' . chr(10) . '        // 123.^^^' . chr(10) . '        int offset3 = next;' . chr(10) . '        for ( ; offset3 < length; ) {' . chr(10) . '            final int c3 = s.codePointAt(offset3);' . chr(10) . '            switch (c3) {' . chr(10) . '                case ' . chr(39) . '0' . chr(39) . ': case ' . chr(39) . '1' . chr(39) . ': case ' . chr(39) . '2' . chr(39) . ': case ' . chr(39) . '3' . chr(39) . ': case ' . chr(39) . '4' . chr(39) . ':' . chr(10) . '                case ' . chr(39) . '5' . chr(39) . ': case ' . chr(39) . '6' . chr(39) . ': case ' . chr(39) . '7' . chr(39) . ': case ' . chr(39) . '8' . chr(39) . ': case ' . chr(39) . '9' . chr(39) . ':' . chr(10) . '                    break;' . chr(10) . '                case ' . chr(39) . 'E' . chr(39) . ': case ' . chr(39) . 'e' . chr(39) . ':' . chr(10) . '                    // start exponential part' . chr(10) . '                    return _parse_exp(length, signal, offset, offset3+1);' . chr(10) . '                default:    // invalid' . chr(10) . '                    return new PlDouble(Double.parseDouble(this.s.substring(0, offset3)));' . chr(10) . '            }' . chr(10) . '            offset3++;' . chr(10) . '        }' . chr(10) . '        if (offset3 == 1) {' . chr(10) . '            return PlCx.INT0;   // string is "."' . chr(10) . '        }' . chr(10) . '        return new PlDouble(Double.parseDouble(this.s.substring(0, offset3)));' . chr(10) . '    }' . chr(10) . '    private PlObject _parse() {' . chr(10) . '        final int length = s.length();' . chr(10) . '        int signal = 0;' . chr(10) . '        for (int offset = 0; offset < length; ) {' . chr(10) . '            final int c = s.codePointAt(offset);' . chr(10) . '            switch (c) {' . chr(10) . '                case ' . chr(39) . 'i' . chr(39) . ': case ' . chr(39) . 'I' . chr(39) . ':' . chr(10) . '                            if (this.s.substring(offset, offset+3).equalsIgnoreCase("inf")) {' . chr(10) . '                                if (signal < 0) {' . chr(10) . '                                    return new PlDouble(Double.NEGATIVE_INFINITY);' . chr(10) . '                                }' . chr(10) . '                                else {' . chr(10) . '                                    return new PlDouble(Double.POSITIVE_INFINITY);' . chr(10) . '                                }' . chr(10) . '                            }' . chr(10) . '                            return PlCx.INT0;' . chr(10) . '                case ' . chr(39) . 'n' . chr(39) . ': case ' . chr(39) . 'N' . chr(39) . ':' . chr(10) . '                            if (this.s.substring(offset, offset+3).equalsIgnoreCase("nan")) {' . chr(10) . '                                return new PlDouble(Double.NaN);' . chr(10) . '                            }' . chr(10) . '                            return PlCx.INT0;' . chr(10) . '                case ' . chr(39) . '.' . chr(39) . ':   // starts with dot' . chr(10) . '                            if (signal != 0) {' . chr(10) . '                                signal = 1;' . chr(10) . '                            }' . chr(10) . '                            return _parse_dot(length, signal, offset, offset+1);' . chr(10) . '                case ' . chr(39) . '0' . chr(39) . ': case ' . chr(39) . '1' . chr(39) . ': case ' . chr(39) . '2' . chr(39) . ': case ' . chr(39) . '3' . chr(39) . ': case ' . chr(39) . '4' . chr(39) . ':' . chr(10) . '                case ' . chr(39) . '5' . chr(39) . ': case ' . chr(39) . '6' . chr(39) . ': case ' . chr(39) . '7' . chr(39) . ': case ' . chr(39) . '8' . chr(39) . ': case ' . chr(39) . '9' . chr(39) . ':' . chr(10) . '                            // starts with number' . chr(10) . '                            if (signal == 0) {' . chr(10) . '                                signal = 1;' . chr(10) . '                            }' . chr(10) . '                            int offset2 = offset+1;' . chr(10) . '                            for ( ; offset2 < length; ) {' . chr(10) . '                                final int c2 = s.codePointAt(offset2);' . chr(10) . '                                switch (c2) {' . chr(10) . '                                    case ' . chr(39) . '0' . chr(39) . ': case ' . chr(39) . '1' . chr(39) . ': case ' . chr(39) . '2' . chr(39) . ': case ' . chr(39) . '3' . chr(39) . ': case ' . chr(39) . '4' . chr(39) . ':' . chr(10) . '                                    case ' . chr(39) . '5' . chr(39) . ': case ' . chr(39) . '6' . chr(39) . ': case ' . chr(39) . '7' . chr(39) . ': case ' . chr(39) . '8' . chr(39) . ': case ' . chr(39) . '9' . chr(39) . ':' . chr(10) . '                                        // more numbers' . chr(10) . '                                        break;' . chr(10) . '                                    case ' . chr(39) . '.' . chr(39) . ':' . chr(10) . '                                        // start decimal part' . chr(10) . '                                        return _parse_dot(length, signal, offset, offset2+1);' . chr(10) . '                                    case ' . chr(39) . 'E' . chr(39) . ': case ' . chr(39) . 'e' . chr(39) . ':' . chr(10) . '                                        // start exponential part' . chr(10) . '                                        return _parse_exp(length, signal, offset, offset2+1);' . chr(10) . '                                    default:' . chr(10) . '                                        // return integer' . chr(10) . '                                        if (signal < 0) {' . chr(10) . '                                            return new PlInt(-Integer.parseInt(this.s.substring(offset, offset2)));' . chr(10) . '                                        }' . chr(10) . '                                        else {' . chr(10) . '                                            return new PlInt(Integer.parseInt(this.s.substring(offset, offset2)));' . chr(10) . '                                        }' . chr(10) . '                                }' . chr(10) . '                                offset2++;' . chr(10) . '                            }' . chr(10) . '                            // integer' . chr(10) . '                            if (signal < 0) {' . chr(10) . '                                return new PlInt(-Integer.parseInt(this.s.substring(offset, offset2)));' . chr(10) . '                            }' . chr(10) . '                            else {' . chr(10) . '                                return new PlInt(Integer.parseInt(this.s.substring(offset, offset2)));' . chr(10) . '                            }' . chr(10) . '                case ' . chr(39) . '+' . chr(39) . ':   // starts with +' . chr(10) . '                            if (signal != 0) {' . chr(10) . '                                // invalid' . chr(10) . '                                return PlCx.INT0;' . chr(10) . '                            }' . chr(10) . '                            signal = 1;' . chr(10) . '                            break;' . chr(10) . '                case ' . chr(39) . '-' . chr(39) . ':   // starts with -' . chr(10) . '                            if (signal != 0) {' . chr(10) . '                                // invalid' . chr(10) . '                                return PlCx.INT0;' . chr(10) . '                            }' . chr(10) . '                            signal = -1;' . chr(10) . '                            break;' . chr(10) . '                case ' . chr(39) . ' ' . chr(39) . ': case ' . chr(39) . chr(92) . 't' . chr(39) . ': case ' . chr(39) . chr(92) . 'n' . chr(39) . ': case ' . chr(39) . chr(92) . 'r' . chr(39) . ':' . chr(10) . '                            // starts with space' . chr(10) . '                            if (signal != 0) {' . chr(10) . '                                // invalid' . chr(10) . '                                return PlCx.INT0;' . chr(10) . '                            }' . chr(10) . '                            break;' . chr(10) . '                default:    // invalid' . chr(10) . '                            return PlCx.INT0;' . chr(10) . '            }' . chr(10) . '            offset++;' . chr(10) . '        }' . chr(10) . '        return PlCx.INT0;' . chr(10) . '    }' . chr(10) . '    public long to_long() {' . chr(10) . '        return this.parse().to_long();' . chr(10) . '    }' . chr(10) . '    public double to_double() {' . chr(10) . '        return this.parse().to_double();' . chr(10) . '    }' . chr(10) . '    public String toString() {' . chr(10) . '        return this.s;' . chr(10) . '    }' . chr(10) . '    public boolean to_bool() {' . chr(10) . '        return this.s != ""' . chr(10) . '            && this.s != "0";' . chr(10) . '    }' . chr(10) . '    public boolean is_string() {' . chr(10) . '        return true;' . chr(10) . '    }' . chr(10) . '    public PlObject _decr() {' . chr(10) . '        // --$x' . chr(10) . '        return this.add(PlCx.MIN1);' . chr(10) . '    }' . chr(10) . chr(10) . '    // $x++ when $x is PlString' . chr(10) . '    private static final String _string_increment(String s) {' . chr(10) . '        if (s.length() < 2) {' . chr(10) . '            final int c = s.codePointAt(0);' . chr(10) . '            if ((c >= ' . chr(39) . '0' . chr(39) . ' && c <= ' . chr(39) . '8' . chr(39) . ') || (c >= ' . chr(39) . 'A' . chr(39) . ' && c <= ' . chr(39) . 'Y' . chr(39) . ') || (c >= ' . chr(39) . 'a' . chr(39) . ' && c <= ' . chr(39) . 'y' . chr(39) . ')) {' . chr(10) . '                return "" + (char)(c + 1);' . chr(10) . '            }' . chr(10) . '            if (c == ' . chr(39) . '9' . chr(39) . ') {' . chr(10) . '                return "10";' . chr(10) . '            }' . chr(10) . '            if (c == ' . chr(39) . 'Z' . chr(39) . ') {' . chr(10) . '                return "AA";' . chr(10) . '            }' . chr(10) . '            if (c == ' . chr(39) . 'z' . chr(39) . ') {' . chr(10) . '                return "aa";' . chr(10) . '            }' . chr(10) . '            return "1";' . chr(10) . '        }' . chr(10) . '        String c = _string_increment(s.substring(s.length()-1, s.length()));' . chr(10) . '        if (c.length() == 1) {' . chr(10) . '            return s.substring(0, s.length()-1) + c;' . chr(10) . '        }' . chr(10) . '        return _string_increment(s.substring(0, s.length()-1)) + c.substring(c.length()-1, c.length());' . chr(10) . '    }' . chr(10) . '    public PlObject _incr() {' . chr(10) . '        // ++$x' . chr(10) . '        final int length = s.length();' . chr(10) . '        if (length == 0) {' . chr(10) . '            return PlCx.INT1;' . chr(10) . '        }' . chr(10) . '        int c = this.s.codePointAt(0);' . chr(10) . '        switch (c) {' . chr(10) . '            case ' . chr(39) . ' ' . chr(39) . ': case ' . chr(39) . chr(92) . 't' . chr(39) . ': case ' . chr(39) . chr(92) . 'n' . chr(39) . ': case ' . chr(39) . chr(92) . 'r' . chr(39) . ':' . chr(10) . '            case ' . chr(39) . '+' . chr(39) . ': case ' . chr(39) . '-' . chr(39) . ': case ' . chr(39) . '.' . chr(39) . ':' . chr(10) . '            case ' . chr(39) . '0' . chr(39) . ': case ' . chr(39) . '1' . chr(39) . ': case ' . chr(39) . '2' . chr(39) . ': case ' . chr(39) . '3' . chr(39) . ': case ' . chr(39) . '4' . chr(39) . ':' . chr(10) . '            case ' . chr(39) . '5' . chr(39) . ': case ' . chr(39) . '6' . chr(39) . ': case ' . chr(39) . '7' . chr(39) . ': case ' . chr(39) . '8' . chr(39) . ': case ' . chr(39) . '9' . chr(39) . ':' . chr(10) . '                return this.add(PlCx.INT1);' . chr(10) . '        }' . chr(10) . '        c = s.codePointAt(length - 1);' . chr(10) . '        if ((c >= ' . chr(39) . '0' . chr(39) . ' && c <= ' . chr(39) . '8' . chr(39) . ') || (c >= ' . chr(39) . 'A' . chr(39) . ' && c <= ' . chr(39) . 'Y' . chr(39) . ') || (c >= ' . chr(39) . 'a' . chr(39) . ' && c <= ' . chr(39) . 'y' . chr(39) . ')) {' . chr(10) . '            return new PlString(s.substring(0, length-1) + (char)(c + 1));' . chr(10) . '        }' . chr(10) . '        return new PlString(_string_increment(this.s));' . chr(10) . '    }' . chr(10) . '    public PlObject neg() {' . chr(10) . '        final int length = s.length();' . chr(10) . '        if (length == 0) {' . chr(10) . '            return PlCx.INT0;' . chr(10) . '        }' . chr(10) . '        final int c = this.s.codePointAt(0);' . chr(10) . '        switch (c) {' . chr(10) . '            case ' . chr(39) . '+' . chr(39) . ': case ' . chr(39) . '-' . chr(39) . ':' . chr(10) . '                if (c == ' . chr(39) . '+' . chr(39) . ') {' . chr(10) . '                    return new PlString( ' . chr(39) . '-' . chr(39) . ' + s.substring(1) );' . chr(10) . '                }' . chr(10) . '                if (c == ' . chr(39) . '-' . chr(39) . ') {' . chr(10) . '                    return new PlString( ' . chr(39) . '+' . chr(39) . ' + s.substring(1) );' . chr(10) . '                }' . chr(10) . '            case ' . chr(39) . '.' . chr(39) . ':' . chr(10) . '            case ' . chr(39) . ' ' . chr(39) . ': case ' . chr(39) . chr(92) . 't' . chr(39) . ': case ' . chr(39) . chr(92) . 'n' . chr(39) . ': case ' . chr(39) . chr(92) . 'r' . chr(39) . ':' . chr(10) . '            case ' . chr(39) . '0' . chr(39) . ': case ' . chr(39) . '1' . chr(39) . ': case ' . chr(39) . '2' . chr(39) . ': case ' . chr(39) . '3' . chr(39) . ': case ' . chr(39) . '4' . chr(39) . ':' . chr(10) . '            case ' . chr(39) . '5' . chr(39) . ': case ' . chr(39) . '6' . chr(39) . ': case ' . chr(39) . '7' . chr(39) . ': case ' . chr(39) . '8' . chr(39) . ': case ' . chr(39) . '9' . chr(39) . ':' . chr(10) . '                return this.parse().neg();' . chr(10) . '        }' . chr(10) . '        if ((c >= ' . chr(39) . 'A' . chr(39) . ' && c <= ' . chr(39) . 'Z' . chr(39) . ') || (c >= ' . chr(39) . 'a' . chr(39) . ' && c <= ' . chr(39) . 'z' . chr(39) . ')) {' . chr(10) . '            return new PlString( ' . chr(39) . '-' . chr(39) . ' + s );' . chr(10) . '        }' . chr(10) . '        return PlCx.INT0;' . chr(10) . '    }' . chr(10) . '    public PlObject abs() {' . chr(10) . '        return this.parse().abs();' . chr(10) . '    }' . chr(10) . '    public PlObject num_cmp(PlObject b) {' . chr(10) . '        return this.parse().num_cmp(b);' . chr(10) . '    }' . chr(10) . '    public PlObject num_cmp2(PlObject b) {' . chr(10) . '        return b.num_cmp2(this.parse());' . chr(10) . '    }' . chr(10) . (join('', map {
                    my $perl = $_;
                    my $native = $number_binop{$perl}->{'op'};
                    my $returns = $number_binop{$perl}->{'returns'};
                    my $num_returns = $number_binop{$perl}->{'num_returns'};
                    if ($returns eq 'PlDouble') {
                        '    public PlObject ' . $perl . '(PlObject b) {' . chr(10) . '        // ' . chr(39) . 'num' . chr(39) . ' - int, ' . chr(39) . 'num' . chr(39) . ' - num' . chr(10) . '        return this.parse().' . $perl . '(b);' . chr(10) . '    }' . chr(10) . '    public PlObject ' . $perl . '2(PlObject b) {' . chr(10) . '        // int - ' . chr(39) . 'num' . chr(39) . chr(10) . '        return b.' . $perl . '(this.parse());' . chr(10) . '    }' . chr(10)
                    }
                    else {
                        '    public PlObject ' . $perl . '(PlObject b) {' . chr(10) . '        // ' . chr(39) . 'num' . chr(39) . ' - int, ' . chr(39) . 'num' . chr(39) . ' - num' . chr(10) . '        return this.parse().' . $perl . '(b);' . chr(10) . '    }' . chr(10) . '    public PlObject ' . $perl . '2(PlObject b) {' . chr(10) . '        // int - ' . chr(39) . 'num' . chr(39) . chr(10) . '        return b.' . $perl . '(this.parse());' . chr(10) . '    }' . chr(10)
                    }
                } sort {
                    $a cmp $b
                } keys(%number_binop))) . '}' . chr(10) . join('', (map {
                    my $class = $java_classes{$_};
                    my $java_class_name = $class->{'java_type'};
                    my $perl_to_java = $class->{'perl_to_java'};
                    my $perl_package = $class->{'perl_package'};
                    my $java_native_to_perl = $class->{'java_native_to_perl'};
                    $class->{'import'} || $class->{'extends'} || $class->{'implements'} ? 'class ' . $java_native_to_perl . ' extends PlReference {' . chr(10) . '    public static final PlString REF = new PlString("' . $perl_package . '");' . chr(10) . '    private ' . $java_class_name . ' stuff;' . chr(10) . chr(10) . '    public ' . $java_native_to_perl . '(' . $java_class_name . ' stuff) {' . chr(10) . '        this.stuff = stuff;' . chr(10) . '    }' . chr(10) . '    public ' . $java_class_name . ' ' . $perl_to_java . '() {' . chr(10) . '        return this.stuff;' . chr(10) . '    }' . chr(10) . '    public PlString ref() {' . chr(10) . chr(9) . chr(9) . 'return REF;' . chr(10) . '    }' . chr(10) . '    public boolean is_undef() {' . chr(10) . '        return stuff == null;' . chr(10) . '    }' . chr(10) . '}' . chr(10) : ()
                } sort {
                    $a cmp $b
                } keys(%java_classes))) . '// end Perl-Java runtime' . chr(10)
            }
            1
        }
    }
    # use strict
    my $_V5_COMPILER_NAME = Perlito5::Compiler::compiler_name;
    my $_V5_COMPILER_VERSION = $Perlito5::VERSION;
    my $source = '';
    my $backend = ${chr(15)};
    my $compile_only = 0;
    my $execute = 1;
    my $verbose = 0;
    my $expand_use = 1;
    my $boilerplate = 1;
    my $bootstrapping = 0;
    my $wrapper_begin = '';
    my $wrapper_end = '';
    my $wrapper_priority = 0;
    my @Use;
    my $i_switch = 0;
    my $i_switch_extension = '';
    my @e_switch;
    $Perlito5::FILE_NAME = '';
    if ($verbose) {
        warn('// Perlito5 compiler');
        warn('// ARGV: ' . join(${'"'}, @ARGV))
    }
    my $help_message = chr(10) . 'perlito5 [switches] [programfile]' . chr(10) . '  switches:' . chr(10) . '    -c              check syntax only (runs BEGIN and CHECK blocks)' . chr(10) . '    -e program      one line of program (omit programfile)' . chr(10) . '    -E program      like -e, but enables all optional features' . chr(10) . '    -h --help' . chr(10) . '    -Idirectory     specify @INC/include directory (several -I' . chr(39) . 's allowed)' . chr(10) . '    -[mM][-]module  execute "use/no module..." before executing program' . chr(10) . '    -n              assume "while (<>) { ... }" loop around program' . chr(10) . '    -p              assume loop like -n but print line also, like sed' . chr(10) . '    -V --version' . chr(10) . '    -v' . chr(10) . '    --verbose' . chr(10) . '    -Ctarget        target backend: js, perl5, perl6, xs, java' . chr(10) . '    -Cast-perl5     emits a dump of the abstract syntax tree as a Perl dump' . chr(10) . '    -Cast-json      emits a dump of the abstract syntax tree in JSON format' . chr(10) . '    --expand_use --noexpand_use' . chr(10) . '                    expand ' . chr(39) . 'use' . chr(39) . ' statements at compile time' . chr(10) . '    --boilerplate --noboilerplate' . chr(10) . '                    emits or not boilerplate code' . chr(10) . '    --bootstrapping set this when compiling the compiler,' . chr(10) . '                    otherwise the new subroutine definitions will overwrite the current compiler' . chr(10);
    my $copyright_message = 'This is Perlito5 ' . $_V5_COMPILER_VERSION . ', an implementation of the Perl language.' . chr(10) . chr(10) . 'The Perl language is Copyright 1987-2012, Larry Wall' . chr(10) . 'The Perlito5 implementation is Copyright 2011, 2012 by Flavio Soibelmann Glock and others.' . chr(10) . chr(10) . 'Perl may be copied only under the terms of either the Artistic License or the' . chr(10) . 'GNU General Public License, which may be found in the Perl 5 source kit.' . chr(10) . chr(10) . 'Complete documentation for Perl, including FAQ lists, should be found on' . chr(10) . 'this system using "man perl" or "perldoc perl".  If you have access to the' . chr(10) . 'Internet, point your browser at http://www.perl.org/, the Perl Home Page.' . chr(10);
    sub Perlito5::chomp_switch {
        my $s = substr($ARGV[0], 2);
        if ($s) {
            $ARGV[0] = '-' . $s
        }
        else {
            shift(@ARGV)
        }
    }
    sub Perlito5::get_text_from_switch {
        my $s = substr($ARGV[0], 2);
        if (!$s) {
            shift(@ARGV);
            $s = $ARGV[0]
        }
        if ($s) {
            my $c = substr($s, 0, 1);
            if ($c eq '"' || $c eq chr(39)) {
                if (substr($s, -1, 1) eq $c) {
                    $s = substr($s, 1, -1)
                }
            }
        }
        return $s
    }
    push(@Use, 'no warnings');
    push(@Use, 'no strict');
    ARG_LOOP:
    while (@ARGV && substr($ARGV[0], 0, 1) eq '-') {
        if ($ARGV[0] eq '--verbose') {
            $verbose = 1;
            shift(@ARGV)
        }
        elsif (substr($ARGV[0], 0, 2) eq '-I') {
            my $lib = get_text_from_switch();
            unshift(@INC, $lib);
            shift(@ARGV)
        }
        elsif (substr($ARGV[0], 0, 2) eq '-e' || substr($ARGV[0], 0, 2) eq '-E') {
            my $source = get_text_from_switch();
            push(@e_switch, $source);
            $Perlito5::FILE_NAME = '-e';
            if ($verbose) {
                warn('// source from command line: ' . $source)
            }
            shift(@ARGV)
        }
        elsif (substr($ARGV[0], 0, 2) eq '-c') {
            $compile_only = 1;
            $execute = 0;
            $backend = 'perl5';
            chomp_switch()
        }
        elsif (substr($ARGV[0], 0, 2) eq '-C') {
            $backend = get_text_from_switch();
            $execute = 0;
            shift(@ARGV)
        }
        elsif (substr($ARGV[0], 0, 2) eq '-i') {
            $i_switch = 1;
            $ARGV[0] ne '-i' && ($i_switch_extension = get_text_from_switch());
            die('switch -i ' . $i_switch_extension . ' not yet implemented.' . chr(10));
            shift(@ARGV)
        }
        elsif ($ARGV[0] eq '-MO=Deparse') {
            $backend = 'perl5';
            $execute = 0;
            $expand_use = 0;
            shift(@ARGV)
        }
        elsif (uc(substr($ARGV[0], 0, 2)) eq '-M') {
            my $s = $ARGV[0];
            my $import = '';
            if (substr($s, 1, 1) eq 'm') {
                $import = '()'
            }
            $s = substr($s, 2);
            my $use = 'use';
            if (substr($s, 0, 1) eq '-') {
                $use = 'no';
                $s = substr($s, 1)
            }
            if (index($s, '=') > -1) {
                ($s, $import) = split('=', $s);
                $import = 'split(/,/,q{' . $import . '})'
            }
            push(@Use, $use . ' ' . $s . ' ' . $import);
            shift(@ARGV)
        }
        elsif (substr($ARGV[0], 0, 2) eq '-w') {
            push(@Use, 'use warnings');
            chomp_switch()
        }
        elsif (substr($ARGV[0], 0, 2) eq '-W') {
            push(@Use, 'use warnings');
            chomp_switch()
        }
        elsif (substr($ARGV[0], 0, 2) eq '-X') {
            push(@Use, 'no warnings');
            chomp_switch()
        }
        elsif (substr($ARGV[0], 0, 2) eq '-n') {
            if ($wrapper_priority < 1) {
                $wrapper_begin = ' LINE: while (<>) { ';
                $wrapper_end = ' } ';
                $wrapper_priority = 1
            }
            chomp_switch()
        }
        elsif (substr($ARGV[0], 0, 2) eq '-p') {
            if ($wrapper_priority < 2) {
                $wrapper_begin = ' LINE: while (<>) { ';
                $wrapper_end = ' } continue { ' . ' print or die "-p destination: $!' . chr(92) . 'n"; ' . ' } ';
                $wrapper_priority = 2
            }
            chomp_switch()
        }
        elsif ($ARGV[0] eq '-V') {
            $backend = '';
            say($_V5_COMPILER_NAME, ' ', $_V5_COMPILER_VERSION);
            if ($ENV{'PERL5LIB'}) {
                say('  %ENV:');
                say('    PERL5LIB="' . $ENV{'PERL5LIB'} . '"')
            }
            say('  @INC:');
            say('    ' . $_)
                for @INC;
            shift(@ARGV)
        }
        elsif ($ARGV[0] eq '-v' || $ARGV[0] eq '--version') {
            $backend = '';
            say($copyright_message);
            shift(@ARGV)
        }
        elsif ($ARGV[0] eq '-h' || $ARGV[0] eq '--help' || !@ARGV) {
            $backend = '';
            say($_V5_COMPILER_NAME, ' ', $_V5_COMPILER_VERSION, $help_message);
            shift(@ARGV)
        }
        elsif ($ARGV[0] eq '--expand_use') {
            $expand_use = 1;
            shift(@ARGV)
        }
        elsif ($ARGV[0] eq '--noexpand_use') {
            $expand_use = 0;
            shift(@ARGV)
        }
        elsif ($ARGV[0] eq '--boilerplate') {
            $boilerplate = 1;
            shift(@ARGV)
        }
        elsif ($ARGV[0] eq '--noboilerplate') {
            $boilerplate = 0;
            shift(@ARGV)
        }
        elsif ($ARGV[0] eq '--bootstrapping') {
            $bootstrapping = 1;
            shift(@ARGV)
        }
        elsif ($ARGV[0] eq '-') {
            shift(@ARGV);
            last(ARG_LOOP)
        }
        else {
            die('Unrecognized switch: ' . $ARGV[0] . '  (-h will show valid options).' . chr(10))
        }
    }
    if (!$expand_use) {
        $Perlito5::EMIT_USE = 1
    }
    if ($backend) {
        local $Perlito5::LINE_NUMBER = 1;
        if (@e_switch) {
            $source = join(${'"'}, @e_switch)
        }
        else {
            $Perlito5::FILE_NAME = $ARGV[0];
            if ($verbose) {
                warn('// source from file: ', $ARGV[0])
            }
            my $source_filename = shift(@ARGV);
            if ($source_filename eq '') {
                local $/ = undef;
                $source = <STDIN>
            }
            else {
                open(FILE, '<:encoding(UTF-8)', $source_filename) or die('Cannot read ' . $source_filename . ': ' . ${'!'} . chr(10));
                local $/ = undef;
                $source = <FILE>;
                close(FILE)
            }
        }
        ${0} = $Perlito5::FILE_NAME;
        if ($verbose) {
            warn('// backend: ', $backend);
            warn('now parsing')
        }
        $Perlito5::PKG_NAME = 'main';
        $Perlito5::PROTO = {};
        Perlito5::set_global_phase('BEGIN');
        $source = chr(10) . '# line 1' . chr(10) . $source;
        if ($wrapper_begin) {
            $source = ' ' . $wrapper_begin . ';' . chr(10) . '                    ' . $source . ';' . chr(10) . '                    ' . $wrapper_end . chr(10) . '                  '
        }
        if ($execute) {
            $Perlito5::EXPAND_USE = 1;
            local ${'@'};
            my $init = join('; ', @Use);
            eval(chr(10) . '            Perlito5::set_global_phase("CHECK");' . chr(10) . '            $_->() for @Perlito5::CHECK_BLOCK;' . chr(10) . '            package main;' . chr(10) . '            ' . $init . ';' . chr(10) . '            Perlito5::set_global_phase("INIT");' . chr(10) . '            $_->() for @Perlito5::INIT_BLOCK;' . chr(10) . '            Perlito5::set_global_phase("RUN");' . chr(10) . '            ' . $source . ';' . chr(10) . '            $@ = undef' . chr(10) . '        ');
            my $error = ${'@'};
            $error && warn($error);
            Perlito5::set_global_phase('END');
            $_->()
                for @Perlito5::END_BLOCK;
            if ($error) {
                exit(255)
            }
        }
        else {
            eval {
                %INC = ();
                $bootstrapping && ($Perlito5::EXPAND_USE = 0);
                # no strict
                my $m;
                my $ok;
                eval {
                    $m = Perlito5::Grammar::exp_stmts($source, 0);
                    $ok = 1
                };
                if (!$ok || $m->{'to'} < length($source)) {
                    my $error = ${'@'} || ($m->{'to'} < length($source) && 'Syntax Error near ' . $m->{'to'}) || 'Unknown error';
                    warn($error);
                    exit(255)
                }
                else {
                    my $comp_units;
                    if ($ENV{'PERLITO5DEV'}) {
                        $comp_units = Perlito5::Match::flat($m)
                    }
                    elsif ($expand_use) {
                        my $ok;
                        eval {
                            $comp_units = Perlito5::Grammar::Use::add_comp_unit(Perlito5::Match::flat($m));
                            $ok = 1
                        };
                        if (!$ok) {
                            my $error = ${'@'} || 'Unknown error loading a module';
                            warn($error);
                            exit(255)
                        }
                    }
                    else {
                        $comp_units = Perlito5::Match::flat($m)
                    }
                    $comp_units = [Perlito5::AST::CompUnit::->new('name' => 'main', 'body' => $comp_units)];
                    {
                        local ${chr(7) . 'LOBAL_PHASE'};
                        Perlito5::set_global_phase('CHECK');
                        $_->()
                            for @Perlito5::CHECK_BLOCK
                    }
                    if ($compile_only) {
                        say($Perlito5::FILE_NAME . ' syntax OK')
                    }
                    elsif ($backend eq 'perl5') {
                        if ($expand_use) {
                            print(Perlito5::Perl5::Runtime::->emit_perl5())
                        }
                        else {
                            $Perlito5::EMIT_USE = 1
                        }
                        my @data = Perlito5::AST::CompUnit::emit_perl5_program($comp_units);
                        my $out = [];
                        Perlito5::Perl5::PrettyPrinter::pretty_print(\@data, 0, $out);
                        print(join('', @{$out}), ';1' . chr(10))
                    }
                    elsif ($backend eq 'perl6') {
                        if ($boilerplate) {
                            say('use v6;')
                        }
                        if (!$boilerplate) {
                            if (ref($comp_units) eq 'ARRAY' && (@{$comp_units} == 1) && ref($comp_units->[0]) eq 'Perlito5::AST::CompUnit') {
                                $comp_units = $comp_units->[0]->{'body'}
                            }
                        }
                        my @data = Perlito5::AST::CompUnit::emit_perl6_program($comp_units);
                        my $out = [];
                        Perlito5::Perl6::PrettyPrinter::pretty_print(\@data, 0, $out);
                        print(join('', @{$out}));
                        $boilerplate && print(chr(10))
                    }
                    elsif ($backend eq 'js') {
                        print(Perlito5::AST::CompUnit::emit_javascript2_program($comp_units, 'expand_use' => $expand_use))
                    }
                    elsif ($backend eq 'js3') {
                        print(Perlito5::AST::CompUnit::emit_javascript3_program($comp_units, 'expand_use' => $expand_use))
                    }
                    elsif ($backend eq 'xs') {
                        print(Perlito5::AST::CompUnit::emit_xs_program($comp_units))
                    }
                    elsif ($backend eq 'java') {
                        print(Perlito5::AST::CompUnit::emit_java_program($comp_units, 'expand_use' => $expand_use))
                    }
                    elsif ($backend eq 'ast-perl5') {
                        say(Perlito5::Dumper::ast_dumper($comp_units))
                    }
                    elsif ($backend eq 'ast-json') {
                        say(Perlito5::JSON::ast_dumper($comp_units))
                    }
                    elsif ($backend eq 'ast-pretty') {
                        eval('use Data::Printer {colored=>1,class=>{expand=>"all",show_methods=>"none"}};p($comp_units);1');
                        print(${'@'})
                    }
                    elsif ($backend eq '_comp') {
                        say(Perlito5::Dumper::ast_dumper($Perlito5::SCOPE))
                    }
                    elsif ($backend eq '_globals') {
                        say(Perlito5::CompileTime::Dumper::emit_globals($Perlito5::GLOBAL))
                    }
                    elsif ($backend eq '_compile_time') {
                        say(Perlito5::Dumper::ast_dumper(Perlito5::AST::CompUnit::emit_compile_time_program($comp_units)))
                    }
                    else {
                        die('don' . chr(39) . 't know what to do with backend ' . chr(39) . $backend . chr(39))
                    }
                }
                ${'@'} = undef
            }
        }
        if (${'@'}) {
            my $error = ${'@'};
            warn($error);
            exit(255)
        }
    }
}
;1
