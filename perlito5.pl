# Do not edit this file - Generated by Perlito5 9.0

use v5.10;
use feature 'say';

package main;
undef();
package Perlito5;
package main;
package strict;
sub strict::import {
    $Perlito5::STRICT = 1
}
sub strict::unimport {
    $Perlito5::STRICT = 0
}
1;
package main;
package warnings;
sub warnings::import {
    $Perlito5::WARNINGS = 1
}
sub warnings::unimport {
    $Perlito5::WARNINGS = 0
}
1;
package main;
undef();
package Perlito5::Match;
sub Perlito5::Match::flat {
    my $self = $_[0];
    defined($self->{'capture'}) ? $self->{'capture'} : substr($self->{'str'}, $self->{'from'}, ($self->{'to'} - $self->{'from'}))
}
1;
package main;
package feature;
sub feature::import {}
sub feature::unimport {}
1;
package main;
package Perlito5::Grammar::Precedence;
# use feature
sub Perlito5::Grammar::Precedence::new {
    my $class = shift;
    bless({@_}, $class)
}
my $Operator = {};
my $Precedence = {};
my $PrefixPrecedence = {};
my $Assoc = {};
sub Perlito5::Grammar::Precedence::is_assoc_type {
    my $assoc_type = shift;
    my $op_name = shift;
    return $Assoc->{$assoc_type}->{$op_name}
}
sub Perlito5::Grammar::Precedence::is_fixity_type {
    my $fixity_type = shift;
    my $op_name = shift;
    return $Operator->{$fixity_type}->{$op_name}
}
sub Perlito5::Grammar::Precedence::is_term {
    my $token = shift;
    ($token->[0] eq 'term') || ($token->[0] eq 'postfix_or_term') || ($token->[0] eq 'postfix')
}
sub Perlito5::Grammar::Precedence::is_num {
    $_[0] ge 0 && $_[0] le 9
}
sub Perlito5::Grammar::Precedence::is_ident_middle {
    my $c = shift;
    ($c ge 'a' && $c le 'z') || ($c ge 0 && $c le 9) || ($c eq '_')
}
my @Parsed_op_chars = (2, 1);
my %Parsed_op = ('?' => sub {
    Perlito5::Grammar::Expression::term_ternary($_[0], $_[1])
}, '(' => sub {
    Perlito5::Grammar::Expression::term_paren($_[0], $_[1])
}, '[' => sub {
    Perlito5::Grammar::Expression::term_square($_[0], $_[1])
}, '{' => sub {
    Perlito5::Grammar::Expression::term_curly($_[0], $_[1])
}, '->' => sub {
    Perlito5::Grammar::Expression::term_arrow($_[0], $_[1])
});
my @Term_chars;
my %Term;
sub Perlito5::Grammar::Precedence::add_term {
    my $name = shift;
    my $param = shift;
    $Term{$name} = $param;
    unshift(@Term_chars, scalar(@Term_chars) + 1)
        while @Term_chars < length($name)
}
my $End_token;
my $End_token_chars;
my %Op;
my @Op_chars = (3, 2, 1);
sub Perlito5::Grammar::Precedence::op_parse {
    my $str = shift;
    my $pos = shift;
    my $last_is_term = shift;
    for my $len (@{$End_token_chars}) {
        my $term = substr($str, $pos, $len);
        if (exists($End_token->{$term})) {
            my $c1 = substr($str, $pos + $len - 1, 1);
            my $c2 = substr($str, $pos + $len, 1);
            if (!(is_ident_middle($c1) && is_ident_middle($c2)) && !($c1 eq '<' && $c2 eq '<')) {
                return {'str' => $str, 'from' => $pos, 'to' => $pos, 'capture' => ['end', $term]}
            }
        }
    }
    if (!$last_is_term) {
        for my $len (@Term_chars) {
            my $term = substr($str, $pos, $len);
            if (exists($Term{$term})) {
                my $c1 = substr($str, $pos + $len - 1, 1);
                my $c2 = substr($str, $pos + $len, 1);
                if (is_num($c1) || !is_ident_middle($c1) || !is_ident_middle($c2)) {
                    my $m = $Term{$term}->($str, $pos);
                    $m && return $m
                }
            }
        }
    }
    for my $len (@Parsed_op_chars) {
        my $op = substr($str, $pos, $len);
        if (exists($Parsed_op{$op})) {
            my $m = $Parsed_op{$op}->($str, $pos);
            $m && return $m
        }
    }
    for my $len (@Op_chars) {
        my $op = substr($str, $pos, $len);
        if (exists($Op{$op})) {
            my $c1 = substr($str, $pos + $len - 1, 1);
            my $c2 = substr($str, $pos + $len, 1);
            if ((!(is_ident_middle($c1) && is_ident_middle($c2)) && !($c1 eq '&' && $c2 eq '&')) || ($c1 eq 'x' && $c2 ge 0 && $c2 le 9)) {
                if (exists($Operator->{'infix'}->{$op}) && !exists($Operator->{'prefix'}->{$op}) && !$last_is_term) {}
                else {
                    return {'str' => $str, 'from' => $pos, 'to' => $pos + $len, 'capture' => ['op', $op]}
                }
            }
        }
    }
    return Perlito5::Grammar::Bareword::term_bareword($str, $pos)
}
sub Perlito5::Grammar::Precedence::add_op {
    my($fixity, $names, $precedence, $param) = @_;
    $param //= {};
    my $assoc = $param->{'assoc'} || 'left';
    for my $name (@{$names}) {
        $Operator->{$fixity}->{$name} = 1;
        $Precedence->{$name} = $precedence;
        $fixity eq 'prefix' && ($PrefixPrecedence->{$name} = $precedence);
        $Assoc->{$assoc}->{$name} = 1;
        $Op{$name} = 1
    }
}
my $prec = 100;
add_op('postfix', ['.( )', '.[ ]', '.{ }', '( )', '[ ]', 'funcall', 'funcall_no_params', 'methcall', 'methcall_no_params', 'block', 'hash'], $prec);
$prec = $prec - 1;
add_op('prefix', ['++', '--'], $prec);
add_op('postfix', ['++', '--'], $prec);
$prec = $prec - 1;
add_op('infix', ['**'], $prec, {'assoc' => 'right'});
$prec = $prec - 1;
add_op('prefix', [chr(92), '+', '-', '~', '!'], $prec);
$prec = $prec - 1;
add_op('infix', ['=~', '!~'], $prec);
$prec = $prec - 1;
add_op('infix', ['*', '/', '%', 'x'], $prec);
$prec = $prec - 1;
add_op('infix', ['+', '-'], $prec);
add_op('infix', ['.'], $prec, {'assoc' => 'list'});
$prec = $prec - 1;
add_op('infix', ['<<', '>>'], $prec);
$prec = $prec - 1;
add_op('prefix', ['-r', '-w', '-x', '-o', '-R', '-W', '-X', '-O', '-e', '-z', '-s', '-f', '-d', '-l', '-p', '-S', '-b', '-c', '-t', '-u', '-g', '-k', '-T', '-B', '-M', '-A', '-C'], $prec);
$prec = $prec - 1;
add_op('infix', ['lt', 'le', 'gt', 'ge', '<=', '>=', '<', '>'], $prec, {'assoc' => 'chain'});
$prec = $prec - 1;
add_op('infix', ['<=>', 'cmp', '==', '!=', 'ne', 'eq'], $prec, {'assoc' => 'chain'});
$prec = $prec - 1;
add_op('infix', ['&'], $prec);
$prec = $prec - 1;
add_op('infix', ['|', '^'], $prec);
$prec = $prec - 1;
add_op('infix', ['..', '...'], $prec);
add_op('infix', ['~~'], $prec, {'assoc' => 'chain'});
$prec = $prec - 1;
add_op('infix', ['&&'], $prec, {'assoc' => 'right'});
$prec = $prec - 1;
add_op('infix', ['||'], $prec, {'assoc' => 'right'});
add_op('infix', ['//'], $prec);
$prec = $prec - 1;
add_op('ternary', ['? :'], $prec, {'assoc' => 'right'});
$prec = $prec - 1;
add_op('infix', ['=', '**=', '+=', '-=', '*=', '/=', 'x=', '|=', '&=', '.=', '<<=', '>>=', '%=', '||=', '&&=', '^=', '//='], $prec, {'assoc' => 'right'});
$prec = $prec - 1;
add_op('infix', ['=>'], $prec);
$prec = $prec - 1;
add_op('list', [','], $prec, {'assoc' => 'list'});
$prec = $prec - 1;
add_op('prefix', ['not'], $prec);
$prec = $prec - 1;
add_op('infix', ['and'], $prec);
$prec = $prec - 1;
add_op('infix', ['or', 'xor'], $prec);
$prec = $prec - 1;
add_op('infix', ['*start*'], $prec);
sub Perlito5::Grammar::Precedence::get_token_precedence {
    my $token = $_[0];
    if ($token->[0] eq 'prefix') {
        return $PrefixPrecedence->{$token->[1]}
    }
    return $Precedence->{$token->[1]}
}
sub Perlito5::Grammar::Precedence::precedence_parse {
    my $self = shift;
    my $get_token = $self->{'get_token'};
    my $reduce = $self->{'reduce'};
    my $last_end_token = $End_token;
    my $last_end_token_chars = $End_token_chars;
    $End_token = $self->{'end_token'};
    $End_token_chars = $self->{'end_token_chars'};
    my $op_stack = [];
    my $num_stack = [];
    my $last = ['op', '*start*'];
    my $last_is_term = 0;
    my $token = $get_token->($last_is_term);
    if ($token->[0] eq 'space') {
        $token = $get_token->($last_is_term)
    }
    while ((defined($token)) && ($token->[0] ne 'end')) {
        my $token_is_term = is_term($token);
        if (($token->[1] eq ',') && (($last->[1] eq '*start*') || ($last->[1] eq ','))) {
            push(@{$num_stack}, ['term', undef])
        }
        if ($Operator->{'prefix'}->{$token->[1]} && (($last->[1] eq '*start*') || !$last_is_term)) {
            $token->[0] = 'prefix';
            unshift(@{$op_stack}, $token)
        }
        elsif ($Operator->{'postfix'}->{$token->[1]} && $last_is_term) {
            my $pr = $Precedence->{$token->[1]};
            while (scalar(@{$op_stack}) && ($pr <= get_token_precedence($op_stack->[0]))) {
                $reduce->($op_stack, $num_stack)
            }
            if ($token->[0] ne 'postfix_or_term') {
                $token->[0] = 'postfix'
            }
            unshift(@{$op_stack}, $token);
            $token_is_term = 1
        }
        elsif ($token_is_term) {
            if ($last_is_term) {
                say('#      last:  ', Data::Dumper::Dumper($last));
                say('#      token: ', Data::Dumper::Dumper($token));
                die('Value tokens must be separated by an operator')
            }
            $token->[0] = 'term';
            push(@{$num_stack}, $token)
        }
        elsif ($Precedence->{$token->[1]}) {
            my $pr = $Precedence->{$token->[1]};
            if ($Assoc->{'right'}->{$token->[1]}) {
                while (scalar(@{$op_stack}) && ($pr < get_token_precedence($op_stack->[0]))) {
                    $reduce->($op_stack, $num_stack)
                }
            }
            else {
                while (scalar(@{$op_stack}) && ($pr <= get_token_precedence($op_stack->[0]))) {
                    $reduce->($op_stack, $num_stack)
                }
            }
            if ($Operator->{'ternary'}->{$token->[1]}) {
                $token->[0] = 'ternary'
            }
            else {
                $token->[0] = 'infix'
            }
            unshift(@{$op_stack}, $token)
        }
        else {
            die('Unknown token: ' . chr(39), $token->[1], chr(39))
        }
        $last = $token;
        $last_is_term = $token_is_term;
        $token = $get_token->($last_is_term);
        if ($token->[0] eq 'space') {
            $token = $get_token->($last_is_term)
        }
    }
    if (defined($token) && ($token->[0] ne 'end')) {
        die('Unexpected end token: ', $token)
    }
    while (scalar(@{$op_stack})) {
        $reduce->($op_stack, $num_stack)
    }
    $End_token = $last_end_token;
    $End_token_chars = $last_end_token_chars;
    return $num_stack
}
1;
package main;
package Perlito5::Grammar::Bareword;
# use strict
sub Perlito5::Grammar::Bareword::the_object {
    my $str = $_[0];
    my $pos = $_[1];
    my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
    my $tmp = ((do {
        my $pos1 = $MATCH->{'to'};
        (do {
            ((do {
                my $tmp = $MATCH;
                $MATCH = {'str' => $str, 'from' => $tmp->{'to'}, 'to' => $tmp->{'to'}};
                my $res = ('$' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}));
                $MATCH = $tmp;
                $res ? 1 : 0
            }) && (do {
                my $m2 = Perlito5::Grammar::Sigil::term_sigil($str, $MATCH->{'to'});
                if ($m2) {
                    $MATCH->{'to'} = $m2->{'to'};
                    $MATCH->{'Perlito5::Grammar::Sigil::term_sigil'} = $m2;
                    1
                }
                else {
                    0
                }
            }) && (do {
                $MATCH->{'str'} = $str;
                $MATCH->{'capture'} = Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::Sigil::term_sigil'})->[1];
                1
            }))
        }) || (do {
            $MATCH->{'to'} = $pos1;
            (('{' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                my $m2 = Perlito5::Grammar::Expression::curly_parse($str, $MATCH->{'to'});
                if ($m2) {
                    $MATCH->{'to'} = $m2->{'to'};
                    $MATCH->{'Perlito5::Grammar::Expression::curly_parse'} = $m2;
                    1
                }
                else {
                    0
                }
            }) && ('}' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                $MATCH->{'str'} = $str;
                $MATCH->{'capture'} = Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::Expression::curly_parse'});
                1
            }))
        }) || (do {
            $MATCH->{'to'} = $pos1;
            ((do {
                my $m2 = Perlito5::Grammar::Print::typeglob($str, $MATCH->{'to'});
                if ($m2) {
                    $MATCH->{'to'} = $m2->{'to'};
                    $MATCH->{'Perlito5::Grammar::Print::typeglob'} = $m2;
                    1
                }
                else {
                    0
                }
            }) && (do {
                $MATCH->{'str'} = $str;
                $MATCH->{'capture'} = Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::Print::typeglob'});
                1
            }))
        })
    }));
    $tmp ? $MATCH : 0
}
sub Perlito5::Grammar::Bareword::term_bareword {
    my $str = $_[0];
    my $pos = $_[1];
    my $p = $pos;
    my $m_namespace = Perlito5::Grammar::optional_namespace_before_ident($str, $p);
    my $namespace = Perlito5::Match::flat($m_namespace);
    $p = $m_namespace->{'to'};
    my $m_name = Perlito5::Grammar::ident($str, $p);
    if (!$m_name) {
        if ($namespace) {
            $m_namespace->{'capture'} = ['term', Perlito5::AST::Var::->new('sigil' => '::', 'name' => '', 'namespace' => $namespace)];
            return $m_namespace
        }
        return 
    }
    my $name = Perlito5::Match::flat($m_name);
    $p = $m_name->{'to'};
    if (substr($str, $p, 2) eq '::') {
        $m_name->{'to'} = $p + 2;
        $m_name->{'capture'} = ['term', Perlito5::AST::Var::->new('sigil' => '::', 'name' => '', 'namespace' => $namespace . '::' . $name)];
        return $m_name
    }
    my $full_name = $name;
    $namespace && ($full_name = $namespace . '::' . $name);
    my $m = Perlito5::Grammar::Space::ws($str, $p);
    if ($m) {
        $p = $m->{'to'}
    }
    my $invocant;
    my $is_subroutine_name;
    my $effective_name = ($namespace || $Perlito5::PKG_NAME) . '::' . $name;
    {
        my $p = eval {
            prototype($effective_name)
        };
        $p && ($Perlito5::PROTO->{$effective_name} = $p)
    }
    if (exists($Perlito5::Grammar::Print::Print{$name})) {
        $invocant = undef
    }
    elsif (exists($Perlito5::PROTO->{$effective_name}) || ((!$namespace || $namespace eq 'CORE') && exists($Perlito5::CORE_PROTO->{'CORE::' . $name}))) {
        $is_subroutine_name = 1;
        $invocant = Perlito5::Grammar::full_ident($str, $p);
        my $package = Perlito5::Match::flat($invocant);
        if ($package) {
            $invocant->{'capture'} = Perlito5::AST::Var::->new('sigil' => '::', 'name' => '', 'namespace' => $package);
            if (substr($str, $invocant->{'to'}, 2) eq '::') {
                $invocant->{'to'} = $invocant->{'to'} + 2
            }
            elsif (!$Perlito5::PACKAGES->{$package}) {
                $invocant = undef
            }
        }
    }
    else {
        $invocant = Perlito5::Grammar::Bareword::the_object($str, $p)
    }
    if ($invocant) {
        $p = $invocant->{'to'};
        my $arg = [];
        $m = Perlito5::Grammar::Space::ws($str, $p);
        $m && ($p = $m->{'to'});
        if (substr($str, $p, 2) eq '->') {}
        elsif (substr($str, $p, 1) eq '(') {
            my $m = Perlito5::Grammar::Expression::term_paren($str, $p);
            if ($m) {
                $arg = $m->{'capture'}->[2];
                $p = $m->{'to'};
                $arg = Perlito5::Grammar::Expression::expand_list($arg)
            }
        }
        else {
            my $m = Perlito5::Grammar::Expression::list_parse($str, $p);
            if ($m->{'capture'} ne '*undef*') {
                $arg = Perlito5::Grammar::Expression::expand_list($m->{'capture'});
                $p = $m->{'to'}
            }
        }
        $m_name->{'capture'} = ['term', Perlito5::AST::Call::->new('method' => $full_name, 'invocant' => Perlito5::Match::flat($invocant), 'arguments' => $arg)];
        $m_name->{'to'} = $p;
        return $m_name
    }
    if (substr($str, $p, 2) eq '=>') {
        $m_name->{'capture'} = ['term', Perlito5::AST::Apply::->new('code' => $name, 'namespace' => $namespace, 'arguments' => [], 'bareword' => 1)];
        $m_name->{'to'} = $p;
        return $m_name
    }
    if (substr($str, $p, 2) eq '->') {
        if ($is_subroutine_name) {
            $m_name->{'capture'} = ['term', Perlito5::AST::Apply::->new('arguments' => [], 'code' => $name, 'namespace' => $namespace)]
        }
        else {
            $m_name->{'capture'} = ['term', Perlito5::AST::Var::->new('name' => '', 'namespace' => $full_name, 'sigil' => '::')]
        }
        $m_name->{'to'} = $p;
        return $m_name
    }
    my $sig;
    if (exists($Perlito5::PROTO->{$effective_name})) {
        $sig = $Perlito5::PROTO->{$effective_name}
    }
    elsif ((!$namespace || $namespace eq 'CORE') && exists($Perlito5::CORE_PROTO->{'CORE::' . $name})) {
        $effective_name = 'CORE::' . $name;
        $sig = $Perlito5::CORE_PROTO->{$effective_name}
    }
    else {
        my $m = Perlito5::Grammar::Number::val_version($str, $pos);
        if ($m) {
            $m->{'capture'} = ['term', $m->{'capture'}];
            return $m
        }
        $sig = undef
    }
    my $has_paren = 0;
    if (defined($sig)) {
        my $arg_index = 1;
        my $optional = 0;
        my @args;
        my $sig_part = substr($sig, 0, 1);
        my $m;
        my $capture;
        if ($sig_part eq '&') {
            $m = Perlito5::Grammar::Space::ws($str, $p);
            $m && ($p = $m->{'to'});
            if (substr($str, $p, 1) ne '(') {
                $sig = substr($sig, 1);
                $m = Perlito5::Grammar::Bareword::prototype_is_ampersand($str, $p);
                $m && ($capture = $m->{'capture'});
                if (!$m) {
                    die('Type of arg ' . $arg_index . ' to ' . $name . ' must be block or sub {}')
                }
                $p = $m->{'to'};
                push(@args, $capture)
            }
        }
        if (substr($sig, 0, 1) eq ';' && substr($str, $p, 2) eq '//') {
            $m_name->{'capture'} = ['term', Perlito5::AST::Apply::->new('code' => $name, 'namespace' => $namespace, 'arguments' => [], 'bareword' => 1)];
            $m_name->{'to'} = $p;
            return $m_name
        }
        if ($sig eq '') {
            if (substr($str, $p, 1) eq '(') {
                $p++;
                $has_paren = 1;
                my $m = Perlito5::Grammar::Space::ws($str, $p);
                if ($m) {
                    $p = $m->{'to'}
                }
                if (substr($str, $p, 1) ne ')') {
                    die('syntax error near ', substr($str, $pos, 10))
                }
                $p++
            }
            if ($name eq '__FILE__') {
                $m_name->{'capture'} = ['term', Perlito5::AST::Buf::->new('buf' => $Perlito5::FILE_NAME)]
            }
            elsif ($name eq '__LINE__') {
                $m_name->{'capture'} = ['term', Perlito5::AST::Int::->new('int' => $Perlito5::LINE_NUMBER)]
            }
            else {
                $m_name->{'capture'} = ['term', Perlito5::AST::Apply::->new('code' => $name, 'namespace' => $namespace, 'arguments' => \@args, 'bareword' => ($has_paren == 0))]
            }
            $m_name->{'to'} = $p;
            return $m_name
        }
        if ($sig eq '_' || $sig eq '$' || $sig eq ';$') {
            my $m;
            my $arg;
            if (substr($str, $p, 1) eq '(') {
                $m = Perlito5::Grammar::Expression::term_paren($str, $p);
                if (!$m) {
                    return $m
                }
                $p = $m->{'to'};
                $has_paren = 1;
                $arg = $m->{'capture'}->[2];
                $arg = Perlito5::Grammar::Expression::expand_list($arg);
                my $v = shift(@{$arg});
                @{$arg} && die('Too many arguments for ' . $name);
                $arg = $v
            }
            else {
                $m = Perlito5::Grammar::Expression::argument_parse($str, $p);
                $arg = $m->{'capture'};
                if ($arg eq '*undef*') {
                    $arg = undef
                }
                elsif (ref($arg) eq 'Perlito5::AST::Apply' && $arg->{'code'} eq 'circumfix:<( )>') {
                    my $v = shift(@{$arg->{'arguments'}});
                    @{$arg->{'arguments'}} && die('Too many arguments for ' . $name);
                    $arg = $v
                }
            }
            if (defined($arg)) {
                push(@args, $arg);
                $has_paren = 1
            }
            else {
                $sig eq '$' && die('Not enough arguments for ' . $name);
                $sig eq '_' && push(@args, Perlito5::AST::Var::->new('namespace' => '', 'name' => '_', 'sigil' => '$'))
            }
            my $ast = Perlito5::AST::Apply::->new('code' => $name, 'namespace' => $namespace, 'arguments' => \@args, 'bareword' => ($has_paren == 0));
            if ($name eq 'eval' && !$namespace) {
                $ast->{'_scope'} = Perlito5::Grammar::Scope::get_snapshot()
            }
            $m->{'capture'} = ['term', $ast];
            return $m
        }
        if ($sig eq ';@') {
            if (substr($str, $p, 1) eq '(') {
                $m = Perlito5::Grammar::Expression::term_paren($str, $p);
                $has_paren = 1;
                my $arg = $m->{'capture'}->[2];
                $arg = Perlito5::Grammar::Expression::expand_list($arg);
                push(@args, @{$arg})
            }
            else {
                $m = Perlito5::Grammar::Expression::list_parse($str, $p);
                my $arg = $m->{'capture'};
                if ($arg ne '*undef*') {
                    $arg = Perlito5::Grammar::Expression::expand_list($arg);
                    push(@args, @{$arg})
                }
            }
            my $ast = Perlito5::AST::Apply::->new('code' => $name, 'namespace' => $namespace, 'arguments' => \@args, 'bareword' => ($has_paren == 0));
            $m->{'capture'} = ['term', $ast];
            return $m
        }
        if ($sig eq '*') {}
    }
    if (substr($str, $p, 1) eq '(') {
        $m = Perlito5::Grammar::Expression::term_paren($str, $p);
        if (!$m) {
            return $m
        }
        my $arg = $m->{'capture'}->[2];
        $arg = Perlito5::Grammar::Expression::expand_list($arg);
        if ($namespace eq '' || $namespace eq 'CORE') {
            if ($name eq 'local' || $name eq 'my' || $name eq 'state' || $name eq 'our') {
                my $declarator = $name;
                for my $var (@{$arg}) {
                    if (ref($var) eq 'Perlito5::AST::Apply' && $var->{'code'} eq 'undef') {}
                    else {
                        my $decl = Perlito5::AST::Decl::->new('decl' => $declarator, 'type' => '', 'var' => $var, 'attributes' => []);
                        $var->{'_decl'} = $name;
                        $var->{'_id'} = $Perlito5::ID++;
                        $declarator eq 'our' && ($var->{'_namespace'} = $Perlito5::PKG_NAME);
                        $declarator eq 'local' && !$var->{'namespace'} && !$var->{'_namespace'} && ($var->{'_namespace'} = $Perlito5::PKG_NAME)
                    }
                }
            }
            if ($name eq 'print' || $name eq 'say') {
                if (@{$arg} == 0) {
                    push(@{$arg}, Perlito5::AST::Var::->new('namespace' => '', 'name' => '_', 'sigil' => '$'))
                }
            }
            if ($name eq 'split') {
                if (@{$arg} == 0) {
                    push(@{$arg}, Perlito5::AST::Buf::->new('buf' => ' '))
                }
                if (@{$arg} == 1) {
                    push(@{$arg}, Perlito5::AST::Var::->new('namespace' => '', 'name' => '_', 'sigil' => '$'))
                }
            }
        }
        $m->{'capture'} = ['term', Perlito5::AST::Apply::->new('code' => $name, 'namespace' => $namespace, 'arguments' => $arg, 'proto' => $sig)];
        return $m
    }
    my $m_list = Perlito5::Grammar::Expression::list_parse($str, $p);
    my $list = $m_list->{'capture'};
    if ($list ne '*undef*') {
        $m_name->{'capture'} = ['postfix_or_term', 'funcall', $namespace, $name, $list];
        $m_name->{'to'} = $m_list->{'to'};
        return $m_name
    }
    if ($namespace eq '' || $namespace eq 'CORE') {
        if ($name eq 'print' || $name eq 'say') {
            $m_name->{'capture'} = ['term', Perlito5::AST::Apply::->new('code' => $name, 'namespace' => $namespace, 'arguments' => [Perlito5::AST::Var::->new('namespace' => '', 'name' => '_', 'sigil' => '$')])];
            return $m_name
        }
        if ($name eq 'split' && ($namespace eq '' || $namespace eq 'CORE')) {
            $m_name->{'capture'} = ['term', Perlito5::AST::Apply::->new('code' => $name, 'namespace' => $namespace, 'arguments' => [Perlito5::AST::Buf::->new('buf' => ' '), Perlito5::AST::Var::->new('namespace' => '', 'name' => '_', 'sigil' => '$')])];
            return $m_name
        }
    }
    $m_name->{'capture'} = ['postfix_or_term', 'funcall_no_params', $namespace, $name];
    return $m_name
}
sub Perlito5::Grammar::Bareword::prototype_is_ampersand {
    my $str = $_[0];
    my $pos = $_[1];
    my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
    my $tmp = ((do {
        my $pos1 = $MATCH->{'to'};
        (do {
            (('sub' eq substr($str, $MATCH->{'to'}, 3) && ($MATCH->{'to'} = 3 + $MATCH->{'to'})) && (do {
                my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{'to'});
                if ($m2) {
                    $MATCH->{'to'} = $m2->{'to'};
                    1
                }
                else {
                    0
                }
            }) && (do {
                my $m2 = Perlito5::Grammar::Block::anon_sub_def($str, $MATCH->{'to'});
                if ($m2) {
                    $MATCH->{'to'} = $m2->{'to'};
                    $MATCH->{'Perlito5::Grammar::Block::anon_sub_def'} = $m2;
                    1
                }
                else {
                    0
                }
            }) && (do {
                $MATCH->{'str'} = $str;
                $MATCH->{'capture'} = Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::Block::anon_sub_def'});
                1
            }))
        }) || (do {
            $MATCH->{'to'} = $pos1;
            ((do {
                my $m2 = Perlito5::Grammar::block($str, $MATCH->{'to'});
                if ($m2) {
                    $MATCH->{'to'} = $m2->{'to'};
                    $MATCH->{'Perlito5::Grammar::block'} = $m2;
                    1
                }
                else {
                    0
                }
            }) && (do {
                $MATCH->{'str'} = $str;
                $MATCH->{'capture'} = Perlito5::AST::Sub::->new('attributes' => [], 'block' => Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::block'}), 'name' => undef, 'namespace' => undef, 'sig' => undef);
                1
            }))
        }) || (do {
            $MATCH->{'to'} = $pos1;
            ((do {
                my $tmp = $MATCH;
                $MATCH = {'str' => $str, 'from' => $tmp->{'to'}, 'to' => $tmp->{'to'}};
                my $res = ((chr(92) eq substr($str, $MATCH->{'to'}, 2) && ($MATCH->{'to'} = 2 + $MATCH->{'to'})) && (do {
                    my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{'to'});
                    if ($m2) {
                        $MATCH->{'to'} = $m2->{'to'};
                        1
                    }
                    else {
                        0
                    }
                }) && ('&' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})));
                $MATCH = $tmp;
                $res ? 1 : 0
            }) && (do {
                my $m2 = Perlito5::Grammar::Expression::argument_parse($str, $MATCH->{'to'});
                if ($m2) {
                    $MATCH->{'to'} = $m2->{'to'};
                    $MATCH->{'Perlito5::Grammar::Expression::argument_parse'} = $m2;
                    1
                }
                else {
                    0
                }
            }) && (do {
                $MATCH->{'str'} = $str;
                $MATCH->{'capture'} = Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::Expression::argument_parse'});
                1
            }))
        })
    }));
    $tmp ? $MATCH : 0
}
1;
package main;
undef();
package Perlito5::Grammar::Attribute;
sub Perlito5::Grammar::Attribute::opt_attribute {
    my $str = $_[0];
    my $pos = $_[1];
    my @attributes;
    my $ws = Perlito5::Grammar::Space::opt_ws($str, $pos);
    if (substr($str, $ws->{'to'}, 1) ne ':') {
        return {'to' => $pos, 'capture' => []}
    }
    $ws = Perlito5::Grammar::Space::opt_ws($str, $ws->{'to'} + 1);
    my $p = $ws->{'to'};
    my $m = Perlito5::Grammar::ident($str, $p);
    !$m && die('syntax error');
    my $to;
    while (1) {
        my $attr = [Perlito5::Match::flat($m), undef];
        $to = $m->{'to'};
        my $delimiter = substr($str, $to, 1);
        if ($delimiter eq '(') {
            my $params = Perlito5::Grammar::String::string_interpolation_parse($str, $m->{'to'} + 1, '(', ')', 0);
            !$params && die('syntax error');
            $attr->[1] = Perlito5::Match::flat($params)->{'buf'};
            $to = $params->{'to'}
        }
        push(@attributes, $attr);
        $ws = Perlito5::Grammar::Space::opt_ws($str, $to);
        if (substr($str, $ws->{'to'}, 1) eq ':') {
            $ws = Perlito5::Grammar::Space::opt_ws($str, $ws->{'to'} + 1)
        }
        $p = $ws->{'to'};
        $m = Perlito5::Grammar::ident($str, $p);
        !$m && return {'to' => $to, 'capture' => \@attributes}
    }
}
1;
package main;
undef();
package Perlito5::Macro;
# use strict
{
    package Perlito5::AST::Apply;
    # use strict
    my %op = ('infix:<+=>' => 'infix:<+>', 'infix:<-=>' => 'infix:<->', 'infix:<*=>' => 'infix:<*>', 'infix:</=>' => 'infix:</>', 'infix:<||=>' => 'infix:<||>', 'infix:<&&=>' => 'infix:<&&>', 'infix:<|=>' => 'infix:<|>', 'infix:<&=>' => 'infix:<&>', 'infix:<//=>' => 'infix:<//>', 'infix:<.=>' => 'list:<.>', 'infix:<x=>' => 'infix:<x>');
    sub Perlito5::AST::Apply::op_assign {
        my $self = $_[0];
        my $code = $self->{'code'};
        ref($code) && return 0;
        if (exists($op{$code})) {
            return Perlito5::AST::Apply::->new('code' => 'infix:<=>', 'arguments' => [$self->{'arguments'}->[0], Perlito5::AST::Apply::->new('code' => $op{$code}, 'arguments' => $self->{'arguments'})])
        }
        return 0
    }
    my %op_auto = ('prefix:<++>' => 1, 'prefix:<-->' => 1, 'postfix:<++>' => 1, 'postfix:<-->' => 1);
    sub Perlito5::AST::Apply::op_auto {
        my $self = $_[0];
        my $code = $self->{'code'};
        ref($code) && return 0;
        if (exists($op_auto{$code})) {
            my $paren = $self->{'arguments'}->[0];
            if ($paren->{'code'} eq 'circumfix:<( )>') {
                my $arg = $paren->{'arguments'}->[-1];
                if ($arg->{'code'} eq 'infix:<=>') {
                    my $var = $arg->{'arguments'}->[0];
                    return Perlito5::AST::Apply::->new('code' => 'do', 'arguments' => [Perlito5::AST::Block::->new('stmts' => [$paren, Perlito5::AST::Apply::->new('code' => $code, 'arguments' => [$var])])])
                }
            }
        }
        return 0
    }
}
sub Perlito5::Macro::while_file {
    my $self = $_[0];
    ref($self) ne 'Perlito5::AST::While' && return 0;
    my $cond = $self->{'cond'};
    if ($cond->isa('Perlito5::AST::Apply') && ($cond->{'code'} eq 'readline')) {
        $self->{'cond'} = bless({'arguments' => [bless({'arguments' => [Perlito5::AST::Var::->new('name' => '_', 'namespace' => '', 'sigil' => '$'), $cond], 'code' => 'infix:<=>', 'namespace' => ''}, 'Perlito5::AST::Apply')], 'bareword' => '', 'code' => 'defined', 'namespace' => ''}, 'Perlito5::AST::Apply');
        return $self
    }
    return 0
}
package main;
package Perlito5::Grammar::Statement;
# use Perlito5::Macro
my @Statement_chars;
my %Statement;
sub Perlito5::Grammar::Statement::add_statement {
    my $name = shift;
    my $param = shift;
    $Statement{$name} = $param;
    unshift(@Statement_chars, scalar(@Statement_chars) + 1)
        while @Statement_chars < length($name)
}
sub Perlito5::Grammar::Statement::stmt_yadayada {
    my $str = $_[0];
    my $pos = $_[1];
    my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
    my $tmp = ((('...' eq substr($str, $MATCH->{'to'}, 3) && ($MATCH->{'to'} = 3 + $MATCH->{'to'})) && (do {
        $MATCH->{'str'} = $str;
        $MATCH->{'capture'} = Perlito5::AST::Apply::->new('code' => 'die', 'namespace' => '', 'arguments' => [Perlito5::AST::Buf::->new('buf' => 'Unimplemented')]);
        1
    })));
    $tmp ? $MATCH : 0
}
sub Perlito5::Grammar::Statement::stmt_format {
    my $str = $_[0];
    my $pos = $_[1];
    my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
    my $tmp = ((('format' eq substr($str, $MATCH->{'to'}, 6) && ($MATCH->{'to'} = 6 + $MATCH->{'to'})) && (do {
        my $m2 = Perlito5::Grammar::Space::ws($str, $MATCH->{'to'});
        if ($m2) {
            $MATCH->{'to'} = $m2->{'to'};
            1
        }
        else {
            0
        }
    }) && (do {
        my $pos1 = $MATCH->{'to'};
        (do {
            (do {
                my $m2 = Perlito5::Grammar::full_ident($str, $MATCH->{'to'});
                if ($m2) {
                    $MATCH->{'to'} = $m2->{'to'};
                    $MATCH->{'Perlito5::Grammar::full_ident'} = $m2;
                    1
                }
                else {
                    0
                }
            })
        }) || (do {
            $MATCH->{'to'} = $pos1;
            (do {
                $MATCH->{'str'} = $str;
                $MATCH->{'Perlito5::Grammar::full_ident'} = 'STDOUT';
                1
            })
        })
    }) && (do {
        $MATCH->{'str'} = $str;
        my $placeholder = Perlito5::AST::Apply::->new('code' => 'list:<.>', 'namespace' => '', 'arguments' => [Perlito5::AST::Apply::->new('code' => 'list:<.>', 'namespace' => '', 'arguments' => [])]);
        push(@Perlito5::Grammar::String::Here_doc, ['single_quote', $placeholder->{'arguments'}->[0]->{'arguments'}, '.']);
        $MATCH->{'capture'} = Perlito5::AST::Apply::->new('code' => 'p5:format', 'namespace' => '', 'arguments' => [Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::full_ident'}), $placeholder]);
        1
    }) && (do {
        my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{'to'});
        if ($m2) {
            $MATCH->{'to'} = $m2->{'to'};
            1
        }
        else {
            0
        }
    }) && ('=' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
        my $m2 = Perlito5::Grammar::Space::ws($str, $MATCH->{'to'});
        if ($m2) {
            $MATCH->{'to'} = $m2->{'to'};
            1
        }
        else {
            0
        }
    })));
    $tmp ? $MATCH : 0
}
sub Perlito5::Grammar::Statement::stmt_package {
    my $str = $_[0];
    my $pos = $_[1];
    my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
    my $tmp = ((('package' eq substr($str, $MATCH->{'to'}, 7) && ($MATCH->{'to'} = 7 + $MATCH->{'to'})) && (do {
        my $m2 = Perlito5::Grammar::Space::ws($str, $MATCH->{'to'});
        if ($m2) {
            $MATCH->{'to'} = $m2->{'to'};
            1
        }
        else {
            0
        }
    }) && (do {
        my $m2 = Perlito5::Grammar::full_ident($str, $MATCH->{'to'});
        if ($m2) {
            $MATCH->{'to'} = $m2->{'to'};
            $MATCH->{'Perlito5::Grammar::full_ident'} = $m2;
            1
        }
        else {
            0
        }
    }) && (do {
        my $pos1 = $MATCH->{'to'};
        (do {
            ((do {
                my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{'to'});
                if ($m2) {
                    $MATCH->{'to'} = $m2->{'to'};
                    1
                }
                else {
                    0
                }
            }) && (do {
                $MATCH->{'str'} = $str;
                my $name = Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::full_ident'});
                $MATCH->{'_package'} = $Perlito5::PKG_NAME;
                $Perlito5::PACKAGES->{$name} = 1;
                $Perlito5::PKG_NAME = $name;
                1
            }) && (do {
                my $m2 = Perlito5::Grammar::block($str, $MATCH->{'to'});
                if ($m2) {
                    $MATCH->{'to'} = $m2->{'to'};
                    $MATCH->{'Perlito5::Grammar::block'} = $m2;
                    1
                }
                else {
                    0
                }
            }) && (do {
                $MATCH->{'str'} = $str;
                $MATCH->{'capture'} = Perlito5::AST::Block::->new('stmts' => [Perlito5::AST::Apply::->new('code' => 'package', 'arguments' => [], 'namespace' => Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::full_ident'})), @{$MATCH->{'Perlito5::Grammar::block'}->{'capture'}->{'stmts'}}]);
                $Perlito5::PKG_NAME = $MATCH->{'_package'};
                1
            }))
        }) || (do {
            $MATCH->{'to'} = $pos1;
            (do {
                $MATCH->{'str'} = $str;
                my $name = Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::full_ident'});
                $Perlito5::PACKAGES->{$name} = 1;
                $Perlito5::PKG_NAME = $name;
                $MATCH->{'capture'} = Perlito5::AST::Apply::->new('code' => 'package', 'arguments' => [], 'namespace' => $name);
                1
            })
        })
    })));
    $tmp ? $MATCH : 0
}
sub Perlito5::Grammar::Statement::exp_stmt {
    my $str = $_[0];
    my $pos = $_[1];
    for my $len (@Statement_chars) {
        my $term = substr($str, $pos, $len);
        if (exists($Statement{$term})) {
            my $m = $Statement{$term}->($str, $pos);
            $m && return $m
        }
    }
    return 0
}
my @Modifier_chars = (7, 6, 5, 4, 3, 2);
my %Modifier = ('if' => 1, 'unless' => 1, 'when' => 1, 'for' => 1, 'foreach' => 1, 'while' => 1, 'until' => 1, 'given' => 1);
sub Perlito5::Grammar::Statement::statement_modifier {
    my $str = $_[0];
    my $pos = $_[1];
    my $expression = $_[2];
    for my $len (@Modifier_chars) {
        my $term = substr($str, $pos, $len);
        if (exists($Modifier{$term})) {
            my $m = modifier($str, $pos + $len, $term, $expression);
            $m && return $m
        }
    }
    return 0
}
sub Perlito5::Grammar::Statement::modifier {
    my $str = $_[0];
    my $pos = $_[1];
    my $modifier = $_[2];
    my $expression = $_[3];
    my $modifier_exp = Perlito5::Grammar::Expression::exp_parse($str, $pos);
    if (!$modifier_exp) {
        die('Expected expression after ' . chr(39), Perlito5::Match::flat($modifier), chr(39))
    }
    if ($modifier eq 'if') {
        return {'str' => $str, 'from' => $pos, 'to' => $modifier_exp->{'to'}, 'capture' => Perlito5::AST::Apply::->new('arguments' => [Perlito5::Match::flat($modifier_exp), $expression], 'code' => 'infix:<&&>', 'namespace' => '')}
    }
    if ($modifier eq 'unless') {
        return {'str' => $str, 'from' => $pos, 'to' => $modifier_exp->{'to'}, 'capture' => Perlito5::AST::Apply::->new('arguments' => [Perlito5::Match::flat($modifier_exp), $expression], 'code' => 'infix:<||>', 'namespace' => '')}
    }
    if ($modifier eq 'when') {
        return {'str' => $str, 'from' => $pos, 'to' => $modifier_exp->{'to'}, 'capture' => Perlito5::AST::When::->new('cond' => Perlito5::Match::flat($modifier_exp), 'body' => $expression)}
    }
    if ($modifier eq 'while') {
        my $stmt = Perlito5::AST::While::->new('cond' => Perlito5::Match::flat($modifier_exp), 'body' => $expression);
        my $out = Perlito5::Macro::while_file($stmt);
        $out && ($stmt = $out);
        return {'str' => $str, 'from' => $pos, 'to' => $modifier_exp->{'to'}, 'capture' => $stmt}
    }
    if ($modifier eq 'until') {
        my $stmt = Perlito5::AST::While::->new('cond' => Perlito5::AST::Apply::->new('arguments' => [Perlito5::Match::flat($modifier_exp)], 'code' => 'prefix:<!>', 'namespace' => ''), 'body' => $expression);
        return {'str' => $str, 'from' => $pos, 'to' => $modifier_exp->{'to'}, 'capture' => $stmt}
    }
    if ($modifier eq 'for' || $modifier eq 'foreach') {
        return {'str' => $str, 'from' => $pos, 'to' => $modifier_exp->{'to'}, 'capture' => Perlito5::AST::For::->new('cond' => Perlito5::Match::flat($modifier_exp), 'body' => $expression, 'topic' => Perlito5::AST::Var::->new('namespace' => '', 'name' => '_', 'sigil' => '$'))}
    }
    die('Unexpected statement modifier ' . chr(39) . $modifier . chr(39))
}
sub Perlito5::Grammar::Statement::statement_parse {
    my $m = statement_parse_inner(@_);
    !@Perlito5::SCOPE_STMT && return $m;
    Perlito5::Grammar::Scope::check_variable_declarations();
    return $m
}
sub Perlito5::Grammar::Statement::statement_parse_inner {
    my $str = $_[0];
    my $pos = $_[1];
    my $res = exp_stmt($str, $pos);
    if ($res) {
        return $res
    }
    $res = Perlito5::Grammar::Expression::exp_parse($str, $pos);
    if (!$res) {
        return 
    }
    if (substr($str, $res->{'to'}, 1) eq ':' && $res->{'capture'}->isa('Perlito5::AST::Apply') && $res->{'capture'}->{'bareword'}) {
        my $label = $res->{'capture'}->{'code'};
        my $ws = Perlito5::Grammar::Space::opt_ws($str, $res->{'to'} + 1);
        my $stmt = statement_parse($str, $ws->{'to'});
        if ($stmt) {
            $stmt->{'capture'}->{'label'} = $label;
            return $stmt
        }
        $res->{'to'} = $ws->{'to'};
        $res->{'capture'} = Perlito5::AST::Apply::->new('arguments' => [], 'code' => 'undef', 'namespace' => '', 'label' => $label);
        return $res
    }
    my $modifier = statement_modifier($str, $res->{'to'}, Perlito5::Match::flat($res));
    my $p = $modifier ? $modifier->{'to'} : $res->{'to'};
    my $terminator = substr($str, $p, 1);
    $terminator ne ';' && $terminator ne '}' && $terminator ne '' && die('Number or Bareword found where operator expected');
    if (!$modifier) {
        return $res
    }
    return $modifier
}
Perlito5::Grammar::Statement::add_statement('...' => \&stmt_yadayada);
Perlito5::Grammar::Statement::add_statement('package' => \&stmt_package);
Perlito5::Grammar::Statement::add_statement('format' => \&stmt_format);
1;
package main;
package Perlito5::Grammar::Expression;
# use Perlito5::Grammar::Precedence
# use Perlito5::Grammar::Bareword
# use Perlito5::Grammar::Attribute
# use Perlito5::Grammar::Statement
sub Perlito5::Grammar::Expression::expand_list {
    my $param_list = shift;
    if (ref($param_list) eq 'Perlito5::AST::Apply' && $param_list->code() eq 'list:<,>') {
        return [grep {
            defined($_)
        } @{$param_list->arguments()}]
    }
    elsif ($param_list eq '*undef*') {
        return []
    }
    else {
        return [$param_list]
    }
}
sub Perlito5::Grammar::Expression::block_or_hash {
    my $o = shift;
    if (defined($o->sig())) {
        return $o
    }
    my $stmts = $o->stmts();
    if (!(defined($stmts)) || scalar(@{$stmts}) == 0) {
        return Perlito5::AST::Apply::->new('code' => 'circumfix:<{ }>', 'namespace' => '', 'arguments' => [])
    }
    if (scalar(@{$stmts}) != 1) {
        return $o
    }
    my $stmt = $stmts->[0];
    if (ref($stmt) eq 'Perlito5::AST::Var') {
        return Perlito5::AST::Apply::->new('code' => 'circumfix:<{ }>', 'namespace' => '', 'arguments' => [$stmt])
    }
    if (ref($stmt) ne 'Perlito5::AST::Apply') {
        return $o
    }
    if ($stmt->code() eq 'infix:<=>>') {
        return Perlito5::AST::Apply::->new('code' => 'circumfix:<{ }>', 'namespace' => '', 'arguments' => [$stmt])
    }
    if ($stmt->code() ne 'list:<,>') {
        return $o
    }
    return Perlito5::AST::Apply::->new('code' => 'circumfix:<{ }>', 'namespace' => '', 'arguments' => expand_list($stmt))
}
sub Perlito5::Grammar::Expression::pop_term {
    my $num_stack = shift;
    my $v = pop(@{$num_stack});
    if (ref($v) eq 'ARRAY') {
        ref($v->[1]) && return $v->[1];
        if ($v->[1] eq 'methcall_no_params') {
            $v = Perlito5::AST::Call::->new('invocant' => undef, 'method' => $v->[2], 'arguments' => []);
            return $v
        }
        if ($v->[1] eq 'funcall_no_params') {
            $v = Perlito5::AST::Apply::->new('code' => $v->[3], 'namespace' => $v->[2], 'arguments' => [], 'bareword' => 1);
            return $v
        }
        if ($v->[1] eq 'methcall') {
            my $param_list = expand_list(($v->[3]));
            $v = Perlito5::AST::Call::->new('invocant' => undef, 'method' => $v->[2], 'arguments' => $param_list);
            return $v
        }
        if ($v->[1] eq 'funcall') {
            my $param_list = expand_list(($v->[4]));
            $v = Perlito5::AST::Apply::->new('code' => $v->[3], 'arguments' => $param_list, 'namespace' => $v->[2]);
            return $v
        }
        if ($v->[1] eq '( )') {
            my $param_list = expand_list($v->[2]);
            $v = Perlito5::AST::Apply::->new('code' => 'circumfix:<( )>', 'arguments' => $param_list, 'namespace' => '');
            return $v
        }
        if ($v->[1] eq '[ ]') {
            my $param_list = expand_list($v->[2]);
            $v = Perlito5::AST::Apply::->new('code' => 'circumfix:<[ ]>', 'arguments' => $param_list, 'namespace' => '');
            return $v
        }
        if ($v->[1] eq 'block') {
            $v = Perlito5::AST::Block::->new('stmts' => $v->[2], 'sig' => $v->[3]);
            $v = block_or_hash($v);
            return $v
        }
        if ($v->[1] eq '.( )') {
            $v = Perlito5::AST::Call::->new('invocant' => undef, 'method' => 'postcircumfix:<( )>', 'arguments' => $v->[2]);
            return $v
        }
        if ($v->[1] eq '.[ ]') {
            $v = Perlito5::AST::Index::->new('obj' => undef, 'index_exp' => $v->[2]);
            return $v
        }
        if ($v->[1] eq '.{ }') {
            $v = Perlito5::AST::Lookup::->new('obj' => undef, 'index_exp' => $v->[2]);
            return $v
        }
        return $v->[1]
    }
    return $v
}
sub Perlito5::Grammar::Expression::reduce_postfix {
    my $op = shift;
    my $value = shift;
    my $v = $op;
    if ($v->[1] eq 'methcall_no_params') {
        $v = Perlito5::AST::Call::->new('invocant' => $value, 'method' => $v->[2], 'arguments' => []);
        return $v
    }
    if ($v->[1] eq 'funcall_no_params') {
        die('Bareword found where operator expected')
    }
    if ($v->[1] eq 'methcall') {
        my $param_list = expand_list($v->[3]);
        $v = Perlito5::AST::Call::->new('invocant' => $value, 'method' => $v->[2], 'arguments' => $param_list);
        return $v
    }
    if ($v->[1] eq 'funcall') {
        die('unexpected function call')
    }
    if ($v->[1] eq '( )') {
        my $param_list = expand_list($v->[2]);
        if (ref($value) eq 'Perlito5::AST::Apply' && !(defined($value->arguments()))) {
            $value->{'arguments'} = $param_list;
            return $value
        }
        if (ref($value) eq 'Perlito5::AST::Call' && !(defined($value->arguments()))) {
            $value->{'arguments'} = $param_list;
            return $value
        }
        $v = Perlito5::AST::Call::->new('invocant' => $value, 'method' => 'postcircumfix:<( )>', 'arguments' => $param_list);
        return $v
    }
    if ($v->[1] eq '[ ]') {
        if (ref($value) eq 'Perlito5::AST::Var') {
            $value->{'_real_sigil'} = '@'
        }
        $v = Perlito5::AST::Index::->new('obj' => $value, 'index_exp' => $v->[2]);
        return $v
    }
    if ($v->[1] eq 'block') {
        if (ref($value) eq 'Perlito5::AST::Var') {
            $value->{'_real_sigil'} = '%'
        }
        $v = Perlito5::AST::Lookup::->new('obj' => $value, 'index_exp' => $v->[2]->[0]);
        return $v
    }
    if ($v->[1] eq '.( )') {
        my $param_list = expand_list($v->[2]);
        $v = Perlito5::AST::Call::->new('invocant' => $value, 'method' => 'postcircumfix:<( )>', 'arguments' => $param_list);
        return $v
    }
    if ($v->[1] eq '.[ ]') {
        $v = Perlito5::AST::Call::->new('invocant' => $value, 'method' => 'postcircumfix:<[ ]>', 'arguments' => $v->[2]);
        return $v
    }
    if ($v->[1] eq '.{ }') {
        $v = Perlito5::AST::Call::->new('invocant' => $value, 'method' => 'postcircumfix:<{ }>', 'arguments' => $v->[2]);
        return $v
    }
    push(@{$op}, $value);
    return $op
}
my $reduce_to_ast = sub {
    my $op_stack = shift;
    my $num_stack = shift;
    my $last_op = shift(@{$op_stack});
    if ($last_op->[0] eq 'prefix') {
        push(@{$num_stack}, Perlito5::AST::Apply::->new('namespace' => '', 'code' => 'prefix:<' . $last_op->[1] . '>', 'arguments' => [pop_term($num_stack)]))
    }
    elsif ($last_op->[0] eq 'postfix') {
        push(@{$num_stack}, Perlito5::AST::Apply::->new('namespace' => '', 'code' => 'postfix:<' . $last_op->[1] . '>', 'arguments' => [pop_term($num_stack)]))
    }
    elsif ($last_op->[0] eq 'postfix_or_term') {
        push(@{$num_stack}, reduce_postfix($last_op, pop_term($num_stack)))
    }
    elsif (Perlito5::Grammar::Precedence::is_assoc_type('list', $last_op->[1])) {
        my $arg;
        if (scalar(@{$num_stack}) < 2) {
            my $v2 = pop_term($num_stack);
            if (ref($v2) eq 'Perlito5::AST::Apply' && $v2->code() eq ('list:<' . $last_op->[1] . '>')) {
                push(@{$num_stack}, Perlito5::AST::Apply::->new('namespace' => $v2->namespace(), 'code' => $v2->code(), 'arguments' => [@{$v2->arguments()}]))
            }
            else {
                push(@{$num_stack}, Perlito5::AST::Apply::->new('namespace' => '', 'code' => 'list:<' . $last_op->[1] . '>', 'arguments' => [$v2]))
            }
            return 
        }
        else {
            my $v2 = pop_term($num_stack);
            $arg = [pop_term($num_stack), $v2]
        }
        if (ref($arg->[0]) eq 'Perlito5::AST::Apply' && $last_op->[0] eq 'infix' && ($arg->[0]->code() eq 'list:<' . $last_op->[1] . '>')) {
            push(@{$num_stack}, Perlito5::AST::Apply::->new('namespace' => '', 'code' => ($arg->[0])->code(), 'arguments' => [@{($arg->[0])->arguments()}, $arg->[1]]));
            return 
        }
        push(@{$num_stack}, Perlito5::AST::Apply::->new('namespace' => '', 'code' => 'list:<' . $last_op->[1] . '>', 'arguments' => $arg))
    }
    elsif (Perlito5::Grammar::Precedence::is_assoc_type('chain', $last_op->[1])) {
        if (scalar(@{$num_stack}) < 2) {
            die('Missing value after operator ' . $last_op->[1])
        }
        my $v2 = pop_term($num_stack);
        my $arg = [pop_term($num_stack), $v2];
        push(@{$num_stack}, Perlito5::AST::Apply::->new('namespace' => '', 'code' => 'infix:<' . $last_op->[1] . '>', 'arguments' => $arg))
    }
    elsif ($last_op->[0] eq 'ternary') {
        if (scalar(@{$num_stack}) < 2) {
            die('Missing value after ternary operator')
        }
        my $v2 = pop_term($num_stack);
        push(@{$num_stack}, Perlito5::AST::Apply::->new('namespace' => '', 'code' => 'ternary:<' . $last_op->[1] . '>', 'arguments' => [pop_term($num_stack), $last_op->[2], $v2]))
    }
    else {
        if (scalar(@{$num_stack}) < 2) {
            die('missing value after operator ' . chr(39) . $last_op->[1] . chr(39))
        }
        my $v2 = pop_term($num_stack);
        push(@{$num_stack}, Perlito5::AST::Apply::->new('namespace' => '', 'code' => 'infix:<' . $last_op->[1] . '>', 'arguments' => [pop_term($num_stack), $v2]))
    }
};
sub Perlito5::Grammar::Expression::term_arrow {
    my $str = $_[0];
    my $pos = $_[1];
    my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
    my $tmp = ((('->' eq substr($str, $MATCH->{'to'}, 2) && ($MATCH->{'to'} = 2 + $MATCH->{'to'})) && (do {
        my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{'to'});
        if ($m2) {
            $MATCH->{'to'} = $m2->{'to'};
            1
        }
        else {
            0
        }
    }) && (do {
        my $pos1 = $MATCH->{'to'};
        (do {
            (('(' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                my $m2 = paren_parse($str, $MATCH->{'to'});
                if ($m2) {
                    $MATCH->{'to'} = $m2->{'to'};
                    $MATCH->{'paren_parse'} = $m2;
                    1
                }
                else {
                    0
                }
            }) && (')' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                $MATCH->{'str'} = $str;
                $MATCH->{'capture'} = ['postfix_or_term', '.( )', Perlito5::Match::flat($MATCH->{'paren_parse'})];
                1
            }))
        }) || (do {
            $MATCH->{'to'} = $pos1;
            (('[' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                my $m2 = square_parse($str, $MATCH->{'to'});
                if ($m2) {
                    $MATCH->{'to'} = $m2->{'to'};
                    $MATCH->{'square_parse'} = $m2;
                    1
                }
                else {
                    0
                }
            }) && (']' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                $MATCH->{'str'} = $str;
                $MATCH->{'capture'} = ['postfix_or_term', '.[ ]', Perlito5::Match::flat($MATCH->{'square_parse'})];
                1
            }))
        }) || (do {
            $MATCH->{'to'} = $pos1;
            (('{' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                my $m2 = curly_parse($str, $MATCH->{'to'});
                if ($m2) {
                    $MATCH->{'to'} = $m2->{'to'};
                    $MATCH->{'curly_parse'} = $m2;
                    1
                }
                else {
                    0
                }
            }) && (do {
                my $pos1 = $MATCH->{'to'};
                (do {
                    ('}' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}))
                }) || (do {
                    $MATCH->{'to'} = $pos1;
                    (do {
                        $MATCH->{'str'} = $str;
                        die('Missing right curly or square bracket');
                        1
                    })
                })
            }) && (do {
                $MATCH->{'str'} = $str;
                $MATCH->{'capture'} = ['postfix_or_term', '.{ }', Perlito5::Match::flat($MATCH->{'curly_parse'})];
                1
            }))
        }) || (do {
            $MATCH->{'to'} = $pos1;
            (('$' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                my $m2 = Perlito5::Grammar::ident($str, $MATCH->{'to'});
                if ($m2) {
                    $MATCH->{'to'} = $m2->{'to'};
                    $MATCH->{'Perlito5::Grammar::ident'} = $m2;
                    1
                }
                else {
                    0
                }
            }) && (do {
                my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{'to'});
                if ($m2) {
                    $MATCH->{'to'} = $m2->{'to'};
                    1
                }
                else {
                    0
                }
            }) && (do {
                my $pos1 = $MATCH->{'to'};
                (do {
                    (('(' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                        my $m2 = paren_parse($str, $MATCH->{'to'});
                        if ($m2) {
                            $MATCH->{'to'} = $m2->{'to'};
                            $MATCH->{'paren_parse'} = $m2;
                            1
                        }
                        else {
                            0
                        }
                    }) && (')' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                        $MATCH->{'str'} = $str;
                        $MATCH->{'capture'} = ['postfix_or_term', 'methcall', Perlito5::AST::Var::->new('sigil' => '$', 'namespace' => '', 'name' => Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::ident'})), Perlito5::Match::flat($MATCH->{'paren_parse'})];
                        1
                    }))
                }) || (do {
                    $MATCH->{'to'} = $pos1;
                    (do {
                        $MATCH->{'str'} = $str;
                        $MATCH->{'capture'} = ['postfix_or_term', 'methcall_no_params', Perlito5::AST::Var::->new('sigil' => '$', 'namespace' => '', 'name' => Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::ident'}))];
                        1
                    })
                })
            }))
        }) || (do {
            $MATCH->{'to'} = $pos1;
            ((do {
                my $m2 = Perlito5::Grammar::full_ident($str, $MATCH->{'to'});
                if ($m2) {
                    $MATCH->{'to'} = $m2->{'to'};
                    $MATCH->{'Perlito5::Grammar::full_ident'} = $m2;
                    1
                }
                else {
                    0
                }
            }) && (do {
                my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{'to'});
                if ($m2) {
                    $MATCH->{'to'} = $m2->{'to'};
                    1
                }
                else {
                    0
                }
            }) && (do {
                my $pos1 = $MATCH->{'to'};
                (do {
                    (('(' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                        my $m2 = paren_parse($str, $MATCH->{'to'});
                        if ($m2) {
                            $MATCH->{'to'} = $m2->{'to'};
                            $MATCH->{'paren_parse'} = $m2;
                            1
                        }
                        else {
                            0
                        }
                    }) && (')' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                        $MATCH->{'str'} = $str;
                        $MATCH->{'capture'} = ['postfix_or_term', 'methcall', Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::full_ident'}), Perlito5::Match::flat($MATCH->{'paren_parse'})];
                        1
                    }))
                }) || (do {
                    $MATCH->{'to'} = $pos1;
                    (do {
                        $MATCH->{'str'} = $str;
                        $MATCH->{'capture'} = ['postfix_or_term', 'methcall_no_params', Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::full_ident'})];
                        1
                    })
                })
            }))
        })
    })));
    $tmp ? $MATCH : 0
}
sub Perlito5::Grammar::Expression::term_ternary {
    my $str = $_[0];
    my $pos = $_[1];
    my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
    my $tmp = ((('?' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
        my $m2 = ternary5_parse($str, $MATCH->{'to'});
        if ($m2) {
            $MATCH->{'to'} = $m2->{'to'};
            $MATCH->{'ternary5_parse'} = $m2;
            1
        }
        else {
            0
        }
    }) && (':' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
        $MATCH->{'str'} = $str;
        $MATCH->{'capture'} = ['op', '? :', Perlito5::Match::flat($MATCH->{'ternary5_parse'})];
        1
    })));
    $tmp ? $MATCH : 0
}
sub Perlito5::Grammar::Expression::term_paren {
    my $str = $_[0];
    my $pos = $_[1];
    my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
    my $tmp = ((('(' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
        my $m2 = paren_parse($str, $MATCH->{'to'});
        if ($m2) {
            $MATCH->{'to'} = $m2->{'to'};
            $MATCH->{'paren_parse'} = $m2;
            1
        }
        else {
            0
        }
    }) && (')' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
        $MATCH->{'str'} = $str;
        $MATCH->{'capture'} = ['postfix_or_term', '( )', Perlito5::Match::flat($MATCH->{'paren_parse'})];
        1
    })));
    $tmp ? $MATCH : 0
}
sub Perlito5::Grammar::Expression::term_square {
    my $str = $_[0];
    my $pos = $_[1];
    my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
    my $tmp = ((('[' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
        my $m2 = square_parse($str, $MATCH->{'to'});
        if ($m2) {
            $MATCH->{'to'} = $m2->{'to'};
            $MATCH->{'square_parse'} = $m2;
            1
        }
        else {
            0
        }
    }) && (']' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
        $MATCH->{'str'} = $str;
        $MATCH->{'capture'} = ['postfix_or_term', '[ ]', Perlito5::Match::flat($MATCH->{'square_parse'})];
        1
    })));
    $tmp ? $MATCH : 0
}
sub Perlito5::Grammar::Expression::term_curly {
    my $str = $_[0];
    my $pos = $_[1];
    my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
    my $tmp = ((('{' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
        my $m = $MATCH;
        if (!(do {
            my $m2 = Perlito5::Grammar::Space::ws($str, $MATCH->{'to'});
            if ($m2) {
                $MATCH->{'to'} = $m2->{'to'};
                1
            }
            else {
                0
            }
        })) {
            $MATCH = $m
        }
        1
    }) && (do {
        $MATCH->{'str'} = $str;
        $MATCH->{'_save_scope'} = [@Perlito5::SCOPE_STMT];
        @Perlito5::SCOPE_STMT = ();
        1
    }) && (do {
        my $m2 = Perlito5::Grammar::exp_stmts($str, $MATCH->{'to'});
        if ($m2) {
            $MATCH->{'to'} = $m2->{'to'};
            $MATCH->{'Perlito5::Grammar::exp_stmts'} = $m2;
            1
        }
        else {
            0
        }
    }) && (do {
        $MATCH->{'str'} = $str;
        @Perlito5::SCOPE_STMT = @{$MATCH->{'_save_scope'}};
        1
    }) && (do {
        my $m = $MATCH;
        if (!(do {
            my $m2 = Perlito5::Grammar::Space::ws($str, $MATCH->{'to'});
            if ($m2) {
                $MATCH->{'to'} = $m2->{'to'};
                1
            }
            else {
                0
            }
        })) {
            $MATCH = $m
        }
        1
    }) && (do {
        my $pos1 = $MATCH->{'to'};
        (do {
            ('}' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}))
        }) || (do {
            $MATCH->{'to'} = $pos1;
            (do {
                $MATCH->{'str'} = $str;
                die('Missing right curly or square bracket');
                1
            })
        })
    }) && (do {
        $MATCH->{'str'} = $str;
        $MATCH->{'capture'} = ['postfix_or_term', 'block', Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::exp_stmts'})];
        1
    })));
    $tmp ? $MATCH : 0
}
sub Perlito5::Grammar::Expression::declarator {
    my $str = $_[0];
    my $pos = $_[1];
    my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
    my $tmp = ((do {
        my $pos1 = $MATCH->{'to'};
        (do {
            ('my' eq substr($str, $MATCH->{'to'}, 2) && ($MATCH->{'to'} = 2 + $MATCH->{'to'}))
        }) || (do {
            $MATCH->{'to'} = $pos1;
            ('state' eq substr($str, $MATCH->{'to'}, 5) && ($MATCH->{'to'} = 5 + $MATCH->{'to'}))
        }) || (do {
            $MATCH->{'to'} = $pos1;
            ('our' eq substr($str, $MATCH->{'to'}, 3) && ($MATCH->{'to'} = 3 + $MATCH->{'to'}))
        })
    }));
    $tmp ? $MATCH : 0
}
sub Perlito5::Grammar::Expression::term_declarator {
    my $str = $_[0];
    my $pos = $_[1];
    my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
    my $tmp = (((do {
        my $m2 = declarator($str, $MATCH->{'to'});
        if ($m2) {
            $MATCH->{'to'} = $m2->{'to'};
            $MATCH->{'declarator'} = $m2;
            1
        }
        else {
            0
        }
    }) && (do {
        my $pos1 = $MATCH->{'to'};
        (do {
            ((do {
                my $m2 = Perlito5::Grammar::Space::ws($str, $MATCH->{'to'});
                if ($m2) {
                    $MATCH->{'to'} = $m2->{'to'};
                    1
                }
                else {
                    0
                }
            }) && (do {
                my $pos1 = $MATCH->{'to'};
                (do {
                    ((do {
                        my $m2 = Perlito5::Grammar::Block::named_sub($str, $MATCH->{'to'});
                        if ($m2) {
                            $MATCH->{'to'} = $m2->{'to'};
                            $MATCH->{'Perlito5::Grammar::Block::named_sub'} = $m2;
                            1
                        }
                        else {
                            0
                        }
                    }) && (do {
                        $MATCH->{'str'} = $str;
                        my $sub = $MATCH->{'Perlito5::Grammar::Block::named_sub'}->{'capture'};
                        $sub->{'decl'} = Perlito5::Match::flat($MATCH->{'declarator'});
                        $MATCH->{'capture'} = ['term', $sub];
                        return $MATCH;
                        1
                    }))
                }) || (do {
                    $MATCH->{'to'} = $pos1;
                    (do {
                        my $m2 = Perlito5::Grammar::opt_type($str, $MATCH->{'to'});
                        if ($m2) {
                            $MATCH->{'to'} = $m2->{'to'};
                            $MATCH->{'Perlito5::Grammar::opt_type'} = $m2;
                            1
                        }
                        else {
                            0
                        }
                    })
                })
            }))
        }) || (do {
            $MATCH->{'to'} = $pos1;
            1
        })
    }) && (do {
        my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{'to'});
        if ($m2) {
            $MATCH->{'to'} = $m2->{'to'};
            1
        }
        else {
            0
        }
    }) && (do {
        my $m2 = Perlito5::Grammar::var_ident($str, $MATCH->{'to'});
        if ($m2) {
            $MATCH->{'to'} = $m2->{'to'};
            $MATCH->{'Perlito5::Grammar::var_ident'} = $m2;
            1
        }
        else {
            0
        }
    }) && (do {
        my $m2 = Perlito5::Grammar::Attribute::opt_attribute($str, $MATCH->{'to'});
        if ($m2) {
            $MATCH->{'to'} = $m2->{'to'};
            $MATCH->{'Perlito5::Grammar::Attribute::opt_attribute'} = $m2;
            1
        }
        else {
            0
        }
    }) && (do {
        $MATCH->{'str'} = $str;
        my $declarator = Perlito5::Match::flat($MATCH->{'declarator'});
        my $type = Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::opt_type'});
        $type && !$Perlito5::PACKAGES->{$type} && die('No such class ' . $type);
        my $var = $MATCH->{'Perlito5::Grammar::var_ident'}->{'capture'};
        $var->{'namespace'} && die('No package name allowed for variable ' . $var->{'sigil'} . $var->{'name'} . ' in "' . $declarator . '"');
        $var->{'_decl'} = $declarator;
        $var->{'_id'} = $Perlito5::ID++;
        $declarator eq 'our' && ($var->{'_namespace'} = $Perlito5::PKG_NAME);
        my $decl = Perlito5::AST::Decl::->new('decl' => $declarator, 'type' => $type, 'var' => $var, 'attributes' => Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::Attribute::opt_attribute'}));
        $MATCH->{'capture'} = ['term', $decl];
        1
    })));
    $tmp ? $MATCH : 0
}
sub Perlito5::Grammar::Expression::term_not {
    my $str = $_[0];
    my $pos = $_[1];
    my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
    my $tmp = ((('not' eq substr($str, $MATCH->{'to'}, 3) && ($MATCH->{'to'} = 3 + $MATCH->{'to'})) && (do {
        my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{'to'});
        if ($m2) {
            $MATCH->{'to'} = $m2->{'to'};
            1
        }
        else {
            0
        }
    }) && ('(' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
        my $m2 = paren_parse($str, $MATCH->{'to'});
        if ($m2) {
            $MATCH->{'to'} = $m2->{'to'};
            $MATCH->{'paren_parse'} = $m2;
            1
        }
        else {
            0
        }
    }) && (')' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
        $MATCH->{'str'} = $str;
        $MATCH->{'capture'} = ['term', Perlito5::AST::Apply::->new('code' => 'prefix:<not>', 'arguments' => expand_list(Perlito5::Match::flat($MATCH->{'paren_parse'})), 'namespace' => '')];
        1
    })));
    $tmp ? $MATCH : 0
}
sub Perlito5::Grammar::Expression::term_local {
    my $str = $_[0];
    my $pos = $_[1];
    my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
    my $tmp = ((('local' eq substr($str, $MATCH->{'to'}, 5) && ($MATCH->{'to'} = 5 + $MATCH->{'to'})) && (do {
        my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{'to'});
        if ($m2) {
            $MATCH->{'to'} = $m2->{'to'};
            1
        }
        else {
            0
        }
    }) && (do {
        my $m2 = Perlito5::Grammar::Sigil::term_sigil($str, $MATCH->{'to'});
        if ($m2) {
            $MATCH->{'to'} = $m2->{'to'};
            $MATCH->{'Perlito5::Grammar::Sigil::term_sigil'} = $m2;
            1
        }
        else {
            0
        }
    }) && (do {
        $MATCH->{'str'} = $str;
        my $declarator = 'local';
        my $type = '';
        $MATCH->{'capture'} = Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::Sigil::term_sigil'})->[1];
        $MATCH = Perlito5::Grammar::String::double_quoted_var_with_subscript($MATCH);
        my $var = $MATCH->{'capture'};
        my $look = Perlito5::Grammar::Scope::lookup_variable($var);
        if ($look && ($look->{'_decl'} eq 'my' || $look->{'_decl'} eq 'state')) {
            die('Can' . chr(39) . 't localize lexical variable ' . $var->{'sigil'} . $var->{'name'})
        }
        $var->{'_id'} = $Perlito5::ID++;
        $var->{'_decl'} = $declarator;
        !$var->{'namespace'} && !$var->{'_namespace'} && ($var->{'_namespace'} = $Perlito5::PKG_NAME);
        my $decl = Perlito5::AST::Decl::->new('decl' => $declarator, 'type' => $type, 'var' => $var);
        $MATCH->{'capture'} = ['term', $decl];
        1
    })));
    $tmp ? $MATCH : 0
}
sub Perlito5::Grammar::Expression::term_return {
    my $str = $_[0];
    my $pos = $_[1];
    my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
    my $tmp = ((('return' eq substr($str, $MATCH->{'to'}, 6) && ($MATCH->{'to'} = 6 + $MATCH->{'to'})) && (do {
        my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{'to'});
        if ($m2) {
            $MATCH->{'to'} = $m2->{'to'};
            1
        }
        else {
            0
        }
    }) && (do {
        my $m2 = list_parse($str, $MATCH->{'to'});
        if ($m2) {
            $MATCH->{'to'} = $m2->{'to'};
            $MATCH->{'list_parse'} = $m2;
            1
        }
        else {
            0
        }
    }) && (do {
        $MATCH->{'str'} = $str;
        my $args = Perlito5::Match::flat($MATCH->{'list_parse'});
        $MATCH->{'capture'} = ['term', Perlito5::AST::Apply::->new('code' => 'return', 'arguments' => $args eq '*undef*' ? [] : [$args], 'namespace' => '')];
        1
    })));
    $tmp ? $MATCH : 0
}
sub Perlito5::Grammar::Expression::term_eval {
    my $str = $_[0];
    my $pos = $_[1];
    my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
    my $tmp = ((('eval' eq substr($str, $MATCH->{'to'}, 4) && ($MATCH->{'to'} = 4 + $MATCH->{'to'})) && (do {
        my $m2 = Perlito5::Grammar::block($str, $MATCH->{'to'});
        if ($m2) {
            $MATCH->{'to'} = $m2->{'to'};
            $MATCH->{'Perlito5::Grammar::block'} = $m2;
            1
        }
        else {
            0
        }
    }) && (do {
        $MATCH->{'str'} = $str;
        $MATCH->{'capture'} = ['term', Perlito5::AST::Apply::->new('code' => 'eval', 'arguments' => [Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::block'})], 'namespace' => '')];
        1
    })));
    $tmp ? $MATCH : 0
}
my $Expr_end_token_chars = [7, 6, 5, 4, 3, 2, 1];
my $Expr_end_token = {']' => 1, ')' => 1, '}' => 1, ';' => 1, 'if' => 1, 'for' => 1, 'else' => 1, 'when' => 1, 'while' => 1, 'until' => 1, 'elsif' => 1, 'unless' => 1, 'foreach' => 1};
my $List_end_token = {':' => 1, 'or' => 1, 'and' => 1, 'xor' => 1, %{$Expr_end_token}};
my $Argument_end_token = {',' => 1, '<' => 1, '>' => 1, '=' => 1, '|' => 1, '^' => 1, '?' => 1, '=>' => 1, 'lt' => 1, 'le' => 1, 'gt' => 1, 'ge' => 1, '<=' => 1, '>=' => 1, '==' => 1, '!=' => 1, 'ne' => 1, 'eq' => 1, '..' => 1, '~~' => 1, '&&' => 1, '||' => 1, '+=' => 1, '-=' => 1, '*=' => 1, '/=' => 1, 'x=' => 1, '|=' => 1, '&=' => 1, '.=' => 1, '^=' => 1, '%=' => 1, '//' => 1, '...' => 1, '<=>' => 1, 'cmp' => 1, '<<=' => 1, '>>=' => 1, '||=' => 1, '&&=' => 1, '//=' => 1, '**=' => 1, %{$List_end_token}};
sub Perlito5::Grammar::Expression::list_parser {
    my($str, $pos, $end_token) = @_;
    my $expr;
    my $last_pos = $pos;
    my $is_first_token = 1;
    my $lexer_stack = [];
    my $last_token_was_space = 1;
    my $get_token = sub {
        my $last_is_term = $_[0];
        my $v;
        if (scalar(@{$lexer_stack})) {
            $v = pop(@{$lexer_stack});
            if ($is_first_token && ($v->[0] eq 'op') && !(Perlito5::Grammar::Precedence::is_fixity_type('prefix', $v->[1]))) {
                $v->[0] = 'end'
            }
        }
        else {
            my $m = Perlito5::Grammar::Precedence::op_parse($str, $last_pos, $last_is_term);
            if ($m) {
                my $spc = Perlito5::Grammar::Space::ws($str, $m->{'to'});
                if ($spc) {
                    $m->{'to'} = $spc->{'to'}
                }
            }
            if (!$m) {
                return ['end', '*end*']
            }
            $v = $m->{'capture'};
            if ($is_first_token && ($v->[0] eq 'op') && !(Perlito5::Grammar::Precedence::is_fixity_type('prefix', $v->[1]))) {
                $v->[0] = 'end'
            }
            if ($v->[0] ne 'end') {
                $last_pos = $m->{'to'}
            }
        }
        $last_token_was_space = ($v->[0] eq 'space');
        $is_first_token = 0;
        return $v
    };
    my $prec = Perlito5::Grammar::Precedence::->new('get_token' => $get_token, 'reduce' => $reduce_to_ast, 'end_token' => $end_token, 'end_token_chars' => $Expr_end_token_chars);
    my $res = $prec->precedence_parse();
    if (scalar(@{$res}) == 0) {
        return {'str' => $str, 'from' => $pos, 'to' => $last_pos, 'capture' => '*undef*'}
    }
    my $result = pop_term($res);
    return {'str' => $str, 'from' => $pos, 'to' => $last_pos, 'capture' => $result}
}
sub Perlito5::Grammar::Expression::argument_parse {
    my($str, $pos) = @_;
    return list_parser($str, $pos, $Argument_end_token)
}
sub Perlito5::Grammar::Expression::list_parse {
    my($str, $pos) = @_;
    return list_parser($str, $pos, $List_end_token)
}
sub Perlito5::Grammar::Expression::circumfix_parse {
    my($str, $pos, $delimiter) = @_;
    my $expr;
    my $last_pos = $pos;
    my $get_token = sub {
        my $last_is_term = $_[0];
        my $m = Perlito5::Grammar::Precedence::op_parse($str, $last_pos, $last_is_term);
        if ($m) {
            my $spc = Perlito5::Grammar::Space::ws($str, $m->{'to'});
            if ($spc) {
                $m->{'to'} = $spc->{'to'}
            }
        }
        if (!$m) {
            my $msg = 'Expected closing delimiter: ' . $delimiter;
            ($delimiter eq '}' || $delimiter eq ']') && ($msg = 'Missing right curly or square bracket');
            die($msg . ' near ', $last_pos)
        }
        my $v = $m->{'capture'};
        if ($v->[0] ne 'end') {
            $last_pos = $m->{'to'}
        }
        return $v
    };
    my %delim_token;
    $delim_token{$delimiter} = 1;
    my $prec = Perlito5::Grammar::Precedence::->new('get_token' => $get_token, 'reduce' => $reduce_to_ast, 'end_token' => \%delim_token, 'end_token_chars' => [length($delimiter)]);
    my $res = $prec->precedence_parse();
    $res = pop_term($res);
    if (!(defined($res))) {
        $res = '*undef*'
    }
    return {'str' => $str, 'from' => $pos, 'to' => $last_pos, 'capture' => $res}
}
sub Perlito5::Grammar::Expression::ternary5_parse {
    return circumfix_parse(@_, ':')
}
sub Perlito5::Grammar::Expression::curly_parse {
    return circumfix_parse(@_, '}')
}
sub Perlito5::Grammar::Expression::square_parse {
    return circumfix_parse(@_, ']')
}
sub Perlito5::Grammar::Expression::paren_parse {
    return circumfix_parse(@_, ')')
}
sub Perlito5::Grammar::Expression::exp_parse {
    my($str, $pos) = @_;
    my $expr;
    my $last_pos = $pos;
    my $lexer_stack = [];
    my $get_token = sub {
        my $last_is_term = $_[0];
        my $v;
        if (scalar(@{$lexer_stack})) {
            $v = pop(@{$lexer_stack})
        }
        else {
            my $m = Perlito5::Grammar::Precedence::op_parse($str, $last_pos, $last_is_term);
            if ($m) {
                my $spc = Perlito5::Grammar::Space::ws($str, $m->{'to'});
                if ($spc) {
                    $m->{'to'} = $spc->{'to'}
                }
            }
            if (!$m) {
                return ['end', '*end*']
            }
            $v = $m->{'capture'};
            if ($v->[0] ne 'end') {
                $last_pos = $m->{'to'}
            }
        }
        return $v
    };
    my $prec = Perlito5::Grammar::Precedence::->new('get_token' => $get_token, 'reduce' => $reduce_to_ast, 'end_token' => $Expr_end_token, 'end_token_chars' => $Expr_end_token_chars);
    my $res = $prec->precedence_parse();
    if (scalar(@{$res}) == 0) {
        return 0
    }
    my $result = pop_term($res);
    return {'str' => $str, 'from' => $pos, 'to' => $last_pos, 'capture' => $result}
}
Perlito5::Grammar::Precedence::add_term('my' => \&term_declarator);
Perlito5::Grammar::Precedence::add_term('our' => \&term_declarator);
Perlito5::Grammar::Precedence::add_term('eval' => \&term_eval);
Perlito5::Grammar::Precedence::add_term('state' => \&term_declarator);
Perlito5::Grammar::Precedence::add_term('local' => \&term_local);
Perlito5::Grammar::Precedence::add_term('return' => \&term_return);
Perlito5::Grammar::Precedence::add_term('not' => \&term_not);
1;
package main;
package Perlito5::Grammar;
# use strict
# use Perlito5::Grammar::Expression
sub Perlito5::Grammar::unless {
    my $str = $_[0];
    my $pos = $_[1];
    my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
    my $tmp = ((('unless' eq substr($str, $MATCH->{'to'}, 6) && ($MATCH->{'to'} = 6 + $MATCH->{'to'})) && (do {
        my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{'to'});
        if ($m2) {
            $MATCH->{'to'} = $m2->{'to'};
            1
        }
        else {
            0
        }
    }) && (do {
        $MATCH->{'str'} = $str;
        Perlito5::Grammar::Scope::create_new_compile_time_scope();
        1
    }) && (do {
        my $m2 = Perlito5::Grammar::Expression::term_paren($str, $MATCH->{'to'});
        if ($m2) {
            $MATCH->{'to'} = $m2->{'to'};
            $MATCH->{'Perlito5::Grammar::Expression::term_paren'} = $m2;
            1
        }
        else {
            0
        }
    }) && (do {
        my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{'to'});
        if ($m2) {
            $MATCH->{'to'} = $m2->{'to'};
            1
        }
        else {
            0
        }
    }) && (do {
        my $m2 = block($str, $MATCH->{'to'});
        if ($m2) {
            $MATCH->{'to'} = $m2->{'to'};
            $MATCH->{'block'} = $m2;
            1
        }
        else {
            0
        }
    }) && (do {
        my $pos1 = $MATCH->{'to'};
        (do {
            ((do {
                my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{'to'});
                if ($m2) {
                    $MATCH->{'to'} = $m2->{'to'};
                    1
                }
                else {
                    0
                }
            }) && ('else' eq substr($str, $MATCH->{'to'}, 4) && ($MATCH->{'to'} = 4 + $MATCH->{'to'})) && (do {
                my $m2 = block2($str, $MATCH->{'to'});
                if ($m2) {
                    $MATCH->{'to'} = $m2->{'to'};
                    $MATCH->{'block2'} = $m2;
                    1
                }
                else {
                    0
                }
            }) && (do {
                $MATCH->{'str'} = $str;
                $MATCH->{'capture'} = Perlito5::AST::If::->new('cond' => Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::Expression::term_paren'})->[2], 'body' => Perlito5::Match::flat($MATCH->{'block2'}), 'otherwise' => Perlito5::Match::flat($MATCH->{'block'}));
                1
            }))
        }) || (do {
            $MATCH->{'to'} = $pos1;
            (do {
                $MATCH->{'str'} = $str;
                $MATCH->{'capture'} = Perlito5::AST::If::->new('cond' => Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::Expression::term_paren'})->[2], 'body' => Perlito5::AST::Block::->new('stmts' => []), 'otherwise' => Perlito5::Match::flat($MATCH->{'block'}));
                1
            })
        })
    }) && (do {
        $MATCH->{'str'} = $str;
        Perlito5::Grammar::Scope::end_compile_time_scope();
        1
    })));
    $tmp ? $MATCH : 0
}
sub Perlito5::Grammar::if_ {
    my $str = $_[0];
    my $pos = $_[1];
    my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
    my $tmp = ((('if' eq substr($str, $MATCH->{'to'}, 2) && ($MATCH->{'to'} = 2 + $MATCH->{'to'})) && (do {
        my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{'to'});
        if ($m2) {
            $MATCH->{'to'} = $m2->{'to'};
            1
        }
        else {
            0
        }
    }) && (do {
        $MATCH->{'str'} = $str;
        Perlito5::Grammar::Scope::create_new_compile_time_scope();
        1
    }) && (do {
        my $m2 = Perlito5::Grammar::Expression::term_paren($str, $MATCH->{'to'});
        if ($m2) {
            $MATCH->{'to'} = $m2->{'to'};
            $MATCH->{'Perlito5::Grammar::Expression::term_paren'} = $m2;
            1
        }
        else {
            0
        }
    }) && (do {
        my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{'to'});
        if ($m2) {
            $MATCH->{'to'} = $m2->{'to'};
            1
        }
        else {
            0
        }
    }) && (do {
        my $m2 = block($str, $MATCH->{'to'});
        if ($m2) {
            $MATCH->{'to'} = $m2->{'to'};
            $MATCH->{'block'} = $m2;
            1
        }
        else {
            0
        }
    }) && (do {
        my $pos1 = $MATCH->{'to'};
        (do {
            ((do {
                my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{'to'});
                if ($m2) {
                    $MATCH->{'to'} = $m2->{'to'};
                    1
                }
                else {
                    0
                }
            }) && ('else' eq substr($str, $MATCH->{'to'}, 4) && ($MATCH->{'to'} = 4 + $MATCH->{'to'})) && (do {
                my $m2 = block2($str, $MATCH->{'to'});
                if ($m2) {
                    $MATCH->{'to'} = $m2->{'to'};
                    $MATCH->{'block2'} = $m2;
                    1
                }
                else {
                    0
                }
            }) && (do {
                $MATCH->{'str'} = $str;
                $MATCH->{'capture'} = Perlito5::AST::If::->new('cond' => Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::Expression::term_paren'})->[2], 'body' => Perlito5::Match::flat($MATCH->{'block'}), 'otherwise' => Perlito5::Match::flat($MATCH->{'block2'}));
                1
            }))
        }) || (do {
            $MATCH->{'to'} = $pos1;
            ((do {
                my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{'to'});
                if ($m2) {
                    $MATCH->{'to'} = $m2->{'to'};
                    1
                }
                else {
                    0
                }
            }) && ('els' eq substr($str, $MATCH->{'to'}, 3) && ($MATCH->{'to'} = 3 + $MATCH->{'to'})) && (do {
                my $m2 = if_($str, $MATCH->{'to'});
                if ($m2) {
                    $MATCH->{'to'} = $m2->{'to'};
                    $MATCH->{'if_'} = $m2;
                    1
                }
                else {
                    0
                }
            }) && (do {
                $MATCH->{'str'} = $str;
                $MATCH->{'capture'} = Perlito5::AST::If::->new('cond' => Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::Expression::term_paren'})->[2], 'body' => Perlito5::Match::flat($MATCH->{'block'}), 'otherwise' => Perlito5::AST::Block::->new('stmts' => [Perlito5::Match::flat($MATCH->{'if_'})]));
                1
            }))
        }) || (do {
            $MATCH->{'to'} = $pos1;
            (do {
                $MATCH->{'str'} = $str;
                $MATCH->{'capture'} = Perlito5::AST::If::->new('cond' => Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::Expression::term_paren'})->[2], 'body' => Perlito5::Match::flat($MATCH->{'block'}), 'otherwise' => Perlito5::AST::Block::->new('stmts' => []));
                1
            })
        })
    }) && (do {
        $MATCH->{'str'} = $str;
        Perlito5::Grammar::Scope::end_compile_time_scope();
        1
    })));
    $tmp ? $MATCH : 0
}
sub Perlito5::Grammar::when {
    my $str = $_[0];
    my $pos = $_[1];
    my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
    my $tmp = ((('when' eq substr($str, $MATCH->{'to'}, 4) && ($MATCH->{'to'} = 4 + $MATCH->{'to'})) && (do {
        my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{'to'});
        if ($m2) {
            $MATCH->{'to'} = $m2->{'to'};
            1
        }
        else {
            0
        }
    }) && (do {
        $MATCH->{'str'} = $str;
        Perlito5::Grammar::Scope::create_new_compile_time_scope();
        1
    }) && (do {
        my $m2 = Perlito5::Grammar::Expression::term_paren($str, $MATCH->{'to'});
        if ($m2) {
            $MATCH->{'to'} = $m2->{'to'};
            $MATCH->{'Perlito5::Grammar::Expression::term_paren'} = $m2;
            1
        }
        else {
            0
        }
    }) && (do {
        my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{'to'});
        if ($m2) {
            $MATCH->{'to'} = $m2->{'to'};
            1
        }
        else {
            0
        }
    }) && (do {
        my $m2 = block($str, $MATCH->{'to'});
        if ($m2) {
            $MATCH->{'to'} = $m2->{'to'};
            $MATCH->{'block'} = $m2;
            1
        }
        else {
            0
        }
    }) && (do {
        $MATCH->{'str'} = $str;
        $MATCH->{'capture'} = Perlito5::AST::When::->new('cond' => Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::Expression::term_paren'})->[2], 'body' => Perlito5::Match::flat($MATCH->{'block'}));
        1
    }) && (do {
        $MATCH->{'str'} = $str;
        Perlito5::Grammar::Scope::end_compile_time_scope();
        1
    })));
    $tmp ? $MATCH : 0
}
sub Perlito5::Grammar::for {
    my $str = $_[0];
    my $pos = $_[1];
    my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
    my $tmp = ((('for' eq substr($str, $MATCH->{'to'}, 3) && ($MATCH->{'to'} = 3 + $MATCH->{'to'})) && (do {
        my $m = $MATCH;
        if (!('each' eq substr($str, $MATCH->{'to'}, 4) && ($MATCH->{'to'} = 4 + $MATCH->{'to'}))) {
            $MATCH = $m
        }
        1
    }) && (do {
        $MATCH->{'str'} = $str;
        Perlito5::Grammar::Scope::create_new_compile_time_scope();
        1
    }) && (do {
        my $pos1 = $MATCH->{'to'};
        (do {
            ((do {
                my $pos1 = $MATCH->{'to'};
                (do {
                    ((do {
                        my $m2 = Perlito5::Grammar::Space::ws($str, $MATCH->{'to'});
                        if ($m2) {
                            $MATCH->{'to'} = $m2->{'to'};
                            1
                        }
                        else {
                            0
                        }
                    }) && (do {
                        my $m2 = Perlito5::Grammar::Expression::term_declarator($str, $MATCH->{'to'});
                        if ($m2) {
                            $MATCH->{'to'} = $m2->{'to'};
                            $MATCH->{'Perlito5::Grammar::Expression::term_declarator'} = $m2;
                            1
                        }
                        else {
                            0
                        }
                    }) && (do {
                        $MATCH->{'str'} = $str;
                        $MATCH->{'_tmp'} = Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::Expression::term_declarator'})->[1];
                        1
                    }))
                }) || (do {
                    $MATCH->{'to'} = $pos1;
                    ((do {
                        my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{'to'});
                        if ($m2) {
                            $MATCH->{'to'} = $m2->{'to'};
                            1
                        }
                        else {
                            0
                        }
                    }) && (do {
                        my $tmp = $MATCH;
                        $MATCH = {'str' => $str, 'from' => $tmp->{'to'}, 'to' => $tmp->{'to'}};
                        my $res = ('$' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}));
                        $MATCH = $tmp;
                        $res ? 1 : 0
                    }) && (do {
                        my $m2 = Perlito5::Grammar::Sigil::term_sigil($str, $MATCH->{'to'});
                        if ($m2) {
                            $MATCH->{'to'} = $m2->{'to'};
                            $MATCH->{'Perlito5::Grammar::Sigil::term_sigil'} = $m2;
                            1
                        }
                        else {
                            0
                        }
                    }) && (do {
                        $MATCH->{'str'} = $str;
                        $MATCH->{'_tmp'} = Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::Sigil::term_sigil'})->[1];
                        1
                    }))
                })
            }) && (do {
                my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{'to'});
                if ($m2) {
                    $MATCH->{'to'} = $m2->{'to'};
                    1
                }
                else {
                    0
                }
            }) && ('(' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                my $m2 = Perlito5::Grammar::Expression::paren_parse($str, $MATCH->{'to'});
                if ($m2) {
                    $MATCH->{'to'} = $m2->{'to'};
                    $MATCH->{'Perlito5::Grammar::Expression::paren_parse'} = $m2;
                    1
                }
                else {
                    0
                }
            }) && (')' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                my $m2 = block($str, $MATCH->{'to'});
                if ($m2) {
                    $MATCH->{'to'} = $m2->{'to'};
                    $MATCH->{'block'} = $m2;
                    1
                }
                else {
                    0
                }
            }) && (do {
                my $m2 = opt_continue_block($str, $MATCH->{'to'});
                if ($m2) {
                    $MATCH->{'to'} = $m2->{'to'};
                    $MATCH->{'opt_continue_block'} = $m2;
                    1
                }
                else {
                    0
                }
            }) && (do {
                $MATCH->{'str'} = $str;
                my $body = Perlito5::Match::flat($MATCH->{'block'});
                $MATCH->{'capture'} = Perlito5::AST::For::->new('cond' => Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::Expression::paren_parse'}), 'body' => $body, 'continue' => $MATCH->{'opt_continue_block'}->{'capture'}, 'topic' => $MATCH->{'_tmp'});
                1
            }))
        }) || (do {
            $MATCH->{'to'} = $pos1;
            ((do {
                my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{'to'});
                if ($m2) {
                    $MATCH->{'to'} = $m2->{'to'};
                    1
                }
                else {
                    0
                }
            }) && ('(' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                my $pos1 = $MATCH->{'to'};
                (do {
                    ((do {
                        my $m2 = Perlito5::Grammar::Expression::exp_parse($str, $MATCH->{'to'});
                        if ($m2) {
                            $MATCH->{'to'} = $m2->{'to'};
                            $MATCH->{'Perlito5::Grammar::Expression::exp_parse'} = $m2;
                            1
                        }
                        else {
                            0
                        }
                    }) && (do {
                        $MATCH->{'str'} = $str;
                        Perlito5::Grammar::Scope::check_variable_declarations();
                        1
                    }))
                }) || (do {
                    $MATCH->{'to'} = $pos1;
                    ()
                }) || (do {
                    $MATCH->{'to'} = $pos1;
                    ((do {
                        my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{'to'});
                        if ($m2) {
                            $MATCH->{'to'} = $m2->{'to'};
                            1
                        }
                        else {
                            0
                        }
                    }) && (do {
                        my $tmp = $MATCH;
                        $MATCH = {'str' => $str, 'from' => $tmp->{'to'}, 'to' => $tmp->{'to'}};
                        my $res = (';' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}));
                        $MATCH = $tmp;
                        $res ? 1 : 0
                    }))
                })
            }) && (do {
                my $pos1 = $MATCH->{'to'};
                (do {
                    ((';' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                        $MATCH->{'str'} = $str;
                        $MATCH->{'c_style_for'} = 1;
                        1
                    }) && (do {
                        my $pos1 = $MATCH->{'to'};
                        (do {
                            ((do {
                                my $m2 = Perlito5::Grammar::exp($str, $MATCH->{'to'});
                                if ($m2) {
                                    $MATCH->{'to'} = $m2->{'to'};
                                    $MATCH->{'Perlito5::Grammar::exp'} = $m2;
                                    1
                                }
                                else {
                                    0
                                }
                            }) && (do {
                                $MATCH->{'str'} = $str;
                                Perlito5::Grammar::Scope::check_variable_declarations();
                                1
                            }))
                        }) || (do {
                            $MATCH->{'to'} = $pos1;
                            ()
                        }) || (do {
                            $MATCH->{'to'} = $pos1;
                            (do {
                                my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{'to'});
                                if ($m2) {
                                    $MATCH->{'to'} = $m2->{'to'};
                                    1
                                }
                                else {
                                    0
                                }
                            })
                        })
                    }) && (';' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                        my $pos1 = $MATCH->{'to'};
                        (do {
                            (do {
                                my $m2 = Perlito5::Grammar::exp2($str, $MATCH->{'to'});
                                if ($m2) {
                                    $MATCH->{'to'} = $m2->{'to'};
                                    $MATCH->{'Perlito5::Grammar::exp2'} = $m2;
                                    1
                                }
                                else {
                                    0
                                }
                            })
                        }) || (do {
                            $MATCH->{'to'} = $pos1;
                            ()
                        }) || (do {
                            $MATCH->{'to'} = $pos1;
                            (do {
                                my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{'to'});
                                if ($m2) {
                                    $MATCH->{'to'} = $m2->{'to'};
                                    1
                                }
                                else {
                                    0
                                }
                            })
                        })
                    }))
                }) || (do {
                    $MATCH->{'to'} = $pos1;
                    1
                })
            }) && (')' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                my $m2 = block($str, $MATCH->{'to'});
                if ($m2) {
                    $MATCH->{'to'} = $m2->{'to'};
                    $MATCH->{'block'} = $m2;
                    1
                }
                else {
                    0
                }
            }) && (do {
                my $m2 = opt_continue_block($str, $MATCH->{'to'});
                if ($m2) {
                    $MATCH->{'to'} = $m2->{'to'};
                    $MATCH->{'opt_continue_block'} = $m2;
                    1
                }
                else {
                    0
                }
            }) && (do {
                $MATCH->{'str'} = $str;
                my $header;
                my $body = Perlito5::Match::flat($MATCH->{'block'});
                my $topic;
                if ($MATCH->{'c_style_for'}) {
                    $header = [$MATCH->{'Perlito5::Grammar::Expression::exp_parse'}->{'capture'}, $MATCH->{'Perlito5::Grammar::exp'}->{'capture'}, $MATCH->{'Perlito5::Grammar::exp2'}->{'capture'}]
                }
                else {
                    $header = $MATCH->{'Perlito5::Grammar::Expression::exp_parse'}->{'capture'};
                    $topic = Perlito5::AST::Var::->new('namespace' => '', 'name' => '_', 'sigil' => '$')
                }
                $MATCH->{'capture'} = Perlito5::AST::For::->new('cond' => $header, 'body' => $body, 'continue' => $MATCH->{'opt_continue_block'}->{'capture'}, 'topic' => $topic);
                1
            }))
        })
    }) && (do {
        $MATCH->{'str'} = $str;
        Perlito5::Grammar::Scope::end_compile_time_scope();
        1
    })));
    $tmp ? $MATCH : 0
}
sub Perlito5::Grammar::while {
    my $str = $_[0];
    my $pos = $_[1];
    my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
    my $tmp = ((('while' eq substr($str, $MATCH->{'to'}, 5) && ($MATCH->{'to'} = 5 + $MATCH->{'to'})) && (do {
        my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{'to'});
        if ($m2) {
            $MATCH->{'to'} = $m2->{'to'};
            1
        }
        else {
            0
        }
    }) && (do {
        $MATCH->{'str'} = $str;
        Perlito5::Grammar::Scope::create_new_compile_time_scope();
        1
    }) && ('(' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
        my $m2 = Perlito5::Grammar::Expression::paren_parse($str, $MATCH->{'to'});
        if ($m2) {
            $MATCH->{'to'} = $m2->{'to'};
            $MATCH->{'Perlito5::Grammar::Expression::paren_parse'} = $m2;
            1
        }
        else {
            0
        }
    }) && (')' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
        my $m2 = block($str, $MATCH->{'to'});
        if ($m2) {
            $MATCH->{'to'} = $m2->{'to'};
            $MATCH->{'block'} = $m2;
            1
        }
        else {
            0
        }
    }) && (do {
        my $m2 = opt_continue_block($str, $MATCH->{'to'});
        if ($m2) {
            $MATCH->{'to'} = $m2->{'to'};
            $MATCH->{'opt_continue_block'} = $m2;
            1
        }
        else {
            0
        }
    }) && (do {
        $MATCH->{'str'} = $str;
        my $cond = Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::Expression::paren_parse'});
        if ($cond eq '*undef*') {
            $cond = Perlito5::AST::Int::->new('int' => 1)
        }
        my $stmt = Perlito5::AST::While::->new('cond' => $cond, 'body' => Perlito5::Match::flat($MATCH->{'block'}), 'continue' => $MATCH->{'opt_continue_block'}->{'capture'});
        my $out = Perlito5::Macro::while_file($stmt);
        $out && ($stmt = $out);
        $MATCH->{'capture'} = $stmt;
        1
    }) && (do {
        $MATCH->{'str'} = $str;
        Perlito5::Grammar::Scope::end_compile_time_scope();
        1
    })));
    $tmp ? $MATCH : 0
}
sub Perlito5::Grammar::until {
    my $str = $_[0];
    my $pos = $_[1];
    my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
    my $tmp = ((('until' eq substr($str, $MATCH->{'to'}, 5) && ($MATCH->{'to'} = 5 + $MATCH->{'to'})) && (do {
        my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{'to'});
        if ($m2) {
            $MATCH->{'to'} = $m2->{'to'};
            1
        }
        else {
            0
        }
    }) && (do {
        $MATCH->{'str'} = $str;
        Perlito5::Grammar::Scope::create_new_compile_time_scope();
        1
    }) && ('(' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
        my $m2 = Perlito5::Grammar::Expression::paren_parse($str, $MATCH->{'to'});
        if ($m2) {
            $MATCH->{'to'} = $m2->{'to'};
            $MATCH->{'Perlito5::Grammar::Expression::paren_parse'} = $m2;
            1
        }
        else {
            0
        }
    }) && (')' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
        my $m2 = block($str, $MATCH->{'to'});
        if ($m2) {
            $MATCH->{'to'} = $m2->{'to'};
            $MATCH->{'block'} = $m2;
            1
        }
        else {
            0
        }
    }) && (do {
        my $m2 = opt_continue_block($str, $MATCH->{'to'});
        if ($m2) {
            $MATCH->{'to'} = $m2->{'to'};
            $MATCH->{'opt_continue_block'} = $m2;
            1
        }
        else {
            0
        }
    }) && (do {
        $MATCH->{'str'} = $str;
        my $cond = Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::Expression::paren_parse'});
        if ($cond eq '*undef*') {
            $cond = Perlito5::AST::Int::->new('int' => 1)
        }
        $MATCH->{'capture'} = Perlito5::AST::While::->new('cond' => Perlito5::AST::Apply::->new('arguments' => [$cond], 'code' => 'prefix:<!>', 'namespace' => ''), 'body' => Perlito5::Match::flat($MATCH->{'block'}), 'continue' => $MATCH->{'opt_continue_block'}->{'capture'});
        1
    }) && (do {
        $MATCH->{'str'} = $str;
        Perlito5::Grammar::Scope::end_compile_time_scope();
        1
    })));
    $tmp ? $MATCH : 0
}
sub Perlito5::Grammar::given {
    my $str = $_[0];
    my $pos = $_[1];
    my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
    my $tmp = ((('given' eq substr($str, $MATCH->{'to'}, 5) && ($MATCH->{'to'} = 5 + $MATCH->{'to'})) && (do {
        my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{'to'});
        if ($m2) {
            $MATCH->{'to'} = $m2->{'to'};
            1
        }
        else {
            0
        }
    }) && (do {
        $MATCH->{'str'} = $str;
        Perlito5::Grammar::Scope::create_new_compile_time_scope();
        1
    }) && ('(' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
        my $m2 = Perlito5::Grammar::Expression::paren_parse($str, $MATCH->{'to'});
        if ($m2) {
            $MATCH->{'to'} = $m2->{'to'};
            $MATCH->{'Perlito5::Grammar::Expression::paren_parse'} = $m2;
            1
        }
        else {
            0
        }
    }) && (')' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
        my $m2 = block($str, $MATCH->{'to'});
        if ($m2) {
            $MATCH->{'to'} = $m2->{'to'};
            $MATCH->{'block'} = $m2;
            1
        }
        else {
            0
        }
    }) && (do {
        $MATCH->{'str'} = $str;
        my $body = Perlito5::Match::flat($MATCH->{'block'});
        $body->{'sig'} = Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::var_ident'});
        $MATCH->{'capture'} = Perlito5::AST::Given::->new('cond' => Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::Expression::paren_parse'}), 'body' => $body);
        1
    }) && (do {
        $MATCH->{'str'} = $str;
        Perlito5::Grammar::Scope::end_compile_time_scope();
        1
    })));
    $tmp ? $MATCH : 0
}
Perlito5::Grammar::Statement::add_statement('if' => \&if_);
Perlito5::Grammar::Statement::add_statement('for' => \&for);
Perlito5::Grammar::Statement::add_statement('foreach' => \&for);
Perlito5::Grammar::Statement::add_statement('when' => \&when);
Perlito5::Grammar::Statement::add_statement('while' => \&while);
Perlito5::Grammar::Statement::add_statement('until' => \&until);
Perlito5::Grammar::Statement::add_statement('given' => \&given);
Perlito5::Grammar::Statement::add_statement('unless' => \&unless);
package main;
undef();
package Perlito5::Grammar::String;
# use Perlito5::Grammar::Precedence
sub Perlito5::Grammar::String::term_q_quote {
    my $str = $_[0];
    my $pos = $_[1];
    my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
    my $tmp = (((do {
        my $pos1 = $MATCH->{'to'};
        (do {
            (('q' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                my $pos1 = $MATCH->{'to'};
                (do {
                    ('#' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}))
                }) || (do {
                    $MATCH->{'to'} = $pos1;
                    ((do {
                        my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{'to'});
                        if ($m2) {
                            $MATCH->{'to'} = $m2->{'to'};
                            1
                        }
                        else {
                            0
                        }
                    }) && (do {
                        my $tmp = $MATCH;
                        $MATCH = {'str' => $str, 'from' => $tmp->{'to'}, 'to' => $tmp->{'to'}};
                        my $res = ('=>' eq substr($str, $MATCH->{'to'}, 2) && ($MATCH->{'to'} = 2 + $MATCH->{'to'}));
                        $MATCH = $tmp;
                        $res ? 0 : 1
                    }) && ('' ne substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})))
                })
            }))
        }) || (do {
            $MATCH->{'to'} = $pos1;
            (chr(39) eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}))
        })
    }) && (do {
        my $m2 = q_quote_parse($str, $MATCH->{'to'});
        if ($m2) {
            $MATCH->{'to'} = $m2->{'to'};
            $MATCH->{'q_quote_parse'} = $m2;
            1
        }
        else {
            0
        }
    }) && (do {
        $MATCH->{'str'} = $str;
        $MATCH->{'capture'} = ['term', Perlito5::Match::flat($MATCH->{'q_quote_parse'})];
        1
    })));
    $tmp ? $MATCH : 0
}
sub Perlito5::Grammar::String::term_qq_quote {
    my $str = $_[0];
    my $pos = $_[1];
    my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
    my $tmp = (((do {
        my $pos1 = $MATCH->{'to'};
        (do {
            (('qq' eq substr($str, $MATCH->{'to'}, 2) && ($MATCH->{'to'} = 2 + $MATCH->{'to'})) && (do {
                my $pos1 = $MATCH->{'to'};
                (do {
                    ('#' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}))
                }) || (do {
                    $MATCH->{'to'} = $pos1;
                    ((do {
                        my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{'to'});
                        if ($m2) {
                            $MATCH->{'to'} = $m2->{'to'};
                            1
                        }
                        else {
                            0
                        }
                    }) && (do {
                        my $tmp = $MATCH;
                        $MATCH = {'str' => $str, 'from' => $tmp->{'to'}, 'to' => $tmp->{'to'}};
                        my $res = ('=>' eq substr($str, $MATCH->{'to'}, 2) && ($MATCH->{'to'} = 2 + $MATCH->{'to'}));
                        $MATCH = $tmp;
                        $res ? 0 : 1
                    }) && ('' ne substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})))
                })
            }))
        }) || (do {
            $MATCH->{'to'} = $pos1;
            ('"' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}))
        })
    }) && (do {
        my $m2 = qq_quote_parse($str, $MATCH->{'to'});
        if ($m2) {
            $MATCH->{'to'} = $m2->{'to'};
            $MATCH->{'qq_quote_parse'} = $m2;
            1
        }
        else {
            0
        }
    }) && (do {
        $MATCH->{'str'} = $str;
        $MATCH->{'capture'} = ['term', Perlito5::Match::flat($MATCH->{'qq_quote_parse'})];
        1
    })));
    $tmp ? $MATCH : 0
}
sub Perlito5::Grammar::String::term_qw_quote {
    my $str = $_[0];
    my $pos = $_[1];
    my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
    my $tmp = ((('qw' eq substr($str, $MATCH->{'to'}, 2) && ($MATCH->{'to'} = 2 + $MATCH->{'to'})) && (do {
        my $pos1 = $MATCH->{'to'};
        (do {
            ('#' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}))
        }) || (do {
            $MATCH->{'to'} = $pos1;
            ((do {
                my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{'to'});
                if ($m2) {
                    $MATCH->{'to'} = $m2->{'to'};
                    1
                }
                else {
                    0
                }
            }) && (do {
                my $tmp = $MATCH;
                $MATCH = {'str' => $str, 'from' => $tmp->{'to'}, 'to' => $tmp->{'to'}};
                my $res = ('=>' eq substr($str, $MATCH->{'to'}, 2) && ($MATCH->{'to'} = 2 + $MATCH->{'to'}));
                $MATCH = $tmp;
                $res ? 0 : 1
            }) && ('' ne substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})))
        })
    }) && (do {
        my $m2 = qw_quote_parse($str, $MATCH->{'to'});
        if ($m2) {
            $MATCH->{'to'} = $m2->{'to'};
            $MATCH->{'qw_quote_parse'} = $m2;
            1
        }
        else {
            0
        }
    }) && (do {
        $MATCH->{'str'} = $str;
        $MATCH->{'capture'} = ['term', Perlito5::Match::flat($MATCH->{'qw_quote_parse'})];
        1
    })));
    $tmp ? $MATCH : 0
}
sub Perlito5::Grammar::String::term_m_quote {
    my $str = $_[0];
    my $pos = $_[1];
    my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
    my $tmp = (((do {
        my $pos1 = $MATCH->{'to'};
        (do {
            (('m' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                my $pos1 = $MATCH->{'to'};
                (do {
                    ('#' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}))
                }) || (do {
                    $MATCH->{'to'} = $pos1;
                    ((do {
                        my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{'to'});
                        if ($m2) {
                            $MATCH->{'to'} = $m2->{'to'};
                            1
                        }
                        else {
                            0
                        }
                    }) && (do {
                        my $tmp = $MATCH;
                        $MATCH = {'str' => $str, 'from' => $tmp->{'to'}, 'to' => $tmp->{'to'}};
                        my $res = ('=>' eq substr($str, $MATCH->{'to'}, 2) && ($MATCH->{'to'} = 2 + $MATCH->{'to'}));
                        $MATCH = $tmp;
                        $res ? 0 : 1
                    }) && ('' ne substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})))
                })
            }))
        }) || (do {
            $MATCH->{'to'} = $pos1;
            ('/' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}))
        })
    }) && (do {
        my $m2 = m_quote_parse($str, $MATCH->{'to'});
        if ($m2) {
            $MATCH->{'to'} = $m2->{'to'};
            $MATCH->{'m_quote_parse'} = $m2;
            1
        }
        else {
            0
        }
    }) && (do {
        $MATCH->{'str'} = $str;
        $MATCH->{'capture'} = ['term', Perlito5::Match::flat($MATCH->{'m_quote_parse'})];
        1
    })));
    $tmp ? $MATCH : 0
}
sub Perlito5::Grammar::String::term_s_quote {
    my $str = $_[0];
    my $pos = $_[1];
    my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
    my $tmp = ((('s' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
        my $pos1 = $MATCH->{'to'};
        (do {
            ('#' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}))
        }) || (do {
            $MATCH->{'to'} = $pos1;
            ((do {
                my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{'to'});
                if ($m2) {
                    $MATCH->{'to'} = $m2->{'to'};
                    1
                }
                else {
                    0
                }
            }) && (do {
                my $tmp = $MATCH;
                $MATCH = {'str' => $str, 'from' => $tmp->{'to'}, 'to' => $tmp->{'to'}};
                my $res = ('=>' eq substr($str, $MATCH->{'to'}, 2) && ($MATCH->{'to'} = 2 + $MATCH->{'to'}));
                $MATCH = $tmp;
                $res ? 0 : 1
            }) && ('' ne substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})))
        })
    }) && (do {
        my $m2 = s_quote_parse($str, $MATCH->{'to'});
        if ($m2) {
            $MATCH->{'to'} = $m2->{'to'};
            $MATCH->{'s_quote_parse'} = $m2;
            1
        }
        else {
            0
        }
    }) && (do {
        $MATCH->{'str'} = $str;
        $MATCH->{'capture'} = ['term', Perlito5::Match::flat($MATCH->{'s_quote_parse'})];
        1
    })));
    $tmp ? $MATCH : 0
}
sub Perlito5::Grammar::String::term_qx {
    my $str = $_[0];
    my $pos = $_[1];
    my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
    my $tmp = (((do {
        my $pos1 = $MATCH->{'to'};
        (do {
            (('qx' eq substr($str, $MATCH->{'to'}, 2) && ($MATCH->{'to'} = 2 + $MATCH->{'to'})) && (do {
                my $pos1 = $MATCH->{'to'};
                (do {
                    ('#' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}))
                }) || (do {
                    $MATCH->{'to'} = $pos1;
                    ((do {
                        my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{'to'});
                        if ($m2) {
                            $MATCH->{'to'} = $m2->{'to'};
                            1
                        }
                        else {
                            0
                        }
                    }) && (do {
                        my $tmp = $MATCH;
                        $MATCH = {'str' => $str, 'from' => $tmp->{'to'}, 'to' => $tmp->{'to'}};
                        my $res = ('=>' eq substr($str, $MATCH->{'to'}, 2) && ($MATCH->{'to'} = 2 + $MATCH->{'to'}));
                        $MATCH = $tmp;
                        $res ? 0 : 1
                    }) && ('' ne substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})))
                })
            }))
        }) || (do {
            $MATCH->{'to'} = $pos1;
            ('`' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}))
        })
    }) && (do {
        my $m2 = qx_quote_parse($str, $MATCH->{'to'});
        if ($m2) {
            $MATCH->{'to'} = $m2->{'to'};
            $MATCH->{'qx_quote_parse'} = $m2;
            1
        }
        else {
            0
        }
    }) && (do {
        $MATCH->{'str'} = $str;
        $MATCH->{'capture'} = ['term', Perlito5::Match::flat($MATCH->{'qx_quote_parse'})];
        1
    })));
    $tmp ? $MATCH : 0
}
sub Perlito5::Grammar::String::term_glob {
    my $str = $_[0];
    my $pos = $_[1];
    my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
    my $tmp = ((('<' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
        my $m2 = glob_quote_parse($str, $MATCH->{'to'});
        if ($m2) {
            $MATCH->{'to'} = $m2->{'to'};
            $MATCH->{'glob_quote_parse'} = $m2;
            1
        }
        else {
            0
        }
    }) && (do {
        $MATCH->{'str'} = $str;
        $MATCH->{'capture'} = ['term', Perlito5::Match::flat($MATCH->{'glob_quote_parse'})];
        1
    })));
    $tmp ? $MATCH : 0
}
sub Perlito5::Grammar::String::term_tr_quote {
    my $str = $_[0];
    my $pos = $_[1];
    my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
    my $tmp = (((do {
        my $pos1 = $MATCH->{'to'};
        (do {
            ('tr' eq substr($str, $MATCH->{'to'}, 2) && ($MATCH->{'to'} = 2 + $MATCH->{'to'}))
        }) || (do {
            $MATCH->{'to'} = $pos1;
            ('y' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}))
        })
    }) && (do {
        my $pos1 = $MATCH->{'to'};
        (do {
            ('#' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}))
        }) || (do {
            $MATCH->{'to'} = $pos1;
            ((do {
                my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{'to'});
                if ($m2) {
                    $MATCH->{'to'} = $m2->{'to'};
                    1
                }
                else {
                    0
                }
            }) && (do {
                my $tmp = $MATCH;
                $MATCH = {'str' => $str, 'from' => $tmp->{'to'}, 'to' => $tmp->{'to'}};
                my $res = ('=>' eq substr($str, $MATCH->{'to'}, 2) && ($MATCH->{'to'} = 2 + $MATCH->{'to'}));
                $MATCH = $tmp;
                $res ? 0 : 1
            }) && ('' ne substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})))
        })
    }) && (do {
        my $m2 = tr_quote_parse($str, $MATCH->{'to'});
        if ($m2) {
            $MATCH->{'to'} = $m2->{'to'};
            $MATCH->{'tr_quote_parse'} = $m2;
            1
        }
        else {
            0
        }
    }) && (do {
        $MATCH->{'str'} = $str;
        $MATCH->{'capture'} = ['term', Perlito5::Match::flat($MATCH->{'tr_quote_parse'})];
        1
    })));
    $tmp ? $MATCH : 0
}
sub Perlito5::Grammar::String::term_qr_quote {
    my $str = $_[0];
    my $pos = $_[1];
    my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
    my $tmp = ((('qr' eq substr($str, $MATCH->{'to'}, 2) && ($MATCH->{'to'} = 2 + $MATCH->{'to'})) && (do {
        my $pos1 = $MATCH->{'to'};
        (do {
            ('#' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}))
        }) || (do {
            $MATCH->{'to'} = $pos1;
            ((do {
                my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{'to'});
                if ($m2) {
                    $MATCH->{'to'} = $m2->{'to'};
                    1
                }
                else {
                    0
                }
            }) && (do {
                my $tmp = $MATCH;
                $MATCH = {'str' => $str, 'from' => $tmp->{'to'}, 'to' => $tmp->{'to'}};
                my $res = ('=>' eq substr($str, $MATCH->{'to'}, 2) && ($MATCH->{'to'} = 2 + $MATCH->{'to'}));
                $MATCH = $tmp;
                $res ? 0 : 1
            }) && ('' ne substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})))
        })
    }) && (do {
        my $m2 = qr_quote_parse($str, $MATCH->{'to'});
        if ($m2) {
            $MATCH->{'to'} = $m2->{'to'};
            $MATCH->{'qr_quote_parse'} = $m2;
            1
        }
        else {
            0
        }
    }) && (do {
        $MATCH->{'str'} = $str;
        $MATCH->{'capture'} = ['term', Perlito5::Match::flat($MATCH->{'qr_quote_parse'})];
        1
    })));
    $tmp ? $MATCH : 0
}
my %pair = ('{' => '}', '(' => ')', '[' => ']', '<' => '>');
my %escape_sequence = ('a', 7, 'b', 8, 'e', 27, 'f', 12, 'n', 10, 'r', 13, 't', 9);
my %hex = map(+($_ => 1), 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 'A', 'B', 'C', 'D', 'E', 'F');
my %octal = map(+($_ => 1), 0, 1, 2, 3, 4, 5, 6, 7);
sub Perlito5::Grammar::String::q_quote_parse {
    my $str = $_[0];
    my $pos = $_[1];
    my $delimiter = substr($str, $pos - 1, 1);
    my $open_delimiter = $delimiter;
    exists($pair{$delimiter}) && ($delimiter = $pair{$delimiter});
    return string_interpolation_parse($str, $pos, $open_delimiter, $delimiter, 0)
}
sub Perlito5::Grammar::String::qq_quote_parse {
    my $str = $_[0];
    my $pos = $_[1];
    my $delimiter = substr($str, $pos - 1, 1);
    my $open_delimiter = $delimiter;
    exists($pair{$delimiter}) && ($delimiter = $pair{$delimiter});
    return string_interpolation_parse($str, $pos, $open_delimiter, $delimiter, 1)
}
sub Perlito5::Grammar::String::qw_quote_parse {
    my $str = $_[0];
    my $pos = $_[1];
    my $delimiter = substr($str, $pos - 1, 1);
    my $open_delimiter = $delimiter;
    exists($pair{$delimiter}) && ($delimiter = $pair{$delimiter});
    my $m = string_interpolation_parse($str, $pos, $open_delimiter, $delimiter, 0);
    if ($m) {
        $m->{'capture'} = Perlito5::AST::Apply::->new('code' => 'list:<,>', 'arguments' => [map(Perlito5::AST::Buf::->new('buf' => $_), split(' ', Perlito5::Match::flat($m)->{'buf'}))], 'namespace' => '')
    }
    return $m
}
sub Perlito5::Grammar::String::m_quote_parse {
    my $str = $_[0];
    my $pos = $_[1];
    my $delimiter = substr($str, $pos - 1, 1);
    my $open_delimiter = $delimiter;
    my $closing_delimiter = $delimiter;
    exists($pair{$delimiter}) && ($closing_delimiter = $pair{$delimiter});
    my $interpolate = 2;
    $delimiter eq chr(39) && ($interpolate = 3);
    my $part1 = string_interpolation_parse($str, $pos, $open_delimiter, $closing_delimiter, $interpolate);
    $part1 || return $part1;
    my $str_regex = $part1->{'capture'};
    my $p = $part1->{'to'};
    my $modifiers = '';
    my $m = Perlito5::Grammar::ident($str, $p);
    if ($m) {
        $modifiers = Perlito5::Match::flat($m);
        $part1->{'to'} = $m->{'to'}
    }
    $part1->{'capture'} = Perlito5::AST::Apply::->new('code' => 'p5:m', 'arguments' => [$str_regex, Perlito5::AST::Buf::->new('buf' => $modifiers), Perlito5::AST::Var::->new('sigil' => '$', 'namespace' => '', 'name' => '_')], 'namespace' => '');
    return $part1
}
sub Perlito5::Grammar::String::s_quote_parse {
    my $str = $_[0];
    my $pos = $_[1];
    my $delimiter = substr($str, $pos - 1, 1);
    my $open_delimiter = $delimiter;
    my $closing_delimiter = $delimiter;
    exists($pair{$delimiter}) && ($closing_delimiter = $pair{$delimiter});
    my $part1 = string_interpolation_parse($str, $pos, $open_delimiter, $closing_delimiter, 1);
    $part1 || return $part1;
    my $str_regex = Perlito5::AST::Buf::->new('buf' => substr($str, $pos, $part1->{'to'} - $pos - 1));
    my $part2;
    my $m;
    my $p = $part1->{'to'};
    if (exists($pair{$delimiter})) {
        $m = Perlito5::Grammar::Space::opt_ws($str, $p);
        $p = $m->{'to'};
        $delimiter = substr($str, $p, 1);
        my $open_delimiter = $delimiter;
        $p++;
        $closing_delimiter = $delimiter;
        exists($pair{$delimiter}) && ($closing_delimiter = $pair{$delimiter});
        $part2 = string_interpolation_parse($str, $p, $open_delimiter, $closing_delimiter, 1);
        $part2 || return $part2
    }
    else {
        $part2 = string_interpolation_parse($str, $p, $open_delimiter, $closing_delimiter, 1);
        $part2 || return $part2
    }
    $p = $part2->{'to'};
    my $modifiers = '';
    $m = Perlito5::Grammar::ident($str, $p);
    if ($m) {
        $modifiers = Perlito5::Match::flat($m)
    }
    my $replace;
    if ($modifiers =~ m!e!) {
        delete($part2->{'capture'});
        $replace = Perlito5::Match::flat($part2);
        $replace = substr($replace, 0, -1);
        $replace = '{' . $replace . '}';
        my $m = Perlito5::Grammar::block($replace, 0);
        if (!$m) {
            die('syntax error')
        }
        $replace = Perlito5::Match::flat($m);
        if ($modifiers =~ m!ee!) {
            $replace = Perlito5::AST::Block::->new('sig' => undef, 'stmts' => [Perlito5::AST::Apply::->new('code' => 'eval', 'arguments' => [Perlito5::AST::Apply::->new('code' => 'do', 'arguments' => [$replace])], 'bareword' => '', 'namespace' => '')])
        }
    }
    else {
        $replace = Perlito5::Match::flat($part2)
    }
    if ($m) {
        $part2->{'to'} = $m->{'to'}
    }
    $part2->{'capture'} = Perlito5::AST::Apply::->new('code' => 'p5:s', 'arguments' => [$str_regex, $replace, Perlito5::AST::Buf::->new('buf' => $modifiers), Perlito5::AST::Var::->new('sigil' => '$', 'namespace' => '', 'name' => '_')], 'namespace' => '');
    return $part2
}
sub Perlito5::Grammar::String::qr_quote_parse {
    my $str = $_[0];
    my $pos = $_[1];
    my $delimiter = substr($str, $pos - 1, 1);
    my $open_delimiter = $delimiter;
    my $closing_delimiter = $delimiter;
    exists($pair{$delimiter}) && ($closing_delimiter = $pair{$delimiter});
    my $interpolate = 2;
    $delimiter eq chr(39) && ($interpolate = 3);
    my $part1 = string_interpolation_parse($str, $pos, $open_delimiter, $closing_delimiter, $interpolate);
    $part1 || return $part1;
    my $str_regex = $part1->{'capture'};
    my $p = $part1->{'to'};
    my $modifiers = '';
    my $m = Perlito5::Grammar::ident($str, $p);
    if ($m) {
        $modifiers = Perlito5::Match::flat($m);
        $part1->{'to'} = $m->{'to'}
    }
    $part1->{'capture'} = Perlito5::AST::Apply::->new('code' => 'p5:qr', 'arguments' => [$str_regex, Perlito5::AST::Buf::->new('buf' => $modifiers)], 'namespace' => '');
    return $part1
}
sub Perlito5::Grammar::String::qx_quote_parse {
    my $str = $_[0];
    my $pos = $_[1];
    my $delimiter = substr($str, $pos - 1, 1);
    my $open_delimiter = $delimiter;
    exists($pair{$delimiter}) && ($delimiter = $pair{$delimiter});
    my $m = string_interpolation_parse($str, $pos, $open_delimiter, $delimiter, 0);
    if ($m) {
        $m->{'capture'} = Perlito5::AST::Apply::->new('code' => 'qx', 'arguments' => [Perlito5::Match::flat($m)], 'namespace' => '')
    }
    return $m
}
sub Perlito5::Grammar::String::glob_quote_parse {
    my $str = $_[0];
    my $pos = $_[1];
    my $delimiter = substr($str, $pos - 1, 1);
    my $open_delimiter = $delimiter;
    exists($pair{$delimiter}) && ($delimiter = $pair{$delimiter});
    if (substr($str, $pos, 3) eq '<>>') {
        return {'str' => $str, 'from' => $pos, 'to' => $pos + 3, 'capture' => Perlito5::AST::Apply::->new('code' => 'readline', 'arguments' => [Perlito5::AST::Apply::->new('code' => '<>', 'arguments' => [], 'namespace' => '', 'bareword' => 1)], 'namespace' => '')}
    }
    if (substr($str, $pos, 1) eq '>') {
        return {'str' => $str, 'from' => $pos, 'to' => $pos + 1, 'capture' => Perlito5::AST::Apply::->new('code' => 'readline', 'arguments' => [], 'namespace' => '')}
    }
    my $p = $pos;
    my $sigil = '::';
    if (substr($str, $p, 1) eq '$') {
        $sigil = '$';
        $p++
    }
    my $m_namespace = Perlito5::Grammar::optional_namespace_before_ident($str, $p);
    my $namespace = Perlito5::Match::flat($m_namespace);
    $p = $m_namespace->{'to'};
    my $m_name = Perlito5::Grammar::ident($str, $p);
    if ($m_name && substr($str, $m_name->{'to'}, 1) eq '>') {
        if ($sigil eq '::') {
            return {'str' => $str, 'from' => $pos, 'to' => $m_name->{'to'} + 1, 'capture' => Perlito5::AST::Apply::->new('code' => 'readline', 'arguments' => [Perlito5::AST::Apply::->new('code' => Perlito5::Match::flat($m_name), 'arguments' => [], 'namespace' => $namespace, 'bareword' => 1)], 'namespace' => '')}
        }
        return {'str' => $str, 'from' => $pos, 'to' => $m_name->{'to'} + 1, 'capture' => Perlito5::AST::Apply::->new('code' => 'readline', 'arguments' => [Perlito5::AST::Var::->new('sigil' => $sigil, 'name' => Perlito5::Match::flat($m_name), 'namespace' => $namespace)], 'namespace' => '')}
    }
    my $m = string_interpolation_parse($str, $pos, $open_delimiter, $delimiter, 1);
    if ($m) {
        $m->{'capture'} = Perlito5::AST::Apply::->new('code' => 'glob', 'arguments' => [Perlito5::Match::flat($m)], 'namespace' => '')
    }
    return $m
}
sub Perlito5::Grammar::String::tr_quote_parse {
    my $str = $_[0];
    my $pos = $_[1];
    my $delimiter = substr($str, $pos - 1, 1);
    my $open_delimiter = $delimiter;
    my $closing_delimiter = $delimiter;
    exists($pair{$delimiter}) && ($closing_delimiter = $pair{$delimiter});
    my $part1 = string_interpolation_parse($str, $pos, $open_delimiter, $closing_delimiter, 1);
    $part1 || return $part1;
    my $str_regex = Perlito5::AST::Buf::->new('buf' => substr($str, $pos, $part1->{'to'} - $pos - 1));
    my $part2;
    my $m;
    my $p = $part1->{'to'};
    if (exists($pair{$delimiter})) {
        $m = Perlito5::Grammar::Space::opt_ws($str, $p);
        $p = $m->{'to'};
        $delimiter = substr($str, $p, 1);
        my $open_delimiter = $delimiter;
        $p++;
        $closing_delimiter = $delimiter;
        exists($pair{$delimiter}) && ($closing_delimiter = $pair{$delimiter});
        $part2 = string_interpolation_parse($str, $p, $open_delimiter, $closing_delimiter, 1);
        $part2 || return $part2
    }
    else {
        $part2 = string_interpolation_parse($str, $p, $open_delimiter, $closing_delimiter, 1);
        $part2 || return $part2
    }
    $p = $part2->{'to'};
    my $modifiers = '';
    $m = Perlito5::Grammar::ident($str, $p);
    if ($m) {
        $modifiers = Perlito5::Match::flat($m);
        $part2->{'to'} = $m->{'to'}
    }
    $part2->{'capture'} = Perlito5::AST::Apply::->new('code' => 'p5:tr', 'arguments' => [$str_regex, Perlito5::Match::flat($part2), Perlito5::AST::Buf::->new('buf' => $modifiers), Perlito5::AST::Var::->new('sigil' => '$', 'namespace' => '', 'name' => '_')], 'namespace' => '');
    return $part2
}
sub Perlito5::Grammar::String::apply_quote_flags {
    my($c, $quote_flags) = @_;
    length($c) || return $c;
    if ($quote_flags->{'l'}) {
        $c = lcfirst($c);
        delete($quote_flags->{'l'})
    }
    if ($quote_flags->{'u'}) {
        $c = ucfirst($c);
        delete($quote_flags->{'u'})
    }
    $quote_flags->{'L'} && ($c = lc($c));
    $quote_flags->{'U'} && ($c = uc($c));
    $quote_flags->{'Q'} && ($c = quotemeta($c));
    return $c
}
sub Perlito5::Grammar::String::string_interpolation_parse {
    my $str = $_[0];
    my $pos = $_[1];
    my $open_delimiter = $_[2];
    my $delimiter = $_[3];
    my $interpolate = $_[4];
    my $quote_flags = $_[5] || {};
    my $interpolate_vars = ($interpolate == 1 || $interpolate == 2);
    my $p = $pos;
    my $balanced = $open_delimiter && exists($pair{$open_delimiter});
    my @args;
    my $buf = '';
    while ($p < length($str) && substr($str, $p, length($delimiter)) ne $delimiter) {
        my $c = substr($str, $p, 1);
        my $c2 = substr($str, $p + 1, 1);
        my $m;
        my $more = '';
        if ($balanced && $c eq chr(92) && ($c2 eq $open_delimiter || $c2 eq $delimiter)) {
            $p++;
            $c = $c2
        }
        elsif ($balanced && $c eq $open_delimiter) {
            $buf .= $c;
            $p++;
            $m = string_interpolation_parse($str, $p, $open_delimiter, $delimiter, $interpolate, $quote_flags);
            $more = $delimiter
        }
        elsif ($interpolate_vars && ($c eq '$' || $c eq '@')) {
            my $match = Perlito5::Grammar::String::double_quoted_var($str, $p, $delimiter, $interpolate);
            if ($match) {
                my $ast = $match->{'capture'};
                if ($quote_flags->{'l'}) {
                    $ast = Perlito5::AST::Apply::->new('namespace' => '', 'code' => 'lcfirst', 'arguments' => [$ast]);
                    delete($quote_flags->{'l'})
                }
                if ($quote_flags->{'u'}) {
                    $ast = Perlito5::AST::Apply::->new('namespace' => '', 'code' => 'ucfirst', 'arguments' => [$ast]);
                    delete($quote_flags->{'u'})
                }
                $quote_flags->{'L'} && ($ast = Perlito5::AST::Apply::->new('namespace' => '', 'code' => 'lc', 'arguments' => [$ast]));
                $quote_flags->{'U'} && ($ast = Perlito5::AST::Apply::->new('namespace' => '', 'code' => 'uc', 'arguments' => [$ast]));
                $quote_flags->{'Q'} && ($ast = Perlito5::AST::Apply::->new('namespace' => '', 'code' => 'quotemeta', 'arguments' => [$ast]));
                $match->{'capture'} = $ast
            }
            $m = $match
        }
        elsif ($c eq chr(92)) {
            if ($interpolate) {
                if ($c2 eq 'E') {
                    my $flag_to_reset = $quote_flags->{'last_flag'};
                    if ($flag_to_reset) {
                        delete($quote_flags->{$flag_to_reset});
                        delete($quote_flags->{'last_flag'})
                    }
                    else {
                        $quote_flags = {}
                    }
                    $p += 1;
                    $c = ''
                }
                elsif ($c2 eq 'L') {
                    $quote_flags->{$c2} = 1;
                    delete($quote_flags->{'U'});
                    $quote_flags->{'last_flag'} = $c2;
                    $p += 1;
                    $c = ''
                }
                elsif ($c2 eq 'U') {
                    $quote_flags->{$c2} = 1;
                    delete($quote_flags->{'L'});
                    $quote_flags->{'last_flag'} = $c2;
                    $p += 1;
                    $c = ''
                }
                elsif ($c2 eq 'Q') {
                    $quote_flags->{$c2} = 1;
                    $quote_flags->{'last_flag'} = $c2;
                    $p += 1;
                    $c = ''
                }
                elsif ($c2 eq 'l') {
                    $quote_flags->{'u'} || ($quote_flags->{$c2} = 1);
                    $p += 1;
                    $c = ''
                }
                elsif ($c2 eq 'u') {
                    $quote_flags->{'l'} || ($quote_flags->{$c2} = 1);
                    $p += 1;
                    $c = ''
                }
            }
            if ($c) {
                if ($interpolate == 2) {
                    $m = {'str' => $str, 'from' => $p, 'to' => $p + 2, 'capture' => Perlito5::AST::Buf::->new('buf' => substr($str, $p, 2))}
                }
                elsif ($interpolate == 1) {
                    $m = Perlito5::Grammar::String::double_quoted_unescape($str, $p)
                }
                else {
                    $m = $c2 eq chr(92) ? {'str' => $str, 'from' => $p, 'to' => $p + 2, 'capture' => Perlito5::AST::Buf::->new('buf' => chr(92))} : $c2 eq chr(39) ? {'str' => $str, 'from' => $p, 'to' => $p + 2, 'capture' => Perlito5::AST::Buf::->new('buf' => chr(39))} : 0
                }
            }
        }
        if ($m) {
            my $obj = Perlito5::Match::flat($m);
            if (ref($obj) eq 'Perlito5::AST::Buf') {
                $buf .= apply_quote_flags($obj->{'buf'}, $quote_flags);
                $obj = undef
            }
            if ($obj) {
                if (length($buf)) {
                    push(@args, Perlito5::AST::Buf::->new('buf' => $buf));
                    $buf = ''
                }
                push(@args, $obj)
            }
            $p = $m->{'to'};
            $buf .= $more
        }
        else {
            $p++;
            if ($c eq chr(10) || $c eq chr(13)) {
                my $m = here_doc($str, $p);
                if ($p != $m->{'to'}) {
                    $p = $m->{'to'}
                }
                else {
                    $buf .= apply_quote_flags($c, $quote_flags)
                }
            }
            else {
                $buf .= apply_quote_flags($c, $quote_flags)
            }
        }
    }
    if (length($buf)) {
        push(@args, Perlito5::AST::Buf::->new('buf' => $buf))
    }
    substr($str, $p, length($delimiter)) ne $delimiter && die('Can' . chr(39) . 't find string terminator ' . chr(39) . $delimiter . chr(39) . ' anywhere before EOF');
    $p += length($delimiter);
    my $ast;
    if (!@args) {
        $ast = Perlito5::AST::Buf::->new('buf' => '')
    }
    elsif (@args == 1) {
        $ast = $args[0]
    }
    else {
        $ast = Perlito5::AST::Apply::->new('namespace' => '', 'code' => 'list:<.>', 'arguments' => \@args)
    }
    return {'str' => $str, 'from' => $pos, 'to' => $p, 'capture' => $ast}
}
our @Here_doc;
sub Perlito5::Grammar::String::here_doc_wanted {
    my $str = $_[0];
    my $pos = $_[1];
    my $delimiter;
    my $type = 'double_quote';
    my $p = $pos;
    if (substr($str, $p, 2) eq '<<') {
        $p += 2;
        my $quote = substr($str, $p, 1);
        if ($quote eq chr(39) || $quote eq '"') {
            $p += 1;
            my $m = string_interpolation_parse($str, $p, $quote, $quote, 0);
            if ($m) {
                $p = $m->{'to'};
                $delimiter = Perlito5::Match::flat($m)->{'buf'};
                $type = $quote eq chr(39) ? 'single_quote' : 'double_quote'
            }
        }
        else {
            $quote eq chr(92) && ($p += 1);
            my $m = Perlito5::Grammar::ident($str, $p);
            if ($m) {
                $p = $m->{'to'};
                $delimiter = Perlito5::Match::flat($m);
                $type = $quote eq chr(92) ? 'single_quote' : 'double_quote'
            }
            else {
                $Perlito5::WARNINGS && warn('Use of bare << to mean <<"" is deprecated');
                $delimiter = '';
                $type = 'double_quote'
            }
        }
    }
    if (!defined($delimiter)) {
        return 0
    }
    my $placeholder = Perlito5::AST::Apply::->new('code' => 'list:<.>', 'namespace' => '', 'arguments' => [Perlito5::AST::Apply::->new('code' => 'list:<.>', 'namespace' => '', 'arguments' => [])]);
    push(@Here_doc, [$type, $placeholder->{'arguments'}->[0]->{'arguments'}, $delimiter]);
    return {'str' => $str, 'from' => $pos, 'to' => $p, 'capture' => ['term', $placeholder]}
}
sub Perlito5::Grammar::String::newline {
    my $str = $_[0];
    my $pos = $_[1];
    my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
    my $tmp = ((do {
        my $pos1 = $MATCH->{'to'};
        (do {
            ((chr(10) eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                my $m = $MATCH;
                if (!(chr(13) eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}))) {
                    $MATCH = $m
                }
                1
            }))
        }) || (do {
            $MATCH->{'to'} = $pos1;
            ((chr(13) eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                my $m = $MATCH;
                if (!(chr(10) eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}))) {
                    $MATCH = $m
                }
                1
            }))
        })
    }));
    $tmp ? $MATCH : 0
}
sub Perlito5::Grammar::String::here_doc {
    my $str = $_[0];
    my $pos = $_[1];
    if (!@Here_doc) {
        return {'str' => $str, 'from' => $pos, 'to' => $pos}
    }
    my $p = $pos;
    my $here = shift(@Here_doc);
    my $type = $here->[0];
    my $result = $here->[1];
    my $delimiter = $here->[2];
    if ($type eq 'single_quote') {
        while ($p < length($str)) {
            if (substr($str, $p, length($delimiter)) eq $delimiter) {
                push(@{$result}, Perlito5::AST::Buf::->new('buf' => substr($str, $pos, $p - $pos)));
                $p += length($delimiter);
                my $m = newline($str, $p);
                if ($p >= length($str) || $m) {
                    $m && ($p = $m->{'to'});
                    return {'str' => $str, 'from' => $pos, 'to' => $p - 1}
                }
            }
            while ($p < length($str) && (substr($str, $p, 1) ne chr(10) && substr($str, $p, 1) ne chr(13))) {
                $p++
            }
            while ($p < length($str) && (substr($str, $p, 1) eq chr(10) || substr($str, $p, 1) eq chr(13))) {
                $p++
            }
        }
    }
    else {
        my $m;
        if (substr($str, $p, length($delimiter)) eq $delimiter) {
            $p += length($delimiter);
            $m = newline($str, $p);
            if ($p >= length($str) || $m) {
                push(@{$result}, Perlito5::AST::Buf::->new('buf' => ''));
                $m && ($p = $m->{'to'});
                return {'str' => $str, 'from' => $pos, 'to' => $p}
            }
        }
        $m = string_interpolation_parse($str, $pos, '', chr(10) . $delimiter . chr(10), 1);
        if ($m) {
            push(@{$result}, Perlito5::Match::flat($m));
            push(@{$result}, Perlito5::AST::Buf::->new('buf' => chr(10)));
            $m->{'to'} = $m->{'to'} - 1;
            return $m
        }
    }
    die('Can' . chr(39) . 't find string terminator "' . $delimiter . '" anywhere before EOF')
}
sub Perlito5::Grammar::String::double_quoted_unescape {
    my $str = $_[0];
    my $pos = $_[1];
    my $c2 = substr($str, $pos + 1, 1);
    my $m;
    if (exists($escape_sequence{$c2})) {
        $m = {'str' => $str, 'from' => $pos, 'to' => $pos + 2, 'capture' => Perlito5::AST::Buf::->new('buf' => chr($escape_sequence{$c2}))}
    }
    elsif ($c2 eq 'c') {
        my $c3 = ord(uc(substr($str, $pos + 2, 1))) - ord('A') + 1;
        $c3 < 0 && ($c3 = 128 + $c3);
        $m = {'str' => $str, 'from' => $pos, 'to' => $pos + 3, 'capture' => Perlito5::AST::Buf::->new('buf' => chr($c3))}
    }
    elsif ($c2 eq 'x') {
        if (substr($str, $pos + 2, 1) eq '{') {
            my $p = $pos + 3;
            $p++
                while $p < length($str) && substr($str, $p, 1) ne '}';
            my $hex_code = substr($str, $pos + 3, $p - $pos - 3);
            $hex_code || ($hex_code = 0);
            my $tmp = oct('0x' . $hex_code);
            $m = {'str' => $str, 'from' => $pos, 'to' => $p + 1, 'capture' => Perlito5::AST::Buf::->new('buf' => chr($tmp))}
        }
        else {
            my $p = $pos + 2;
            $hex{uc(substr($str, $p, 1))} && $p++;
            $hex{uc(substr($str, $p, 1))} && $p++;
            my $hex_code = substr($str, $pos + 2, $p - $pos - 2);
            $hex_code || ($hex_code = 0);
            my $tmp = oct('0x' . $hex_code);
            $m = {'str' => $str, 'from' => $pos, 'to' => $p, 'capture' => Perlito5::AST::Buf::->new('buf' => chr($tmp))}
        }
    }
    elsif (exists($octal{$c2})) {
        my $p = $pos + 1;
        $octal{substr($str, $p, 1)} && $p++;
        $octal{substr($str, $p, 1)} && $p++;
        $octal{substr($str, $p, 1)} && $p++;
        my $oct_code = substr($str, $pos + 1, $p - $pos - 1);
        my $tmp = oct($oct_code);
        $m = {'str' => $str, 'from' => $pos, 'to' => $p, 'capture' => Perlito5::AST::Buf::->new('buf' => chr($tmp))}
    }
    elsif ($c2 eq 'N') {
        die('TODO - ' . chr(92) . 'N{charname} not implemented; requires ' . chr(39) . 'use charnames' . chr(39))
    }
    else {
        $m = {'str' => $str, 'from' => $pos, 'to' => $pos + 2, 'capture' => Perlito5::AST::Buf::->new('buf' => $c2)}
    }
    return $m
}
sub Perlito5::Grammar::String::double_quoted_var_with_subscript {
    my $m_var = $_[0];
    my $interpolate = $_[1];
    my $str = $m_var->{'str'};
    my $pos = $m_var->{'to'};
    my $p = $pos;
    my $m_index;
    if (substr($str, $p, 3) eq '->[') {
        $p += 3;
        $m_index = Perlito5::Grammar::Expression::list_parse($str, $p);
        $m_index || die('syntax error');
        my $exp = $m_index->{'capture'};
        $p = $m_index->{'to'};
        ($exp eq '*undef*' || substr($str, $p, 1) ne ']') && die('syntax error');
        $p++;
        $m_index->{'capture'} = Perlito5::AST::Call::->new('method' => 'postcircumfix:<[ ]>', 'invocant' => $m_var->{'capture'}, 'arguments' => $exp);
        $m_index->{'to'} = $p;
        return double_quoted_var_with_subscript($m_index, $interpolate)
    }
    if (substr($str, $p, 3) eq '->{') {
        $pos += 2;
        $m_index = Perlito5::Grammar::Expression::term_curly($str, $pos);
        $m_index || die('syntax error');
        $m_index->{'capture'} = Perlito5::AST::Call::->new('method' => 'postcircumfix:<{ }>', 'invocant' => $m_var->{'capture'}, 'arguments' => Perlito5::Match::flat($m_index)->[2]->[0]);
        return double_quoted_var_with_subscript($m_index, $interpolate)
    }
    if (substr($str, $p, 1) eq '[') {
        if ($interpolate == 2) {
            my $m = Perlito5::Grammar::Number::term_digit($str, $p + 1) || (substr($str, $p + 1, 1) eq '-' && Perlito5::Grammar::Number::term_digit($str, $p + 2)) || Perlito5::Grammar::Sigil::term_sigil($str, $p + 1);
            $m || return $m_var;
            substr($str, $m->{'to'}, 1) eq ']' || return $m_var
        }
        $p++;
        $m_index = Perlito5::Grammar::Expression::list_parse($str, $p);
        if ($m_index) {
            my $exp = $m_index->{'capture'};
            $p = $m_index->{'to'};
            if ($exp ne '*undef*' && substr($str, $p, 1) eq ']') {
                $p++;
                my $value = $m_var->{'capture'};
                if (ref($value) eq 'Perlito5::AST::Var') {
                    $value->{'_real_sigil'} = '@'
                }
                $m_index->{'capture'} = Perlito5::AST::Index::->new('obj' => $value, 'index_exp' => $exp);
                $m_index->{'to'} = $p;
                return double_quoted_var_with_subscript($m_index, $interpolate)
            }
        }
    }
    $m_index = Perlito5::Grammar::Expression::term_curly($str, $pos);
    if ($m_index) {
        my $value = $m_var->{'capture'};
        if (ref($value) eq 'Perlito5::AST::Var') {
            $value->{'_real_sigil'} = '%'
        }
        $m_index->{'capture'} = Perlito5::AST::Lookup::->new('obj' => $value, 'index_exp' => Perlito5::Match::flat($m_index)->[2]->[0]);
        return double_quoted_var_with_subscript($m_index, $interpolate)
    }
    return $m_var
}
sub Perlito5::Grammar::String::double_quoted_var {
    my $str = $_[0];
    my $pos = $_[1];
    my $delimiter = $_[2];
    my $interpolate = $_[3];
    my $c = substr($str, $pos, 1);
    if ($c eq '$' && substr($str, $pos + 1, 1) eq '{') {
        my $m = Perlito5::Grammar::Sigil::term_sigil($str, $pos);
        $m || return $m;
        my $var = Perlito5::Match::flat($m)->[1];
        $m->{'capture'} = $var;
        return $m
    }
    elsif ($c eq '$' && substr($str, $pos + 1, 1) eq '$' && !Perlito5::Grammar::word($str, $pos + 2)) {
        return {'str' => $str, 'capture' => Perlito5::AST::Var::->new('name' => '$', 'sigil' => '$', 'namespace' => ''), 'from' => $pos, 'to' => $pos + 2}
    }
    elsif ($c eq '$' && substr($str, $pos + 1, length($delimiter)) ne $delimiter) {
        my $m = Perlito5::Grammar::Sigil::term_sigil($str, $pos);
        $m || return $m;
        $m->{'capture'} = $m->{'capture'}->[1];
        return double_quoted_var_with_subscript($m, $interpolate)
    }
    elsif ($c eq '@' && substr($str, $pos + 1, length($delimiter)) ne $delimiter) {
        my $m = Perlito5::Grammar::Sigil::term_sigil($str, $pos);
        $m || return $m;
        $m->{'capture'} = $m->{'capture'}->[1];
        $m = double_quoted_var_with_subscript($m, $interpolate);
        $m->{'capture'} = Perlito5::AST::Apply::->new('code' => 'join', 'arguments' => [Perlito5::AST::Var::->new('name' => '"', 'sigil' => '$', 'namespace' => ''), $m->{'capture'}], 'namespace' => '');
        return $m
    }
    return 0
}
Perlito5::Grammar::Precedence::add_term(chr(39) => \&term_q_quote);
Perlito5::Grammar::Precedence::add_term('"' => \&term_qq_quote);
Perlito5::Grammar::Precedence::add_term('/' => \&term_m_quote);
Perlito5::Grammar::Precedence::add_term('<' => \&term_glob);
Perlito5::Grammar::Precedence::add_term('<<>>' => \&term_glob);
Perlito5::Grammar::Precedence::add_term('<<' => \&here_doc_wanted);
Perlito5::Grammar::Precedence::add_term('`' => \&term_qx);
Perlito5::Grammar::Precedence::add_term('m' => \&term_m_quote);
Perlito5::Grammar::Precedence::add_term('q' => \&term_q_quote);
Perlito5::Grammar::Precedence::add_term('qq' => \&term_qq_quote);
Perlito5::Grammar::Precedence::add_term('qw' => \&term_qw_quote);
Perlito5::Grammar::Precedence::add_term('qx' => \&term_qx);
Perlito5::Grammar::Precedence::add_term('qr' => \&term_qr_quote);
Perlito5::Grammar::Precedence::add_term('s' => \&term_s_quote);
Perlito5::Grammar::Precedence::add_term('tr' => \&term_tr_quote);
Perlito5::Grammar::Precedence::add_term('y' => \&term_tr_quote);
1;
package main;
undef();
package Perlito5::Grammar::Sigil;
# use Perlito5::Grammar::Precedence
my %special_var = ('$_' => '', '$&' => '', '$`' => '', '$' . chr(39) => '', '$+' => '', '@+' => '', '%+' => '', '$.' => '', '$/' => '', '$|' => '', '$,' => '', '$' . chr(92) => '', '$"' => '', '$;' => '', '$%' => '', '$=' => '', '$-' => '', '@-' => '', '%-' => '', '$~' => '', '$^' => '', '$:' => '', '$?' => '', '$!' => '', '%!' => '', '$@' => '', '$$' => '', '$<' => '', '$>' => '', '$(' => '', '$)' => '', '$[' => '', '$]' => '', '@_' => '', '*_' => '', '*&' => '', '*`' => '', '*' . chr(39) => '', '*+' => '', '*.' => '', '*/' => '', '*|' => '', '*,' => '', '*' . chr(92) => '', '*"' => '', '*;' => '', '*%' => '', '*=' => '', '*-' => '', '*~' => '', '*^' => '', '*:' => '', '*?' => '', '*!' => '', '*@' => '', '*$' => '', '*<' => '', '*>' => '', '*(' => '', '*)' => '', '*[' => '', '*]' => '', '*_' => '', '**' => '', '*#' => '', '$#+' => '', '$#-' => '', '$#_' => '');
sub Perlito5::Grammar::Sigil::term_special_var {
    my $str = $_[0];
    my $pos = $_[1];
    my $len = 0;
    my $s = substr($str, $pos, 3);
    if ($s eq '$#[') {
        $len = 2
    }
    elsif (exists($special_var{$s})) {
        $len = length($s)
    }
    else {
        $s = substr($str, $pos, 2);
        if (exists($special_var{$s})) {
            $len = 2
        }
    }
    if ($len) {
        my $c0 = substr($str, $pos + $len - 1, 1);
        my $c1 = substr($str, $pos + $len, 1);
        if (($c0 eq '$' || $c0 eq '@' || $c0 eq '%' || $c0 eq '*' || $c0 eq '&') && ($c1 eq '$' || $c1 eq '@' || $c1 eq '%' || $c1 eq '*' || $c1 eq '&' || ($c1 ge 'a' && $c1 le 'z') || ($c1 ge 'A' && $c1 le 'Z') || ($c1 ge 0 && $c1 le 9))) {}
        else {
            return {'str' => $str, 'from' => $pos, 'to' => $pos + $len, 'capture' => ['term', Perlito5::AST::Var::->new('sigil' => substr($s, 0, $len - 1), 'namespace' => $special_var{$s}, 'name' => substr($s, $len - 1, 1), '_namespace' => 'main')]}
        }
    }
    return 0
}
my %sigil = ('$' => 1, '%' => 1, '@' => 1, '&' => 1, '*' => 1);
sub Perlito5::Grammar::Sigil::term_sigil {
    my $str = $_[0];
    my $pos = $_[1];
    my $c1 = substr($str, $pos, 1);
    exists($sigil{$c1}) || return ;
    my $p = $pos + 1;
    my $sigil = $c1;
    if (substr($str, $pos, 2) eq '$#') {
        $sigil = '$#';
        $p++
    }
    my $m = Perlito5::Grammar::Space::opt_ws($str, $p);
    $p = $m->{'to'};
    $c1 = substr($str, $p, 1);
    my $q = $p + 1;
    if ($c1 eq '{') {
        my $p = $q;
        $m = Perlito5::Grammar::Space::opt_ws($str, $p);
        $p = $m->{'to'};
        $m = Perlito5::Grammar::optional_namespace_before_ident($str, $p);
        if ($m) {
            my $namespace = Perlito5::Match::flat($m);
            my $pos = $m->{'to'};
            my $n = Perlito5::Grammar::var_name($str, $m->{'to'});
            my $name;
            if ($n) {
                $name = Perlito5::Match::flat($n);
                $pos = $n->{'to'}
            }
            if ($namespace || $name) {
                my $spc = Perlito5::Grammar::Space::opt_ws($str, $pos);
                if (substr($str, $pos, 1) eq '{' || substr($str, $pos, 1) eq '[' || substr($str, $pos, 1) eq '}') {
                    $m->{'capture'} = Perlito5::AST::Var::->new('sigil' => $sigil, 'namespace' => $namespace, 'name' => $name);
                    $m->{'to'} = $spc->{'to'};
                    $m = Perlito5::Grammar::String::double_quoted_var_with_subscript($m);
                    $m->{'capture'} = ['term', $m->{'capture'}];
                    $spc = Perlito5::Grammar::Space::opt_ws($str, $m->{'to'});
                    my $p = $spc->{'to'};
                    if (substr($str, $p, 1) eq '}') {
                        $m->{'to'} = $p + 1;
                        return $m
                    }
                }
            }
        }
        my $caret = Perlito5::Grammar::caret_char($str, $p);
        if ($caret) {
            my $p = $caret->{'to'};
            my $name = Perlito5::Match::flat($caret);
            $m = Perlito5::Grammar::var_name($str, $p);
            if ($m) {
                $name = $name . Perlito5::Match::flat($m);
                $p = $m->{'to'}
            }
            if (substr($str, $p, 1) eq '}') {
                $caret->{'capture'} = ['term', Perlito5::AST::Apply::->new('arguments' => [Perlito5::AST::Buf::->new('buf' => $name)], 'code' => 'prefix:<' . $sigil . '>', 'namespace' => '')];
                $caret->{'to'} = $p + 1;
                return $caret
            }
        }
        $m = Perlito5::Grammar::Expression::curly_parse($str, $p);
        if ($m) {
            my $p = $m->{'to'};
            if (substr($str, $p, 1) eq '}') {
                $m->{'to'} = $m->{'to'} + 1;
                $m->{'capture'} = ['term', Perlito5::AST::Apply::->new('arguments' => [$m->{'capture'}], 'code' => 'prefix:<' . $sigil . '>', 'namespace' => '')];
                return $m
            }
        }
    }
    my $caret = Perlito5::Grammar::caret_char($str, $p);
    if ($caret) {
        my $name = Perlito5::Match::flat($caret);
        $caret->{'capture'} = ['term', Perlito5::AST::Apply::->new('arguments' => [Perlito5::AST::Buf::->new('buf' => $name)], 'code' => 'prefix:<' . $sigil . '>', 'namespace' => '')];
        return $caret
    }
    if ($c1 eq '$') {
        my $m2 = Perlito5::Grammar::Space::opt_ws($str, $p + 1);
        my $p2 = $m2->{'to'};
        my $c2 = substr($str, $p2, 1);
        if ($c2 ne ',' && $c2 ne ';') {
            $m = term_sigil($str, $p);
            if ($m) {
                $m->{'capture'} = ['term', Perlito5::AST::Apply::->new('arguments' => [$m->{'capture'}->[1]], 'code' => 'prefix:<' . $sigil . '>', 'namespace' => '')];
                return $m
            }
        }
    }
    $m = Perlito5::Grammar::optional_namespace_before_ident($str, $p);
    if ($m) {
        my $namespace = Perlito5::Match::flat($m);
        my $n = Perlito5::Grammar::var_name($str, $m->{'to'});
        if ($n) {
            $n->{'capture'} = ['term', Perlito5::AST::Var::->new('sigil' => $sigil, 'namespace' => $namespace, 'name' => Perlito5::Match::flat($n), ($sigil eq '$#' ? ('_real_sigil' => '@') : ()))];
            return $n
        }
        if ($namespace) {
            $m->{'capture'} = ['term', Perlito5::AST::Var::->new('sigil' => $sigil, 'namespace' => $namespace, 'name' => undef, ($sigil eq '$#' ? ('_real_sigil' => '@') : ()))];
            return $m
        }
    }
    return term_special_var($str, $pos)
}
Perlito5::Grammar::Precedence::add_term('$' => \&term_sigil);
Perlito5::Grammar::Precedence::add_term('@' => \&term_sigil);
Perlito5::Grammar::Precedence::add_term('%' => \&term_sigil);
Perlito5::Grammar::Precedence::add_term('&' => \&term_sigil);
Perlito5::Grammar::Precedence::add_term('*' => \&term_sigil);
1;
package main;
package Perlito5::Grammar::Use;
# use Perlito5::Grammar::Precedence
# use Perlito5::Grammar
# use strict
my %Perlito_internal_module = ('strict' => 'Perlito5X::strict', 'warnings' => 'Perlito5X::warnings', 'feature' => 'Perlito5X::feature', 'utf8' => 'Perlito5X::utf8', 'bytes' => 'Perlito5X::bytes', 'encoding' => 'Perlito5X::encoding', 'Carp' => 'Perlito5X::Carp', 'Exporter' => 'Perlito5X::Exporter', 'Data::Dumper' => 'Perlito5X::Dumper');
sub Perlito5::Grammar::Use::use_decl {
    my $str = $_[0];
    my $pos = $_[1];
    my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
    my $tmp = ((do {
        my $pos1 = $MATCH->{'to'};
        (do {
            ('use' eq substr($str, $MATCH->{'to'}, 3) && ($MATCH->{'to'} = 3 + $MATCH->{'to'}))
        }) || (do {
            $MATCH->{'to'} = $pos1;
            ('no' eq substr($str, $MATCH->{'to'}, 2) && ($MATCH->{'to'} = 2 + $MATCH->{'to'}))
        })
    }));
    $tmp ? $MATCH : 0
}
sub Perlito5::Grammar::Use::version_string {
    my $str = $_[0];
    my $pos = $_[1];
    my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
    my $tmp = ((do {
        my $pos1 = $MATCH->{'to'};
        (do {
            ((do {
                my $m2 = Perlito5::Grammar::Number::val_version($str, $MATCH->{'to'});
                if ($m2) {
                    $MATCH->{'to'} = $m2->{'to'};
                    $MATCH->{'Perlito5::Grammar::Number::val_version'} = $m2;
                    1
                }
                else {
                    0
                }
            }) && (do {
                $MATCH->{'str'} = $str;
                $MATCH->{'capture'} = $MATCH->{'Perlito5::Grammar::Number::val_version'}->{'capture'};
                1
            }))
        }) || (do {
            $MATCH->{'to'} = $pos1;
            ((do {
                my $m2 = Perlito5::Grammar::Number::term_digit($str, $MATCH->{'to'});
                if ($m2) {
                    $MATCH->{'to'} = $m2->{'to'};
                    $MATCH->{'Perlito5::Grammar::Number::term_digit'} = $m2;
                    1
                }
                else {
                    0
                }
            }) && (do {
                $MATCH->{'str'} = $str;
                my $version = $MATCH->{'Perlito5::Grammar::Number::term_digit'}->{'capture'}->[1]->{'buf'} || $MATCH->{'Perlito5::Grammar::Number::term_digit'}->{'capture'}->[1]->{'int'} || $MATCH->{'Perlito5::Grammar::Number::term_digit'}->{'capture'}->[1]->{'num'};
                $MATCH->{'capture'} = Perlito5::AST::Buf::->new('buf' => $version);
                1
            }))
        })
    }));
    $tmp ? $MATCH : 0
}
sub Perlito5::Grammar::Use::term_require {
    my $str = $_[0];
    my $pos = $_[1];
    my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
    my $tmp = ((('require' eq substr($str, $MATCH->{'to'}, 7) && ($MATCH->{'to'} = 7 + $MATCH->{'to'})) && (do {
        my $m2 = Perlito5::Grammar::Space::ws($str, $MATCH->{'to'});
        if ($m2) {
            $MATCH->{'to'} = $m2->{'to'};
            1
        }
        else {
            0
        }
    }) && (do {
        my $pos1 = $MATCH->{'to'};
        (do {
            ((do {
                my $m2 = version_string($str, $MATCH->{'to'});
                if ($m2) {
                    $MATCH->{'to'} = $m2->{'to'};
                    $MATCH->{'version_string'} = $m2;
                    1
                }
                else {
                    0
                }
            }) && (do {
                $MATCH->{'str'} = $str;
                my $version = $MATCH->{'version_string'}->{'capture'};
                $version->{'is_version_string'} = 1;
                $MATCH->{'capture'} = ['term', Perlito5::AST::Apply::->new('code' => 'require', 'namespace' => '', 'arguments' => [$version])];
                1
            }))
        }) || (do {
            $MATCH->{'to'} = $pos1;
            ((do {
                my $m2 = Perlito5::Grammar::full_ident($str, $MATCH->{'to'});
                if ($m2) {
                    $MATCH->{'to'} = $m2->{'to'};
                    $MATCH->{'Perlito5::Grammar::full_ident'} = $m2;
                    1
                }
                else {
                    0
                }
            }) && (do {
                $MATCH->{'str'} = $str;
                my $module_name = Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::full_ident'});
                my $filename = modulename_to_filename($module_name);
                $MATCH->{'capture'} = ['term', Perlito5::AST::Apply::->new('code' => 'require', 'namespace' => '', 'arguments' => [Perlito5::AST::Buf::->new('buf' => $filename)])];
                1
            }))
        })
    })));
    $tmp ? $MATCH : 0
}
sub Perlito5::Grammar::Use::stmt_use {
    my $str = $_[0];
    my $pos = $_[1];
    my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
    my $tmp = (((do {
        my $m2 = use_decl($str, $MATCH->{'to'});
        if ($m2) {
            $MATCH->{'to'} = $m2->{'to'};
            $MATCH->{'use_decl'} = $m2;
            1
        }
        else {
            0
        }
    }) && (do {
        my $m2 = Perlito5::Grammar::Space::ws($str, $MATCH->{'to'});
        if ($m2) {
            $MATCH->{'to'} = $m2->{'to'};
            1
        }
        else {
            0
        }
    }) && (do {
        my $pos1 = $MATCH->{'to'};
        (do {
            ((do {
                my $m2 = version_string($str, $MATCH->{'to'});
                if ($m2) {
                    $MATCH->{'to'} = $m2->{'to'};
                    $MATCH->{'version_string'} = $m2;
                    1
                }
                else {
                    0
                }
            }) && (do {
                $MATCH->{'str'} = $str;
                my $version = $MATCH->{'version_string'}->{'capture'}->{'buf'};
                Perlito5::test_perl_version($version);
                $MATCH->{'capture'} = Perlito5::AST::Apply::->new('code' => 'undef', 'namespace' => '', 'arguments' => []);
                1
            }))
        }) || (do {
            $MATCH->{'to'} = $pos1;
            ((do {
                my $m2 = Perlito5::Grammar::full_ident($str, $MATCH->{'to'});
                if ($m2) {
                    $MATCH->{'to'} = $m2->{'to'};
                    $MATCH->{'Perlito5::Grammar::full_ident'} = $m2;
                    1
                }
                else {
                    0
                }
            }) && (do {
                my $m = $MATCH;
                if (!(('-' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                    my $m2 = Perlito5::Grammar::ident($str, $MATCH->{'to'});
                    if ($m2) {
                        $MATCH->{'to'} = $m2->{'to'};
                        if (exists($MATCH->{'Perlito5::Grammar::ident'})) {
                            push(@{$MATCH->{'Perlito5::Grammar::ident'}}, $m2)
                        }
                        else {
                            $MATCH->{'Perlito5::Grammar::ident'} = [$m2]
                        }
                        1
                    }
                    else {
                        0
                    }
                }))) {
                    $MATCH = $m
                }
                1
            }) && (do {
                my $m = $MATCH;
                if (!((do {
                    my $m2 = Perlito5::Grammar::Space::ws($str, $MATCH->{'to'});
                    if ($m2) {
                        $MATCH->{'to'} = $m2->{'to'};
                        1
                    }
                    else {
                        0
                    }
                }) && (do {
                    my $m2 = version_string($str, $MATCH->{'to'});
                    if ($m2) {
                        $MATCH->{'to'} = $m2->{'to'};
                        if (exists($MATCH->{'version_string'})) {
                            push(@{$MATCH->{'version_string'}}, $m2)
                        }
                        else {
                            $MATCH->{'version_string'} = [$m2]
                        }
                        1
                    }
                    else {
                        0
                    }
                }) && (do {
                    my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{'to'});
                    if ($m2) {
                        $MATCH->{'to'} = $m2->{'to'};
                        1
                    }
                    else {
                        0
                    }
                }))) {
                    $MATCH = $m
                }
                1
            }) && (do {
                my $m2 = Perlito5::Grammar::Expression::list_parse($str, $MATCH->{'to'});
                if ($m2) {
                    $MATCH->{'to'} = $m2->{'to'};
                    $MATCH->{'Perlito5::Grammar::Expression::list_parse'} = $m2;
                    1
                }
                else {
                    0
                }
            }) && (do {
                $MATCH->{'str'} = $str;
                my $version = $MATCH->{'version_string'}->[0]->{'capture'}->{'buf'};
                my $list = Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::Expression::list_parse'});
                if ($list eq '*undef*') {
                    $list = undef
                }
                else {
                    my $m = $MATCH->{'Perlito5::Grammar::Expression::list_parse'};
                    my $list_code = substr($str, $m->{'from'}, $m->{'to'} - $m->{'from'});
                    my @list = eval($list_code);
                    $list = \@list
                }
                my $full_ident = Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::full_ident'});
                $Perlito5::PACKAGES->{$full_ident} = 1;
                my $use_decl = Perlito5::Match::flat($MATCH->{'use_decl'});
                if ($use_decl eq 'use' && $full_ident eq 'vars' && $list) {
                    my $code = 'our (' . join(', ', @{$list}) . ')';
                    my $m = Perlito5::Grammar::Statement::statement_parse($code, 0);
                    !$m && die('not a valid variable name: ' . join(${'"'}, @{$list}));
                    $MATCH->{'capture'} = $m->{'capture'}
                }
                elsif ($full_ident eq 'strict') {
                    $Perlito5::STRICT = ($use_decl eq 'no' ? 0 : 1);
                    my $ast = Perlito5::AST::Use::->new('code' => $use_decl, 'mod' => $full_ident, 'arguments' => $list);
                    $MATCH->{'capture'} = $ast
                }
                elsif ($use_decl eq 'use' && $full_ident eq 'constant' && $list) {
                    my @ast;
                    my $name = shift(@{$list});
                    if (ref($name) eq 'HASH') {
                        for my $key (sort(keys(%{$name}))) {
                            my $code = 'sub ' . $key . ' () { ' . Perlito5::Dumper::_dumper($name->{$key}) . ' }';
                            my $m = Perlito5::Grammar::Statement::statement_parse($code, 0);
                            !$m && die('not a valid constant: ' . join(${'"'}, @{$list}));
                            push(@ast, $m->{'capture'})
                        }
                    }
                    else {
                        my $code = 'sub ' . $name . ' () { (' . join(', ', map {
                            Perlito5::Dumper::_dumper($_)
                        } @{$list}) . ') }';
                        my $m = Perlito5::Grammar::Statement::statement_parse($code, 0);
                        !$m && die('not a valid constant: ' . join(${'"'}, @{$list}));
                        push(@ast, $m->{'capture'})
                    }
                    $MATCH->{'capture'} = Perlito5::AST::Block::->new('stmts' => \@ast)
                }
                else {
                    my $ast = Perlito5::AST::Use::->new('code' => $use_decl, 'mod' => $full_ident, 'arguments' => $list);
                    parse_time_eval($ast);
                    $MATCH->{'capture'} = $ast
                }
                1
            }))
        }) || (do {
            $MATCH->{'to'} = $pos1;
            (do {
                $MATCH->{'str'} = $str;
                die('Syntax error');
                1
            })
        })
    })));
    $tmp ? $MATCH : 0
}
sub Perlito5::Grammar::Use::parse_time_eval {
    my $ast = shift;
    my $module_name = $ast->mod();
    my $use_or_not = $ast->code();
    my $arguments = $ast->{'arguments'};
    my $skip_import = defined($arguments) && @{$arguments} == 0;
    defined($arguments) || ($arguments = []);
    if ($Perlito5::EXPAND_USE) {
        my $current_module_name = $Perlito5::PKG_NAME;
        my $filename = modulename_to_filename($module_name);
        require($filename);
        if (!$skip_import) {
            if ($use_or_not eq 'use') {
                if (defined(&{$module_name . '::import'})) {
                    unshift(@{$Perlito5::CALLER}, [$current_module_name]);
                    eval('package ' . $current_module_name . ';' . chr(10) . '$module_name->import(@$arguments); 1') or die(${'@'});
                    shift(@{$Perlito5::CALLER})
                }
            }
            elsif ($use_or_not eq 'no') {
                if (defined(&{$module_name . '::unimport'})) {
                    unshift(@{$Perlito5::CALLER}, [$current_module_name]);
                    eval('package ' . $current_module_name . ';' . chr(10) . '$module_name->unimport(@$arguments); 1') or die(${'@'});
                    shift(@{$Perlito5::CALLER})
                }
            }
        }
    }
}
sub Perlito5::Grammar::Use::emit_time_eval {
    my $ast = shift;
    if ($ast->mod() eq 'strict') {
        if ($ast->code() eq 'use') {
            strict::->import()
        }
        elsif ($ast->code() eq 'no') {
            strict::->unimport()
        }
    }
}
sub Perlito5::Grammar::Use::modulename_to_filename {
    my $s = shift;
    exists($Perlito_internal_module{$s}) && ($s = $Perlito_internal_module{$s});
    $s =~ s!::!/!g;
    return $s . '.pm'
}
sub Perlito5::Grammar::Use::filename_lookup {
    my $filename = shift;
    if (exists($INC{$filename})) {
        $INC{$filename} && return 'done';
        die('Compilation failed in require')
    }
    for my $prefix (@INC, '.') {
        my $realfilename = $prefix . '/' . $filename;
        if (-f $realfilename) {
            $INC{$filename} = $realfilename;
            return 'todo'
        }
    }
    die('Can' . chr(39) . 't locate ' . $filename . ' in @INC ' . '(@INC contains ' . join(' ', @INC) . ').')
}
sub Perlito5::Grammar::Use::expand_use {
    my $comp_units = shift;
    my $stmt = shift;
    my $module_name = $stmt->mod();
    my $filename = modulename_to_filename($module_name);
    filename_lookup($filename) eq 'done' && return ;
    local $Perlito5::FILE_NAME = $filename;
    local $Perlito5::LINE_NUMBER = 1;
    my $realfilename = $INC{$filename};
    open(FILE, '<', $realfilename) or die('Cannot read ' . $realfilename . ': ' . ${'!'} . chr(10));
    local ${'/'} = undef;
    my $source = <FILE>;
    close(FILE);
    my $m = Perlito5::Grammar::exp_stmts($source, 0);
    $m->{'to'} != length($source) && die('Syntax Error near ', $m->{'to'});
    if ($m->{'to'} != length($source)) {
        my $pos = $m->{'to'} - 10;
        $pos < 0 && ($pos = 0);
        print('* near: ', substr($source, $pos, 20), chr(10));
        print('* filename: ' . $realfilename . chr(10));
        die('Syntax Error near ', $m->{'to'})
    }
    push(@{$comp_units}, @{add_comp_unit([Perlito5::AST::CompUnit::->new('name' => 'main', 'body' => Perlito5::Match::flat($m))])})
}
sub Perlito5::Grammar::Use::add_comp_unit {
    my $parse = shift;
    my $comp_units = [];
    for my $comp_unit (@{$parse}) {
        if (defined($comp_unit)) {
            if ($comp_unit->isa('Perlito5::AST::Use')) {
                expand_use($comp_units, $comp_unit)
            }
            elsif ($comp_unit->isa('Perlito5::AST::CompUnit')) {
                for my $stmt (@{$comp_unit->body()}) {
                    if ($stmt->isa('Perlito5::AST::Use')) {
                        expand_use($comp_units, $stmt)
                    }
                }
            }
            push(@{$comp_units}, $comp_unit)
        }
    }
    return $comp_units
}
sub Perlito5::Grammar::Use::require {
    my $filename = shift;
    filename_lookup($filename) eq 'done' && return ;
    my $result = do($filename);
    if (${'@'}) {
        $INC{$filename} = undef;
        die(${'@'})
    }
    elsif (!$result) {
        delete($INC{$filename});
        ${'@'} && warn(${'@'});
        die($filename . ' did not return true value')
    }
    else {
        return $result
    }
}
sub Perlito5::Grammar::Use::do_file {
    my $filename = shift;
    eval {
        filename_lookup($filename);
        1
    } or do {
        $INC{$filename} = undef;
        ${'@'} = '';
        ${'!'} = 'No such file or directory';
        return 'undef'
    };
    my $realfilename = $INC{$filename};
    open(FILE, '<', $realfilename) or die('Cannot read ' . $realfilename . ': ' . ${'!'} . chr(10));
    local ${'/'} = undef;
    my $source = <FILE>;
    close(FILE);
    return $source
}
Perlito5::Grammar::Statement::add_statement('no' => \&stmt_use);
Perlito5::Grammar::Statement::add_statement('use' => \&stmt_use);
Perlito5::Grammar::Precedence::add_term('require' => \&term_require);
1;
package main;
package Perlito5::Grammar::Scope;
# use strict
our %Special_var = ('ARGV' => 1, 'INC' => 1, 'ENV' => 1, 'SIG' => 1, '_' => 1);
sub Perlito5::Grammar::Scope::new {
    return {'block' => []}
}
sub Perlito5::Grammar::Scope::new_base_scope {
    return {'block' => []}
}
sub Perlito5::Grammar::Scope::create_new_compile_time_scope {
    my $new_scope = {'block' => []};
    push(@{$Perlito5::SCOPE->{'block'}}, $new_scope);
    $Perlito5::SCOPE_DEPTH++;
    $Perlito5::SCOPE = $new_scope
}
sub Perlito5::Grammar::Scope::end_compile_time_scope {
    my $pos = 0;
    $Perlito5::SCOPE_DEPTH--;
    $Perlito5::SCOPE = $Perlito5::BASE_SCOPE;
    while ($Perlito5::SCOPE_DEPTH > $pos) {
        $pos++;
        $Perlito5::SCOPE = $Perlito5::SCOPE->{'block'}->[-1]
    }
}
sub Perlito5::Grammar::Scope::lookup_variable {
    my $var = shift;
    my $scope = shift() // $Perlito5::BASE_SCOPE;
    $var->{'namespace'} && return $var;
    $var->{'_decl'} && return $var;
    my $look = lookup_variable_inner($var, $scope, 0);
    $look && return $look;
    my $c = substr($var->{'name'}, 0, 1);
    if ($Special_var{$var->{'name'}} || $c lt 'A' || ($c gt 'Z' && $c lt 'a') || $c gt 'z') {
        $var->{'_decl'} = 'global';
        $var->{'_namespace'} = 'main';
        return $var
    }
    if ($var->{'sigil'} eq '$' && ($var->{'name'} eq 'a' || $var->{'name'} eq 'b')) {
        if (!$var->{'_real_sigil'}) {
            $var->{'_decl'} = 'global';
            $var->{'_namespace'} = $Perlito5::PKG_NAME;
            return $var
        }
    }
    return 
}
sub Perlito5::Grammar::Scope::lookup_variable_inner {
    my($var, $scope, $depth) = @_;
    $depth > $Perlito5::SCOPE_DEPTH && return ;
    my $block = $scope->{'block'};
    if (@{$block} && ref($block->[-1]) eq 'HASH' && $block->[-1]->{'block'}) {
        my $look = lookup_variable_inner($var, $block->[-1], $depth + 1);
        $look && return $look
    }
    for my $item (reverse(@{$block})) {
        if (ref($item) eq 'Perlito5::AST::Var' && $item->{'_decl'} && $item->{'_decl'} ne 'global' && $item->{'name'} eq $var->{'name'}) {
            my $sigil = $var->{'_real_sigil'} || $var->{'sigil'};
            my $item_sigil = $item->{'_real_sigil'} || $item->{'sigil'};
            if ($sigil eq $item_sigil) {
                return $item
            }
        }
    }
    return 
}
sub Perlito5::Grammar::Scope::check_variable_declarations {
    for my $item (@Perlito5::SCOPE_STMT) {
        if (ref($item) eq 'Perlito5::AST::Var') {
            my $var = $item;
            my $look = lookup_variable($var);
            if ($look) {
                $look->{'_id'} && ($var->{'_id'} = $look->{'_id'});
                $look->{'_decl'} && ($var->{'_decl'} = $look->{'_decl'});
                $look->{'_namespace'} && ($var->{'_namespace'} = $look->{'_namespace'})
            }
            else {
                if ($Perlito5::STRICT) {
                    my $sigil = $var->{'_real_sigil'} || $var->{'sigil'};
                    if ($sigil ne '*' && $sigil ne '&') {
                        die('Global symbol "' . $sigil . $var->{'name'} . '"' . ' requires explicit package name' . ' at ' . $Perlito5::FILE_NAME)
                    }
                }
                $var->{'_decl'} = 'global';
                $var->{'_namespace'} = $Perlito5::PKG_NAME
            }
        }
    }
    push(@{$Perlito5::SCOPE->{'block'}}, @Perlito5::SCOPE_STMT);
    @Perlito5::SCOPE_STMT = ()
}
sub Perlito5::Grammar::Scope::get_snapshot {
    my @result;
    my $scope = shift() // $Perlito5::BASE_SCOPE;
    my $block = $scope->{'block'};
    if (@{$block} && ref($block->[-1]) eq 'HASH' && $block->[-1]->{'block'}) {
        my $look = get_snapshot($block->[-1]);
        unshift(@result, @{$look->{'block'}})
    }
    for my $item (@{$block}) {
        if (ref($item) eq 'Perlito5::AST::Var' && $item->{'_decl'}) {
            unshift(@result, $item)
        }
    }
    return {'block' => \@result}
}
1;
package main;
package Perlito5::Grammar::Block;
# use Perlito5::Grammar::Expression
# use Perlito5::Grammar::Scope
# use strict
our %Named_block = ('BEGIN' => 1, 'UNITCHECK' => 1, 'CHECK' => 1, 'INIT' => 1, 'END' => 1);
sub Perlito5::Grammar::Block::block {
    my $str = $_[0];
    my $pos = $_[1];
    my $m = Perlito5::Grammar::Space::opt_ws($str, $pos);
    $pos = $m->{'to'};
    if (substr($str, $pos, 1) ne '{') {
        return 
    }
    $pos++;
    Perlito5::Grammar::Scope::check_variable_declarations();
    Perlito5::Grammar::Scope::create_new_compile_time_scope();
    $m = Perlito5::Grammar::exp_stmts($str, $pos);
    if (!$m) {
        die('syntax error')
    }
    $pos = $m->{'to'};
    my $capture = Perlito5::Match::flat($m);
    $m = Perlito5::Grammar::Space::opt_ws($str, $pos);
    $pos = $m->{'to'};
    if (substr($str, $pos, 1) ne '}') {
        die('syntax error')
    }
    $m->{'to'} = $pos + 1;
    $m->{'capture'} = Perlito5::AST::Block::->new('stmts' => $capture, 'sig' => undef);
    Perlito5::Grammar::Scope::end_compile_time_scope();
    return $m
}
sub Perlito5::Grammar::Block::eval_begin_block {
    local ${'@'};
    my $code = 'package ' . $Perlito5::PKG_NAME . ';' . chr(10) . $_[0];
    eval('{ ' . $code . ' }; 1') or die('Error in BEGIN block: ' . ${'@'})
}
sub Perlito5::Grammar::Block::opt_continue_block {
    my $str = $_[0];
    my $pos = $_[1];
    my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
    my $tmp = ((do {
        my $pos1 = $MATCH->{'to'};
        (do {
            ((do {
                my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{'to'});
                if ($m2) {
                    $MATCH->{'to'} = $m2->{'to'};
                    1
                }
                else {
                    0
                }
            }) && ('continue' eq substr($str, $MATCH->{'to'}, 8) && ($MATCH->{'to'} = 8 + $MATCH->{'to'})) && (do {
                my $m2 = block($str, $MATCH->{'to'});
                if ($m2) {
                    $MATCH->{'to'} = $m2->{'to'};
                    $MATCH->{'block'} = $m2;
                    1
                }
                else {
                    0
                }
            }) && (do {
                $MATCH->{'str'} = $str;
                $MATCH->{'capture'} = Perlito5::Match::flat($MATCH->{'block'});
                $MATCH->{'capture'}->{'is_continue'} = 1;
                1
            }))
        }) || (do {
            $MATCH->{'to'} = $pos1;
            (do {
                $MATCH->{'str'} = $str;
                $MATCH->{'capture'} = Perlito5::AST::Block::->new('stmts' => [], 'sig' => undef);
                1
            })
        })
    }));
    $tmp ? $MATCH : 0
}
sub Perlito5::Grammar::Block::anon_block {
    my $str = $_[0];
    my $pos = $_[1];
    my $p = $pos;
    my $m = Perlito5::Grammar::block($str, $p);
    !$m && return ;
    $p = $m->{'to'};
    my $block = Perlito5::Match::flat($m);
    $m = Perlito5::Grammar::opt_continue_block($str, $p);
    $p = $m->{'to'};
    my $continue = Perlito5::Match::flat($m);
    my $v = $block;
    $continue->{'is_continue'} || ($v = Perlito5::Grammar::Expression::block_or_hash($v));
    $m->{'capture'} = $v;
    if ($continue->{'is_continue'}) {
        $m->{'capture'}->{'continue'} = $continue
    }
    return $m
}
sub Perlito5::Grammar::Block::special_named_block {
    my $str = $_[0];
    my $pos = $_[1];
    my $p = $pos;
    my $block_name;
    my $m_name = Perlito5::Grammar::ident($str, $p);
    !$m_name && return ;
    $p = $m_name->{'to'};
    $block_name = Perlito5::Match::flat($m_name);
    my $ws = Perlito5::Grammar::Space::opt_ws($str, $p);
    $p = $ws->{'to'};
    my $block_start = $p;
    my $m = Perlito5::Grammar::block($str, $p);
    !$m && return ;
    $p = $m->{'to'};
    my $block = Perlito5::Match::flat($m);
    my $compile_block = $Perlito5::SCOPE->{'block'}->[-1];
    $compile_block->{'type'} = 'sub';
    $compile_block->{'name'} = $block_name;
    if ($block_name eq 'BEGIN') {
        local $Perlito5::PHASE = 'BEGIN';
        eval_begin_block(substr($str, $block_start, $m->{'to'} - $block_start));
        $m->{'capture'} = Perlito5::AST::Apply::->new('code' => 'undef', 'namespace' => '', 'arguments' => [])
    }
    else {
        $m->{'capture'} = $block;
        $m->{'capture'}->{'name'} = $block_name
    }
    return $m
}
sub Perlito5::Grammar::Block::named_sub_def {
    my $str = $_[0];
    my $pos = $_[1];
    my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
    my $tmp = (((do {
        my $m2 = Perlito5::Grammar::optional_namespace_before_ident($str, $MATCH->{'to'});
        if ($m2) {
            $MATCH->{'to'} = $m2->{'to'};
            $MATCH->{'Perlito5::Grammar::optional_namespace_before_ident'} = $m2;
            1
        }
        else {
            0
        }
    }) && (do {
        my $m2 = Perlito5::Grammar::ident($str, $MATCH->{'to'});
        if ($m2) {
            $MATCH->{'to'} = $m2->{'to'};
            $MATCH->{'Perlito5::Grammar::ident'} = $m2;
            1
        }
        else {
            0
        }
    }) && (do {
        my $m2 = Perlito5::Grammar::Block::prototype_($str, $MATCH->{'to'});
        if ($m2) {
            $MATCH->{'to'} = $m2->{'to'};
            $MATCH->{'Perlito5::Grammar::Block::prototype_'} = $m2;
            1
        }
        else {
            0
        }
    }) && (do {
        my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{'to'});
        if ($m2) {
            $MATCH->{'to'} = $m2->{'to'};
            1
        }
        else {
            0
        }
    }) && (do {
        my $m2 = Perlito5::Grammar::Attribute::opt_attribute($str, $MATCH->{'to'});
        if ($m2) {
            $MATCH->{'to'} = $m2->{'to'};
            $MATCH->{'Perlito5::Grammar::Attribute::opt_attribute'} = $m2;
            1
        }
        else {
            0
        }
    }) && (do {
        my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{'to'});
        if ($m2) {
            $MATCH->{'to'} = $m2->{'to'};
            1
        }
        else {
            0
        }
    }) && (do {
        my $pos1 = $MATCH->{'to'};
        (do {
            ((do {
                my $m2 = Perlito5::Grammar::block($str, $MATCH->{'to'});
                if ($m2) {
                    $MATCH->{'to'} = $m2->{'to'};
                    $MATCH->{'Perlito5::Grammar::block'} = $m2;
                    1
                }
                else {
                    0
                }
            }) && (do {
                $MATCH->{'str'} = $str;
                $MATCH->{'_tmp'} = Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::block'});
                1
            }))
        }) || (do {
            $MATCH->{'to'} = $pos1;
            ((do {
                my $m2 = Perlito5::Grammar::Statement::statement_parse($str, $MATCH->{'to'});
                if ($m2) {
                    $MATCH->{'to'} = $m2->{'to'};
                    1
                }
                else {
                    0
                }
            }) && (do {
                $MATCH->{'str'} = $str;
                die('Illegal declaration of subroutine ' . chr(39), Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::ident'}), chr(39));
                1
            }))
        }) || (do {
            $MATCH->{'to'} = $pos1;
            (do {
                $MATCH->{'str'} = $str;
                $MATCH->{'_tmp'} = undef;
                1
            })
        })
    }) && (do {
        $MATCH->{'str'} = $str;
        my $name = Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::ident'});
        my $sig = Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::Block::prototype_'});
        $sig eq '*undef*' && ($sig = undef);
        my $attributes = Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::Attribute::opt_attribute'});
        my($proto) = grep {
            $_->[0] eq 'prototype'
        } @{$attributes};
        if ($proto) {
            $attributes = [grep {
                $_->[0] ne 'prototype'
            } @{$attributes}];
            $sig = $proto->[1]
        }
        my $namespace = Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::optional_namespace_before_ident'});
        if ($name) {
            if (!$namespace) {
                $namespace = $name eq '_' ? 'main' : $Perlito5::PKG_NAME
            }
            my $full_name = $namespace . '::' . $name;
            $Perlito5::PROTO->{$full_name} = $sig;
            if ($MATCH->{'_tmp'}) {
                my $block = $Perlito5::SCOPE->{'block'}->[-1];
                $block->{'type'} = 'sub';
                $block->{'name'} = $full_name
            }
        }
        $MATCH->{'capture'} = Perlito5::AST::Sub::->new('name' => $name, 'namespace' => $namespace, 'sig' => $sig, 'block' => $MATCH->{'_tmp'}, 'attributes' => $attributes);
        1
    })));
    $tmp ? $MATCH : 0
}
sub Perlito5::Grammar::Block::named_sub {
    my $str = $_[0];
    my $pos = $_[1];
    substr($str, $pos, 3) eq 'sub' || return ;
    my $ws = Perlito5::Grammar::Space::ws($str, $pos + 3);
    $ws || return ;
    my $p = $ws->{'to'};
    my $m_name = Perlito5::Grammar::ident($str, $p);
    $m_name || return ;
    my $block_name = Perlito5::Match::flat($m_name);
    if (exists($Named_block{$block_name})) {
        return Perlito5::Grammar::Block::special_named_block($str, $p)
    }
    return Perlito5::Grammar::Block::named_sub_def($str, $p)
}
sub Perlito5::Grammar::Block::term_anon_sub {
    my $str = $_[0];
    my $pos = $_[1];
    my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
    my $tmp = ((('sub' eq substr($str, $MATCH->{'to'}, 3) && ($MATCH->{'to'} = 3 + $MATCH->{'to'})) && (do {
        my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{'to'});
        if ($m2) {
            $MATCH->{'to'} = $m2->{'to'};
            1
        }
        else {
            0
        }
    }) && (do {
        my $m2 = Perlito5::Grammar::Block::anon_sub_def($str, $MATCH->{'to'});
        if ($m2) {
            $MATCH->{'to'} = $m2->{'to'};
            $MATCH->{'Perlito5::Grammar::Block::anon_sub_def'} = $m2;
            1
        }
        else {
            0
        }
    }) && (do {
        $MATCH->{'str'} = $str;
        $MATCH->{'capture'} = ['term', Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::Block::anon_sub_def'})];
        1
    })));
    $tmp ? $MATCH : 0
}
sub Perlito5::Grammar::Block::term_do {
    my $str = $_[0];
    my $pos = $_[1];
    my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
    my $tmp = ((('do' eq substr($str, $MATCH->{'to'}, 2) && ($MATCH->{'to'} = 2 + $MATCH->{'to'})) && (do {
        my $m2 = Perlito5::Grammar::block($str, $MATCH->{'to'});
        if ($m2) {
            $MATCH->{'to'} = $m2->{'to'};
            $MATCH->{'Perlito5::Grammar::block'} = $m2;
            1
        }
        else {
            0
        }
    }) && (do {
        $MATCH->{'str'} = $str;
        $MATCH->{'capture'} = ['term', Perlito5::AST::Apply::->new('code' => 'do', 'arguments' => [Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::block'})])];
        1
    })));
    $tmp ? $MATCH : 0
}
sub Perlito5::Grammar::Block::args_sig {
    my $str = $_[0];
    my $pos = $_[1];
    my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
    my $tmp = ((do {
        my $last_match_null = 0;
        my $m = $MATCH;
        my $to = $MATCH->{'to'};
        while ((do {
            my $pos1 = $MATCH->{'to'};
            (do {
                (';' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}))
            }) || (do {
                $MATCH->{'to'} = $pos1;
                (chr(92) eq substr($str, $MATCH->{'to'}, 2) && ($MATCH->{'to'} = 2 + $MATCH->{'to'}))
            }) || (do {
                $MATCH->{'to'} = $pos1;
                ('[' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}))
            }) || (do {
                $MATCH->{'to'} = $pos1;
                (']' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}))
            }) || (do {
                $MATCH->{'to'} = $pos1;
                ('*' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}))
            }) || (do {
                $MATCH->{'to'} = $pos1;
                ('+' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}))
            }) || (do {
                $MATCH->{'to'} = $pos1;
                ('@' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}))
            }) || (do {
                $MATCH->{'to'} = $pos1;
                ('%' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}))
            }) || (do {
                $MATCH->{'to'} = $pos1;
                ('$' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}))
            }) || (do {
                $MATCH->{'to'} = $pos1;
                ('&' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}))
            })
        }) && ($last_match_null < 2)) {
            if ($to == $MATCH->{'to'}) {
                $last_match_null = $last_match_null + 1
            }
            else {
                $last_match_null = 0
            }
            $m = $MATCH;
            $to = $MATCH->{'to'}
        }
        $MATCH = $m;
        $MATCH->{'to'} = $to;
        1
    }));
    $tmp ? $MATCH : 0
}
sub Perlito5::Grammar::Block::prototype_ {
    my $str = $_[0];
    my $pos = $_[1];
    my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
    my $tmp = ((do {
        my $pos1 = $MATCH->{'to'};
        (do {
            ((do {
                my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{'to'});
                if ($m2) {
                    $MATCH->{'to'} = $m2->{'to'};
                    1
                }
                else {
                    0
                }
            }) && ('(' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{'to'});
                if ($m2) {
                    $MATCH->{'to'} = $m2->{'to'};
                    1
                }
                else {
                    0
                }
            }) && ('_' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{'to'});
                if ($m2) {
                    $MATCH->{'to'} = $m2->{'to'};
                    1
                }
                else {
                    0
                }
            }) && (')' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                $MATCH->{'str'} = $str;
                $MATCH->{'capture'} = '_';
                1
            }))
        }) || (do {
            $MATCH->{'to'} = $pos1;
            ((do {
                my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{'to'});
                if ($m2) {
                    $MATCH->{'to'} = $m2->{'to'};
                    1
                }
                else {
                    0
                }
            }) && ('(' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{'to'});
                if ($m2) {
                    $MATCH->{'to'} = $m2->{'to'};
                    1
                }
                else {
                    0
                }
            }) && (do {
                my $m2 = args_sig($str, $MATCH->{'to'});
                if ($m2) {
                    $MATCH->{'to'} = $m2->{'to'};
                    $MATCH->{'args_sig'} = $m2;
                    1
                }
                else {
                    0
                }
            }) && (do {
                my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{'to'});
                if ($m2) {
                    $MATCH->{'to'} = $m2->{'to'};
                    1
                }
                else {
                    0
                }
            }) && (')' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                $MATCH->{'str'} = $str;
                $MATCH->{'capture'} = '' . Perlito5::Match::flat($MATCH->{'args_sig'});
                1
            }))
        }) || (do {
            $MATCH->{'to'} = $pos1;
            (do {
                $MATCH->{'str'} = $str;
                $MATCH->{'capture'} = '*undef*';
                1
            })
        })
    }));
    $tmp ? $MATCH : 0
}
sub Perlito5::Grammar::Block::anon_sub_def {
    my $str = $_[0];
    my $pos = $_[1];
    my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
    my $tmp = (((do {
        my $m2 = prototype_($str, $MATCH->{'to'});
        if ($m2) {
            $MATCH->{'to'} = $m2->{'to'};
            $MATCH->{'prototype_'} = $m2;
            1
        }
        else {
            0
        }
    }) && (do {
        my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{'to'});
        if ($m2) {
            $MATCH->{'to'} = $m2->{'to'};
            1
        }
        else {
            0
        }
    }) && (do {
        my $m2 = Perlito5::Grammar::Attribute::opt_attribute($str, $MATCH->{'to'});
        if ($m2) {
            $MATCH->{'to'} = $m2->{'to'};
            $MATCH->{'Perlito5::Grammar::Attribute::opt_attribute'} = $m2;
            1
        }
        else {
            0
        }
    }) && (do {
        my $m2 = Perlito5::Grammar::block($str, $MATCH->{'to'});
        if ($m2) {
            $MATCH->{'to'} = $m2->{'to'};
            $MATCH->{'Perlito5::Grammar::block'} = $m2;
            1
        }
        else {
            0
        }
    }) && (do {
        $MATCH->{'str'} = $str;
        my $sig = Perlito5::Match::flat($MATCH->{'prototype_'});
        $sig eq '*undef*' && ($sig = undef);
        my $attributes = Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::Attribute::opt_attribute'});
        my($proto) = grep {
            $_->[0] eq 'prototype'
        } @{$attributes};
        if ($proto) {
            $attributes = [grep {
                $_->[0] ne 'prototype'
            } @{$attributes}];
            $sig = $proto->[1]
        }
        $MATCH->{'capture'} = Perlito5::AST::Sub::->new('name' => undef, 'namespace' => undef, 'sig' => $sig, 'block' => Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::block'}), 'attributes' => $attributes);
        1
    })));
    $tmp ? $MATCH : 0
}
Perlito5::Grammar::Precedence::add_term('do' => \&term_do);
Perlito5::Grammar::Precedence::add_term('sub' => \&term_anon_sub);
Perlito5::Grammar::Statement::add_statement('{' => \&anon_block);
Perlito5::Grammar::Statement::add_statement('sub' => \&named_sub);
Perlito5::Grammar::Statement::add_statement($_ => \&special_named_block)
    for keys(%Named_block);
1;
package main;
package Perlito5::Grammar::Space;
# use Perlito5::Grammar::Precedence
my %line_index;
sub Perlito5::Grammar::Space::count_line {
    my $pos = $_[0];
    $pos < $line_index{$Perlito5::FILE_NAME} && return ;
    $line_index{$Perlito5::FILE_NAME} = $pos + 1;
    $Perlito5::LINE_NUMBER++
}
my %space = ('#' => sub {
    my $m = Perlito5::Grammar::Space::to_eol($_[0], $_[1]);
    $m->{'to'}
}, chr(9) => sub {
    $_[1]
}, chr(10) => sub {
    my $str = $_[0];
    my $pos = $_[1];
    count_line($pos);
    substr($str, $pos, 1) eq chr(13) && $pos++;
    my $m = Perlito5::Grammar::Space::start_of_line($_[0], $pos);
    $m->{'to'}
}, chr(12) => sub {
    $_[1]
}, chr(13) => sub {
    my $str = $_[0];
    my $pos = $_[1];
    if (substr($str, $pos, 1) eq chr(10)) {
        count_line($pos);
        $pos++
    }
    my $m = Perlito5::Grammar::Space::start_of_line($_[0], $pos);
    $m->{'to'}
}, chr(32) => sub {
    $_[1]
});
sub Perlito5::Grammar::Space::term_space {
    my $str = $_[0];
    my $pos = $_[1];
    my $p = $pos;
    while (exists($space{substr($str, $p, 1)})) {
        $p = $space{substr($str, $p, 1)}->($str, $p + 1)
    }
    (substr($str, $p, 7) eq '__END__' || substr($str, $p, 8) eq '__DATA__') && return term_end($str, $p);
    return {'str' => $str, 'from' => $pos, 'to' => $p, 'capture' => ['space', ' ']}
}
sub Perlito5::Grammar::Space::term_end {
    my $str = $_[0];
    my $p = $_[1];
    my $is_data = 0;
    if (substr($str, $_[1], 7) eq '__END__' && $Perlito5::PKG_NAME eq 'main') {
        $p = $p + 7;
        $is_data = 1
    }
    elsif (substr($str, $_[1], 8) eq '__DATA__') {
        $p = $p + 8;
        $is_data = 1
    }
    my $m = Perlito5::Grammar::Space::to_eol($str, $p);
    $p = $m->{'to'};
    if (substr($str, $p, 1) eq chr(10)) {
        count_line($p);
        $p++;
        substr($str, $p, 1) eq chr(13) && $p++
    }
    elsif (substr($str, $p, 1) eq chr(13)) {
        $p++;
        if (substr($str, $p, 1) eq chr(10)) {
            count_line($p);
            $p++
        }
    }
    if ($is_data) {
        $Perlito5::DATA_SECTION{$Perlito5::PKG_NAME} = substr($_[0], $p)
    }
    return {'str' => $str, 'from' => $_[1], 'to' => length($_[0]), 'capture' => ['space', ' ']}
}
Perlito5::Grammar::Precedence::add_term('#' => \&term_space);
Perlito5::Grammar::Precedence::add_term(chr(9) => \&term_space);
Perlito5::Grammar::Precedence::add_term(chr(10) => \&term_space);
Perlito5::Grammar::Precedence::add_term(chr(12) => \&term_space);
Perlito5::Grammar::Precedence::add_term(chr(13) => \&term_space);
Perlito5::Grammar::Precedence::add_term(chr(32) => \&term_space);
Perlito5::Grammar::Precedence::add_term('__END__' => \&term_end);
Perlito5::Grammar::Precedence::add_term('__DATA__' => \&term_end);
sub Perlito5::Grammar::Space::to_eol {
    my $str = $_[0];
    my $pos = $_[1];
    my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
    my $tmp = ((do {
        my $last_match_null = 0;
        my $m = $MATCH;
        my $to = $MATCH->{'to'};
        while (((do {
            my $tmp = $MATCH;
            $MATCH = {'str' => $str, 'from' => $tmp->{'to'}, 'to' => $tmp->{'to'}};
            my $res = (do {
                my $pos1 = $MATCH->{'to'};
                (do {
                    (chr(10) eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}))
                }) || (do {
                    $MATCH->{'to'} = $pos1;
                    (chr(13) eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}))
                })
            });
            $MATCH = $tmp;
            $res ? 0 : 1
        }) && ('' ne substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}))) && ($last_match_null < 2)) {
            if ($to == $MATCH->{'to'}) {
                $last_match_null = $last_match_null + 1
            }
            else {
                $last_match_null = 0
            }
            $m = $MATCH;
            $to = $MATCH->{'to'}
        }
        $MATCH = $m;
        $MATCH->{'to'} = $to;
        1
    }));
    $tmp ? $MATCH : 0
}
sub Perlito5::Grammar::Space::pod_pod_begin {
    my $str = $_[0];
    my $pos = $_[1];
    my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
    my $tmp = ((do {
        my $pos1 = $MATCH->{'to'};
        (do {
            ((do {
                my $pos1 = $MATCH->{'to'};
                (do {
                    (chr(10) eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}))
                }) || (do {
                    $MATCH->{'to'} = $pos1;
                    (chr(13) eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}))
                })
            }) && ('=cut' eq substr($str, $MATCH->{'to'}, 4) && ($MATCH->{'to'} = 4 + $MATCH->{'to'})) && (do {
                my $m2 = to_eol($str, $MATCH->{'to'});
                if ($m2) {
                    $MATCH->{'to'} = $m2->{'to'};
                    1
                }
                else {
                    0
                }
            }))
        }) || (do {
            $MATCH->{'to'} = $pos1;
            (('' ne substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                my $m2 = to_eol($str, $MATCH->{'to'});
                if ($m2) {
                    $MATCH->{'to'} = $m2->{'to'};
                    1
                }
                else {
                    0
                }
            }) && (do {
                my $m2 = pod_pod_begin($str, $MATCH->{'to'});
                if ($m2) {
                    $MATCH->{'to'} = $m2->{'to'};
                    1
                }
                else {
                    0
                }
            }))
        })
    }));
    $tmp ? $MATCH : 0
}
sub Perlito5::Grammar::Space::pod_begin {
    my $str = $_[0];
    my $pos = $_[1];
    my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
    my $tmp = ((do {
        my $pos1 = $MATCH->{'to'};
        (do {
            ((do {
                my $pos1 = $MATCH->{'to'};
                (do {
                    (chr(10) eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}))
                }) || (do {
                    $MATCH->{'to'} = $pos1;
                    (chr(13) eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}))
                })
            }) && ('=end' eq substr($str, $MATCH->{'to'}, 4) && ($MATCH->{'to'} = 4 + $MATCH->{'to'})) && (do {
                my $m2 = to_eol($str, $MATCH->{'to'});
                if ($m2) {
                    $MATCH->{'to'} = $m2->{'to'};
                    1
                }
                else {
                    0
                }
            }))
        }) || (do {
            $MATCH->{'to'} = $pos1;
            (('' ne substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                my $m2 = to_eol($str, $MATCH->{'to'});
                if ($m2) {
                    $MATCH->{'to'} = $m2->{'to'};
                    1
                }
                else {
                    0
                }
            }) && (do {
                my $m2 = pod_begin($str, $MATCH->{'to'});
                if ($m2) {
                    $MATCH->{'to'} = $m2->{'to'};
                    1
                }
                else {
                    0
                }
            }))
        })
    }));
    $tmp ? $MATCH : 0
}
sub Perlito5::Grammar::Space::start_of_line {
    my $str = $_[0];
    my $pos = $_[1];
    my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
    my $tmp = (((do {
        my $m2 = Perlito5::Grammar::String::here_doc($str, $MATCH->{'to'});
        if ($m2) {
            $MATCH->{'to'} = $m2->{'to'};
            1
        }
        else {
            0
        }
    }) && (do {
        my $pos1 = $MATCH->{'to'};
        (do {
            (('=' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                my $pos1 = $MATCH->{'to'};
                (do {
                    (('pod' eq substr($str, $MATCH->{'to'}, 3) && ($MATCH->{'to'} = 3 + $MATCH->{'to'})) && (do {
                        my $m2 = pod_pod_begin($str, $MATCH->{'to'});
                        if ($m2) {
                            $MATCH->{'to'} = $m2->{'to'};
                            1
                        }
                        else {
                            0
                        }
                    }))
                }) || (do {
                    $MATCH->{'to'} = $pos1;
                    (('head' eq substr($str, $MATCH->{'to'}, 4) && ($MATCH->{'to'} = 4 + $MATCH->{'to'})) && (do {
                        my $m2 = pod_pod_begin($str, $MATCH->{'to'});
                        if ($m2) {
                            $MATCH->{'to'} = $m2->{'to'};
                            1
                        }
                        else {
                            0
                        }
                    }))
                }) || (do {
                    $MATCH->{'to'} = $pos1;
                    (('begin' eq substr($str, $MATCH->{'to'}, 5) && ($MATCH->{'to'} = 5 + $MATCH->{'to'})) && (do {
                        my $m2 = pod_begin($str, $MATCH->{'to'});
                        if ($m2) {
                            $MATCH->{'to'} = $m2->{'to'};
                            1
                        }
                        else {
                            0
                        }
                    }))
                }) || (do {
                    $MATCH->{'to'} = $pos1;
                    (('for' eq substr($str, $MATCH->{'to'}, 3) && ($MATCH->{'to'} = 3 + $MATCH->{'to'})) && (do {
                        my $m2 = pod_begin($str, $MATCH->{'to'});
                        if ($m2) {
                            $MATCH->{'to'} = $m2->{'to'};
                            1
                        }
                        else {
                            0
                        }
                    }))
                }) || (do {
                    $MATCH->{'to'} = $pos1;
                    (('encoding' eq substr($str, $MATCH->{'to'}, 8) && ($MATCH->{'to'} = 8 + $MATCH->{'to'})) && (do {
                        my $m2 = to_eol($str, $MATCH->{'to'});
                        if ($m2) {
                            $MATCH->{'to'} = $m2->{'to'};
                            1
                        }
                        else {
                            0
                        }
                    }))
                }) || (do {
                    $MATCH->{'to'} = $pos1;
                    (('cut' eq substr($str, $MATCH->{'to'}, 3) && ($MATCH->{'to'} = 3 + $MATCH->{'to'})) && (do {
                        my $m2 = to_eol($str, $MATCH->{'to'});
                        if ($m2) {
                            $MATCH->{'to'} = $m2->{'to'};
                            1
                        }
                        else {
                            0
                        }
                    }))
                })
            }))
        }) || (do {
            $MATCH->{'to'} = $pos1;
            (('#' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                my $last_match_null = 0;
                my $m = $MATCH;
                my $to = $MATCH->{'to'};
                while ((do {
                    my $pos1 = $MATCH->{'to'};
                    (do {
                        (' ' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}))
                    }) || (do {
                        $MATCH->{'to'} = $pos1;
                        (chr(9) eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}))
                    })
                }) && ($last_match_null < 2)) {
                    if ($to == $MATCH->{'to'}) {
                        $last_match_null = $last_match_null + 1
                    }
                    else {
                        $last_match_null = 0
                    }
                    $m = $MATCH;
                    $to = $MATCH->{'to'}
                }
                $MATCH = $m;
                $MATCH->{'to'} = $to;
                1
            }) && ('line' eq substr($str, $MATCH->{'to'}, 4) && ($MATCH->{'to'} = 4 + $MATCH->{'to'})) && (do {
                my $last_match_null = 0;
                my $m = $MATCH;
                my $to = $MATCH->{'to'};
                my $count = 0;
                while ((do {
                    my $pos1 = $MATCH->{'to'};
                    (do {
                        (' ' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}))
                    }) || (do {
                        $MATCH->{'to'} = $pos1;
                        (chr(9) eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}))
                    })
                }) && ($last_match_null < 2)) {
                    if ($to == $MATCH->{'to'}) {
                        $last_match_null = $last_match_null + 1
                    }
                    else {
                        $last_match_null = 0
                    }
                    $m = $MATCH;
                    $to = $MATCH->{'to'};
                    $count = $count + 1
                }
                $MATCH = $m;
                $MATCH->{'to'} = $to;
                $count > 0
            }) && (do {
                my $m2 = Perlito5::Grammar::Number::digits($str, $MATCH->{'to'});
                if ($m2) {
                    $MATCH->{'to'} = $m2->{'to'};
                    $MATCH->{'Perlito5::Grammar::Number::digits'} = $m2;
                    1
                }
                else {
                    0
                }
            }) && (do {
                my $last_match_null = 0;
                my $m = $MATCH;
                my $to = $MATCH->{'to'};
                while ((do {
                    my $pos1 = $MATCH->{'to'};
                    (do {
                        (' ' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}))
                    }) || (do {
                        $MATCH->{'to'} = $pos1;
                        (chr(9) eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}))
                    })
                }) && ($last_match_null < 2)) {
                    if ($to == $MATCH->{'to'}) {
                        $last_match_null = $last_match_null + 1
                    }
                    else {
                        $last_match_null = 0
                    }
                    $m = $MATCH;
                    $to = $MATCH->{'to'}
                }
                $MATCH = $m;
                $MATCH->{'to'} = $to;
                1
            }) && (do {
                my $m2 = to_eol($str, $MATCH->{'to'});
                if ($m2) {
                    $MATCH->{'to'} = $m2->{'to'};
                    1
                }
                else {
                    0
                }
            }) && (do {
                $MATCH->{'str'} = $str;
                $Perlito5::LINE_NUMBER = 0 + Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::Number::digits'});
                1
            }))
        }) || (do {
            $MATCH->{'to'} = $pos1;
            1
        })
    })));
    $tmp ? $MATCH : 0
}
sub Perlito5::Grammar::Space::ws {
    my $str = shift;
    my $pos = shift;
    my $p = $pos;
    while (exists($space{substr($str, $p, 1)})) {
        $p = $space{substr($str, $p, 1)}->($str, $p + 1)
    }
    (substr($str, $p, 7) eq '__END__' || substr($str, $p, 8) eq '__DATA__') && return term_end($str, $p);
    if ($p == $pos) {
        return 0
    }
    return {'str' => $str, 'from' => $pos, 'to' => $p}
}
sub Perlito5::Grammar::Space::opt_ws {
    my $str = shift;
    my $pos = shift;
    my $p = $pos;
    while (exists($space{substr($str, $p, 1)})) {
        $p = $space{substr($str, $p, 1)}->($str, $p + 1)
    }
    (substr($str, $p, 7) eq '__END__' || substr($str, $p, 8) eq '__DATA__') && return term_end($str, $p);
    return {'str' => $str, 'from' => $pos, 'to' => $p}
}
1;
package main;
package Perlito5::Grammar::Print;
# use strict
our %Print = ('print' => 1, 'printf' => 1, 'say' => 1, 'exec' => 1, 'system' => 1);
sub Perlito5::Grammar::Print::print_decl {
    my $str = $_[0];
    my $pos = $_[1];
    my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
    my $tmp = ((do {
        my $pos1 = $MATCH->{'to'};
        (do {
            ('printf' eq substr($str, $MATCH->{'to'}, 6) && ($MATCH->{'to'} = 6 + $MATCH->{'to'}))
        }) || (do {
            $MATCH->{'to'} = $pos1;
            ('print' eq substr($str, $MATCH->{'to'}, 5) && ($MATCH->{'to'} = 5 + $MATCH->{'to'}))
        }) || (do {
            $MATCH->{'to'} = $pos1;
            ('say' eq substr($str, $MATCH->{'to'}, 3) && ($MATCH->{'to'} = 3 + $MATCH->{'to'}))
        }) || (do {
            $MATCH->{'to'} = $pos1;
            ('exec' eq substr($str, $MATCH->{'to'}, 4) && ($MATCH->{'to'} = 4 + $MATCH->{'to'}))
        }) || (do {
            $MATCH->{'to'} = $pos1;
            ('system' eq substr($str, $MATCH->{'to'}, 6) && ($MATCH->{'to'} = 6 + $MATCH->{'to'}))
        })
    }));
    $tmp ? $MATCH : 0
}
sub Perlito5::Grammar::Print::the_object {
    my $str = $_[0];
    my $pos = $_[1];
    my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
    my $tmp = (((do {
        my $pos1 = $MATCH->{'to'};
        (do {
            ((do {
                my $tmp = $MATCH;
                $MATCH = {'str' => $str, 'from' => $tmp->{'to'}, 'to' => $tmp->{'to'}};
                my $res = ('$' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}));
                $MATCH = $tmp;
                $res ? 1 : 0
            }) && (do {
                my $m2 = Perlito5::Grammar::Sigil::term_sigil($str, $MATCH->{'to'});
                if ($m2) {
                    $MATCH->{'to'} = $m2->{'to'};
                    $MATCH->{'Perlito5::Grammar::Sigil::term_sigil'} = $m2;
                    1
                }
                else {
                    0
                }
            }) && (do {
                my $tmp = $MATCH;
                $MATCH = {'str' => $str, 'from' => $tmp->{'to'}, 'to' => $tmp->{'to'}};
                my $res = ('+' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}));
                $MATCH = $tmp;
                $res ? 0 : 1
            }) && (do {
                $MATCH->{'str'} = $str;
                $MATCH->{'capture'} = Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::Sigil::term_sigil'})->[1];
                1
            }))
        }) || (do {
            $MATCH->{'to'} = $pos1;
            ((do {
                my $tmp = $MATCH;
                $MATCH = {'str' => $str, 'from' => $tmp->{'to'}, 'to' => $tmp->{'to'}};
                my $res = ('{' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}));
                $MATCH = $tmp;
                $res ? 1 : 0
            }) && (do {
                my $m2 = Perlito5::Grammar::Expression::term_curly($str, $MATCH->{'to'});
                if ($m2) {
                    $MATCH->{'to'} = $m2->{'to'};
                    $MATCH->{'Perlito5::Grammar::Expression::term_curly'} = $m2;
                    1
                }
                else {
                    0
                }
            }) && (do {
                $MATCH->{'str'} = $str;
                $MATCH->{'capture'} = Perlito5::AST::Block::->new('stmts' => $MATCH->{'Perlito5::Grammar::Expression::term_curly'}->{'capture'}->[2]);
                1
            }))
        }) || (do {
            $MATCH->{'to'} = $pos1;
            ((do {
                my $m2 = typeglob($str, $MATCH->{'to'});
                if ($m2) {
                    $MATCH->{'to'} = $m2->{'to'};
                    $MATCH->{'typeglob'} = $m2;
                    1
                }
                else {
                    0
                }
            }) && (do {
                my $tmp = $MATCH;
                $MATCH = {'str' => $str, 'from' => $tmp->{'to'}, 'to' => $tmp->{'to'}};
                my $res = ('(' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}));
                $MATCH = $tmp;
                $res ? 0 : 1
            }) && (do {
                $MATCH->{'str'} = $str;
                $MATCH->{'capture'} = Perlito5::Match::flat($MATCH->{'typeglob'});
                1
            }))
        })
    }) && (do {
        $MATCH->{'str'} = $str;
        my $pos = $MATCH->{'to'};
        my $m = Perlito5::Grammar::Space::ws($MATCH->{'str'}, $pos);
        $m && ($pos = $m->{'to'});
        my $s = substr($MATCH->{'str'}, $pos, 1);
        my $s2 = substr($MATCH->{'str'}, $pos, 2);
        if ($s eq ',' || $s eq '?' || $s2 eq '->' || $s eq '[' || $s eq '{') {
            return 
        }
        if ($s eq '+') {
            my $m = Perlito5::Grammar::Space::ws($MATCH->{'str'}, $pos + 1);
            if ($m) {
                return 
            }
        }
        else {
            my $m = Perlito5::Grammar::Precedence::op_parse($MATCH->{'str'}, $pos, 1);
            my $next_op = $m ? Perlito5::Match::flat($m)->[1] : '';
            my $is_infix = Perlito5::Grammar::Precedence::is_fixity_type('infix', $next_op);
            $is_infix && return 
        }
        1
    })));
    $tmp ? $MATCH : 0
}
sub Perlito5::Grammar::Print::typeglob {
    my $str = $_[0];
    my $pos = $_[1];
    my $p = $pos;
    my $m_namespace = Perlito5::Grammar::optional_namespace_before_ident($str, $p);
    my $namespace = Perlito5::Match::flat($m_namespace);
    $p = $m_namespace->{'to'};
    my $m_name = Perlito5::Grammar::ident($str, $p);
    if (!$m_name) {
        if ($namespace) {
            $m_namespace->{'capture'} = Perlito5::AST::Var::->new('sigil' => '::', 'name' => '', 'namespace' => $namespace);
            return $m_namespace
        }
        return 
    }
    my $name = Perlito5::Match::flat($m_name);
    $p = $m_name->{'to'};
    if (substr($str, $p, 2) eq '::') {
        $m_name->{'to'} = $p + 2;
        $m_name->{'capture'} = Perlito5::AST::Var::->new('sigil' => '::', 'name' => '', 'namespace' => $namespace . '::' . $name);
        return $m_name
    }
    my $effective_name = ($namespace || $Perlito5::PKG_NAME) . '::' . $name;
    if (exists($Perlito5::PROTO->{$effective_name}) || exists(&{$effective_name})) {
        return 
    }
    if ((!$namespace || $namespace eq 'CORE') && exists($Perlito5::CORE_PROTO->{'CORE::' . $name})) {
        return 
    }
    my $full_name = $name;
    $namespace && ($full_name = $namespace . '::' . $name);
    $m_name->{'capture'} = Perlito5::AST::Var::->new('sigil' => '::', 'name' => '', 'namespace' => $full_name);
    return $m_name
}
sub Perlito5::Grammar::Print::print_ast {
    my($decl, $the_object, $expr) = @_;
    Perlito5::AST::Apply::->new('namespace' => '', 'code' => $decl, 'special_arg' => $the_object, 'arguments' => $expr)
}
sub Perlito5::Grammar::Print::term_print {
    my $str = $_[0];
    my $pos = $_[1];
    my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
    my $tmp = (((do {
        my $m2 = print_decl($str, $MATCH->{'to'});
        if ($m2) {
            $MATCH->{'to'} = $m2->{'to'};
            $MATCH->{'print_decl'} = $m2;
            1
        }
        else {
            0
        }
    }) && (do {
        my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{'to'});
        if ($m2) {
            $MATCH->{'to'} = $m2->{'to'};
            1
        }
        else {
            0
        }
    }) && (do {
        my $pos1 = $MATCH->{'to'};
        (do {
            (('(' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{'to'});
                if ($m2) {
                    $MATCH->{'to'} = $m2->{'to'};
                    1
                }
                else {
                    0
                }
            }) && (do {
                $MATCH->{'str'} = $str;
                $MATCH->{'_scope'} = $#Perlito5::SCOPE_STMT;
                1
            }) && (do {
                my $pos1 = $MATCH->{'to'};
                (do {
                    ((do {
                        my $m2 = the_object($str, $MATCH->{'to'});
                        if ($m2) {
                            $MATCH->{'to'} = $m2->{'to'};
                            $MATCH->{'the_object'} = $m2;
                            1
                        }
                        else {
                            0
                        }
                    }) && (do {
                        my $m2 = Perlito5::Grammar::Expression::list_parse($str, $MATCH->{'to'});
                        if ($m2) {
                            $MATCH->{'to'} = $m2->{'to'};
                            $MATCH->{'Perlito5::Grammar::Expression::list_parse'} = $m2;
                            1
                        }
                        else {
                            0
                        }
                    }))
                }) || (do {
                    $MATCH->{'to'} = $pos1;
                    (do {
                        $MATCH->{'str'} = $str;
                        $#Perlito5::SCOPE_STMT = $MATCH->{'_scope'};
                        return ;
                        1
                    })
                })
            }) && (')' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                $MATCH->{'str'} = $str;
                my $list = Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::Expression::list_parse'});
                !ref($list) && return ;
                $MATCH->{'capture'} = ['term', print_ast(Perlito5::Match::flat($MATCH->{'print_decl'}), Perlito5::Match::flat($MATCH->{'the_object'}), Perlito5::Grammar::Expression::expand_list($list))];
                1
            }))
        }) || (do {
            $MATCH->{'to'} = $pos1;
            ((do {
                $MATCH->{'str'} = $str;
                $MATCH->{'_scope'} = $#Perlito5::SCOPE_STMT;
                1
            }) && (do {
                my $pos1 = $MATCH->{'to'};
                (do {
                    ((do {
                        my $m2 = the_object($str, $MATCH->{'to'});
                        if ($m2) {
                            $MATCH->{'to'} = $m2->{'to'};
                            $MATCH->{'the_object'} = $m2;
                            1
                        }
                        else {
                            0
                        }
                    }) && (do {
                        my $m2 = Perlito5::Grammar::Expression::list_parse($str, $MATCH->{'to'});
                        if ($m2) {
                            $MATCH->{'to'} = $m2->{'to'};
                            $MATCH->{'Perlito5::Grammar::Expression::list_parse'} = $m2;
                            1
                        }
                        else {
                            0
                        }
                    }))
                }) || (do {
                    $MATCH->{'to'} = $pos1;
                    (do {
                        $MATCH->{'str'} = $str;
                        $#Perlito5::SCOPE_STMT = $MATCH->{'_scope'};
                        return ;
                        1
                    })
                })
            }) && (do {
                $MATCH->{'str'} = $str;
                my $list = Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::Expression::list_parse'});
                !ref($list) && return ;
                $MATCH->{'capture'} = ['term', print_ast(Perlito5::Match::flat($MATCH->{'print_decl'}), Perlito5::Match::flat($MATCH->{'the_object'}), Perlito5::Grammar::Expression::expand_list($list))];
                1
            }))
        })
    })));
    $tmp ? $MATCH : 0
}
Perlito5::Grammar::Precedence::add_term('print' => \&term_print);
Perlito5::Grammar::Precedence::add_term('printf' => \&term_print);
Perlito5::Grammar::Precedence::add_term('say' => \&term_print);
Perlito5::Grammar::Precedence::add_term('exec' => \&term_print);
Perlito5::Grammar::Precedence::add_term('system' => \&term_print);
1;
package main;
package Perlito5::Grammar::Map;
# use strict
sub Perlito5::Grammar::Map::map_or_grep {
    my $str = $_[0];
    my $pos = $_[1];
    my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
    my $tmp = ((do {
        my $pos1 = $MATCH->{'to'};
        (do {
            ('map' eq substr($str, $MATCH->{'to'}, 3) && ($MATCH->{'to'} = 3 + $MATCH->{'to'}))
        }) || (do {
            $MATCH->{'to'} = $pos1;
            ('grep' eq substr($str, $MATCH->{'to'}, 4) && ($MATCH->{'to'} = 4 + $MATCH->{'to'}))
        })
    }));
    $tmp ? $MATCH : 0
}
sub Perlito5::Grammar::Map::term_map_or_grep {
    my $str = $_[0];
    my $pos = $_[1];
    my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
    my $tmp = (((do {
        my $m2 = map_or_grep($str, $MATCH->{'to'});
        if ($m2) {
            $MATCH->{'to'} = $m2->{'to'};
            $MATCH->{'map_or_grep'} = $m2;
            1
        }
        else {
            0
        }
    }) && (do {
        my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{'to'});
        if ($m2) {
            $MATCH->{'to'} = $m2->{'to'};
            1
        }
        else {
            0
        }
    }) && (do {
        my $pos1 = $MATCH->{'to'};
        (do {
            ((do {
                my $m2 = Perlito5::Grammar::block($str, $MATCH->{'to'});
                if ($m2) {
                    $MATCH->{'to'} = $m2->{'to'};
                    $MATCH->{'Perlito5::Grammar::block'} = $m2;
                    1
                }
                else {
                    0
                }
            }) && (do {
                my $m2 = Perlito5::Grammar::Expression::list_parse($str, $MATCH->{'to'});
                if ($m2) {
                    $MATCH->{'to'} = $m2->{'to'};
                    $MATCH->{'Perlito5::Grammar::Expression::list_parse'} = $m2;
                    1
                }
                else {
                    0
                }
            }) && (do {
                $MATCH->{'str'} = $str;
                $MATCH->{'capture'} = ['term', Perlito5::AST::Apply::->new('code' => Perlito5::Match::flat($MATCH->{'map_or_grep'}), 'special_arg' => $MATCH->{'Perlito5::Grammar::block'}->{'capture'}, 'arguments' => Perlito5::Grammar::Expression::expand_list($MATCH->{'Perlito5::Grammar::Expression::list_parse'}->{'capture'}), 'namespace' => '')];
                1
            }))
        }) || (do {
            $MATCH->{'to'} = $pos1;
            (('(' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{'to'});
                if ($m2) {
                    $MATCH->{'to'} = $m2->{'to'};
                    1
                }
                else {
                    0
                }
            }) && (do {
                my $m2 = Perlito5::Grammar::block($str, $MATCH->{'to'});
                if ($m2) {
                    $MATCH->{'to'} = $m2->{'to'};
                    $MATCH->{'Perlito5::Grammar::block'} = $m2;
                    1
                }
                else {
                    0
                }
            }) && (do {
                my $m2 = Perlito5::Grammar::Expression::list_parse($str, $MATCH->{'to'});
                if ($m2) {
                    $MATCH->{'to'} = $m2->{'to'};
                    $MATCH->{'Perlito5::Grammar::Expression::list_parse'} = $m2;
                    1
                }
                else {
                    0
                }
            }) && (')' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                $MATCH->{'str'} = $str;
                $MATCH->{'capture'} = ['term', Perlito5::AST::Apply::->new('code' => Perlito5::Match::flat($MATCH->{'map_or_grep'}), 'special_arg' => $MATCH->{'Perlito5::Grammar::block'}->{'capture'}, 'arguments' => Perlito5::Grammar::Expression::expand_list($MATCH->{'Perlito5::Grammar::Expression::list_parse'}->{'capture'}), 'namespace' => '')];
                1
            }))
        })
    })));
    $tmp ? $MATCH : 0
}
sub Perlito5::Grammar::Map::term_sort {
    my $str = $_[0];
    my $pos = $_[1];
    my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
    my $tmp = ((('sort' eq substr($str, $MATCH->{'to'}, 4) && ($MATCH->{'to'} = 4 + $MATCH->{'to'})) && (do {
        my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{'to'});
        if ($m2) {
            $MATCH->{'to'} = $m2->{'to'};
            1
        }
        else {
            0
        }
    }) && (do {
        my $pos1 = $MATCH->{'to'};
        (do {
            ((do {
                my $pos1 = $MATCH->{'to'};
                (do {
                    ((do {
                        my $m2 = Perlito5::Grammar::block($str, $MATCH->{'to'});
                        if ($m2) {
                            $MATCH->{'to'} = $m2->{'to'};
                            $MATCH->{'Perlito5::Grammar::block'} = $m2;
                            1
                        }
                        else {
                            0
                        }
                    }) && (do {
                        $MATCH->{'str'} = $str;
                        $MATCH->{'_tmp'} = $MATCH->{'Perlito5::Grammar::block'}->{'capture'};
                        1
                    }))
                }) || (do {
                    $MATCH->{'to'} = $pos1;
                    ((do {
                        my $m2 = Perlito5::Grammar::full_ident($str, $MATCH->{'to'});
                        if ($m2) {
                            $MATCH->{'to'} = $m2->{'to'};
                            $MATCH->{'Perlito5::Grammar::full_ident'} = $m2;
                            1
                        }
                        else {
                            0
                        }
                    }) && (do {
                        $MATCH->{'str'} = $str;
                        my $name = Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::full_ident'});
                        ($Perlito5::CORE_PROTO->{$name} || $Perlito5::CORE_PROTO->{'CORE::' . $name}) && return ;
                        $MATCH->{'_tmp'} = $name;
                        1
                    }))
                }) || (do {
                    $MATCH->{'to'} = $pos1;
                    ((do {
                        my $tmp = $MATCH;
                        $MATCH = {'str' => $str, 'from' => $tmp->{'to'}, 'to' => $tmp->{'to'}};
                        my $res = ('$' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}));
                        $MATCH = $tmp;
                        $res ? 1 : 0
                    }) && (do {
                        my $m2 = Perlito5::Grammar::Sigil::term_sigil($str, $MATCH->{'to'});
                        if ($m2) {
                            $MATCH->{'to'} = $m2->{'to'};
                            $MATCH->{'Perlito5::Grammar::Sigil::term_sigil'} = $m2;
                            1
                        }
                        else {
                            0
                        }
                    }) && (do {
                        $MATCH->{'str'} = $str;
                        my $var = Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::Sigil::term_sigil'})->[1];
                        ref($var) ne 'Perlito5::AST::Var' && return ;
                        $MATCH->{'_tmp'} = $var;
                        1
                    }))
                })
            }) && (do {
                my $m2 = Perlito5::Grammar::Expression::list_parse($str, $MATCH->{'to'});
                if ($m2) {
                    $MATCH->{'to'} = $m2->{'to'};
                    $MATCH->{'Perlito5::Grammar::Expression::list_parse'} = $m2;
                    1
                }
                else {
                    0
                }
            }) && (do {
                $MATCH->{'str'} = $str;
                $MATCH->{'capture'} = ['term', Perlito5::AST::Apply::->new('code' => 'sort', 'special_arg' => $MATCH->{'_tmp'}, 'arguments' => Perlito5::Grammar::Expression::expand_list($MATCH->{'Perlito5::Grammar::Expression::list_parse'}->{'capture'}), 'namespace' => '')];
                1
            }))
        }) || (do {
            $MATCH->{'to'} = $pos1;
            (('(' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{'to'});
                if ($m2) {
                    $MATCH->{'to'} = $m2->{'to'};
                    1
                }
                else {
                    0
                }
            }) && (do {
                my $pos1 = $MATCH->{'to'};
                (do {
                    ((do {
                        my $m2 = Perlito5::Grammar::full_ident($str, $MATCH->{'to'});
                        if ($m2) {
                            $MATCH->{'to'} = $m2->{'to'};
                            $MATCH->{'Perlito5::Grammar::full_ident'} = $m2;
                            1
                        }
                        else {
                            0
                        }
                    }) && (do {
                        my $m2 = Perlito5::Grammar::Space::ws($str, $MATCH->{'to'});
                        if ($m2) {
                            $MATCH->{'to'} = $m2->{'to'};
                            1
                        }
                        else {
                            0
                        }
                    }) && (do {
                        $MATCH->{'str'} = $str;
                        my $name = Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::full_ident'});
                        ($Perlito5::CORE_PROTO->{$name} || $Perlito5::CORE_PROTO->{'CORE::' . $name}) && return ;
                        $MATCH->{'_tmp'} = $name;
                        1
                    }))
                }) || (do {
                    $MATCH->{'to'} = $pos1;
                    ((do {
                        my $m2 = Perlito5::Grammar::block($str, $MATCH->{'to'});
                        if ($m2) {
                            $MATCH->{'to'} = $m2->{'to'};
                            $MATCH->{'Perlito5::Grammar::block'} = $m2;
                            1
                        }
                        else {
                            0
                        }
                    }) && (do {
                        $MATCH->{'str'} = $str;
                        $MATCH->{'_tmp'} = $MATCH->{'Perlito5::Grammar::block'}->{'capture'};
                        1
                    }))
                }) || (do {
                    $MATCH->{'to'} = $pos1;
                    ((do {
                        my $tmp = $MATCH;
                        $MATCH = {'str' => $str, 'from' => $tmp->{'to'}, 'to' => $tmp->{'to'}};
                        my $res = ('$' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}));
                        $MATCH = $tmp;
                        $res ? 1 : 0
                    }) && (do {
                        my $m2 = Perlito5::Grammar::Sigil::term_sigil($str, $MATCH->{'to'});
                        if ($m2) {
                            $MATCH->{'to'} = $m2->{'to'};
                            $MATCH->{'Perlito5::Grammar::Sigil::term_sigil'} = $m2;
                            1
                        }
                        else {
                            0
                        }
                    }) && (do {
                        $MATCH->{'str'} = $str;
                        my $var = Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::Sigil::term_sigil'})->[1];
                        ref($var) ne 'Perlito5::AST::Var' && return ;
                        $MATCH->{'_tmp'} = $var;
                        1
                    }))
                })
            }) && (do {
                my $m2 = Perlito5::Grammar::Expression::list_parse($str, $MATCH->{'to'});
                if ($m2) {
                    $MATCH->{'to'} = $m2->{'to'};
                    $MATCH->{'Perlito5::Grammar::Expression::list_parse'} = $m2;
                    1
                }
                else {
                    0
                }
            }) && (')' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                $MATCH->{'str'} = $str;
                $MATCH->{'capture'} = ['term', Perlito5::AST::Apply::->new('code' => 'sort', 'special_arg' => $MATCH->{'_tmp'}, 'arguments' => Perlito5::Grammar::Expression::expand_list($MATCH->{'Perlito5::Grammar::Expression::list_parse'}->{'capture'}), 'namespace' => '')];
                1
            }))
        })
    })));
    $tmp ? $MATCH : 0
}
Perlito5::Grammar::Precedence::add_term('map' => \&term_map_or_grep);
Perlito5::Grammar::Precedence::add_term('grep' => \&term_map_or_grep);
Perlito5::Grammar::Precedence::add_term('sort' => \&term_sort);
1;
package main;
package Perlito5::Grammar::Number;
# use strict
# use Perlito5::Grammar::Precedence
sub Perlito5::Grammar::Number::term_digit {
    my $str = $_[0];
    my $pos = $_[1];
    my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
    my $tmp = ((do {
        my $pos1 = $MATCH->{'to'};
        (do {
            ((do {
                my $m2 = Perlito5::Grammar::Number::val_octal($str, $MATCH->{'to'});
                if ($m2) {
                    $MATCH->{'to'} = $m2->{'to'};
                    $MATCH->{'Perlito5::Grammar::Number::val_octal'} = $m2;
                    1
                }
                else {
                    0
                }
            }) && (do {
                $MATCH->{'str'} = $str;
                $MATCH->{'capture'} = ['term', Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::Number::val_octal'})];
                1
            }))
        }) || (do {
            $MATCH->{'to'} = $pos1;
            ((do {
                my $m2 = Perlito5::Grammar::Number::val_vstring($str, $MATCH->{'to'});
                if ($m2) {
                    $MATCH->{'to'} = $m2->{'to'};
                    $MATCH->{'Perlito5::Grammar::Number::val_vstring'} = $m2;
                    1
                }
                else {
                    0
                }
            }) && (do {
                $MATCH->{'str'} = $str;
                $MATCH->{'capture'} = ['term', Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::Number::val_vstring'})];
                1
            }))
        }) || (do {
            $MATCH->{'to'} = $pos1;
            ((do {
                my $m2 = Perlito5::Grammar::Number::val_num($str, $MATCH->{'to'});
                if ($m2) {
                    $MATCH->{'to'} = $m2->{'to'};
                    $MATCH->{'Perlito5::Grammar::Number::val_num'} = $m2;
                    1
                }
                else {
                    0
                }
            }) && (do {
                $MATCH->{'str'} = $str;
                $MATCH->{'capture'} = ['term', Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::Number::val_num'})];
                1
            }))
        }) || (do {
            $MATCH->{'to'} = $pos1;
            ((do {
                my $m2 = Perlito5::Grammar::Number::val_int($str, $MATCH->{'to'});
                if ($m2) {
                    $MATCH->{'to'} = $m2->{'to'};
                    $MATCH->{'Perlito5::Grammar::Number::val_int'} = $m2;
                    1
                }
                else {
                    0
                }
            }) && (do {
                $MATCH->{'str'} = $str;
                $MATCH->{'capture'} = ['term', Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::Number::val_int'})];
                1
            }))
        })
    }));
    $tmp ? $MATCH : 0
}
Perlito5::Grammar::Precedence::add_term($_ => \&term_digit)
    for '.', 0 .. 9;
sub Perlito5::Grammar::Number::digit {
    substr($_[0], $_[1], 1) =~ m!\d! ? {'str' => $_[0], 'from' => $_[1], 'to' => $_[1] + 1} : 0
}
sub Perlito5::Grammar::Number::exponent {
    my $str = $_[0];
    my $pos = $_[1];
    my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
    my $tmp = (((do {
        my $pos1 = $MATCH->{'to'};
        (do {
            ('e' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}))
        }) || (do {
            $MATCH->{'to'} = $pos1;
            ('E' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}))
        })
    }) && (do {
        my $pos1 = $MATCH->{'to'};
        (do {
            ('+' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}))
        }) || (do {
            $MATCH->{'to'} = $pos1;
            ('-' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}))
        }) || (do {
            $MATCH->{'to'} = $pos1;
            1
        })
    }) && (do {
        my $last_match_null = 0;
        my $m = $MATCH;
        my $to = $MATCH->{'to'};
        my $count = 0;
        while ((do {
            my $pos1 = $MATCH->{'to'};
            (do {
                ('_' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}))
            }) || (do {
                $MATCH->{'to'} = $pos1;
                (do {
                    my $m2 = digit($str, $MATCH->{'to'});
                    if ($m2) {
                        $MATCH->{'to'} = $m2->{'to'};
                        1
                    }
                    else {
                        0
                    }
                })
            })
        }) && ($last_match_null < 2)) {
            if ($to == $MATCH->{'to'}) {
                $last_match_null = $last_match_null + 1
            }
            else {
                $last_match_null = 0
            }
            $m = $MATCH;
            $to = $MATCH->{'to'};
            $count = $count + 1
        }
        $MATCH = $m;
        $MATCH->{'to'} = $to;
        $count > 0
    })));
    $tmp ? $MATCH : 0
}
sub Perlito5::Grammar::Number::val_num {
    my $str = $_[0];
    my $pos = $_[1];
    my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
    my $tmp = (((do {
        my $pos1 = $MATCH->{'to'};
        (do {
            (('.' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                my $m2 = digit($str, $MATCH->{'to'});
                if ($m2) {
                    $MATCH->{'to'} = $m2->{'to'};
                    1
                }
                else {
                    0
                }
            }) && (do {
                my $last_match_null = 0;
                my $m = $MATCH;
                my $to = $MATCH->{'to'};
                while ((do {
                    my $pos1 = $MATCH->{'to'};
                    (do {
                        ('_' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}))
                    }) || (do {
                        $MATCH->{'to'} = $pos1;
                        (do {
                            my $m2 = digit($str, $MATCH->{'to'});
                            if ($m2) {
                                $MATCH->{'to'} = $m2->{'to'};
                                1
                            }
                            else {
                                0
                            }
                        })
                    })
                }) && ($last_match_null < 2)) {
                    if ($to == $MATCH->{'to'}) {
                        $last_match_null = $last_match_null + 1
                    }
                    else {
                        $last_match_null = 0
                    }
                    $m = $MATCH;
                    $to = $MATCH->{'to'}
                }
                $MATCH = $m;
                $MATCH->{'to'} = $to;
                1
            }) && (do {
                my $m = $MATCH;
                if (!(do {
                    my $m2 = exponent($str, $MATCH->{'to'});
                    if ($m2) {
                        $MATCH->{'to'} = $m2->{'to'};
                        1
                    }
                    else {
                        0
                    }
                })) {
                    $MATCH = $m
                }
                1
            }))
        }) || (do {
            $MATCH->{'to'} = $pos1;
            ((do {
                my $m2 = digit($str, $MATCH->{'to'});
                if ($m2) {
                    $MATCH->{'to'} = $m2->{'to'};
                    1
                }
                else {
                    0
                }
            }) && (do {
                my $last_match_null = 0;
                my $m = $MATCH;
                my $to = $MATCH->{'to'};
                while ((do {
                    my $pos1 = $MATCH->{'to'};
                    (do {
                        ('_' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}))
                    }) || (do {
                        $MATCH->{'to'} = $pos1;
                        (do {
                            my $m2 = digit($str, $MATCH->{'to'});
                            if ($m2) {
                                $MATCH->{'to'} = $m2->{'to'};
                                1
                            }
                            else {
                                0
                            }
                        })
                    })
                }) && ($last_match_null < 2)) {
                    if ($to == $MATCH->{'to'}) {
                        $last_match_null = $last_match_null + 1
                    }
                    else {
                        $last_match_null = 0
                    }
                    $m = $MATCH;
                    $to = $MATCH->{'to'}
                }
                $MATCH = $m;
                $MATCH->{'to'} = $to;
                1
            }) && (do {
                my $pos1 = $MATCH->{'to'};
                (do {
                    (do {
                        my $m2 = exponent($str, $MATCH->{'to'});
                        if ($m2) {
                            $MATCH->{'to'} = $m2->{'to'};
                            1
                        }
                        else {
                            0
                        }
                    })
                }) || (do {
                    $MATCH->{'to'} = $pos1;
                    (('.' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                        my $tmp = $MATCH;
                        $MATCH = {'str' => $str, 'from' => $tmp->{'to'}, 'to' => $tmp->{'to'}};
                        my $res = ('.' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}));
                        $MATCH = $tmp;
                        $res ? 0 : 1
                    }) && (do {
                        my $last_match_null = 0;
                        my $m = $MATCH;
                        my $to = $MATCH->{'to'};
                        while ((do {
                            my $pos1 = $MATCH->{'to'};
                            (do {
                                ('_' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}))
                            }) || (do {
                                $MATCH->{'to'} = $pos1;
                                (do {
                                    my $m2 = digit($str, $MATCH->{'to'});
                                    if ($m2) {
                                        $MATCH->{'to'} = $m2->{'to'};
                                        1
                                    }
                                    else {
                                        0
                                    }
                                })
                            })
                        }) && ($last_match_null < 2)) {
                            if ($to == $MATCH->{'to'}) {
                                $last_match_null = $last_match_null + 1
                            }
                            else {
                                $last_match_null = 0
                            }
                            $m = $MATCH;
                            $to = $MATCH->{'to'}
                        }
                        $MATCH = $m;
                        $MATCH->{'to'} = $to;
                        1
                    }) && (do {
                        my $m = $MATCH;
                        if (!(do {
                            my $m2 = exponent($str, $MATCH->{'to'});
                            if ($m2) {
                                $MATCH->{'to'} = $m2->{'to'};
                                1
                            }
                            else {
                                0
                            }
                        })) {
                            $MATCH = $m
                        }
                        1
                    }))
                })
            }))
        })
    }) && (do {
        $MATCH->{'str'} = $str;
        my $s = Perlito5::Match::flat($MATCH);
        $s =~ s!_!!g;
        $MATCH->{'capture'} = Perlito5::AST::Num::->new('num' => $s);
        1
    })));
    $tmp ? $MATCH : 0
}
sub Perlito5::Grammar::Number::digits {
    my $str = $_[0];
    my $pos = $_[1];
    my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
    my $tmp = ((do {
        my $last_match_null = 0;
        my $m = $MATCH;
        my $to = $MATCH->{'to'};
        my $count = 0;
        while ((do {
            my $m2 = digit($str, $MATCH->{'to'});
            if ($m2) {
                $MATCH->{'to'} = $m2->{'to'};
                1
            }
            else {
                0
            }
        }) && ($last_match_null < 2)) {
            if ($to == $MATCH->{'to'}) {
                $last_match_null = $last_match_null + 1
            }
            else {
                $last_match_null = 0
            }
            $m = $MATCH;
            $to = $MATCH->{'to'};
            $count = $count + 1
        }
        $MATCH = $m;
        $MATCH->{'to'} = $to;
        $count > 0
    }));
    $tmp ? $MATCH : 0
}
sub Perlito5::Grammar::Number::digits_underscore {
    my $str = $_[0];
    my $pos = $_[1];
    my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
    my $tmp = (((do {
        my $m2 = digit($str, $MATCH->{'to'});
        if ($m2) {
            $MATCH->{'to'} = $m2->{'to'};
            1
        }
        else {
            0
        }
    }) && (do {
        my $last_match_null = 0;
        my $m = $MATCH;
        my $to = $MATCH->{'to'};
        while ((do {
            my $pos1 = $MATCH->{'to'};
            (do {
                ('_' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}))
            }) || (do {
                $MATCH->{'to'} = $pos1;
                (do {
                    my $m2 = digit($str, $MATCH->{'to'});
                    if ($m2) {
                        $MATCH->{'to'} = $m2->{'to'};
                        1
                    }
                    else {
                        0
                    }
                })
            })
        }) && ($last_match_null < 2)) {
            if ($to == $MATCH->{'to'}) {
                $last_match_null = $last_match_null + 1
            }
            else {
                $last_match_null = 0
            }
            $m = $MATCH;
            $to = $MATCH->{'to'}
        }
        $MATCH = $m;
        $MATCH->{'to'} = $to;
        1
    })));
    $tmp ? $MATCH : 0
}
sub Perlito5::Grammar::Number::val_octal {
    my $str = $_[0];
    my $pos = $_[1];
    my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
    my $tmp = (((0 eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
        my $pos1 = $MATCH->{'to'};
        (do {
            ((do {
                my $pos1 = $MATCH->{'to'};
                (do {
                    ('x' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}))
                }) || (do {
                    $MATCH->{'to'} = $pos1;
                    ('X' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}))
                })
            }) && (do {
                my $last_match_null = 0;
                my $m = $MATCH;
                my $to = $MATCH->{'to'};
                my $count = 0;
                while ((do {
                    my $m2 = Perlito5::Grammar::word($str, $MATCH->{'to'});
                    if ($m2) {
                        $MATCH->{'to'} = $m2->{'to'};
                        1
                    }
                    else {
                        0
                    }
                }) && ($last_match_null < 2)) {
                    if ($to == $MATCH->{'to'}) {
                        $last_match_null = $last_match_null + 1
                    }
                    else {
                        $last_match_null = 0
                    }
                    $m = $MATCH;
                    $to = $MATCH->{'to'};
                    $count = $count + 1
                }
                $MATCH = $m;
                $MATCH->{'to'} = $to;
                $count > 0
            }))
        }) || (do {
            $MATCH->{'to'} = $pos1;
            ((do {
                my $pos1 = $MATCH->{'to'};
                (do {
                    ('b' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}))
                }) || (do {
                    $MATCH->{'to'} = $pos1;
                    ('B' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}))
                })
            }) && (do {
                my $last_match_null = 0;
                my $m = $MATCH;
                my $to = $MATCH->{'to'};
                my $count = 0;
                while ((do {
                    my $pos1 = $MATCH->{'to'};
                    (do {
                        ('_' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}))
                    }) || (do {
                        $MATCH->{'to'} = $pos1;
                        (0 eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}))
                    }) || (do {
                        $MATCH->{'to'} = $pos1;
                        (1 eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}))
                    })
                }) && ($last_match_null < 2)) {
                    if ($to == $MATCH->{'to'}) {
                        $last_match_null = $last_match_null + 1
                    }
                    else {
                        $last_match_null = 0
                    }
                    $m = $MATCH;
                    $to = $MATCH->{'to'};
                    $count = $count + 1
                }
                $MATCH = $m;
                $MATCH->{'to'} = $to;
                $count > 0
            }))
        }) || (do {
            $MATCH->{'to'} = $pos1;
            (do {
                my $last_match_null = 0;
                my $m = $MATCH;
                my $to = $MATCH->{'to'};
                my $count = 0;
                while ((do {
                    my $pos1 = $MATCH->{'to'};
                    (do {
                        ('_' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}))
                    }) || (do {
                        $MATCH->{'to'} = $pos1;
                        (do {
                            my $m2 = digit($str, $MATCH->{'to'});
                            if ($m2) {
                                $MATCH->{'to'} = $m2->{'to'};
                                1
                            }
                            else {
                                0
                            }
                        })
                    })
                }) && ($last_match_null < 2)) {
                    if ($to == $MATCH->{'to'}) {
                        $last_match_null = $last_match_null + 1
                    }
                    else {
                        $last_match_null = 0
                    }
                    $m = $MATCH;
                    $to = $MATCH->{'to'};
                    $count = $count + 1
                }
                $MATCH = $m;
                $MATCH->{'to'} = $to;
                $count > 0
            })
        })
    }) && (do {
        $MATCH->{'str'} = $str;
        $MATCH->{'capture'} = Perlito5::AST::Int::->new('int' => oct(lc(Perlito5::Match::flat($MATCH))));
        1
    })));
    $tmp ? $MATCH : 0
}
sub Perlito5::Grammar::Number::val_int {
    my $str = $_[0];
    my $pos = $_[1];
    my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
    my $tmp = (((do {
        my $m2 = digits_underscore($str, $MATCH->{'to'});
        if ($m2) {
            $MATCH->{'to'} = $m2->{'to'};
            1
        }
        else {
            0
        }
    }) && (do {
        $MATCH->{'str'} = $str;
        my $s = Perlito5::Match::flat($MATCH);
        $s =~ s!_!!g;
        $MATCH->{'capture'} = Perlito5::AST::Int::->new('int' => $s);
        1
    })));
    $tmp ? $MATCH : 0
}
sub Perlito5::Grammar::Number::val_vstring {
    my $str = $_[0];
    my $pos = $_[1];
    my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
    my $tmp = (((do {
        my $m2 = val_int($str, $MATCH->{'to'});
        if ($m2) {
            $MATCH->{'to'} = $m2->{'to'};
            $MATCH->{'val_int'} = $m2;
            1
        }
        else {
            0
        }
    }) && (do {
        my $last_match_null = 0;
        my $m = $MATCH;
        my $to = $MATCH->{'to'};
        my $count = 0;
        while ((('.' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
            my $m2 = digits_underscore($str, $MATCH->{'to'});
            if ($m2) {
                $MATCH->{'to'} = $m2->{'to'};
                if (exists($MATCH->{'digits_underscore'})) {
                    push(@{$MATCH->{'digits_underscore'}}, $m2)
                }
                else {
                    $MATCH->{'digits_underscore'} = [$m2]
                }
                1
            }
            else {
                0
            }
        })) && ($last_match_null < 2)) {
            if ($to == $MATCH->{'to'}) {
                $last_match_null = $last_match_null + 1
            }
            else {
                $last_match_null = 0
            }
            $m = $MATCH;
            $to = $MATCH->{'to'};
            $count = $count + 1
        }
        $MATCH = $m;
        $MATCH->{'to'} = $to;
        $count > 0
    }) && (do {
        $MATCH->{'str'} = $str;
        my @parts = map {
            Perlito5::Match::flat($_)
        } @{$MATCH->{'digits_underscore'}};
        @parts < 2 && return ;
        $MATCH->{'capture'} = Perlito5::AST::Buf::->new('buf' => join('', map {
            chr($_)
        } $MATCH->{'val_int'}->{'capture'}->{'int'}, @parts));
        1
    })));
    $tmp ? $MATCH : 0
}
sub Perlito5::Grammar::Number::val_version {
    my $str = $_[0];
    my $pos = $_[1];
    my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
    my $tmp = ((('v' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
        my $m2 = val_int($str, $MATCH->{'to'});
        if ($m2) {
            $MATCH->{'to'} = $m2->{'to'};
            $MATCH->{'val_int'} = $m2;
            1
        }
        else {
            0
        }
    }) && (do {
        my $last_match_null = 0;
        my $m = $MATCH;
        my $to = $MATCH->{'to'};
        while ((('.' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
            my $m2 = digits_underscore($str, $MATCH->{'to'});
            if ($m2) {
                $MATCH->{'to'} = $m2->{'to'};
                if (exists($MATCH->{'digits_underscore'})) {
                    push(@{$MATCH->{'digits_underscore'}}, $m2)
                }
                else {
                    $MATCH->{'digits_underscore'} = [$m2]
                }
                1
            }
            else {
                0
            }
        })) && ($last_match_null < 2)) {
            if ($to == $MATCH->{'to'}) {
                $last_match_null = $last_match_null + 1
            }
            else {
                $last_match_null = 0
            }
            $m = $MATCH;
            $to = $MATCH->{'to'}
        }
        $MATCH = $m;
        $MATCH->{'to'} = $to;
        1
    }) && (do {
        $MATCH->{'str'} = $str;
        my @parts = map {
            Perlito5::Match::flat($_)
        } @{$MATCH->{'digits_underscore'}};
        $MATCH->{'capture'} = Perlito5::AST::Buf::->new('buf' => join('', map {
            chr($_)
        } $MATCH->{'val_int'}->{'capture'}->{'int'}, @parts));
        1
    })));
    $tmp ? $MATCH : 0
}
1;
package main;
package Perlito5::Grammar;
# use Perlito5::Grammar::Expression
# use Perlito5::Grammar::Statement
# use Perlito5::Grammar::Control
# use Perlito5::Grammar::String
# use Perlito5::Grammar::Sigil
# use Perlito5::Grammar::Use
# use Perlito5::Grammar::Block
# use Perlito5::Grammar::Space
# use Perlito5::Grammar::Print
# use Perlito5::Grammar::Map
# use Perlito5::Grammar::Attribute
# use Perlito5::Grammar::Number
sub Perlito5::Grammar::word {
    substr($_[0], $_[1], 1) =~ m!\w! ? {'str' => $_[0], 'from' => $_[1], 'to' => $_[1] + 1} : 0
}
sub Perlito5::Grammar::ident {
    (substr($_[0], $_[1], 1) !~ m!\w! || substr($_[0], $_[1], 1) =~ m!\d!) && return ;
    my $m = {'str' => $_[0], 'from' => $_[1], 'to' => $_[1] + 1};
    $m->{'to'}++
        while substr($_[0], $m->{'to'}, 1) =~ m!\w!;
    $m
}
sub Perlito5::Grammar::caret_char {
    my $c = substr($_[0], $_[1], 1);
    my $pos = $_[1];
    if ($c eq '^') {
        $pos++;
        $c = substr($_[0], $pos, 1);
        ($c lt 'A' || $c gt 'Z') && return 0;
        $c = chr(ord($c) - ord('A') + 1)
    }
    elsif (Perlito5::Grammar::Space::ws($_[0], $pos)) {
        return 0
    }
    ($c lt chr(1) || $c gt chr(26)) && return 0;
    return {'str' => $_[0], 'from' => $_[1], 'to' => $pos + 1, 'capture' => $c}
}
sub Perlito5::Grammar::full_ident {
    my $str = $_[0];
    my $pos = $_[1];
    my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
    my $tmp = (((do {
        my $m2 = ident($str, $MATCH->{'to'});
        if ($m2) {
            $MATCH->{'to'} = $m2->{'to'};
            1
        }
        else {
            0
        }
    }) && (do {
        my $last_match_null = 0;
        my $m = $MATCH;
        my $to = $MATCH->{'to'};
        while ((('::' eq substr($str, $MATCH->{'to'}, 2) && ($MATCH->{'to'} = 2 + $MATCH->{'to'})) && (do {
            my $m2 = ident($str, $MATCH->{'to'});
            if ($m2) {
                $MATCH->{'to'} = $m2->{'to'};
                1
            }
            else {
                0
            }
        })) && ($last_match_null < 2)) {
            if ($to == $MATCH->{'to'}) {
                $last_match_null = $last_match_null + 1
            }
            else {
                $last_match_null = 0
            }
            $m = $MATCH;
            $to = $MATCH->{'to'}
        }
        $MATCH = $m;
        $MATCH->{'to'} = $to;
        1
    })));
    $tmp ? $MATCH : 0
}
sub Perlito5::Grammar::namespace_before_ident {
    my $str = $_[0];
    my $pos = $_[1];
    my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
    my $tmp = (((do {
        my $m2 = ident($str, $MATCH->{'to'});
        if ($m2) {
            $MATCH->{'to'} = $m2->{'to'};
            1
        }
        else {
            0
        }
    }) && (do {
        my $tmp = $MATCH;
        $MATCH = {'str' => $str, 'from' => $tmp->{'to'}, 'to' => $tmp->{'to'}};
        my $res = ('::' eq substr($str, $MATCH->{'to'}, 2) && ($MATCH->{'to'} = 2 + $MATCH->{'to'}));
        $MATCH = $tmp;
        $res ? 1 : 0
    }) && (do {
        my $last_match_null = 0;
        my $m = $MATCH;
        my $to = $MATCH->{'to'};
        while ((('::' eq substr($str, $MATCH->{'to'}, 2) && ($MATCH->{'to'} = 2 + $MATCH->{'to'})) && (do {
            my $m2 = ident($str, $MATCH->{'to'});
            if ($m2) {
                $MATCH->{'to'} = $m2->{'to'};
                1
            }
            else {
                0
            }
        }) && (do {
            my $tmp = $MATCH;
            $MATCH = {'str' => $str, 'from' => $tmp->{'to'}, 'to' => $tmp->{'to'}};
            my $res = ('::' eq substr($str, $MATCH->{'to'}, 2) && ($MATCH->{'to'} = 2 + $MATCH->{'to'}));
            $MATCH = $tmp;
            $res ? 1 : 0
        })) && ($last_match_null < 2)) {
            if ($to == $MATCH->{'to'}) {
                $last_match_null = $last_match_null + 1
            }
            else {
                $last_match_null = 0
            }
            $m = $MATCH;
            $to = $MATCH->{'to'}
        }
        $MATCH = $m;
        $MATCH->{'to'} = $to;
        1
    })));
    $tmp ? $MATCH : 0
}
sub Perlito5::Grammar::optional_namespace_before_ident {
    my $str = $_[0];
    my $pos = $_[1];
    my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
    my $tmp = ((do {
        my $pos1 = $MATCH->{'to'};
        (do {
            ((do {
                my $m2 = namespace_before_ident($str, $MATCH->{'to'});
                if ($m2) {
                    $MATCH->{'to'} = $m2->{'to'};
                    $MATCH->{'namespace_before_ident'} = $m2;
                    1
                }
                else {
                    0
                }
            }) && (do {
                my $last_match_null = 0;
                my $m = $MATCH;
                my $to = $MATCH->{'to'};
                while (('::' eq substr($str, $MATCH->{'to'}, 2) && ($MATCH->{'to'} = 2 + $MATCH->{'to'})) && ($last_match_null < 2)) {
                    if ($to == $MATCH->{'to'}) {
                        $last_match_null = $last_match_null + 1
                    }
                    else {
                        $last_match_null = 0
                    }
                    $m = $MATCH;
                    $to = $MATCH->{'to'}
                }
                $MATCH = $m;
                $MATCH->{'to'} = $to;
                1
            }) && (do {
                $MATCH->{'str'} = $str;
                $MATCH->{'capture'} = Perlito5::Match::flat($MATCH->{'namespace_before_ident'});
                1
            }))
        }) || (do {
            $MATCH->{'to'} = $pos1;
            (('::' eq substr($str, $MATCH->{'to'}, 2) && ($MATCH->{'to'} = 2 + $MATCH->{'to'})) && (do {
                my $m2 = optional_namespace_before_ident($str, $MATCH->{'to'});
                if ($m2) {
                    $MATCH->{'to'} = $m2->{'to'};
                    $MATCH->{'optional_namespace_before_ident'} = $m2;
                    1
                }
                else {
                    0
                }
            }) && (do {
                $MATCH->{'str'} = $str;
                my $name = Perlito5::Match::flat($MATCH->{'optional_namespace_before_ident'});
                $MATCH->{'capture'} = 'main';
                $name ne '' && ($MATCH->{'capture'} .= '::' . $name);
                1
            }))
        }) || (do {
            $MATCH->{'to'} = $pos1;
            (1 && (do {
                $MATCH->{'str'} = $str;
                $MATCH->{'capture'} = '';
                1
            }))
        })
    }));
    $tmp ? $MATCH : 0
}
sub Perlito5::Grammar::exp_stmts2 {
    my $str = $_[0];
    my $pos = $_[1];
    my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
    my $tmp = (((do {
        my $m2 = exp_stmts($str, $MATCH->{'to'});
        if ($m2) {
            $MATCH->{'to'} = $m2->{'to'};
            $MATCH->{'exp_stmts'} = $m2;
            1
        }
        else {
            0
        }
    }) && (do {
        $MATCH->{'str'} = $str;
        $MATCH->{'capture'} = Perlito5::Match::flat($MATCH->{'exp_stmts'});
        1
    })));
    $tmp ? $MATCH : 0
}
sub Perlito5::Grammar::exp {
    my $str = $_[0];
    my $pos = $_[1];
    my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
    my $tmp = (((do {
        my $m2 = Perlito5::Grammar::Expression::exp_parse($str, $MATCH->{'to'});
        if ($m2) {
            $MATCH->{'to'} = $m2->{'to'};
            $MATCH->{'Perlito5::Grammar::Expression::exp_parse'} = $m2;
            1
        }
        else {
            0
        }
    }) && (do {
        $MATCH->{'str'} = $str;
        $MATCH->{'capture'} = Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::Expression::exp_parse'});
        1
    })));
    $tmp ? $MATCH : 0
}
sub Perlito5::Grammar::exp2 {
    my $str = $_[0];
    my $pos = $_[1];
    my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
    my $tmp = (((do {
        my $m2 = Perlito5::Grammar::Expression::exp_parse($str, $MATCH->{'to'});
        if ($m2) {
            $MATCH->{'to'} = $m2->{'to'};
            $MATCH->{'Perlito5::Grammar::Expression::exp_parse'} = $m2;
            1
        }
        else {
            0
        }
    }) && (do {
        $MATCH->{'str'} = $str;
        $MATCH->{'capture'} = Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::Expression::exp_parse'});
        1
    })));
    $tmp ? $MATCH : 0
}
sub Perlito5::Grammar::opt_type {
    my $str = $_[0];
    my $pos = $_[1];
    my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
    my $tmp = ((do {
        my $pos1 = $MATCH->{'to'};
        (do {
            ((do {
                my $m = $MATCH;
                if (!('::' eq substr($str, $MATCH->{'to'}, 2) && ($MATCH->{'to'} = 2 + $MATCH->{'to'}))) {
                    $MATCH = $m
                }
                1
            }) && (do {
                my $m2 = full_ident($str, $MATCH->{'to'});
                if ($m2) {
                    $MATCH->{'to'} = $m2->{'to'};
                    $MATCH->{'full_ident'} = $m2;
                    1
                }
                else {
                    0
                }
            }) && (do {
                $MATCH->{'str'} = $str;
                $MATCH->{'capture'} = Perlito5::Match::flat($MATCH->{'full_ident'});
                1
            }))
        }) || (do {
            $MATCH->{'to'} = $pos1;
            (1 && (do {
                $MATCH->{'str'} = $str;
                $MATCH->{'capture'} = '';
                1
            }))
        })
    }));
    $tmp ? $MATCH : 0
}
sub Perlito5::Grammar::var_sigil {
    my $str = $_[0];
    my $pos = $_[1];
    my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
    my $tmp = ((do {
        my $pos1 = $MATCH->{'to'};
        (do {
            ('$' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}))
        }) || (do {
            $MATCH->{'to'} = $pos1;
            ('%' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}))
        }) || (do {
            $MATCH->{'to'} = $pos1;
            ('@' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}))
        }) || (do {
            $MATCH->{'to'} = $pos1;
            ('&' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}))
        }) || (do {
            $MATCH->{'to'} = $pos1;
            ('*' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}))
        })
    }));
    $tmp ? $MATCH : 0
}
sub Perlito5::Grammar::var_name {
    my $str = $_[0];
    my $pos = $_[1];
    my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
    my $tmp = ((do {
        my $pos1 = $MATCH->{'to'};
        (do {
            (do {
                my $m2 = full_ident($str, $MATCH->{'to'});
                if ($m2) {
                    $MATCH->{'to'} = $m2->{'to'};
                    $MATCH->{'full_ident'} = $m2;
                    1
                }
                else {
                    0
                }
            })
        }) || (do {
            $MATCH->{'to'} = $pos1;
            (do {
                my $m2 = Perlito5::Grammar::Number::digits($str, $MATCH->{'to'});
                if ($m2) {
                    $MATCH->{'to'} = $m2->{'to'};
                    $MATCH->{'Perlito5::Grammar::Number::digits'} = $m2;
                    1
                }
                else {
                    0
                }
            })
        })
    }));
    $tmp ? $MATCH : 0
}
sub Perlito5::Grammar::var_ident {
    my $str = $_[0];
    my $pos = $_[1];
    my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
    my $tmp = (((do {
        my $m2 = var_sigil($str, $MATCH->{'to'});
        if ($m2) {
            $MATCH->{'to'} = $m2->{'to'};
            $MATCH->{'var_sigil'} = $m2;
            1
        }
        else {
            0
        }
    }) && (do {
        my $m2 = optional_namespace_before_ident($str, $MATCH->{'to'});
        if ($m2) {
            $MATCH->{'to'} = $m2->{'to'};
            $MATCH->{'optional_namespace_before_ident'} = $m2;
            1
        }
        else {
            0
        }
    }) && (do {
        my $m2 = var_name($str, $MATCH->{'to'});
        if ($m2) {
            $MATCH->{'to'} = $m2->{'to'};
            $MATCH->{'var_name'} = $m2;
            1
        }
        else {
            0
        }
    }) && (do {
        $MATCH->{'str'} = $str;
        $MATCH->{'capture'} = Perlito5::AST::Var::->new('sigil' => Perlito5::Match::flat($MATCH->{'var_sigil'}), 'namespace' => Perlito5::Match::flat($MATCH->{'optional_namespace_before_ident'}), 'name' => Perlito5::Match::flat($MATCH->{'var_name'}));
        1
    })));
    $tmp ? $MATCH : 0
}
sub Perlito5::Grammar::block {
    Perlito5::Grammar::Block::block(@_)
}
sub Perlito5::Grammar::block2 {
    Perlito5::Grammar::Block::block(@_)
}
sub Perlito5::Grammar::opt_continue_block {
    Perlito5::Grammar::Block::opt_continue_block(@_)
}
my @PKG;
sub Perlito5::Grammar::exp_stmts {
    my $str = $_[0];
    my $pos = $_[1];
    push(@PKG, $Perlito5::PKG_NAME);
    my $has_semicolon;
    my @stmts;
    my $m = Perlito5::Grammar::Space::opt_ws($str, $pos);
    $pos = $m->{'to'};
    while ($m) {
        if (substr($str, $pos, 1) eq ';') {
            $has_semicolon = 1;
            $m = Perlito5::Grammar::Space::opt_ws($str, $pos + 1);
            $pos = $m->{'to'}
        }
        else {
            $m = Perlito5::Grammar::Statement::statement_parse($str, $pos);
            if ($m) {
                push(@stmts, $m->{'capture'});
                $pos = $m->{'to'};
                if (substr($str, $pos, 1) eq ';') {
                    $has_semicolon = 1;
                    $pos = $pos + 1
                }
                $m = Perlito5::Grammar::Space::opt_ws($str, $pos);
                $pos = $m->{'to'}
            }
        }
    }
    $Perlito5::PKG_NAME = pop(@PKG);
    return {'str' => $str, 'to' => $pos, 'capture' => \@stmts}
}
package main;
package Perlito5;
# use Perlito5::Grammar::Scope
# use strict
defined(${chr(15)}) || (${chr(15)} = 'perlito5');
defined(${'/'}) || (${'/'} = chr(10));
defined(${'"'}) || (${'"'} = ' ');
defined(${','}) || (${','} = undef);
defined(${'!'}) || (${'!'} = '');
defined(${';'}) || (${';'} = chr(28));
defined(${'?'}) || (${'?'} = 0);
defined(${'['}) || (${'['} = 0);
${']'} || (${']'} = '5.020000');
defined(${chr(22)}) || (${chr(22)} = bless({'original' => 'v5.20.0', 'qv' => 1, 'version' => [5, 20, 0]}, 'version'));
our $EXPAND_USE = 1;
our $STRICT = 0;
our $WARNINGS = 0;
our $UTF8 = 0;
our $BYTES = 0;
our $CALLER = [];
our %DATA_SECTION = ();
our $PKG_NAME = '';
our $LINE_NUMBER = 0;
our $FILE_NAME = '';
our $BASE_SCOPE = Perlito5::Grammar::Scope::->new_base_scope();
our $SCOPE = $BASE_SCOPE;
our $SCOPE_DEPTH = 0;
our @SCOPE_STMT = ();
our $ID = 100;
our $PACKAGES = {'STDERR' => 1, 'STDOUT' => 1, 'STDIN' => 1, 'main' => 1, 'strict' => 1, 'warnings' => 1, 'utf8' => 1, 'bytes' => 1, 'encoding' => 1, 'UNIVERSAL' => 1, 'CORE' => 1, 'CORE::GLOBAL' => 1, 'Perlito5::IO' => 1};
push(@INC, $_)
    for split(':', ($ENV{'PERL5LIB'} || ''));
our $SPECIAL_VAR = {'$_' => 'ARG', '$&' => '$MATCH', '$`' => '$PREMATCH', '$' . chr(39) => '$POSTMATCH', '$+' => '$LAST_PAREN_MATCH', '@+' => '@LAST_MATCH_END', '%+' => '%LAST_PAREN_MATCH', '@-' => '@LAST_MATCH_START', '$|' => 'autoflush', '$/' => '$RS', '@_' => '@ARG', '< $' => '$EUID', '$.' => '$NR', '< $< ' => '$UID', '$(' => '$GID', '$#' => undef, '$@' => '$EVAL_ERROR', '$=' => '$FORMAT_LINES_PER_PAGE', '$,' => '$OFS', '$?' => '$CHILD_ERROR', '$*' => undef, '$[' => undef, '$$' => '$PID', '%-' => undef, '$~' => '$FORMAT_NAME', '$-' => '$FORMAT_LINES_LEFT', '$&' => '$MATCH', '$%' => '$FORMAT_PAGE_NUMBER', '$)' => '$EGID', '$]' => undef, '$!' => '$ERRNO', '$;' => '$SUBSEP', '$' . chr(92) => '$ORS', '%!' => undef, '$"' => '$LIST_SEPARATOR', '$_' => '$ARG', '$:' => 'FORMAT_LINE_BREAK_CHARACTERS'};
our $CORE_OVERRIDABLE = {'say' => 1, 'break' => 1, 'given' => 1, 'when' => 1, 'default' => 1, 'state' => 1, 'lock' => 1};
our $CORE_PROTO = {'CORE::shutdown' => '*$', 'CORE::chop' => '_', 'CORE::lstat' => '*', 'CORE::rename' => '$$', 'CORE::lock' => chr(92) . '$', 'CORE::rand' => ';$', 'CORE::gmtime' => ';$', 'CORE::gethostbyname' => '$', 'CORE::each' => chr(92) . '[@%]', 'CORE::ref' => '_', 'CORE::syswrite' => '*$;$$', 'CORE::msgctl' => '$$$', 'CORE::getnetbyname' => '$', 'CORE::write' => ';*', 'CORE::alarm' => '_', 'CORE::print' => undef, 'CORE::getnetent' => '', 'CORE::semget' => '$$$', 'CORE::use' => undef, 'CORE::abs' => '_', 'CORE::break' => '', 'CORE::undef' => ';$', 'CORE::no' => undef, 'CORE::eval' => '_', 'CORE::split' => undef, 'CORE::localtime' => ';$', 'CORE::sort' => undef, 'CORE::chown' => '@', 'CORE::endpwent' => '', 'CORE::getpwent' => '', 'CORE::pos' => undef, 'CORE::lcfirst' => '_', 'CORE::kill' => '@', 'CORE::send' => '*$$;$', 'CORE::endprotoent' => '', 'CORE::semctl' => '$$$$', 'CORE::waitpid' => '$$', 'CORE::utime' => '@', 'CORE::dbmclose' => chr(92) . '%', 'CORE::getpwnam' => '$', 'CORE::substr' => '$$;$$', 'CORE::listen' => '*$', 'CORE::getprotoent' => '', 'CORE::shmget' => '$$$', 'CORE::our' => undef, 'CORE::readlink' => '_', 'CORE::shmwrite' => '$$$$', 'CORE::times' => '', 'CORE::package' => undef, 'CORE::map' => undef, 'CORE::join' => '$@', 'CORE::rmdir' => '_', 'CORE::shmread' => '$$$$', 'CORE::uc' => '_', 'CORE::bless' => '$;$', 'CORE::closedir' => '*', 'CORE::getppid' => '', 'CORE::tie' => chr(92) . '[$@%]$;@', 'CORE::readdir' => '*', 'CORE::gethostent' => '', 'CORE::getlogin' => '', 'CORE::last' => undef, 'CORE::gethostbyaddr' => '$$', 'CORE::accept' => '**', 'CORE::log' => '_', 'CORE::tell' => ';*', 'CORE::readline' => ';*', 'CORE::tied' => undef, 'CORE::socket' => '*$$$', 'CORE::umask' => ';$', 'CORE::sysread' => '*' . chr(92) . '$$;$', 'CORE::syscall' => '$@', 'CORE::quotemeta' => '_', 'CORE::dump' => '', 'CORE::opendir' => '*$', 'CORE::untie' => undef, 'CORE::truncate' => '$$', 'CORE::select' => ';*', 'CORE::sleep' => ';$', 'CORE::seek' => '*$$', 'CORE::read' => '*' . chr(92) . '$$;$', 'CORE::rewinddir' => '*', 'CORE::scalar' => undef, 'CORE::wantarray' => '', 'CORE::oct' => '_', 'CORE::bind' => '*$', 'CORE::stat' => '*', 'CORE::sqrt' => '_', 'CORE::getc' => ';*', 'CORE::fileno' => '*', 'CORE::getpeername' => '*', 'CORE::sin' => '_', 'CORE::getnetbyaddr' => '$$', 'CORE::grep' => undef, 'CORE::setservent' => '$', 'CORE::sub' => undef, 'CORE::shmctl' => '$$$', 'CORE::study' => undef, 'CORE::msgrcv' => '$$$$$', 'CORE::setsockopt' => '*$$$', 'CORE::int' => '_', 'CORE::pop' => ';' . chr(92) . '@', 'CORE::link' => '$$', 'CORE::exec' => undef, 'CORE::setpwent' => '', 'CORE::mkdir' => '_;$', 'CORE::sysseek' => '*$$', 'CORE::endservent' => '', 'CORE::chr' => '_', 'CORE::when' => undef, 'CORE::getpwuid' => '$', 'CORE::setprotoent' => '$', 'CORE::reverse' => '@', 'CORE::say' => undef, 'CORE::goto' => undef, 'CORE::getgrent' => '', 'CORE::endnetent' => '', 'CORE::hex' => '_', 'CORE::binmode' => '*;$', 'CORE::formline' => '$@', 'CORE::getgrnam' => '$', 'CORE::ucfirst' => '_', 'CORE::chdir' => ';$', 'CORE::setnetent' => '$', 'CORE::splice' => chr(92) . '@;$$@', 'CORE::unlink' => '@', 'CORE::time' => '', 'CORE::push' => chr(92) . '@@', 'CORE::exit' => ';$', 'CORE::endgrent' => '', 'CORE::unshift' => chr(92) . '@@', 'CORE::local' => undef, 'CORE::my' => undef, 'CORE::cos' => '_', 'CORE::redo' => undef, 'CORE::warn' => '@', 'CORE::getsockname' => '*', 'CORE::pipe' => '**', 'CORE::sprintf' => '$@', 'CORE::open' => '*;$@', 'CORE::setpgrp' => ';$$', 'CORE::exp' => '_', 'CORE::seekdir' => '*$', 'CORE::getservbyport' => '$$', 'CORE::given' => undef, 'CORE::pack' => '$@', 'CORE::msgget' => '$$', 'CORE::rindex' => '$$;$', 'CORE::srand' => ';$', 'CORE::telldir' => '*', 'CORE::connect' => '*$', 'CORE::getprotobyname' => '$', 'CORE::msgsnd' => '$$$', 'CORE::length' => '_', 'CORE::state' => undef, 'CORE::die' => '@', 'CORE::delete' => undef, 'CORE::getservent' => '', 'CORE::getservbyname' => '$$', 'CORE::setpriority' => '$$$', 'CORE::lc' => '_', 'CORE::fcntl' => '*$$', 'CORE::chroot' => '_', 'CORE::recv' => '*' . chr(92) . '$$$', 'CORE::dbmopen' => chr(92) . '%$$', 'CORE::socketpair' => '**$$$', 'CORE::vec' => '$$$', 'CORE::system' => undef, 'CORE::defined' => '_', 'CORE::index' => '$$;$', 'CORE::caller' => ';$', 'CORE::close' => ';*', 'CORE::atan2' => '$$', 'CORE::semop' => '$$', 'CORE::unpack' => '$;$', 'CORE::ord' => '_', 'CORE::chmod' => '@', 'CORE::prototype' => undef, 'CORE::getprotobynumber' => '$', 'CORE::values' => chr(92) . '[@%]', 'CORE::chomp' => '_', 'CORE::ioctl' => '*$$', 'CORE::eof' => ';*', 'CORE::crypt' => '$$', 'CORE::do' => undef, 'CORE::flock' => '*$', 'CORE::wait' => '', 'CORE::sethostent' => '$', 'CORE::return' => undef, 'CORE::getsockopt' => '*$$', 'CORE::fork' => '', 'CORE::require' => undef, 'CORE::format' => undef, 'CORE::readpipe' => '_', 'CORE::endhostent' => '', 'CORE::getpgrp' => ';$', 'CORE::setgrent' => '', 'CORE::keys' => chr(92) . '[@%]', 'CORE::glob' => undef, 'CORE::getpriority' => '$$', 'CORE::reset' => ';$', 'CORE::sysopen' => '*$$;$', 'CORE::continue' => '', 'CORE::next' => undef, 'CORE::getgrgid' => '$', 'CORE::default' => undef, 'CORE::shift' => ';' . chr(92) . '@', 'CORE::symlink' => '$$', 'CORE::exists' => '$', 'CORE::printf' => '$@', 'CORE::m' => undef, 'CORE::q' => undef, 'CORE::qq' => undef, 'CORE::qw' => undef, 'CORE::qx' => undef, 'CORE::qr' => undef, 'CORE::s' => undef, 'CORE::tr' => undef, 'CORE::y' => undef, 'CORE::if' => undef, 'CORE::unless' => undef, 'CORE::when' => undef, 'CORE::for' => undef, 'CORE::foreach' => undef, 'CORE::while' => undef, 'CORE::given' => undef, 'CORE::and' => undef, 'CORE::or' => undef, 'CORE::xor' => undef, 'CORE::not' => undef, 'CORE::cmp' => undef, 'CORE::__FILE__' => '', 'CORE::__LINE__' => ''};
sub Perlito5::test_perl_version {
    my $version = shift;
    $version =~ s!^v!!;
    if ($version && ord(substr($version, 0, 1)) < 10) {
        my @v = split(m!!, $version);
        push(@v, chr(0))
            while @v < 3;
        $version = sprintf('%d.%03d%03d', map {
            ord($_)
        } @v)
    }
    else {
        my @v = split(m!\.!, $version);
        $v[1] = $v[1] . 0
            while length($v[1]) < 3;
        $version = join('.', @v)
    }
    if ($version gt ${']'}) {
        die('Perl v' . $version . ' required--this is only v' . ${']'})
    }
}
1;
package main;
package Perlito5::Compiler;
# use strict
# use warnings
# use Perlito5::Match
# use Perlito5::Grammar
# use Perlito5::Grammar::Control
# use Perlito5::Grammar::Precedence
# use Perlito5::Grammar::Expression
# use Perlito5::Macro
# use Perlito5::Runtime
1;
# use Perlito5::Compiler
package main;
package Perlito5::Grammar::Regex6;
# use Perlito5::Grammar::Precedence
sub Perlito5::Grammar::Regex6::term_token {
    my $str = $_[0];
    my $pos = $_[1];
    my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
    my $tmp = ((('token' eq substr($str, $MATCH->{'to'}, 5) && ($MATCH->{'to'} = 5 + $MATCH->{'to'})) && (do {
        my $m2 = Perlito5::Grammar::Space::ws($str, $MATCH->{'to'});
        if ($m2) {
            $MATCH->{'to'} = $m2->{'to'};
            1
        }
        else {
            0
        }
    }) && (do {
        my $m2 = Perlito5::Grammar::ident($str, $MATCH->{'to'});
        if ($m2) {
            $MATCH->{'to'} = $m2->{'to'};
            $MATCH->{'Perlito5::Grammar::ident'} = $m2;
            1
        }
        else {
            0
        }
    }) && (do {
        my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{'to'});
        if ($m2) {
            $MATCH->{'to'} = $m2->{'to'};
            1
        }
        else {
            0
        }
    }) && ('{' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
        my $m2 = Perlito5::Grammar::Regex6::rule($str, $MATCH->{'to'});
        if ($m2) {
            $MATCH->{'to'} = $m2->{'to'};
            $MATCH->{'Perlito5::Grammar::Regex6::rule'} = $m2;
            1
        }
        else {
            0
        }
    }) && ('}' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
        $MATCH->{'str'} = $str;
        my $source = Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::ident'}) . '{ ' . 'my $str     = $_[0]; ' . 'my $pos     = $_[1]; ' . 'my $MATCH = { str => $str, from => $pos, to => $pos }; ' . 'my $tmp = ( ' . Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::Regex6::rule'})->emit_perl5() . '); ' . '$tmp ? $MATCH : 0; ' . '}';
        my $ast = Perlito5::Grammar::Block::named_sub_def($source, 0);
        $MATCH->{'capture'} = ['term', Perlito5::Match::flat($ast)];
        1
    })));
    $tmp ? $MATCH : 0
}
Perlito5::Grammar::Precedence::add_term('token', \&term_token);
sub Perlito5::Grammar::Regex6::any {
    my $str = $_[0];
    my $pos = $_[1];
    my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
    my $tmp = (('' ne substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})));
    $tmp ? $MATCH : 0
}
sub Perlito5::Grammar::Regex6::literal {
    my $str = $_[0];
    my $pos = $_[1];
    my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
    my $tmp = ((do {
        my $last_match_null = 0;
        my $m = $MATCH;
        my $to = $MATCH->{'to'};
        while ((do {
            my $pos1 = $MATCH->{'to'};
            (do {
                ((chr(92) eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && ('' ne substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})))
            }) || (do {
                $MATCH->{'to'} = $pos1;
                ((do {
                    my $tmp = $MATCH;
                    $MATCH = {'str' => $str, 'from' => $tmp->{'to'}, 'to' => $tmp->{'to'}};
                    my $res = (chr(39) eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}));
                    $MATCH = $tmp;
                    $res ? 0 : 1
                }) && ('' ne substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})))
            })
        }) && ($last_match_null < 2)) {
            if ($to == $MATCH->{'to'}) {
                $last_match_null = $last_match_null + 1
            }
            else {
                $last_match_null = 0
            }
            $m = $MATCH;
            $to = $MATCH->{'to'}
        }
        $MATCH = $m;
        $MATCH->{'to'} = $to;
        1
    }));
    $tmp ? $MATCH : 0
}
sub Perlito5::Grammar::Regex6::metasyntax_exp {
    my $str = $_[0];
    my $pos = $_[1];
    my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
    my $tmp = ((do {
        my $last_match_null = 0;
        my $m = $MATCH;
        my $to = $MATCH->{'to'};
        my $count = 0;
        while (((do {
            my $tmp = $MATCH;
            $MATCH = {'str' => $str, 'from' => $tmp->{'to'}, 'to' => $tmp->{'to'}};
            my $res = ('>' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}));
            $MATCH = $tmp;
            $res ? 0 : 1
        }) && ('' ne substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}))) && ($last_match_null < 2)) {
            if ($to == $MATCH->{'to'}) {
                $last_match_null = $last_match_null + 1
            }
            else {
                $last_match_null = 0
            }
            $m = $MATCH;
            $to = $MATCH->{'to'};
            $count = $count + 1
        }
        $MATCH = $m;
        $MATCH->{'to'} = $to;
        $count > 0
    }));
    $tmp ? $MATCH : 0
}
sub Perlito5::Grammar::Regex6::string_code {
    my $str = $_[0];
    my $pos = $_[1];
    my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
    my $tmp = ((do {
        my $last_match_null = 0;
        my $m = $MATCH;
        my $to = $MATCH->{'to'};
        my $count = 0;
        while ((do {
            my $pos1 = $MATCH->{'to'};
            (do {
                ((chr(92) eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && ('' ne substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})))
            }) || (do {
                $MATCH->{'to'} = $pos1;
                ((chr(39) eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                    my $m2 = literal($str, $MATCH->{'to'});
                    if ($m2) {
                        $MATCH->{'to'} = $m2->{'to'};
                        1
                    }
                    else {
                        0
                    }
                }) && (chr(39) eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})))
            }) || (do {
                $MATCH->{'to'} = $pos1;
                (('{' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                    my $m2 = string_code($str, $MATCH->{'to'});
                    if ($m2) {
                        $MATCH->{'to'} = $m2->{'to'};
                        1
                    }
                    else {
                        0
                    }
                }) && ('}' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})))
            }) || (do {
                $MATCH->{'to'} = $pos1;
                ((do {
                    my $tmp = $MATCH;
                    $MATCH = {'str' => $str, 'from' => $tmp->{'to'}, 'to' => $tmp->{'to'}};
                    my $res = ('}' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}));
                    $MATCH = $tmp;
                    $res ? 0 : 1
                }) && ('' ne substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})))
            })
        }) && ($last_match_null < 2)) {
            if ($to == $MATCH->{'to'}) {
                $last_match_null = $last_match_null + 1
            }
            else {
                $last_match_null = 0
            }
            $m = $MATCH;
            $to = $MATCH->{'to'};
            $count = $count + 1
        }
        $MATCH = $m;
        $MATCH->{'to'} = $to;
        $count > 0
    }));
    $tmp ? $MATCH : 0
}
sub Perlito5::Grammar::Regex6::parsed_code {
    my $str = $_[0];
    my $pos = $_[1];
    my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
    my $tmp = (((do {
        my $m2 = string_code($str, $MATCH->{'to'});
        if ($m2) {
            $MATCH->{'to'} = $m2->{'to'};
            1
        }
        else {
            0
        }
    }) && (do {
        $MATCH->{'str'} = $str;
        $MATCH->{'capture'} = Perlito5::Match::flat($MATCH);
        1
    })));
    $tmp ? $MATCH : 0
}
sub Perlito5::Grammar::Regex6::rule_term {
    my $str = $_[0];
    my $pos = $_[1];
    my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
    my $tmp = ((do {
        my $pos1 = $MATCH->{'to'};
        (do {
            (('<before' eq substr($str, $MATCH->{'to'}, 7) && ($MATCH->{'to'} = 7 + $MATCH->{'to'})) && (do {
                my $m2 = Perlito5::Grammar::Space::ws($str, $MATCH->{'to'});
                if ($m2) {
                    $MATCH->{'to'} = $m2->{'to'};
                    1
                }
                else {
                    0
                }
            }) && (do {
                my $m2 = rule($str, $MATCH->{'to'});
                if ($m2) {
                    $MATCH->{'to'} = $m2->{'to'};
                    $MATCH->{'rule'} = $m2;
                    1
                }
                else {
                    0
                }
            }) && ('>' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                $MATCH->{'str'} = $str;
                $MATCH->{'capture'} = Perlito5::Rul::Before::->new('rule_exp' => Perlito5::Match::flat($MATCH->{'rule'}));
                1
            }))
        }) || (do {
            $MATCH->{'to'} = $pos1;
            (('<!before' eq substr($str, $MATCH->{'to'}, 8) && ($MATCH->{'to'} = 8 + $MATCH->{'to'})) && (do {
                my $m2 = Perlito5::Grammar::Space::ws($str, $MATCH->{'to'});
                if ($m2) {
                    $MATCH->{'to'} = $m2->{'to'};
                    1
                }
                else {
                    0
                }
            }) && (do {
                my $m2 = rule($str, $MATCH->{'to'});
                if ($m2) {
                    $MATCH->{'to'} = $m2->{'to'};
                    $MATCH->{'rule'} = $m2;
                    1
                }
                else {
                    0
                }
            }) && ('>' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                $MATCH->{'str'} = $str;
                $MATCH->{'capture'} = Perlito5::Rul::NotBefore::->new('rule_exp' => Perlito5::Match::flat($MATCH->{'rule'}));
                1
            }))
        }) || (do {
            $MATCH->{'to'} = $pos1;
            ((chr(39) eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                my $m2 = literal($str, $MATCH->{'to'});
                if ($m2) {
                    $MATCH->{'to'} = $m2->{'to'};
                    $MATCH->{'literal'} = $m2;
                    1
                }
                else {
                    0
                }
            }) && (chr(39) eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                $MATCH->{'str'} = $str;
                $MATCH->{'capture'} = Perlito5::Rul::Constant::->new('constant' => Perlito5::Match::flat($MATCH->{'literal'}));
                1
            }))
        }) || (do {
            $MATCH->{'to'} = $pos1;
            (('<' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                my $pos1 = $MATCH->{'to'};
                (do {
                    (('.' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                        my $m2 = metasyntax_exp($str, $MATCH->{'to'});
                        if ($m2) {
                            $MATCH->{'to'} = $m2->{'to'};
                            $MATCH->{'metasyntax_exp'} = $m2;
                            1
                        }
                        else {
                            0
                        }
                    }) && ('>' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                        $MATCH->{'str'} = $str;
                        $MATCH->{'capture'} = Perlito5::Rul::Subrule::->new('metasyntax' => Perlito5::Match::flat($MATCH->{'metasyntax_exp'}), 'captures' => 0);
                        1
                    }))
                }) || (do {
                    $MATCH->{'to'} = $pos1;
                    ((do {
                        my $m2 = metasyntax_exp($str, $MATCH->{'to'});
                        if ($m2) {
                            $MATCH->{'to'} = $m2->{'to'};
                            $MATCH->{'metasyntax_exp'} = $m2;
                            1
                        }
                        else {
                            0
                        }
                    }) && ('>' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                        $MATCH->{'str'} = $str;
                        $MATCH->{'capture'} = Perlito5::Rul::Subrule::->new('metasyntax' => Perlito5::Match::flat($MATCH->{'metasyntax_exp'}), 'captures' => 1);
                        1
                    }))
                })
            }))
        }) || (do {
            $MATCH->{'to'} = $pos1;
            (('{' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                my $m2 = parsed_code($str, $MATCH->{'to'});
                if ($m2) {
                    $MATCH->{'to'} = $m2->{'to'};
                    $MATCH->{'parsed_code'} = $m2;
                    1
                }
                else {
                    0
                }
            }) && ('}' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                $MATCH->{'str'} = $str;
                $MATCH->{'capture'} = Perlito5::Rul::Block::->new('closure' => Perlito5::Match::flat($MATCH->{'parsed_code'}));
                1
            }))
        }) || (do {
            $MATCH->{'to'} = $pos1;
            ((chr(92) eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                my $pos1 = $MATCH->{'to'};
                (do {
                    (('c' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                        my $m2 = Perlito5::Grammar::Number::digits($str, $MATCH->{'to'});
                        if ($m2) {
                            $MATCH->{'to'} = $m2->{'to'};
                            $MATCH->{'Perlito5::Grammar::Number::digits'} = $m2;
                            1
                        }
                        else {
                            0
                        }
                    }) && (do {
                        $MATCH->{'str'} = $str;
                        $MATCH->{'capture'} = Perlito5::Rul::Constant::->new('constant' => chr(Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::Number::digits'})));
                        1
                    }))
                }) || (do {
                    $MATCH->{'to'} = $pos1;
                    ((do {
                        my $m2 = any($str, $MATCH->{'to'});
                        if ($m2) {
                            $MATCH->{'to'} = $m2->{'to'};
                            $MATCH->{'any'} = $m2;
                            1
                        }
                        else {
                            0
                        }
                    }) && (do {
                        $MATCH->{'str'} = $str;
                        $MATCH->{'capture'} = Perlito5::Rul::SpecialChar::->new('char' => Perlito5::Match::flat($MATCH->{'any'}));
                        1
                    }))
                })
            }))
        }) || (do {
            $MATCH->{'to'} = $pos1;
            (('.' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                $MATCH->{'str'} = $str;
                $MATCH->{'capture'} = Perlito5::Rul::Dot::->new();
                1
            }))
        }) || (do {
            $MATCH->{'to'} = $pos1;
            (('[' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                my $m2 = rule($str, $MATCH->{'to'});
                if ($m2) {
                    $MATCH->{'to'} = $m2->{'to'};
                    $MATCH->{'rule'} = $m2;
                    1
                }
                else {
                    0
                }
            }) && (']' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                $MATCH->{'str'} = $str;
                $MATCH->{'capture'} = Perlito5::Match::flat($MATCH->{'rule'});
                1
            }))
        })
    }));
    $tmp ? $MATCH : 0
}
sub Perlito5::Grammar::Regex6::quant_exp {
    my $str = $_[0];
    my $pos = $_[1];
    my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
    my $tmp = ((do {
        my $pos1 = $MATCH->{'to'};
        (do {
            ('?' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}))
        }) || (do {
            $MATCH->{'to'} = $pos1;
            ('*' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}))
        }) || (do {
            $MATCH->{'to'} = $pos1;
            ('+' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}))
        })
    }));
    $tmp ? $MATCH : 0
}
sub Perlito5::Grammar::Regex6::quantifier {
    my $str = $_[0];
    my $pos = $_[1];
    my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
    my $tmp = (((do {
        my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{'to'});
        if ($m2) {
            $MATCH->{'to'} = $m2->{'to'};
            $MATCH->{'Perlito5::Grammar::Space::opt_ws'} = $m2;
            1
        }
        else {
            0
        }
    }) && (do {
        my $m2 = rule_term($str, $MATCH->{'to'});
        if ($m2) {
            $MATCH->{'to'} = $m2->{'to'};
            $MATCH->{'rule_term'} = $m2;
            1
        }
        else {
            0
        }
    }) && (do {
        my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{'to'});
        if ($m2) {
            $MATCH->{'to'} = $m2->{'to'};
            $MATCH->{'Perlito5::Grammar::Space::opt_ws'} = $m2;
            1
        }
        else {
            0
        }
    }) && (do {
        my $pos1 = $MATCH->{'to'};
        (do {
            ((do {
                my $m2 = quant_exp($str, $MATCH->{'to'});
                if ($m2) {
                    $MATCH->{'to'} = $m2->{'to'};
                    $MATCH->{'quant_exp'} = $m2;
                    1
                }
                else {
                    0
                }
            }) && (do {
                my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{'to'});
                if ($m2) {
                    $MATCH->{'to'} = $m2->{'to'};
                    $MATCH->{'Perlito5::Grammar::Space::opt_ws'} = $m2;
                    1
                }
                else {
                    0
                }
            }) && (do {
                $MATCH->{'str'} = $str;
                $MATCH->{'capture'} = Perlito5::Rul::Quantifier::->new('term' => Perlito5::Match::flat($MATCH->{'rule_term'}), 'quant' => Perlito5::Match::flat($MATCH->{'quant_exp'}));
                1
            }))
        }) || (do {
            $MATCH->{'to'} = $pos1;
            (do {
                $MATCH->{'str'} = $str;
                $MATCH->{'capture'} = Perlito5::Match::flat($MATCH->{'rule_term'});
                1
            })
        })
    })));
    $tmp ? $MATCH : 0
}
sub Perlito5::Grammar::Regex6::concat_list {
    my $str = $_[0];
    my $pos = $_[1];
    my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
    my $tmp = ((do {
        my $pos1 = $MATCH->{'to'};
        (do {
            ((do {
                my $m2 = quantifier($str, $MATCH->{'to'});
                if ($m2) {
                    $MATCH->{'to'} = $m2->{'to'};
                    $MATCH->{'quantifier'} = $m2;
                    1
                }
                else {
                    0
                }
            }) && (do {
                my $pos1 = $MATCH->{'to'};
                (do {
                    ((do {
                        my $m2 = concat_list($str, $MATCH->{'to'});
                        if ($m2) {
                            $MATCH->{'to'} = $m2->{'to'};
                            $MATCH->{'concat_list'} = $m2;
                            1
                        }
                        else {
                            0
                        }
                    }) && (do {
                        $MATCH->{'str'} = $str;
                        $MATCH->{'capture'} = [Perlito5::Match::flat($MATCH->{'quantifier'}), @{Perlito5::Match::flat($MATCH->{'concat_list'})}];
                        1
                    }))
                }) || (do {
                    $MATCH->{'to'} = $pos1;
                    (do {
                        $MATCH->{'str'} = $str;
                        $MATCH->{'capture'} = [Perlito5::Match::flat($MATCH->{'quantifier'})];
                        1
                    })
                })
            }))
        }) || (do {
            $MATCH->{'to'} = $pos1;
            (do {
                $MATCH->{'str'} = $str;
                $MATCH->{'capture'} = [];
                1
            })
        })
    }));
    $tmp ? $MATCH : 0
}
sub Perlito5::Grammar::Regex6::concat_exp {
    my $str = $_[0];
    my $pos = $_[1];
    my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
    my $tmp = (((do {
        my $m2 = concat_list($str, $MATCH->{'to'});
        if ($m2) {
            $MATCH->{'to'} = $m2->{'to'};
            $MATCH->{'concat_list'} = $m2;
            1
        }
        else {
            0
        }
    }) && (do {
        $MATCH->{'str'} = $str;
        $MATCH->{'capture'} = Perlito5::Rul::Concat::->new('concat' => Perlito5::Match::flat($MATCH->{'concat_list'}));
        1
    })));
    $tmp ? $MATCH : 0
}
sub Perlito5::Grammar::Regex6::or_list_exp {
    my $str = $_[0];
    my $pos = $_[1];
    my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
    my $tmp = ((do {
        my $pos1 = $MATCH->{'to'};
        (do {
            ((do {
                my $m2 = concat_exp($str, $MATCH->{'to'});
                if ($m2) {
                    $MATCH->{'to'} = $m2->{'to'};
                    $MATCH->{'concat_exp'} = $m2;
                    1
                }
                else {
                    0
                }
            }) && (do {
                my $pos1 = $MATCH->{'to'};
                (do {
                    (('|' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                        my $m2 = or_list_exp($str, $MATCH->{'to'});
                        if ($m2) {
                            $MATCH->{'to'} = $m2->{'to'};
                            $MATCH->{'or_list_exp'} = $m2;
                            1
                        }
                        else {
                            0
                        }
                    }) && (do {
                        $MATCH->{'str'} = $str;
                        $MATCH->{'capture'} = [Perlito5::Match::flat($MATCH->{'concat_exp'}), @{Perlito5::Match::flat($MATCH->{'or_list_exp'})}];
                        1
                    }))
                }) || (do {
                    $MATCH->{'to'} = $pos1;
                    (do {
                        $MATCH->{'str'} = $str;
                        $MATCH->{'capture'} = [Perlito5::Match::flat($MATCH->{'concat_exp'})];
                        1
                    })
                })
            }))
        }) || (do {
            $MATCH->{'to'} = $pos1;
            (do {
                $MATCH->{'str'} = $str;
                $MATCH->{'capture'} = [];
                1
            })
        })
    }));
    $tmp ? $MATCH : 0
}
sub Perlito5::Grammar::Regex6::rule {
    my $str = $_[0];
    my $pos = $_[1];
    my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
    my $tmp = (((do {
        my $pos1 = $MATCH->{'to'};
        (do {
            ((do {
                my $m = $MATCH;
                if (!(do {
                    my $m2 = Perlito5::Grammar::Space::ws($str, $MATCH->{'to'});
                    if ($m2) {
                        $MATCH->{'to'} = $m2->{'to'};
                        1
                    }
                    else {
                        0
                    }
                })) {
                    $MATCH = $m
                }
                1
            }) && ('|' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})))
        }) || (do {
            $MATCH->{'to'} = $pos1;
            1
        })
    }) && (do {
        my $m2 = or_list_exp($str, $MATCH->{'to'});
        if ($m2) {
            $MATCH->{'to'} = $m2->{'to'};
            $MATCH->{'or_list_exp'} = $m2;
            1
        }
        else {
            0
        }
    }) && (do {
        $MATCH->{'str'} = $str;
        $MATCH->{'capture'} = Perlito5::Rul::Or::->new('or_list' => Perlito5::Match::flat($MATCH->{'or_list_exp'}));
        1
    })));
    $tmp ? $MATCH : 0
}
# use Perlito5::Grammar::Regex6
package main;
undef();
package Perlito5::Rul;
sub Perlito5::Rul::new {
    my $class = shift;
    bless({@_}, $class)
}
sub Perlito5::Rul::constant {
    my $str = shift;
    my $len = length($str);
    if ($str eq chr(92)) {
        $str = chr(92) . chr(92)
    }
    if ($str eq chr(39)) {
        $str = chr(92) . chr(39)
    }
    if ($len) {
        '( ' . chr(39) . $str . chr(39) . ' eq substr( $str, $MATCH->{to}, ' . $len . ') ' . '&& ( $MATCH->{to} = ' . $len . ' + $MATCH->{to} )' . ')'
    }
    else {
        return 1
    }
}
package Perlito5::Rul::Quantifier;
sub Perlito5::Rul::Quantifier::new {
    my $class = shift;
    bless({@_}, $class)
}
sub Perlito5::Rul::Quantifier::term {
    $_[0]->{'term'}
}
sub Perlito5::Rul::Quantifier::quant {
    $_[0]->{'quant'}
}
sub Perlito5::Rul::Quantifier::emit_perl5 {
    my $self = $_[0];
    if ($self->{'quant'} eq '') {
        return $self->{'term'}->emit_perl5()
    }
    if ($self->{'quant'} eq '+') {
        $self->{'term'}->set_captures_to_array();
        return '(do { ' . 'my $last_match_null = 0; ' . 'my $m = $MATCH; ' . 'my $to = $MATCH->{to}; ' . 'my $count = 0; ' . 'while (' . $self->{'term'}->emit_perl5() . ' && ($last_match_null < 2)) ' . '{ ' . 'if ($to == $MATCH->{to}) { ' . '$last_match_null = $last_match_null + 1; ' . '} ' . 'else { ' . '$last_match_null = 0; ' . '}; ' . '$m = $MATCH; ' . '$to = $MATCH->{to}; ' . '$count = $count + 1; ' . '}; ' . '$MATCH = $m; ' . '$MATCH->{to} = $to; ' . '$count > 0; ' . '})'
    }
    if ($self->{'quant'} eq '*') {
        $self->{'term'}->set_captures_to_array();
        return '(do { ' . 'my $last_match_null = 0; ' . 'my $m = $MATCH; ' . 'my $to = $MATCH->{to}; ' . 'while (' . $self->{'term'}->emit_perl5() . ' && ($last_match_null < 2)) ' . '{ ' . 'if ($to == $MATCH->{to}) { ' . '$last_match_null = $last_match_null + 1; ' . '} ' . 'else { ' . '$last_match_null = 0; ' . '}; ' . '$m = $MATCH; ' . '$to = $MATCH->{to}; ' . '}; ' . '$MATCH = $m; ' . '$MATCH->{to} = $to; ' . '1 ' . '})'
    }
    if ($self->{'quant'} eq '?') {
        $self->{'term'}->set_captures_to_array();
        return '(do { ' . 'my $m = $MATCH; ' . 'if (!' . $self->{'term'}->emit_perl5() . ') ' . '{ ' . '$MATCH = $m; ' . '}; ' . '1 ' . '})'
    }
    die('Perlito5::Rul::Quantifier:  not implemented')
}
sub Perlito5::Rul::Quantifier::set_captures_to_array {
    my $self = $_[0];
    $self->{'term'}->set_captures_to_array()
}
package Perlito5::Rul::Or;
sub Perlito5::Rul::Or::new {
    my $class = shift;
    bless({@_}, $class)
}
sub Perlito5::Rul::Or::or_list {
    $_[0]->{'or_list'}
}
sub Perlito5::Rul::Or::emit_perl5 {
    my $self = $_[0];
    if (scalar(@{$self->{'or_list'}}) == 1) {
        return $self->{'or_list'}->[0]->emit_perl5()
    }
    '(do { ' . 'my $pos1 = $MATCH->{to}; (do { ' . join('}) || (do { $MATCH->{to} = $pos1; ', map($_->emit_perl5(), @{$self->{'or_list'}})) . '}) })'
}
sub Perlito5::Rul::Or::set_captures_to_array {
    my $self = $_[0];
    map($_->set_captures_to_array(), @{$self->{'or_list'}})
}
package Perlito5::Rul::Concat;
sub Perlito5::Rul::Concat::new {
    my $class = shift;
    bless({@_}, $class)
}
sub Perlito5::Rul::Concat::concat {
    $_[0]->{'concat'}
}
sub Perlito5::Rul::Concat::emit_perl5 {
    my $self = $_[0];
    if (scalar(@{$self->{'concat'}}) == 1) {
        return $self->{'concat'}->[0]->emit_perl5()
    }
    '(' . join(' && ', map($_->emit_perl5(), @{$self->{'concat'}})) . ')'
}
sub Perlito5::Rul::Concat::set_captures_to_array {
    my $self = $_[0];
    map($_->set_captures_to_array(), @{$self->{'concat'}})
}
package Perlito5::Rul::Subrule;
sub Perlito5::Rul::Subrule::new {
    my $class = shift;
    bless({@_}, $class)
}
sub Perlito5::Rul::Subrule::metasyntax {
    $_[0]->{'metasyntax'}
}
sub Perlito5::Rul::Subrule::captures {
    $_[0]->{'captures'}
}
sub Perlito5::Rul::Subrule::emit_perl5 {
    my $self = $_[0];
    my $meth = $self->{'metasyntax'};
    my $code;
    if ($self->{'captures'} == 1) {
        $code = 'if ($m2) { $MATCH->{to} = $m2->{to}; $MATCH->{' . chr(39) . $self->{'metasyntax'} . chr(39) . '} = $m2; 1 } else { 0 }; '
    }
    elsif ($self->{'captures'} > 1) {
        $code = 'if ($m2) { ' . '$MATCH->{to} = $m2->{to}; ' . 'if (exists $MATCH->{' . chr(39) . $self->{'metasyntax'} . chr(39) . '}) { ' . 'push @{ $MATCH->{' . chr(39) . $self->{'metasyntax'} . chr(39) . '} }, $m2; ' . '} ' . 'else { ' . '$MATCH->{' . chr(39) . $self->{'metasyntax'} . chr(39) . '} = [ $m2 ]; ' . '}; ' . '1 ' . '} else { 0 }; '
    }
    else {
        $code = 'if ($m2) { $MATCH->{to} = $m2->{to}; 1 } else { 0 }; '
    }
    '(do { ' . 'my $m2 = ' . $meth . '($str, $MATCH->{to}); ' . $code . '})'
}
sub Perlito5::Rul::Subrule::set_captures_to_array {
    my $self = $_[0];
    if ($self->{'captures'} > 0) {
        $self->{'captures'} = $self->{'captures'} + 1
    }
}
package Perlito5::Rul::Constant;
sub Perlito5::Rul::Constant::new {
    my $class = shift;
    bless({@_}, $class)
}
sub Perlito5::Rul::Constant::constant {
    $_[0]->{'constant'}
}
sub Perlito5::Rul::Constant::emit_perl5 {
    my $self = $_[0];
    my $str = $self->{'constant'};
    Perlito5::Rul::constant($str)
}
sub Perlito5::Rul::Constant::set_captures_to_array {
    my $self = $_[0]
}
package Perlito5::Rul::Dot;
sub Perlito5::Rul::Dot::new {
    my $class = shift;
    bless({@_}, $class)
}
sub Perlito5::Rul::Dot::emit_perl5 {
    my $self = $_[0];
    '( ' . chr(39) . chr(39) . ' ne substr( $str, $MATCH->{to}, 1 ) ' . '&& ($MATCH->{to} = 1 + $MATCH->{to})' . ')'
}
sub Perlito5::Rul::Dot::set_captures_to_array {
    my $self = $_[0]
}
package Perlito5::Rul::SpecialChar;
sub Perlito5::Rul::SpecialChar::new {
    my $class = shift;
    bless({@_}, $class)
}
sub Perlito5::Rul::SpecialChar::char {
    $_[0]->{'char'}
}
sub Perlito5::Rul::SpecialChar::emit_perl5 {
    my $self = $_[0];
    my $char = $self->{'char'};
    if ($char eq 'n') {
        return Perlito5::Rul::Subrule::->new('metasyntax' => 'is_newline', 'captures' => 0)->emit_perl5()
    }
    if ($char eq 'N') {
        return Perlito5::Rul::Subrule::->new('metasyntax' => 'not_newline', 'captures' => 0)->emit_perl5()
    }
    if ($char eq 'd') {
        return Perlito5::Rul::Subrule::->new('metasyntax' => 'digit', 'captures' => 0)->emit_perl5()
    }
    if ($char eq 's') {
        return Perlito5::Rul::Subrule::->new('metasyntax' => 'space', 'captures' => 0)->emit_perl5()
    }
    if ($char eq 't') {
        return Perlito5::Rul::constant(chr(9))
    }
    return Perlito5::Rul::constant($char)
}
sub Perlito5::Rul::SpecialChar::set_captures_to_array {
    my $self = $_[0]
}
package Perlito5::Rul::Block;
sub Perlito5::Rul::Block::new {
    my $class = shift;
    bless({@_}, $class)
}
sub Perlito5::Rul::Block::closure {
    $_[0]->{'closure'}
}
sub Perlito5::Rul::Block::emit_perl5 {
    my $self = $_[0];
    '(do { ' . '$MATCH->{str} = $str; ' . $self->{'closure'} . '; 1 })'
}
sub Perlito5::Rul::Block::set_captures_to_array {
    my $self = $_[0]
}
package Perlito5::Rul::Before;
sub Perlito5::Rul::Before::new {
    my $class = shift;
    bless({@_}, $class)
}
sub Perlito5::Rul::Before::rule_exp {
    $_[0]->{'rule_exp'}
}
sub Perlito5::Rul::Before::emit_perl5 {
    my $self = $_[0];
    '(do { ' . 'my $tmp = $MATCH; ' . '$MATCH = { ' . chr(39) . 'str' . chr(39) . ' => $str, ' . chr(39) . 'from' . chr(39) . ' => $tmp->{to}, ' . chr(39) . 'to' . chr(39) . ' => $tmp->{to} }; ' . 'my $res = ' . $self->{'rule_exp'}->emit_perl5() . '; ' . '$MATCH = $tmp; ' . '$res ? 1 : 0 ' . '})'
}
sub Perlito5::Rul::Before::set_captures_to_array {
    my $self = $_[0]
}
package Perlito5::Rul::NotBefore;
sub Perlito5::Rul::NotBefore::new {
    my $class = shift;
    bless({@_}, $class)
}
sub Perlito5::Rul::NotBefore::rule_exp {
    $_[0]->{'rule_exp'}
}
sub Perlito5::Rul::NotBefore::emit_perl5 {
    my $self = $_[0];
    '(do { ' . 'my $tmp = $MATCH; ' . '$MATCH = { ' . chr(39) . 'str' . chr(39) . ' => $str, ' . chr(39) . 'from' . chr(39) . ' => $tmp->{to}, ' . chr(39) . 'to' . chr(39) . ' => $tmp->{to} }; ' . 'my $res = ' . $self->{'rule_exp'}->emit_perl5() . '; ' . '$MATCH = $tmp; ' . '$res ? 0 : 1 ' . '})'
}
sub Perlito5::Rul::NotBefore::set_captures_to_array {
    my $self = $_[0]
}
1;
# use Perlito5::Emitter::Token
package main;
package Perlito5::Dumper;
sub Perlito5::Dumper::ast_dumper {
    my $seen = {};
    my $level = '';
    my $pos = '[TODO - recursive structure in AST is not supported]';
    return _dumper($_[0], $level, $seen, $pos)
}
sub Perlito5::Dumper::_dumper {
    my($obj, $tab, $seen, $pos) = @_;
    !defined($obj) && return 'undef';
    my $ref = ref($obj);
    !$ref && return escape_string($obj);
    my $as_string = $obj;
    $seen->{$as_string} && return $seen->{$as_string};
    $seen->{$as_string} = $pos;
    my $tab1 = $tab . '    ';
    if ($ref eq 'ARRAY') {
        @{$obj} || return '[]';
        my @out;
        for my $i (0 .. $#{$obj}) {
            my $here = $pos . '->[' . $i . ']';
            push(@out, $tab1, _dumper($obj->[$i], $tab1, $seen, $here), ',' . chr(10))
        }
        return join('', '[' . chr(10), @out, $tab, ']')
    }
    elsif ($ref eq 'HASH') {
        keys(%{$obj}) || return '{}';
        my @out;
        for my $i (sort(keys(%{$obj}))) {
            my $here = $pos . '->{' . $i . '}';
            push(@out, $tab1, chr(39) . $i . chr(39) . ' => ', _dumper($obj->{$i}, $tab1, $seen, $here), ',' . chr(10))
        }
        return join('', '{' . chr(10), @out, $tab, '}')
    }
    elsif ($ref eq 'SCALAR') {
        return chr(92) . _dumper(${$obj}, $tab1, $seen, $pos)
    }
    elsif ($ref eq 'CODE') {
        return 'sub { "DUMMY" }'
    }
    my @out;
    for my $i (sort(keys(%{$obj}))) {
        my $here = $pos . '->{' . $i . '}';
        push(@out, $tab1, chr(39) . $i . chr(39) . ' => ', _dumper($obj->{$i}, $tab1, $seen, $here), ',' . chr(10))
    }
    return join('', 'bless({' . chr(10), @out, $tab, '}, ' . chr(39) . $ref . chr(39) . ')')
}
my %safe_char = (' ' => 1, '!' => 1, '"' => 1, '#' => 1, '$' => 1, '%' => 1, '&' => 1, '(' => 1, ')' => 1, '*' => 1, '+' => 1, ',' => 1, '-' => 1, '.' => 1, '/' => 1, ':' => 1, ';' => 1, '<' => 1, '=' => 1, '>' => 1, '?' => 1, '@' => 1, '[' => 1, ']' => 1, '^' => 1, '_' => 1, '`' => 1, '{' => 1, '|' => 1, '}' => 1, '~' => 1);
sub Perlito5::Dumper::escape_string {
    my $s = shift;
    my @out;
    my $tmp = '';
    $s eq '' && return chr(39) . chr(39);
    (0 + $s) eq $s && $s =~ m![0-9]! && return 0 + $s;
    for my $i (0 .. length($s) - 1) {
        my $c = substr($s, $i, 1);
        if (($c ge 'a' && $c le 'z') || ($c ge 'A' && $c le 'Z') || ($c ge 0 && $c le 9) || exists($safe_char{$c})) {
            $tmp = $tmp . $c
        }
        else {
            $tmp ne '' && push(@out, chr(39) . $tmp . chr(39));
            push(@out, 'chr(' . ord($c) . ')');
            $tmp = ''
        }
    }
    $tmp ne '' && push(@out, chr(39) . $tmp . chr(39));
    return join(' . ', @out)
}
sub Perlito5::Dumper::_identity {
    $_[0] eq $_[1]
}
1;
# use Perlito5::Dumper
package main;
undef();
package Perlito5::AST::CompUnit;
sub Perlito5::AST::CompUnit::new {
    my $class = shift;
    bless({@_}, $class)
}
sub Perlito5::AST::CompUnit::name {
    $_[0]->{'name'}
}
sub Perlito5::AST::CompUnit::body {
    $_[0]->{'body'}
}
package Perlito5::AST::Int;
sub Perlito5::AST::Int::new {
    my $class = shift;
    bless({@_}, $class)
}
sub Perlito5::AST::Int::int {
    $_[0]->{'int'}
}
package Perlito5::AST::Num;
sub Perlito5::AST::Num::new {
    my $class = shift;
    bless({@_}, $class)
}
sub Perlito5::AST::Num::num {
    $_[0]->{'num'}
}
package Perlito5::AST::Buf;
sub Perlito5::AST::Buf::new {
    my $class = shift;
    bless({@_}, $class)
}
sub Perlito5::AST::Buf::buf {
    $_[0]->{'buf'}
}
package Perlito5::AST::Block;
sub Perlito5::AST::Block::new {
    my $class = shift;
    bless({@_}, $class)
}
sub Perlito5::AST::Block::sig {
    $_[0]->{'sig'}
}
sub Perlito5::AST::Block::stmts {
    $_[0]->{'stmts'}
}
package Perlito5::AST::Index;
sub Perlito5::AST::Index::new {
    my $class = shift;
    bless({@_}, $class)
}
sub Perlito5::AST::Index::obj {
    $_[0]->{'obj'}
}
sub Perlito5::AST::Index::index_exp {
    $_[0]->{'index_exp'}
}
package Perlito5::AST::Lookup;
sub Perlito5::AST::Lookup::new {
    my $class = shift;
    bless({@_}, $class)
}
sub Perlito5::AST::Lookup::obj {
    $_[0]->{'obj'}
}
sub Perlito5::AST::Lookup::index_exp {
    $_[0]->{'index_exp'}
}
sub Perlito5::AST::Lookup::autoquote {
    my $self = shift;
    my $index = shift;
    if ($index->isa('Perlito5::AST::Apply') && $index->{'bareword'}) {
        my $full_name = ($index->{'namespace'} ? $index->{'namespace'} . '::' : '') . $index->{'code'};
        if (!exists($Perlito5::PROTO->{$full_name})) {
            return Perlito5::AST::Buf::->new('buf' => $full_name)
        }
    }
    elsif ($index->isa('Perlito5::AST::Apply') && ($index->code() eq 'prefix:<->' || $index->code() eq 'prefix:<+>')) {
        my $arg = $index->arguments()->[0];
        $arg && return Perlito5::AST::Apply::->new('code' => $index->code(), 'namespace' => $index->namespace(), 'arguments' => [$self->autoquote($arg)])
    }
    elsif ($index->isa('Perlito5::AST::Apply') && ($index->code() eq 'list:<,>')) {
        my $args = $index->arguments();
        return Perlito5::AST::Apply::->new('code' => 'join', 'namespace' => '', 'arguments' => [Perlito5::AST::Var::->new('name' => ';', 'namespace' => '', 'sigil' => '$'), map {
            defined($_) ? $_ : Perlito5::AST::Buf::->new('buf' => '')
        } @{$args}])
    }
    $index
}
package Perlito5::AST::Var;
sub Perlito5::AST::Var::new {
    my($class, %args) = @_;
    my $var = bless(\%args, $class);
    push(@Perlito5::SCOPE_STMT, $var);
    return $var
}
sub Perlito5::AST::Var::sigil {
    $_[0]->{'sigil'}
}
sub Perlito5::AST::Var::namespace {
    $_[0]->{'namespace'}
}
sub Perlito5::AST::Var::name {
    $_[0]->{'name'}
}
sub Perlito5::AST::Var::plain_name {
    my $self = shift;
    if ($self->namespace()) {
        return $self->namespace() . '::' . $self->name()
    }
    return $self->name()
}
package Perlito5::AST::Call;
sub Perlito5::AST::Call::new {
    my $class = shift;
    bless({@_}, $class)
}
sub Perlito5::AST::Call::invocant {
    $_[0]->{'invocant'}
}
sub Perlito5::AST::Call::method {
    $_[0]->{'method'}
}
sub Perlito5::AST::Call::arguments {
    $_[0]->{'arguments'}
}
package Perlito5::AST::Apply;
sub Perlito5::AST::Apply::new {
    my $class = shift;
    bless({@_}, $class)
}
sub Perlito5::AST::Apply::code {
    $_[0]->{'code'}
}
sub Perlito5::AST::Apply::special_arg {
    $_[0]->{'special_arg'}
}
sub Perlito5::AST::Apply::arguments {
    $_[0]->{'arguments'}
}
sub Perlito5::AST::Apply::namespace {
    $_[0]->{'namespace'}
}
package Perlito5::AST::If;
sub Perlito5::AST::If::new {
    my $class = shift;
    bless({@_}, $class)
}
sub Perlito5::AST::If::cond {
    $_[0]->{'cond'}
}
sub Perlito5::AST::If::body {
    $_[0]->{'body'}
}
sub Perlito5::AST::If::otherwise {
    $_[0]->{'otherwise'}
}
package Perlito5::AST::When;
sub Perlito5::AST::When::new {
    my $class = shift;
    bless({@_}, $class)
}
sub Perlito5::AST::When::cond {
    $_[0]->{'cond'}
}
sub Perlito5::AST::When::body {
    $_[0]->{'body'}
}
package Perlito5::AST::While;
sub Perlito5::AST::While::new {
    my $class = shift;
    bless({@_}, $class)
}
sub Perlito5::AST::While::init {
    $_[0]->{'init'}
}
sub Perlito5::AST::While::cond {
    $_[0]->{'cond'}
}
sub Perlito5::AST::While::continue {
    $_[0]->{'continue'}
}
sub Perlito5::AST::While::body {
    $_[0]->{'body'}
}
package Perlito5::AST::For;
sub Perlito5::AST::For::new {
    my $class = shift;
    bless({@_}, $class)
}
sub Perlito5::AST::For::cond {
    $_[0]->{'cond'}
}
sub Perlito5::AST::For::continue {
    $_[0]->{'continue'}
}
sub Perlito5::AST::For::body {
    $_[0]->{'body'}
}
sub Perlito5::AST::For::topic {
    $_[0]->{'topic'}
}
package Perlito5::AST::Given;
sub Perlito5::AST::Given::new {
    my $class = shift;
    bless({@_}, $class)
}
sub Perlito5::AST::Given::cond {
    $_[0]->{'cond'}
}
sub Perlito5::AST::Given::body {
    $_[0]->{'body'}
}
package Perlito5::AST::Decl;
sub Perlito5::AST::Decl::new {
    my $class = shift;
    bless({@_}, $class)
}
sub Perlito5::AST::Decl::decl {
    $_[0]->{'decl'}
}
sub Perlito5::AST::Decl::type {
    $_[0]->{'type'}
}
sub Perlito5::AST::Decl::var {
    $_[0]->{'var'}
}
sub Perlito5::AST::Decl::attributes {
    $_[0]->{'attributes'}
}
package Perlito5::AST::Sub;
sub Perlito5::AST::Sub::new {
    my $class = shift;
    bless({@_}, $class)
}
sub Perlito5::AST::Sub::name {
    $_[0]->{'name'}
}
sub Perlito5::AST::Sub::sig {
    $_[0]->{'sig'}
}
sub Perlito5::AST::Sub::block {
    $_[0]->{'block'}
}
sub Perlito5::AST::Sub::attributes {
    $_[0]->{'attributes'}
}
package Perlito5::AST::Use;
sub Perlito5::AST::Use::new {
    my $class = shift;
    bless({@_}, $class)
}
sub Perlito5::AST::Use::mod {
    $_[0]->{'mod'}
}
sub Perlito5::AST::Use::code {
    $_[0]->{'code'}
}
1;
package main;
undef();
# use Perlito5::AST
# use Perlito5::Dumper
# use strict
package Perlito5::Javascript2;
{
    my %label;
    sub Perlito5::Javascript2::pkg {
        'p5pkg[' . Perlito5::Javascript2::escape_string($Perlito5::PKG_NAME) . ']'
    }
    sub Perlito5::Javascript2::get_label {
        'tmp' . $Perlito5::ID++
    }
    sub Perlito5::Javascript2::tab {
        my $level = shift;
        chr(9) x $level
    }
    our %op_prefix_js_str = ('prefix:<-A>' => 'p5atime', 'prefix:<-C>' => 'p5ctime', 'prefix:<-M>' => 'p5mtime', 'prefix:<-d>' => 'p5is_directory', 'prefix:<-e>' => 'p5file_exists', 'prefix:<-f>' => 'p5is_file', 'prefix:<-s>' => 'p5size');
    our %op_infix_js_str = ('infix:<eq>' => ' == ', 'infix:<ne>' => ' != ', 'infix:<le>' => ' <= ', 'infix:<ge>' => ' >= ', 'infix:<lt>' => ' < ', 'infix:<gt>' => ' > ');
    our %op_infix_js_num = ('infix:<==>' => ' == ', 'infix:<!=>' => ' != ', 'infix:<+>' => ' + ', 'infix:<->' => ' - ', 'infix:<*>' => ' * ', 'infix:</>' => ' / ', 'infix:<>>' => ' > ', 'infix:<<>' => ' < ', 'infix:<>=>' => ' >= ', 'infix:<<=>' => ' <= ', 'infix:<&>' => ' & ', 'infix:<|>' => ' | ', 'infix:<^>' => ' ^ ', 'infix:<>>>' => ' >>> ');
    our %op_to_bool = map(+($_ => 1), 'prefix:<!>', 'infix:<!=>', 'infix:<==>', 'infix:<<=>', 'infix:<>=>', 'infix:<>>', 'infix:<<>', 'infix:<eq>', 'infix:<ne>', 'infix:<ge>', 'infix:<le>', 'infix:<gt>', 'infix:<lt>', 'prefix:<not>', 'exists', 'defined');
    our %op_to_str = map(+($_ => 1), 'substr', 'join', 'list:<.>', 'chr', 'lc', 'uc', 'lcfirst', 'ucfirst', 'ref');
    our %op_to_num = map(+($_ => 1), 'length', 'index', 'ord', 'oct', 'infix:<->', 'infix:<+>', 'infix:<*>', 'infix:</>', 'infix:<%>', 'infix:<**>');
    my %safe_char = (' ' => 1, '!' => 1, '"' => 1, '#' => 1, '$' => 1, '%' => 1, '&' => 1, '(' => 1, ')' => 1, '*' => 1, '+' => 1, ',' => 1, '-' => 1, '.' => 1, '/' => 1, ':' => 1, ';' => 1, '<' => 1, '=' => 1, '>' => 1, '?' => 1, '@' => 1, '[' => 1, ']' => 1, '^' => 1, '_' => 1, '`' => 1, '{' => 1, '|' => 1, '}' => 1, '~' => 1);
    sub Perlito5::Javascript2::escape_string {
        my $s = shift;
        my @out;
        my $tmp = '';
        $s eq '' && return chr(39) . chr(39);
        for my $i (0 .. length($s) - 1) {
            my $c = substr($s, $i, 1);
            if (($c ge 'a' && $c le 'z') || ($c ge 'A' && $c le 'Z') || ($c ge 0 && $c le 9) || exists($safe_char{$c})) {
                $tmp = $tmp . $c
            }
            else {
                $tmp ne '' && push(@out, chr(39) . $tmp . chr(39));
                push(@out, 'String.fromCharCode(' . ord($c) . ')');
                $tmp = ''
            }
        }
        $tmp ne '' && push(@out, chr(39) . $tmp . chr(39));
        return join(' + ', @out)
    }
    sub Perlito5::Javascript2::to_str {
        my $cond = shift;
        my $level = shift;
        my $wantarray = 'scalar';
        if ($cond->isa('Perlito5::AST::Apply') && $cond->code() eq 'circumfix:<( )>' && $cond->{'arguments'} && @{$cond->{'arguments'}}) {
            return to_str($cond->{'arguments'}->[0], $level)
        }
        if (($cond->isa('Perlito5::AST::Buf')) || ($cond->isa('Perlito5::AST::Apply') && exists($op_to_str{$cond->code()}))) {
            return $cond->emit_javascript2($level, $wantarray)
        }
        else {
            return 'p5str(' . $cond->emit_javascript2($level, $wantarray) . ')'
        }
    }
    sub Perlito5::Javascript2::to_num {
        my $cond = shift;
        my $level = shift;
        my $wantarray = 'scalar';
        if ($cond->isa('Perlito5::AST::Int') || $cond->isa('Perlito5::AST::Num') || ($cond->isa('Perlito5::AST::Apply') && exists($op_to_num{$cond->code()}))) {
            return $cond->emit_javascript2($level, $wantarray)
        }
        else {
            return 'p5num(' . $cond->emit_javascript2($level, $wantarray) . ')'
        }
    }
    sub Perlito5::Javascript2::to_bool {
        my $cond = shift;
        my $level = shift;
        my $wantarray = 'scalar';
        if ($cond->isa('Perlito5::AST::Apply') && $cond->code() eq 'circumfix:<( )>' && $cond->{'arguments'} && @{$cond->{'arguments'}}) {
            return to_bool($cond->{'arguments'}->[0], $level)
        }
        if ($cond->isa('Perlito5::AST::Apply') && ($cond->code() eq 'infix:<&&>' || $cond->code() eq 'infix:<and>')) {
            return '(' . to_bool($cond->{'arguments'}->[0], $level) . ' && ' . to_bool($cond->{'arguments'}->[1], $level) . ')'
        }
        if ($cond->isa('Perlito5::AST::Apply') && ($cond->code() eq 'infix:<||>' || $cond->code() eq 'infix:<or>')) {
            return '(' . to_bool($cond->{'arguments'}->[0], $level) . ' || ' . to_bool($cond->{'arguments'}->[1], $level) . ')'
        }
        if (($cond->isa('Perlito5::AST::Int')) || ($cond->isa('Perlito5::AST::Num')) || ($cond->isa('Perlito5::AST::Apply') && exists($op_to_bool{$cond->code()}))) {
            return $cond->emit_javascript2($level, $wantarray)
        }
        else {
            return 'p5bool(' . $cond->emit_javascript2($level, $wantarray) . ')'
        }
    }
    sub Perlito5::Javascript2::is_scalar {
        !$_[0]->isa('Perlito5::AST::Int') && !$_[0]->isa('Perlito5::AST::Num') && !$_[0]->isa('Perlito5::AST::Buf') && !$_[0]->isa('Perlito5::AST::Sub') && !($_[0]->isa('Perlito5::AST::Var') && $_[0]->{'sigil'} eq '$') && !($_[0]->isa('Perlito5::AST::Apply') && (exists($op_to_str{$_[0]->{'code'}}) || exists($op_to_num{$_[0]->{'code'}}) || exists($op_to_bool{$_[0]->{'code'}})))
    }
    sub Perlito5::Javascript2::to_list {
        my $items = to_list_preprocess($_[0]);
        my $level = $_[1];
        my $literal_type = $_[2] || 'array';
        my $wantarray = 'list';
        my $interpolate = 0;
        for $_ (@{$items}) {
            is_scalar($_) && ($interpolate = 1)
        }
        if ($literal_type eq 'hash') {
            if (!$interpolate) {
                my @out;
                my $printable = 1;
                my @in = @{$items};
                while (@in) {
                    my $k = shift(@in);
                    my $v = shift(@in);
                    $k = $k->emit_javascript2($level, 0);
                    $k =~ m![ \[]! && ($printable = 0);
                    $v = $v ? $v->emit_javascript2($level, 0) : 'null';
                    push(@out, $k . ' : ' . $v)
                }
                $printable && return '{' . join(', ', @out) . '}'
            }
            return 'p5a_to_h(' . to_list($items, $level, 'array') . ')'
        }
        $interpolate ? ('p5list_to_a([' . join(', ', map($_->emit_javascript2($level, $wantarray), @{$items})) . '])') : ('[' . join(', ', map($_->emit_javascript2($level, $wantarray), @{$items})) . ']')
    }
    sub Perlito5::Javascript2::to_list_preprocess {
        my @items;
        for my $item (@{$_[0]}) {
            if ($item->isa('Perlito5::AST::Apply') && ($item->code() eq 'circumfix:<( )>' || $item->code() eq 'list:<,>' || $item->code() eq 'infix:<=>>')) {
                if ($item->isa('Perlito5::AST::Apply') && $item->code() eq 'infix:<=>>') {
                    $item->{'arguments'}->[0] = Perlito5::AST::Lookup::->autoquote($item->{'arguments'}->[0])
                }
                for my $arg (@{to_list_preprocess($item->arguments())}) {
                    push(@items, $arg)
                }
            }
            else {
                push(@items, $item)
            }
        }
        return \@items
    }
    sub Perlito5::Javascript2::to_scalar {
        my $items = to_scalar_preprocess($_[0]);
        my $level = $_[1];
        my $wantarray = 'scalar';
        @{$items} ? '(' . join(', ', map($_->emit_javascript2($level, $wantarray), @{$items})) . ')' : 'null'
    }
    sub Perlito5::Javascript2::to_scalar_preprocess {
        my @items;
        for my $item (@{$_[0]}) {
            if ($item->isa('Perlito5::AST::Apply') && ($item->code() eq 'list:<,>' || $item->code() eq 'infix:<=>>')) {
                if ($item->isa('Perlito5::AST::Apply') && $item->code() eq 'infix:<=>>') {
                    $item->{'arguments'}->[0] = Perlito5::AST::Lookup::->autoquote($item->{'arguments'}->[0])
                }
                for my $arg (@{to_scalar_preprocess($item->arguments())}) {
                    push(@items, $arg)
                }
            }
            else {
                push(@items, $item)
            }
        }
        return \@items
    }
    sub Perlito5::Javascript2::to_runtime_context {
        my $items = to_scalar_preprocess($_[0]);
        my $level = $_[1];
        my $wantarray = 'runtime';
        @{$items} == 1 && is_scalar($items->[0]) && return $items->[0]->emit_javascript2($level, $wantarray);
        'p5context(' . '[' . join(', ', map($_->emit_javascript2($level, $wantarray), @{$items})) . ']' . ', p5want)'
    }
    sub Perlito5::Javascript2::to_context {
        my $wantarray = shift;
        $wantarray eq 'list' ? 1 : $wantarray eq 'scalar' ? 0 : $wantarray eq 'void' ? 'null' : 'p5want'
    }
    sub Perlito5::Javascript2::autoquote {
        my $index = shift;
        my $level = shift;
        $index = Perlito5::AST::Lookup::->autoquote($index);
        return to_str($index, $level)
    }
    sub Perlito5::Javascript2::emit_javascript2_autovivify {
        my $obj = shift;
        my $level = shift;
        my $type = shift;
        if ($obj->isa('Perlito5::AST::Index') || $obj->isa('Perlito5::AST::Lookup') || $obj->isa('Perlito5::AST::Call')) {
            return $obj->emit_javascript2($level, 0, $type)
        }
        if ($obj->isa('Perlito5::AST::Apply') && $obj->code() eq 'prefix:<$>') {
            my $arg = $obj->{'arguments'}->[0];
            return 'p5scalar_deref(' . $arg->emit_javascript2($level) . ', ' . Perlito5::Javascript2::escape_string($Perlito5::PKG_NAME) . ', ' . Perlito5::Javascript2::escape_string($type) . ')'
        }
        if ($obj->isa('Perlito5::AST::Apply')) {
            return $obj->emit_javascript2($level)
        }
        if ($obj->isa('Perlito5::AST::Buf')) {
            return $obj->emit_javascript2($level)
        }
        '(' . $obj->emit_javascript2($level) . ' || (' . $obj->emit_javascript2($level) . ' = ' . ($type eq 'array' ? 'new p5ArrayRef([])' : $type eq 'hash' ? 'new p5HashRef({})' : 'new p5ScalarRef(null)') . ')' . ')'
    }
    sub Perlito5::Javascript2::emit_javascript2_list_with_tabs {
        my($level, $argument) = @_;
        my $tab = Perlito5::Javascript2::tab($level);
        return map {
            ref($_) eq 'ARRAY' ? emit_javascript2_list_with_tabs($level + 1, $_) : $tab . $_
        } @{$argument}
    }
    sub Perlito5::Javascript2::emit_func_javascript2 {
        my($level, $wantarray, @argument) = @_;
        return join(chr(10), 'function () {', emit_javascript2_list_with_tabs($level, [\@argument, '}']))
    }
    sub Perlito5::Javascript2::emit_wrap_javascript2 {
        my($level, $wantarray, @argument) = @_;
        return join(chr(10), '(function () {', emit_javascript2_list_with_tabs($level, [\@argument, '})()']))
    }
    sub Perlito5::Javascript2::emit_function_javascript2 {
        my($level, $wantarray, $argument) = @_;
        if ($argument->isa('Perlito5::AST::Apply') && ($argument->code() eq 'return' || $argument->code() eq 'last' || $argument->code() eq 'next' || $argument->code() eq 'redo')) {
            emit_func_javascript2($level, $wantarray, $argument->emit_javascript2($level, $wantarray))
        }
        else {
            emit_func_javascript2($level, $wantarray, 'return ' . $argument->emit_javascript2($level + 1, $wantarray))
        }
    }
    sub Perlito5::Javascript2::emit_wrap_statement_javascript2 {
        my($level, $wantarray, $argument) = @_;
        if ($wantarray eq 'void') {
            return $argument
        }
        emit_wrap_javascript2($level, $wantarray, $argument)
    }
}
package Perlito5::Javascript2::LexicalBlock;
{
    sub Perlito5::Javascript2::LexicalBlock::new {
        my $class = shift;
        bless({@_}, $class)
    }
    sub Perlito5::Javascript2::LexicalBlock::block {
        $_[0]->{'block'}
    }
    sub Perlito5::Javascript2::LexicalBlock::has_decl {
        my $self = $_[0];
        my $type = $_[1];
        for my $decl (@{$self->{'block'}}) {
            grep {
                $_->{'decl'} eq $type
            } $decl->emit_javascript2_get_decl() && return 1
        }
        return 0
    }
    sub Perlito5::Javascript2::LexicalBlock::emit_javascript2_subroutine_body {
        my($self, $level, $wantarray) = @_;
        $self->{'top_level'} = 1;
        my $outer_throw = $Perlito5::THROW;
        $Perlito5::THROW = 0;
        my $s = $self->emit_javascript2($level, $wantarray);
        $Perlito5::THROW = $outer_throw;
        return $s
    }
    sub Perlito5::Javascript2::LexicalBlock::emit_javascript2 {
        my($self, $level, $wantarray) = @_;
        my $original_level = $level;
        my @block;
        for my $stmt (@{$self->{'block'}}) {
            if (defined($stmt)) {
                push(@block, $stmt)
            }
        }
        if (!@block) {
            $wantarray eq 'list' && return 'return []';
            $wantarray eq 'scalar' && return 'return null';
            $wantarray eq 'runtime' && return 'return p5want ? [] : null';
            return 'null;'
        }
        my @str;
        my $has_local = $self->has_decl('local');
        my $has_regex = 0;
        if (grep {
            $_->emit_javascript2_has_regex()
        } @block) {
            $has_local = 1;
            $has_regex = 1
        }
        my $create_context = $self->{'create_context'} && $self->has_decl('my');
        my $outer_pkg = $Perlito5::PKG_NAME;
        if ($self->{'top_level'} || $create_context) {
            $level++
        }
        my $last_statement;
        if ($wantarray ne 'void') {
            $last_statement = pop(@block)
        }
        for my $decl (@block) {
            if (ref($decl) eq 'Perlito5::AST::Apply' && $decl->code() eq 'package') {
                $Perlito5::PKG_NAME = $decl->{'namespace'}
            }
            my @var_decl = $decl->emit_javascript2_get_decl();
            for my $arg (@var_decl) {
                push(@str, $arg->emit_javascript2_init($level, $wantarray))
            }
            if (!($decl->isa('Perlito5::AST::Decl') && $decl->decl() eq 'my')) {
                push(@str, $decl->emit_javascript2($level, 'void') . ';')
            }
        }
        if ($last_statement) {
            my @var_decl = $last_statement->emit_javascript2_get_decl();
            for my $arg (@var_decl) {
                push(@str, $arg->emit_javascript2_init($level, $wantarray))
            }
            if ($last_statement->isa('Perlito5::AST::Apply') && $last_statement->code() eq 'return' && $self->{'top_level'} && @{$last_statement->{'arguments'}}) {
                $last_statement = $last_statement->{'arguments'}->[0]
            }
            if ($last_statement->isa('Perlito5::AST::For') || $last_statement->isa('Perlito5::AST::While') || $last_statement->isa('Perlito5::AST::If') || $last_statement->isa('Perlito5::AST::Block') || $last_statement->isa('Perlito5::AST::Use') || $last_statement->isa('Perlito5::AST::Apply') && $last_statement->code() eq 'goto' || $last_statement->isa('Perlito5::AST::Apply') && $last_statement->code() eq 'return') {
                push(@str, $last_statement->emit_javascript2($level, $wantarray))
            }
            elsif ($has_local) {
                push(@str, 'return p5cleanup_local(local_idx, (' . ($wantarray eq 'runtime' ? Perlito5::Javascript2::to_runtime_context([$last_statement], $level + 1) : $wantarray eq 'scalar' ? Perlito5::Javascript2::to_scalar([$last_statement], $level + 1) : $last_statement->emit_javascript2($level, $wantarray)) . '));')
            }
            else {
                push(@str, 'return (' . ($wantarray eq 'runtime' ? Perlito5::Javascript2::to_runtime_context([$last_statement], $level + 1) : $wantarray eq 'scalar' ? Perlito5::Javascript2::to_scalar([$last_statement], $level + 1) : $last_statement->emit_javascript2($level, $wantarray)) . ');')
            }
        }
        if ($has_local) {
            unshift(@str, ('var local_idx = p5LOCAL.length;', ($has_regex ? ('var regex_tmp = p5_regex_capture;', 'p5LOCAL.push(function(){ p5_regex_capture = regex_tmp });') : ())));
            push(@str, 'p5cleanup_local(local_idx, null);')
        }
        my $out;
        if ($self->{'top_level'} && $Perlito5::THROW) {
            $level = $original_level;
            my $tab = chr(10) . Perlito5::Javascript2::tab($level + 1);
            $out = 'try {' . $tab . join($tab, @str) . chr(10) . Perlito5::Javascript2::tab($level) . '}' . chr(10) . Perlito5::Javascript2::tab($level) . 'catch(err) {' . chr(10) . Perlito5::Javascript2::tab($level + 1) . 'if ( err instanceof Error ) {' . chr(10) . Perlito5::Javascript2::tab($level + 2) . 'throw(err);' . chr(10) . Perlito5::Javascript2::tab($level + 1) . '}' . chr(10) . Perlito5::Javascript2::tab($level + 1) . 'else {' . chr(10) . Perlito5::Javascript2::tab($level + 2) . ($has_local ? 'return p5cleanup_local(local_idx, err)' : 'return(err)') . ';' . chr(10) . Perlito5::Javascript2::tab($level + 1) . '}' . chr(10) . Perlito5::Javascript2::tab($level) . '}'
        }
        elsif ($create_context) {
            $level = $original_level;
            my $tab = chr(10) . Perlito5::Javascript2::tab($level + 1);
            $out = '(function () {' . $tab . join($tab, @str) . chr(10) . Perlito5::Javascript2::tab($level) . '})();'
        }
        else {
            $level = $original_level;
            my $tab = chr(10) . Perlito5::Javascript2::tab($level);
            $out = join($tab, @str)
        }
        $Perlito5::PKG_NAME = $outer_pkg;
        return $out
    }
    sub Perlito5::Javascript2::LexicalBlock::emit_javascript2_has_regex {
        ()
    }
}
package Perlito5::AST::CompUnit;
{
    sub Perlito5::AST::CompUnit::emit_javascript2 {
        my($self, $level, $wantarray) = @_;
        return Perlito5::Javascript2::emit_wrap_javascript2($level, $wantarray, Perlito5::Javascript2::LexicalBlock::->new('block' => $self->{'body'})->emit_javascript2($level + 1, $wantarray))
    }
    sub Perlito5::AST::CompUnit::emit_javascript2_program {
        my($comp_units, %options) = @_;
        $Perlito5::PKG_NAME = 'main';
        my $level = 0;
        my $wantarray = 'void';
        my $str;
        if ($options{'expand_use'}) {
            $str .= Perlito5::Javascript2::Runtime::->emit_javascript2();
            $str .= Perlito5::Javascript2::Array::->emit_javascript2();
            $str .= Perlito5::Javascript2::CORE::->emit_javascript2();
            $str .= Perlito5::Javascript2::IO::->emit_javascript2();
            $str .= Perlito5::Javascript2::Sprintf::->emit_javascript2()
        }
        $str .= 'var p5want;' . chr(10) . 'var List__ = [];' . chr(10);
        for my $comp_unit (@{$comp_units}) {
            $str = $str . $comp_unit->emit_javascript2($level, $wantarray) . chr(10)
        }
        return $str
    }
    sub Perlito5::AST::CompUnit::emit_javascript2_get_decl {
        ()
    }
    sub Perlito5::AST::CompUnit::emit_javascript2_has_regex {
        ()
    }
}
package Perlito5::AST::Int;
{
    sub Perlito5::AST::Int::emit_javascript2 {
        my($self, $level, $wantarray) = @_;
        $self->{'int'}
    }
    sub Perlito5::AST::Int::emit_javascript2_get_decl {
        ()
    }
    sub Perlito5::AST::Int::emit_javascript2_has_regex {
        ()
    }
}
package Perlito5::AST::Num;
{
    sub Perlito5::AST::Num::emit_javascript2 {
        my($self, $level, $wantarray) = @_;
        $self->{'num'}
    }
    sub Perlito5::AST::Num::emit_javascript2_get_decl {
        ()
    }
    sub Perlito5::AST::Num::emit_javascript2_has_regex {
        ()
    }
}
package Perlito5::AST::Buf;
{
    sub Perlito5::AST::Buf::emit_javascript2 {
        my($self, $level, $wantarray) = @_;
        Perlito5::Javascript2::escape_string($self->{'buf'})
    }
    sub Perlito5::AST::Buf::emit_javascript2_get_decl {
        ()
    }
    sub Perlito5::AST::Buf::emit_javascript2_has_regex {
        ()
    }
}
package Perlito5::AST::Block;
{
    sub Perlito5::AST::Block::emit_javascript2 {
        my($self, $level, $wantarray) = @_;
        my $body;
        if ($wantarray ne 'void') {
            $body = Perlito5::Javascript2::LexicalBlock::->new('block' => $self->{'stmts'})
        }
        else {
            $body = Perlito5::Javascript2::LexicalBlock::->new('block' => $self->{'stmts'})
        }
        my $init = '';
        if ($self->{'name'} eq 'INIT') {
            my $tmp = 'p5pkg.main.' . Perlito5::Javascript2::get_label();
            $init = Perlito5::Javascript2::tab($level + 2) . 'if (' . $tmp . ') { return }; ' . $tmp . ' = 1;' . chr(10)
        }
        return 'p5for_lex(' . 'function () {' . chr(10) . $init . Perlito5::Javascript2::tab($level + 2) . $body->emit_javascript2($level + 2, $wantarray) . chr(10) . Perlito5::Javascript2::tab($level + 1) . '}, ' . '[0], ' . $self->emit_javascript2_continue($level, $wantarray) . ', ' . Perlito5::Javascript2::escape_string($self->{'label'} || '') . chr(10) . Perlito5::Javascript2::tab($level) . ')'
    }
    sub Perlito5::AST::Block::emit_javascript2_continue {
        my $self = shift;
        my $level = shift;
        my $wantarray = shift;
        if (!$self->{'continue'} || !@{$self->{'continue'}->{'stmts'}}) {
            return 'false'
        }
        return 'function () {' . chr(10) . (Perlito5::Javascript2::LexicalBlock::->new('block' => $self->{'continue'}->stmts()))->emit_javascript2($level + 2, $wantarray) . chr(10) . Perlito5::Javascript2::tab($level + 1) . '}'
    }
    sub Perlito5::AST::Block::emit_javascript2_get_decl {
        ()
    }
    sub Perlito5::AST::Block::emit_javascript2_has_regex {
        ()
    }
}
package Perlito5::AST::Index;
{
    sub Perlito5::AST::Index::emit_javascript2 {
        my($self, $level, $wantarray, $autovivification_type) = @_;
        my $method = $autovivification_type || 'p5aget';
        $autovivification_type eq 'array' && ($method = 'p5aget_array');
        $autovivification_type eq 'hash' && ($method = 'p5aget_hash');
        if (($self->{'obj'}->isa('Perlito5::AST::Apply') && $self->{'obj'}->{'code'} eq 'prefix:<@>') || ($self->{'obj'}->isa('Perlito5::AST::Var') && $self->{'obj'}->sigil() eq '@') || ($self->{'obj'}->isa('Perlito5::AST::Apply') && $self->{'obj'}->code() eq 'circumfix:<( )>')) {
            return 'p5list_slice(' . $self->{'obj'}->emit_javascript2($level, 'list') . ', ' . Perlito5::Javascript2::to_list([$self->{'index_exp'}], $level) . ', ' . Perlito5::Javascript2::to_context($wantarray) . ')'
        }
        if (($self->{'obj'}->isa('Perlito5::AST::Apply') && $self->{'obj'}->{'code'} eq 'prefix:<%>') || ($self->{'obj'}->isa('Perlito5::AST::Var') && $self->{'obj'}->sigil() eq '%')) {
            my $obj = $self->{'obj'};
            $obj->{'sigil'} eq '%' && ($obj->{'sigil'} = '@');
            $obj->{'code'} eq 'prefix:<%>' && ($obj->{'code'} = 'prefix:<@>');
            return 'p5hash_slice(' . $self->{'obj'}->emit_javascript2($level, 'list') . ', ' . Perlito5::Javascript2::to_list([$self->{'index_exp'}], $level) . ', ' . Perlito5::Javascript2::to_context($wantarray) . ')'
        }
        return $self->emit_javascript2_container($level) . '.' . $method . '(' . Perlito5::Javascript2::to_num($self->{'index_exp'}, $level) . ')'
    }
    sub Perlito5::AST::Index::emit_javascript2_set {
        my($self, $arguments, $level, $wantarray) = @_;
        if (($self->{'obj'}->isa('Perlito5::AST::Apply') && $self->{'obj'}->{'code'} eq 'prefix:<@>') || ($self->{'obj'}->isa('Perlito5::AST::Var') && $self->{'obj'}->sigil() eq '@')) {
            return Perlito5::Javascript2::emit_wrap_javascript2($level, $wantarray, 'var a = [];', 'var v = ' . Perlito5::Javascript2::to_list([$self->{'index_exp'}], $level) . ';', 'var src=' . Perlito5::Javascript2::to_list([$arguments], $level) . ';', 'var out=' . Perlito5::Javascript2::emit_javascript2_autovivify($self->{'obj'}, $level, 'array') . ';', 'var tmp' . ';', 'for (var i=0, l=v.length; i<l; ++i) {', ['tmp = src.p5aget(i);', 'out.p5aset(v[i], tmp);', 'a.push(tmp)'], '}', 'return a')
        }
        return $self->emit_javascript2_container($level) . '.p5aset(' . Perlito5::Javascript2::to_num($self->{'index_exp'}, $level + 1) . ', ' . Perlito5::Javascript2::to_scalar([$arguments], $level + 1) . ')'
    }
    sub Perlito5::AST::Index::emit_javascript2_set_list {
        my($self, $level, $list) = @_;
        my $wantarray = 'list';
        if (($self->{'obj'}->isa('Perlito5::AST::Apply') && $self->{'obj'}->{'code'} eq 'prefix:<@>') || ($self->{'obj'}->isa('Perlito5::AST::Var') && $self->{'obj'}->sigil() eq '@')) {
            return Perlito5::Javascript2::emit_wrap_javascript2($level, $wantarray, 'var a = [];', 'var v = ' . Perlito5::Javascript2::to_list([$self->{'index_exp'}], $level) . ';', 'var out=' . Perlito5::Javascript2::emit_javascript2_autovivify($self->{'obj'}, $level, 'array') . ';', 'var tmp' . ';', 'for (var i=0, l=v.length; i<l; ++i) {', ['tmp = ' . $list . '.shift();', 'out.p5aset(v[i], tmp);', 'a.push(tmp)'], '}', 'return a')
        }
        return $self->emit_javascript2_container($level) . '.p5aset(' . Perlito5::Javascript2::to_num($self->{'index_exp'}, $level + 1) . ', ' . $list . '.shift()' . ')'
    }
    sub Perlito5::AST::Index::emit_javascript2_container {
        my $self = shift;
        my $level = shift;
        if ($self->{'obj'}->isa('Perlito5::AST::Apply') && $self->{'obj'}->{'code'} eq 'prefix:<$>') {
            my $v = Perlito5::AST::Apply::->new(%{$self->{'obj'}}, 'code' => 'prefix:<@>');
            return $v->emit_javascript2($level)
        }
        if ($self->{'obj'}->isa('Perlito5::AST::Apply') && $self->{'obj'}->code() eq 'circumfix:<( )>') {
            return Perlito5::Javascript2::to_list([$self->{'obj'}], $level)
        }
        if ($self->{'obj'}->isa('Perlito5::AST::Var') && $self->{'obj'}->sigil() eq '$') {
            $self->{'obj'}->{'sigil'} = '@';
            return $self->{'obj'}->emit_javascript2($level)
        }
        else {
            return Perlito5::Javascript2::emit_javascript2_autovivify($self->{'obj'}, $level, 'array') . '._array_'
        }
    }
    sub Perlito5::AST::Index::emit_javascript2_get_decl {
        ()
    }
    sub Perlito5::AST::Index::emit_javascript2_has_regex {
        ()
    }
}
package Perlito5::AST::Lookup;
{
    sub Perlito5::AST::Lookup::emit_javascript2 {
        my($self, $level, $wantarray, $autovivification_type) = @_;
        my $method = $autovivification_type || 'p5hget';
        $autovivification_type eq 'array' && ($method = 'p5hget_array');
        $autovivification_type eq 'hash' && ($method = 'p5hget_hash');
        if (($self->{'obj'}->isa('Perlito5::AST::Apply') && $self->{'obj'}->{'code'} eq 'prefix:<@>') || ($self->{'obj'}->isa('Perlito5::AST::Var') && $self->{'obj'}->sigil() eq '@')) {
            my $v;
            if ($self->{'obj'}->isa('Perlito5::AST::Var')) {
                $v = $self->{'obj'}
            }
            $self->{'obj'}->isa('Perlito5::AST::Apply') && ($v = Perlito5::AST::Apply::->new('code' => 'prefix:<%>', 'namespace' => $self->{'obj'}->namespace(), 'arguments' => $self->{'obj'}->arguments()));
            return 'p5list_lookup_slice(' . $v->emit_javascript2($level, 'list') . ', ' . Perlito5::Javascript2::to_list([$self->{'index_exp'}], $level) . ', ' . Perlito5::Javascript2::to_context($wantarray) . ')'
        }
        if (($self->{'obj'}->isa('Perlito5::AST::Apply') && $self->{'obj'}->{'code'} eq 'prefix:<%>') || ($self->{'obj'}->isa('Perlito5::AST::Var') && $self->{'obj'}->sigil() eq '%')) {
            my $v;
            if ($self->{'obj'}->isa('Perlito5::AST::Var')) {
                $v = $self->{'obj'}
            }
            $self->{'obj'}->isa('Perlito5::AST::Apply') && ($v = Perlito5::AST::Apply::->new('code' => 'prefix:<%>', 'namespace' => $self->{'obj'}->namespace(), 'arguments' => $self->{'obj'}->arguments()));
            return 'p5hash_lookup_slice(' . $v->emit_javascript2($level, 'list') . ', ' . Perlito5::Javascript2::to_list([$self->{'index_exp'}], $level) . ', ' . Perlito5::Javascript2::to_context($wantarray) . ')'
        }
        return $self->emit_javascript2_container($level) . '.' . $method . '(' . Perlito5::Javascript2::autoquote($self->{'index_exp'}, $level) . ')'
    }
    sub Perlito5::AST::Lookup::emit_javascript2_set {
        my($self, $arguments, $level, $wantarray) = @_;
        if (($self->{'obj'}->isa('Perlito5::AST::Apply') && $self->{'obj'}->{'code'} eq 'prefix:<@>') || ($self->{'obj'}->isa('Perlito5::AST::Var') && $self->{'obj'}->sigil() eq '@')) {
            my $v;
            $self->{'obj'}->isa('Perlito5::AST::Var') && ($v = $self->{'obj'});
            $self->{'obj'}->isa('Perlito5::AST::Apply') && ($v = Perlito5::AST::Apply::->new('code' => 'prefix:<%>', 'namespace' => $self->{'obj'}->namespace(), 'arguments' => $self->{'obj'}->arguments()));
            return Perlito5::Javascript2::emit_wrap_javascript2($level, $wantarray, 'var a = [];', 'var v = ' . Perlito5::Javascript2::to_list([$self->{'index_exp'}], $level) . ';', 'var src=' . Perlito5::Javascript2::to_list([$arguments], $level) . ';', 'var out=' . $v->emit_javascript2($level) . ';', 'var tmp' . ';', 'for (var i=0, l=v.length; i<l; ++i)' . '{', ['tmp = src.p5hget(i);', 'out.p5hset(v[i], tmp);', 'a.push(tmp)'], '}', 'return a')
        }
        return $self->emit_javascript2_container($level) . '.p5hset(' . Perlito5::Javascript2::autoquote($self->{'index_exp'}, $level) . ', ' . Perlito5::Javascript2::to_scalar([$arguments], $level + 1) . ')'
    }
    sub Perlito5::AST::Lookup::emit_javascript2_set_list {
        my($self, $level, $list) = @_;
        my $wantarray = 'list';
        if (($self->{'obj'}->isa('Perlito5::AST::Apply') && $self->{'obj'}->{'code'} eq 'prefix:<@>') || ($self->{'obj'}->isa('Perlito5::AST::Var') && $self->{'obj'}->sigil() eq '@')) {
            my $v;
            $self->{'obj'}->isa('Perlito5::AST::Var') && ($v = $self->{'obj'});
            $self->{'obj'}->isa('Perlito5::AST::Apply') && ($v = Perlito5::AST::Apply::->new('code' => 'prefix:<%>', 'namespace' => $self->{'obj'}->namespace(), 'arguments' => $self->{'obj'}->arguments()));
            return Perlito5::Javascript2::emit_wrap_javascript2($level, $wantarray, 'var a = [];', 'var v = ' . Perlito5::Javascript2::to_list([$self->{'index_exp'}], $level) . ';', 'var out=' . $v->emit_javascript2($level) . ';', 'var tmp' . ';', 'for (var i=0, l=v.length; i<l; ++i)' . '{', ['tmp = ' . $list . '.shift();', 'out.p5hset(v[i], tmp);', 'a.push(tmp)'], '}', 'return a')
        }
        return $self->emit_javascript2_container($level) . '.p5hset(' . Perlito5::Javascript2::autoquote($self->{'index_exp'}, $level) . ', ' . $list . '.shift()' . ')'
    }
    sub Perlito5::AST::Lookup::emit_javascript2_container {
        my $self = shift;
        my $level = shift;
        if ($self->{'obj'}->isa('Perlito5::AST::Apply') && $self->{'obj'}->{'code'} eq 'prefix:<$>') {
            my $v = Perlito5::AST::Apply::->new(%{$self->{'obj'}}, 'code' => 'prefix:<%>');
            return $v->emit_javascript2($level)
        }
        if ($self->{'obj'}->isa('Perlito5::AST::Var') && $self->{'obj'}->sigil() eq '$') {
            my $v = Perlito5::AST::Var::->new(%{$self->{'obj'}}, 'sigil' => '%');
            return $v->emit_javascript2($level)
        }
        else {
            return Perlito5::Javascript2::emit_javascript2_autovivify($self->{'obj'}, $level, 'hash') . '._hash_'
        }
    }
    sub Perlito5::AST::Lookup::emit_javascript2_get_decl {
        ()
    }
    sub Perlito5::AST::Lookup::emit_javascript2_has_regex {
        ()
    }
}
package Perlito5::AST::Var;
{
    my $table = {'$' => 'v_', '@' => 'List_', '%' => 'Hash_', '&' => ''};
    sub Perlito5::AST::Var::emit_javascript2_global {
        my($self, $level, $wantarray) = @_;
        my $str_name = $self->{'name'};
        my $sigil = $self->{'_real_sigil'} || $self->{'sigil'};
        my $namespace = $self->{'namespace'} || $self->{'_namespace'};
        if ($sigil eq '@' && $self->{'name'} eq '_' && $namespace eq 'main') {
            my $s = 'List__';
            if ($self->{'sigil'} eq '$#') {
                return '(' . $s . '.length - 1)'
            }
            if ($wantarray eq 'scalar') {
                return $s . '.length'
            }
            if ($wantarray eq 'runtime') {
                return '(p5want' . ' ? ' . $s . ' : ' . $s . '.length' . ')'
            }
            return $s
        }
        if ($sigil eq '$' && $self->{'name'} > 0) {
            return 'p5_regex_capture[' . ($self->{'name'} - 1) . ']'
        }
        if ($sigil eq '::') {
            $self->{'namespace'} eq '__PACKAGE__' && return Perlito5::Javascript2::pkg();
            $self->{'namespace'} eq '__SUB__' && return $Perlito5::AST::Sub::SUB_REF // '__SUB__';
            return Perlito5::Javascript2::escape_string($namespace)
        }
        my $s = 'p5make_package(' . Perlito5::Javascript2::escape_string($namespace) . ')[' . Perlito5::Javascript2::escape_string($table->{$sigil} . $str_name) . ']';
        if ($sigil eq '*') {
            return $s
        }
        if ($sigil eq '&') {
            return $s . '(List__, ' . Perlito5::Javascript2::to_context($wantarray) . ')'
        }
        if ($sigil eq '@') {
            $s = $s . ' || (' . $s . ' = [])';
            $s = 'p5pkg[' . $s . ', ' . Perlito5::Javascript2::escape_string($namespace) . '][' . Perlito5::Javascript2::escape_string($table->{$sigil} . $str_name) . ']';
            if ($self->{'sigil'} eq '$#') {
                return '(' . $s . '.length - 1)'
            }
            if ($wantarray eq 'scalar') {
                return $s . '.length'
            }
        }
        elsif ($sigil eq '%') {
            $s = $s . ' || (' . $s . ' = {})';
            $s = 'p5pkg[' . $s . ', ' . Perlito5::Javascript2::escape_string($namespace) . '][' . Perlito5::Javascript2::escape_string($table->{$sigil} . $str_name) . ']'
        }
        return $s
    }
    sub Perlito5::AST::Var::emit_javascript2 {
        my($self, $level, $wantarray) = @_;
        my $sigil = $self->{'_real_sigil'} || $self->{'sigil'};
        my $str_name = $self->{'name'};
        my $decl_type = $self->{'_decl'} || 'global';
        if ($decl_type ne 'my') {
            return $self->emit_javascript2_global($level, $wantarray)
        }
        if ($sigil eq '@') {
            if ($wantarray eq 'scalar') {
                return $self->emit_javascript2($level, 'list') . '.length'
            }
            if ($wantarray eq 'runtime') {
                return '(p5want' . ' ? ' . $self->emit_javascript2($level, 'list') . ' : ' . $self->emit_javascript2($level, 'list') . '.length' . ')'
            }
        }
        if ($self->{'sigil'} eq '$#') {
            return '(' . $table->{'@'} . $str_name . '.length - 1)'
        }
        $table->{$sigil} . $str_name
    }
    sub Perlito5::AST::Var::emit_javascript2_set {
        my($self, $arguments, $level, $wantarray) = @_;
        my $open = $wantarray eq 'void' ? '' : '(';
        my $close = $wantarray eq 'void' ? '' : ')';
        my $sigil = $self->{'_real_sigil'} || $self->{'sigil'};
        if ($sigil eq '$') {
            return $open . $self->emit_javascript2() . ' = ' . Perlito5::Javascript2::to_scalar([$arguments], $level + 1) . $close
        }
        if ($sigil eq '@') {
            if ($self->{'sigil'} eq '$#') {
                $self->{'sigil'} = '@';
                return $open . $self->emit_javascript2() . '.length = 1 + ' . Perlito5::Javascript2::to_scalar([$arguments], $level + 1) . $close
            }
            return $open . $self->emit_javascript2() . ' = ' . Perlito5::Javascript2::to_list([$arguments], $level + 1) . $close
        }
        if ($sigil eq '%') {
            return $open . $self->emit_javascript2() . ' = ' . Perlito5::Javascript2::to_list([$arguments], $level + 1, 'hash') . $close
        }
        if ($sigil eq '*') {
            my $namespace = $self->{'namespace'} || $self->{'_namespace'};
            return 'p5typeglob_set(' . Perlito5::Javascript2::escape_string($namespace) . ', ' . Perlito5::Javascript2::escape_string($self->{'name'}) . ', ' . Perlito5::Javascript2::to_scalar([$arguments], $level + 1) . ')'
        }
        die('don' . chr(39) . 't know how to assign to variable ', $sigil, $self->name())
    }
    sub Perlito5::AST::Var::emit_javascript2_set_list {
        my($self, $level, $list) = @_;
        my $sigil = $self->{'_real_sigil'} || $self->{'sigil'};
        if ($sigil eq '$') {
            return $self->emit_javascript2() . ' = ' . $list . '.shift()'
        }
        if ($sigil eq '@') {
            return join(';' . chr(10) . Perlito5::Javascript2::tab($level), $self->emit_javascript2() . ' = ' . $list, $list . ' = []')
        }
        if ($sigil eq '%') {
            return join(';' . chr(10) . Perlito5::Javascript2::tab($level), $self->emit_javascript2() . ' = p5a_to_h(' . $list . ')', $list . ' = []')
        }
        die('don' . chr(39) . 't know how to assign to variable ', $sigil, $self->name())
    }
    sub Perlito5::AST::Var::emit_javascript2_get_decl {
        ()
    }
    sub Perlito5::AST::Var::emit_javascript2_has_regex {
        ()
    }
}
package Perlito5::AST::Decl;
{
    sub Perlito5::AST::Decl::emit_javascript2 {
        my($self, $level, $wantarray) = @_;
        $self->{'var'}->emit_javascript2($level)
    }
    sub Perlito5::AST::Decl::emit_javascript2_init {
        my($self, $level, $wantarray) = @_;
        if ($self->{'decl'} eq 'local') {
            my $var = $self->{'var'};
            my $var_set;
            my $tmp_name = Perlito5::Javascript2::get_label();
            if (ref($var) eq 'Perlito5::AST::Var') {
                $var_set = $var->emit_javascript2() . ' = v_' . $tmp_name
            }
            else {
                my $tmp = Perlito5::AST::Var::->new('sigil' => '$', 'name' => $tmp_name, '_decl' => 'my');
                $var_set = $var->emit_javascript2_set($tmp)
            }
            return Perlito5::Javascript2::emit_wrap_javascript2($level, $wantarray, 'var v_' . $tmp_name . ' = ' . $var->emit_javascript2() . ';', 'p5LOCAL.push(function(){ ' . $var_set . ' });', 'return ' . $var->emit_javascript2_set(Perlito5::AST::Apply::->new('code' => 'undef', 'arguments' => [], 'namespace' => ''), $level + 1) . ';') . ';'
        }
        if ($self->{'decl'} eq 'my') {
            my $str = 'var ' . $self->{'var'}->emit_javascript2();
            if ($self->{'var'}->sigil() eq '%') {
                $str = $str . ' = {};'
            }
            elsif ($self->{'var'}->sigil() eq '@') {
                $str = $str . ' = [];'
            }
            else {
                $str = $str . ';'
            }
            return $str
        }
        elsif ($self->{'decl'} eq 'our') {
            my $str = $self->{'var'}->emit_javascript2();
            if ($self->{'var'}->sigil() eq '%') {
                $str = $str . ' = {};'
            }
            elsif ($self->{'var'}->sigil() eq '@') {
                $str = $str . ' = [];'
            }
            else {
                return '// our ' . $str
            }
            return 'if (typeof ' . $self->{'var'}->emit_javascript2() . ' == "undefined" ) { ' . $str . '}'
        }
        elsif ($self->{'decl'} eq 'state') {
            return '// state ' . $self->{'var'}->emit_javascript2()
        }
        else {
            die('not implemented: Perlito5::AST::Decl ' . chr(39) . $self->{'decl'} . chr(39))
        }
    }
    sub Perlito5::AST::Decl::emit_javascript2_set {
        my($self, $arguments, $level, $wantarray) = @_;
        $self->var()->emit_javascript2_set($arguments, $level, $wantarray)
    }
    sub Perlito5::AST::Decl::emit_javascript2_set_list {
        my($self, $level, $list) = @_;
        $self->var()->emit_javascript2_set_list($level, $list)
    }
    sub Perlito5::AST::Decl::emit_javascript2_get_decl {
        my $self = shift;
        return ($self)
    }
    sub Perlito5::AST::Decl::emit_javascript2_has_regex {
        ()
    }
}
package Perlito5::AST::Call;
{
    sub Perlito5::AST::Call::emit_javascript2 {
        my($self, $level, $wantarray, $autovivification_type) = @_;
        my $meth = $self->{'method'};
        if ($meth eq 'postcircumfix:<[ ]>') {
            my $method = $autovivification_type || 'p5aget';
            $autovivification_type eq 'array' && ($method = 'p5aget_array');
            $autovivification_type eq 'hash' && ($method = 'p5aget_hash');
            return Perlito5::Javascript2::emit_javascript2_autovivify($self->{'invocant'}, $level, 'array') . '._array_.' . $method . '(' . Perlito5::Javascript2::to_num($self->{'arguments'}, $level + 1) . ')'
        }
        if ($meth eq 'postcircumfix:<{ }>') {
            my $method = $autovivification_type || 'p5hget';
            $autovivification_type eq 'array' && ($method = 'p5hget_array');
            $autovivification_type eq 'hash' && ($method = 'p5hget_hash');
            return Perlito5::Javascript2::emit_javascript2_autovivify($self->{'invocant'}, $level, 'hash') . '._hash_.' . $method . '(' . Perlito5::Javascript2::autoquote($self->{'arguments'}, $level + 1, 'list') . ')'
        }
        if ($meth eq 'postcircumfix:<( )>') {
            my $invocant;
            if (ref($self->{'invocant'}) eq 'Perlito5::AST::Apply' && $self->{'invocant'}->{'code'} eq 'prefix:<&>') {
                my $arg = $self->{'invocant'}->{'arguments'}->[0];
                $invocant = 'p5code_lookup_by_name(' . Perlito5::Javascript2::escape_string($Perlito5::PKG_NAME) . ', ' . $arg->emit_javascript2($level) . ')'
            }
            elsif (ref($self->{'invocant'}) eq 'Perlito5::AST::Var' && $self->{'invocant'}->{'sigil'} eq '&') {
                $invocant = 'p5pkg[' . Perlito5::Javascript2::escape_string(($self->{'invocant'}->{'namespace'} || $Perlito5::PKG_NAME)) . '][' . Perlito5::Javascript2::escape_string($self->{'invocant'}->{'name'}) . ']'
            }
            else {
                $invocant = $self->{'invocant'}->emit_javascript2($level, 'scalar')
            }
            return '(' . $invocant . ')(' . Perlito5::Javascript2::to_list($self->{'arguments'}) . ', ' . Perlito5::Javascript2::to_context($wantarray) . ')'
        }
        my $invocant = $self->{'invocant'}->emit_javascript2($level, 'scalar');
        if (ref($meth) eq 'Perlito5::AST::Var') {
            $meth = $meth->emit_javascript2($level, 'scalar')
        }
        else {
            $meth = Perlito5::Javascript2::escape_string($meth)
        }
        return 'p5call(' . $invocant . ', ' . $meth . ', ' . Perlito5::Javascript2::to_list($self->{'arguments'}) . ', ' . Perlito5::Javascript2::to_context($wantarray) . ')'
    }
    sub Perlito5::AST::Call::emit_javascript2_set {
        my($self, $arguments, $level, $wantarray) = @_;
        if ($self->{'method'} eq 'postcircumfix:<[ ]>') {
            return Perlito5::Javascript2::emit_javascript2_autovivify($self->{'invocant'}, $level, 'array') . '._array_.p5aset(' . Perlito5::Javascript2::to_num($self->{'arguments'}, $level + 1) . ', ' . Perlito5::Javascript2::to_scalar([$arguments], $level + 1) . ')'
        }
        if ($self->{'method'} eq 'postcircumfix:<{ }>') {
            return Perlito5::Javascript2::emit_javascript2_autovivify($self->{'invocant'}, $level, 'hash') . '._hash_.p5hset(' . Perlito5::Javascript2::autoquote($self->{'arguments'}, $level + 1, 'list') . ', ' . Perlito5::Javascript2::to_scalar([$arguments], $level + 1) . ')'
        }
        die('don' . chr(39) . 't know how to assign to method ', $self->{'method'})
    }
    sub Perlito5::AST::Call::emit_javascript2_set_list {
        my($self, $level, $list) = @_;
        if ($self->{'method'} eq 'postcircumfix:<[ ]>') {
            return Perlito5::Javascript2::emit_javascript2_autovivify($self->{'invocant'}, $level, 'array') . '._array_.p5aset(' . Perlito5::Javascript2::to_num($self->{'arguments'}, $level + 1) . ', ' . $list . '.shift()' . ')'
        }
        if ($self->{'method'} eq 'postcircumfix:<{ }>') {
            return Perlito5::Javascript2::emit_javascript2_autovivify($self->{'invocant'}, $level, 'hash') . '._hash_.p5hset(' . Perlito5::Javascript2::autoquote($self->{'arguments'}, $level + 1, 'list') . ', ' . $list . '.shift()' . ')'
        }
        die('don' . chr(39) . 't know how to assign to method ', $self->{'method'})
    }
    sub Perlito5::AST::Call::emit_javascript2_get_decl {
        ()
    }
    sub Perlito5::AST::Call::emit_javascript2_has_regex {
        ()
    }
}
package Perlito5::AST::Apply;
{
    sub Perlito5::AST::Apply::emit_regex_javascript2 {
        my $op = shift;
        my $var = shift;
        my $regex = shift;
        my $level = shift;
        my $wantarray = shift;
        if ($regex->isa('Perlito5::AST::Var')) {
            $regex = {'code' => 'p5:m', 'arguments' => [$regex, '']}
        }
        my $str;
        my $code = $regex->{'code'};
        my $regex_args = $regex->{'arguments'};
        if ($code eq 'p5:s') {
            my $replace = $regex_args->[1];
            my $modifier = $regex_args->[2]->{'buf'};
            my $fun;
            if (ref($replace) eq 'Perlito5::AST::Block') {
                $replace = Perlito5::AST::Sub::->new('block' => $replace);
                $fun = $replace->emit_javascript2($level + 2, $wantarray);
                $modifier =~ s!e!!g
            }
            else {
                $fun = Perlito5::Javascript2::emit_function_javascript2($level + 2, $wantarray, $replace)
            }
            $str = Perlito5::Javascript2::emit_wrap_javascript2($level + 1, $wantarray, 'var tmp = p5s(' . $var->emit_javascript2() . ', ' . $regex_args->[0]->emit_javascript2() . ', ' . $fun . ', ' . Perlito5::Javascript2::escape_string($modifier) . ', ' . ($wantarray eq 'runtime' ? 'p5want' : $wantarray eq 'list' ? 1 : 0) . ');', $var->emit_javascript2() . ' = tmp[0];', 'return tmp[1];')
        }
        elsif ($code eq 'p5:m') {
            $str = 'p5m(' . $var->emit_javascript2() . ', ' . $regex_args->[0]->emit_javascript2() . ', ' . Perlito5::Javascript2::escape_string($regex_args->[1]->{'buf'}) . ', ' . ($wantarray eq 'runtime' ? 'p5want' : $wantarray eq 'list' ? 1 : 0) . ')'
        }
        elsif ($code eq 'p5:tr') {
            $str = Perlito5::Javascript2::emit_wrap_javascript2($level + 1, $wantarray, 'var tmp = p5tr(' . $var->emit_javascript2() . ', ' . $regex_args->[0]->emit_javascript2() . ', ' . $regex_args->[1]->emit_javascript2() . ', ' . Perlito5::Javascript2::escape_string($regex_args->[2]->{'buf'}) . ', ' . ($wantarray eq 'runtime' ? 'p5want' : $wantarray eq 'list' ? 1 : 0) . ');', $var->emit_javascript2() . ' = tmp[0];', 'return tmp[1];')
        }
        else {
            die('Error: regex emitter - unknown operator ' . $code)
        }
        if ($op eq '=~') {
            return $str
        }
        if ($op eq '!~') {
            return '!(' . $str . ')'
        }
        die('Error: regex emitter')
    }
    sub Perlito5::AST::Apply::emit_javascript2_set {
        my($self, $arguments, $level, $wantarray) = @_;
        my $code = $self->{'code'};
        if ($code eq 'prefix:<$>') {
            return 'p5scalar_deref_set(' . Perlito5::Javascript2::emit_javascript2_autovivify($self->{'arguments'}->[0], $level + 1, 'scalar') . ', ' . Perlito5::Javascript2::to_scalar([$arguments], $level + 1) . ', ' . Perlito5::Javascript2::escape_string($Perlito5::PKG_NAME) . ')'
        }
        if ($code eq 'prefix:<*>') {
            return 'p5typeglob_deref_set(' . Perlito5::Javascript2::to_scalar($self->{'arguments'}, $level + 1) . ', ' . Perlito5::Javascript2::to_scalar([$arguments], $level + 1) . ', ' . Perlito5::Javascript2::escape_string($Perlito5::PKG_NAME) . ')'
        }
        my $open = $wantarray eq 'void' ? '' : '(';
        my $close = $wantarray eq 'void' ? '' : ')';
        $open . $self->emit_javascript2($level + 1) . ' = ' . $arguments->emit_javascript2($level + 1) . $close
    }
    my %emit_js = ('infix:<=~>' => sub {
        my($self, $level, $wantarray) = @_;
        emit_regex_javascript2('=~', $self->{'arguments'}->[0], $self->{'arguments'}->[1], $level, $wantarray)
    }, 'infix:<!~>' => sub {
        my($self, $level, $wantarray) = @_;
        emit_regex_javascript2('!~', $self->{'arguments'}->[0], $self->{'arguments'}->[1], $level, $wantarray)
    }, 'p5:s' => sub {
        my($self, $level, $wantarray) = @_;
        emit_regex_javascript2('=~', $self->{'arguments'}->[3], $self, $level, $wantarray)
    }, 'p5:m' => sub {
        my($self, $level, $wantarray) = @_;
        emit_regex_javascript2('=~', $self->{'arguments'}->[2], $self, $level, $wantarray)
    }, 'p5:tr' => sub {
        my($self, $level, $wantarray) = @_;
        emit_regex_javascript2('=~', $self->{'arguments'}->[3], $self, $level, $wantarray)
    }, 'p5:qr' => sub {
        my($self, $level, $wantarray) = @_;
        'p5qr(' . Perlito5::Javascript2::to_str($self->{'arguments'}->[0]) . ', ' . Perlito5::Javascript2::to_str($self->{'arguments'}->[1]) . ')'
    }, '__PACKAGE__' => sub {
        my $self = $_[0];
        Perlito5::Javascript2::escape_string($Perlito5::PKG_NAME)
    }, '__SUB__' => sub {
        my $self = $_[0];
        $Perlito5::AST::Sub::SUB_REF // '__SUB__'
    }, 'wantarray' => sub {
        my $self = $_[0];
        'p5want'
    }, 'package' => sub {
        my $self = $_[0];
        'p5make_package(' . Perlito5::Javascript2::escape_string($self->{'namespace'}) . ')'
    }, 'infix:<&&>' => sub {
        my($self, $level, $wantarray) = @_;
        'p5and(' . $self->{'arguments'}->[0]->emit_javascript2($level, 'scalar') . ', ' . Perlito5::Javascript2::emit_function_javascript2($level, $wantarray, $self->{'arguments'}->[1]) . ')'
    }, 'infix:<and>' => sub {
        my($self, $level, $wantarray) = @_;
        'p5and(' . $self->{'arguments'}->[0]->emit_javascript2($level, 'scalar') . ', ' . Perlito5::Javascript2::emit_function_javascript2($level, $wantarray, $self->{'arguments'}->[1]) . ')'
    }, 'infix:<||>' => sub {
        my($self, $level, $wantarray) = @_;
        'p5or(' . $self->{'arguments'}->[0]->emit_javascript2($level, 'scalar') . ', ' . Perlito5::Javascript2::emit_function_javascript2($level, $wantarray, $self->{'arguments'}->[1]) . ')'
    }, 'infix:<or>' => sub {
        my($self, $level, $wantarray) = @_;
        'p5or(' . $self->{'arguments'}->[0]->emit_javascript2($level, 'scalar') . ', ' . Perlito5::Javascript2::emit_function_javascript2($level, $wantarray, $self->{'arguments'}->[1]) . ')'
    }, 'infix:<xor>' => sub {
        my($self, $level, $wantarray) = @_;
        'p5xor(' . $self->{'arguments'}->[0]->emit_javascript2($level, 'scalar') . ', ' . Perlito5::Javascript2::emit_function_javascript2($level, $wantarray, $self->{'arguments'}->[1]) . ')'
    }, 'infix:<=>>' => sub {
        my($self, $level, $wantarray) = @_;
        Perlito5::AST::Lookup::->autoquote($self->{'arguments'}->[0])->emit_javascript2($level) . ', ' . $self->{'arguments'}->[1]->emit_javascript2($level)
    }, 'infix:<cmp>' => sub {
        my $self = $_[0];
        'p5cmp(' . join(', ', map(Perlito5::Javascript2::to_str($_), @{$self->{'arguments'}})) . ')'
    }, 'infix:<<=>>' => sub {
        my $self = $_[0];
        'p5cmp(' . join(', ', map(Perlito5::Javascript2::to_num($_), @{$self->{'arguments'}})) . ')'
    }, 'infix:<**>' => sub {
        my $self = $_[0];
        'Math.pow(' . join(', ', map(Perlito5::Javascript2::to_num($_), @{$self->{'arguments'}})) . ')'
    }, 'infix:<<<>' => sub {
        my $self = $_[0];
        'p5shift_left(' . join(', ', map(Perlito5::Javascript2::to_num($_), @{$self->{'arguments'}})) . ')'
    }, 'infix:<%>' => sub {
        my $self = $_[0];
        'p5modulo(' . join(', ', map(Perlito5::Javascript2::to_num($_), @{$self->{'arguments'}})) . ')'
    }, 'prefix:<!>' => sub {
        my $self = shift;
        my $level = shift;
        '!( ' . Perlito5::Javascript2::to_bool($self->{'arguments'}->[0], $level) . ')'
    }, 'prefix:<not>' => sub {
        my $self = shift;
        my $level = shift;
        my $arg = pop(@{$self->{'arguments'}});
        if (!$arg) {
            return 'true'
        }
        '!( ' . Perlito5::Javascript2::to_bool($arg, $level) . ')'
    }, 'prefix:<~>' => sub {
        my $self = $_[0];
        'p5complement( ' . Perlito5::Javascript2::to_num($self->{'arguments'}->[0]) . ')'
    }, 'prefix:<->' => sub {
        my($self, $level, $wantarray) = @_;
        'p5negative( ' . $self->{'arguments'}->[0]->emit_javascript2($level, 'scalar') . ')'
    }, 'prefix:<+>' => sub {
        my($self, $level, $wantarray) = @_;
        '(' . $self->{'arguments'}->[0]->emit_javascript2($level, $wantarray) . ')'
    }, 'require' => sub {
        my($self, $level, $wantarray) = @_;
        my $arg = $self->{'arguments'}->[0];
        if ($arg->{'is_version_string'}) {
            return 'p5pkg["Perlito5"]["test_perl_version"]([' . Perlito5::Javascript2::to_str($self->{'arguments'}->[0]) . '], ' . Perlito5::Javascript2::to_context($wantarray) . ')'
        }
        'p5pkg["Perlito5::Grammar::Use"]["require"]([' . Perlito5::Javascript2::to_str($self->{'arguments'}->[0]) . ', ' . ($self->{'arguments'}->[0]->{'bareword'} ? 1 : 0) . '], ' . Perlito5::Javascript2::to_context($wantarray) . ')'
    }, 'select' => sub {
        my($self, $level, $wantarray) = @_;
        'p5pkg["CORE"]["select"]([' . ($self->{'arguments'}->[0]->{'bareword'} ? Perlito5::Javascript2::to_str($self->{'arguments'}->[0]) : $self->{'arguments'}->[0]->emit_javascript2($level, 'scalar')) . '])'
    }, 'prefix:<$>' => sub {
        my($self, $level, $wantarray) = @_;
        my $arg = $self->{'arguments'}->[0];
        return 'p5scalar_deref(' . $arg->emit_javascript2($level) . ', ' . Perlito5::Javascript2::escape_string($Perlito5::PKG_NAME) . ', ' . '""' . ')'
    }, 'prefix:<@>' => sub {
        my($self, $level, $wantarray) = @_;
        my $arg = $self->{'arguments'}->[0];
        my $s = 'p5array_deref(' . Perlito5::Javascript2::emit_javascript2_autovivify($arg, $level, 'array') . ', ' . Perlito5::Javascript2::escape_string($Perlito5::PKG_NAME) . ')';
        return $wantarray eq 'scalar' ? 'p5num(' . $s . ')' : $s
    }, 'prefix:<$#>' => sub {
        my($self, $level, $wantarray) = @_;
        my $arg = $self->{'arguments'}->[0];
        return '(p5array_deref(' . Perlito5::Javascript2::emit_javascript2_autovivify($arg, $level, 'array') . ', ' . Perlito5::Javascript2::escape_string($Perlito5::PKG_NAME) . ').length - 1)'
    }, 'prefix:<%>' => sub {
        my($self, $level, $wantarray) = @_;
        my $arg = $self->{'arguments'}->[0];
        return 'p5hash_deref(' . Perlito5::Javascript2::emit_javascript2_autovivify($arg, $level, 'hash') . ', ' . Perlito5::Javascript2::escape_string($Perlito5::PKG_NAME) . ')'
    }, 'prefix:<&>' => sub {
        my($self, $level, $wantarray) = @_;
        my $arg = $self->{'arguments'}->[0];
        'p5code_lookup_by_name(' . Perlito5::Javascript2::escape_string($Perlito5::PKG_NAME) . ', ' . $arg->emit_javascript2($level) . ')([])'
    }, 'circumfix:<[ ]>' => sub {
        my($self, $level, $wantarray) = @_;
        '(new p5ArrayRef(' . Perlito5::Javascript2::to_list($self->{'arguments'}) . '))'
    }, 'circumfix:<{ }>' => sub {
        my($self, $level, $wantarray) = @_;
        '(new p5HashRef(' . Perlito5::Javascript2::to_list($self->{'arguments'}, $level, 'hash') . '))'
    }, 'prefix:<' . chr(92) . '>' => sub {
        my($self, $level, $wantarray) = @_;
        my $arg = $self->{'arguments'}->[0];
        if ($arg->isa('Perlito5::AST::Apply')) {
            if ($arg->{'code'} eq 'prefix:<@>') {
                return '(new p5ArrayRef(' . $arg->emit_javascript2($level) . '))'
            }
            if ($arg->{'code'} eq 'prefix:<%>') {
                return '(new p5HashRef(' . $arg->emit_javascript2($level) . '))'
            }
            if ($arg->{'code'} eq 'circumfix:<( )>') {
                return 'p5_list_of_refs(' . Perlito5::Javascript2::to_list($arg->{'arguments'}) . ')'
            }
            if ($arg->{'code'} eq 'prefix:<&>') {
                return 'p5code_lookup_by_name(' . Perlito5::Javascript2::escape_string($Perlito5::PKG_NAME) . ', ' . $arg->{'arguments'}->[0]->emit_javascript2($level) . ')'
            }
        }
        if ($arg->isa('Perlito5::AST::Var')) {
            if ($arg->sigil() eq '@') {
                return '(new p5ArrayRef(' . $arg->emit_javascript2($level) . '))'
            }
            if ($arg->sigil() eq '%') {
                return '(new p5HashRef(' . $arg->emit_javascript2($level) . '))'
            }
            if ($arg->sigil() eq '*') {
                return '(new p5GlobRef(' . $arg->emit_javascript2($level) . '))'
            }
            if ($arg->sigil() eq '&') {
                if ($arg->{'namespace'}) {
                    return 'p5pkg[' . Perlito5::Javascript2::escape_string($arg->{'namespace'}) . '].' . $arg->{'name'}
                }
                else {
                    return Perlito5::Javascript2::pkg() . '.' . $arg->{'name'}
                }
            }
        }
        return '(new p5ScalarRef(' . $arg->emit_javascript2($level) . '))'
    }, 'postfix:<++>' => sub {
        my($self, $level, $wantarray) = @_;
        my $arg = $self->{'arguments'}->[0];
        if ($arg->isa('Perlito5::AST::Index') || $arg->isa('Perlito5::AST::Lookup') || $arg->isa('Perlito5::AST::Call')) {
            return $arg->emit_javascript2($level + 1, 0, 'p5postincr')
        }
        if ($arg->isa('Perlito5::AST::Var') && $arg->{'sigil'} eq '$') {
            my $tmp = Perlito5::Javascript2::get_label();
            return Perlito5::Javascript2::emit_wrap_javascript2($level, 'scalar', 'var ' . $tmp . ' = ' . $arg->emit_javascript2($level) . ';', $arg->emit_javascript2($level) . ' = p5incr_(' . $tmp . ');', 'return ' . $tmp)
        }
        '(' . join(' ', map($_->emit_javascript2(), @{$self->{'arguments'}})) . ')++'
    }, 'postfix:<-->' => sub {
        my($self, $level, $wantarray) = @_;
        my $arg = $self->{'arguments'}->[0];
        if ($arg->isa('Perlito5::AST::Index') || $arg->isa('Perlito5::AST::Lookup') || $arg->isa('Perlito5::AST::Call')) {
            return $arg->emit_javascript2($level + 1, 0, 'p5postdecr')
        }
        if ($arg->isa('Perlito5::AST::Var') && $arg->{'sigil'} eq '$') {
            my $tmp = Perlito5::Javascript2::get_label();
            return Perlito5::Javascript2::emit_wrap_javascript2($level, 'scalar', 'var ' . $tmp . ' = ' . $arg->emit_javascript2($level) . ';', $arg->emit_javascript2($level) . ' = p5decr_(' . $tmp . ');', 'return ' . $tmp)
        }
        '(' . join(' ', map($_->emit_javascript2(), @{$self->{'arguments'}})) . ')--'
    }, 'prefix:<++>' => sub {
        my($self, $level, $wantarray) = @_;
        my $arg = $self->{'arguments'}->[0];
        if ($arg->isa('Perlito5::AST::Index') || $arg->isa('Perlito5::AST::Lookup') || $arg->isa('Perlito5::AST::Call')) {
            return $arg->emit_javascript2($level + 1, 0, 'p5incr')
        }
        if ($arg->isa('Perlito5::AST::Var') && $arg->{'sigil'} eq '$') {
            my $tmp = Perlito5::Javascript2::get_label();
            return Perlito5::Javascript2::emit_wrap_javascript2($level, 'scalar', 'var ' . $tmp . ' = ' . $arg->emit_javascript2($level) . ';', $arg->emit_javascript2($level) . ' = p5incr_(' . $tmp . ');', 'return ' . $arg->emit_javascript2($level + 1))
        }
        '++(' . join(' ', map($_->emit_javascript2(), @{$self->{'arguments'}})) . ')'
    }, 'prefix:<-->' => sub {
        my($self, $level, $wantarray) = @_;
        my $arg = $self->{'arguments'}->[0];
        if ($arg->isa('Perlito5::AST::Index') || $arg->isa('Perlito5::AST::Lookup') || $arg->isa('Perlito5::AST::Call')) {
            return $arg->emit_javascript2($level + 1, 0, 'p5decr')
        }
        if ($arg->isa('Perlito5::AST::Var') && $arg->{'sigil'} eq '$') {
            my $tmp = Perlito5::Javascript2::get_label();
            return Perlito5::Javascript2::emit_wrap_javascript2($level, 'scalar', 'var ' . $tmp . ' = ' . $arg->emit_javascript2($level) . ';', $arg->emit_javascript2($level) . ' = p5decr_(' . $tmp . ');', 'return ' . $arg->emit_javascript2($level + 1))
        }
        '--(' . join(' ', map($_->emit_javascript2(), @{$self->{'arguments'}})) . ')'
    }, 'infix:<x>' => sub {
        my($self, $level, $wantarray) = @_;
        my $arg = $self->{'arguments'}->[0];
        if (ref($arg) eq 'Perlito5::AST::Apply' && ($arg->{'code'} eq 'circumfix:<( )>' || $arg->{'code'} eq 'list:<,>')) {
            return 'p5list_replicate(' . $self->{'arguments'}->[0]->emit_javascript2($level, 'list') . ',' . Perlito5::Javascript2::to_num($self->{'arguments'}->[1], $level) . ', ' . ($wantarray eq 'runtime' ? 'p5want' : $wantarray eq 'list' ? 1 : 0) . ')'
        }
        'p5str_replicate(' . Perlito5::Javascript2::to_str($self->{'arguments'}->[0], $level) . ',' . Perlito5::Javascript2::to_num($self->{'arguments'}->[1], $level) . ')'
    }, 'list:<.>' => sub {
        my($self, $level, $wantarray) = @_;
        '(' . join(' + ', map(Perlito5::Javascript2::to_str($_), @{$self->{'arguments'}})) . ')'
    }, 'list:<,>' => sub {
        my($self, $level, $wantarray) = @_;
        Perlito5::Javascript2::to_list($self->{'arguments'})
    }, 'infix:<..>' => sub {
        my($self, $level, $wantarray) = @_;
        return 'p5range(' . $self->{'arguments'}->[0]->emit_javascript2($level) . ', ' . $self->{'arguments'}->[1]->emit_javascript2($level) . ', ' . ($wantarray eq 'runtime' ? 'p5want' : $wantarray eq 'list' ? 1 : 0) . ', ' . '"' . Perlito5::Javascript2::get_label() . '"' . ', ' . 0 . ')'
    }, 'infix:<...>' => sub {
        my($self, $level, $wantarray) = @_;
        return 'p5range(' . $self->{'arguments'}->[0]->emit_javascript2($level) . ', ' . $self->{'arguments'}->[1]->emit_javascript2($level) . ', ' . ($wantarray eq 'runtime' ? 'p5want' : $wantarray eq 'list' ? 1 : 0) . ', ' . '"' . Perlito5::Javascript2::get_label() . '"' . ', ' . 1 . ')'
    }, 'delete' => sub {
        my($self, $level, $wantarray) = @_;
        my $arg = $self->{'arguments'}->[0];
        if ($arg->isa('Perlito5::AST::Lookup')) {
            my $v = $arg->obj();
            if ($v->isa('Perlito5::AST::Var') && $v->sigil() eq '$') {
                return '(delete ' . $v->emit_javascript2() . '[' . $arg->autoquote($arg->{'index_exp'})->emit_javascript2($level) . '])'
            }
            return '(delete ' . $v->emit_javascript2() . '._hash_[' . $arg->autoquote($arg->{'index_exp'})->emit_javascript2($level) . '])'
        }
        if ($arg->isa('Perlito5::AST::Index')) {
            my $v = $arg->obj();
            if ($v->isa('Perlito5::AST::Var') && $v->sigil() eq '$') {
                return '(delete ' . $v->emit_javascript2() . '[' . $arg->{'index_exp'}->emit_javascript2($level) . '])'
            }
            return '(delete ' . $v->emit_javascript2() . '._array_[' . $arg->{'index_exp'}->emit_javascript2($level) . '])'
        }
        if ($arg->isa('Perlito5::AST::Call')) {
            if ($arg->method() eq 'postcircumfix:<{ }>') {
                return '(delete ' . $arg->invocant()->emit_javascript2() . '._hash_[' . Perlito5::AST::Lookup::->autoquote($arg->{'arguments'})->emit_javascript2($level) . '])'
            }
            if ($arg->method() eq 'postcircumfix:<[ ]>') {
                return '(delete ' . $arg->invocant()->emit_javascript2() . '._array_[' . $arg->{'arguments'}->emit_javascript2($level) . '])'
            }
        }
        if ($arg->isa('Perlito5::AST::Var') && $arg->sigil() eq '&') {
            die('TODO delete &code')
        }
        if ($arg->isa('Perlito5::AST::Apply') && $arg->{'code'} eq 'prefix:<&>') {
            die('TODO delete &$code')
        }
    }, 'scalar' => sub {
        my($self, $level, $wantarray) = @_;
        Perlito5::Javascript2::to_scalar($self->{'arguments'}, $level + 1)
    }, 'ternary:<? :>' => sub {
        my($self, $level, $wantarray) = @_;
        '( ' . Perlito5::Javascript2::to_bool($self->{'arguments'}->[0]) . ' ? ' . ($self->{'arguments'}->[1])->emit_javascript2($level, $wantarray) . ' : ' . ($self->{'arguments'}->[2])->emit_javascript2($level, $wantarray) . ')'
    }, 'my' => sub {
        my($self, $level, $wantarray) = @_;
        'p5context(' . '[' . join(', ', map($_->emit_javascript2($level, $wantarray), @{$self->{'arguments'}})) . '], ' . ($wantarray eq 'runtime' ? 'p5want' : $wantarray eq 'list' ? 1 : 0) . ')'
    }, 'our' => sub {
        my($self, $level, $wantarray) = @_;
        'p5context(' . '[' . join(', ', map($_->emit_javascript2($level, $wantarray), @{$self->{'arguments'}})) . '], ' . ($wantarray eq 'runtime' ? 'p5want' : $wantarray eq 'list' ? 1 : 0) . ')'
    }, 'local' => sub {
        my($self, $level, $wantarray) = @_;
        'p5context(' . '[' . join(', ', map($_->emit_javascript2($level, $wantarray), @{$self->{'arguments'}})) . '], ' . ($wantarray eq 'runtime' ? 'p5want' : $wantarray eq 'list' ? 1 : 0) . ')'
    }, 'circumfix:<( )>' => sub {
        my($self, $level, $wantarray) = @_;
        'p5context(' . '[' . join(', ', map($_->emit_javascript2($level, $wantarray), @{$self->{'arguments'}})) . '], ' . ($wantarray eq 'runtime' ? 'p5want' : $wantarray eq 'list' ? 1 : 0) . ')'
    }, 'infix:<=>' => sub {
        my($self, $level, $wantarray) = @_;
        my $parameters = $self->{'arguments'}->[0];
        my $arguments = $self->{'arguments'}->[1];
        if ($parameters->isa('Perlito5::AST::Apply') && ($parameters->code() eq 'my' || $parameters->code() eq 'local' || $parameters->code() eq 'circumfix:<( )>')) {
            if ($wantarray eq 'void') {
                my $tmp = Perlito5::Javascript2::get_label();
                return join(';' . chr(10) . Perlito5::Javascript2::tab($level), 'var ' . $tmp . ' = ' . Perlito5::Javascript2::to_list([$arguments], $level + 1), (map($_->emit_javascript2_set_list($level, $tmp), @{$parameters->arguments()})))
            }
            my $tmp = Perlito5::Javascript2::get_label();
            my $tmp2 = Perlito5::Javascript2::get_label();
            return Perlito5::Javascript2::emit_wrap_javascript2($level, $wantarray, 'var ' . $tmp . ' = ' . Perlito5::Javascript2::to_list([$arguments], $level + 1) . ';', 'var ' . $tmp2 . ' = ' . $tmp . '.slice(0);', (map($_->emit_javascript2_set_list($level + 1, $tmp) . ';', @{$parameters->arguments()})), 'return ' . $tmp2)
        }
        return $parameters->emit_javascript2_set($arguments, $level + 1, $wantarray)
    }, 'break' => sub {
        my($self, $level, $wantarray) = @_;
        $Perlito5::THROW = 1;
        Perlito5::Javascript2::emit_wrap_statement_javascript2($level, $wantarray, 'throw(new p5_error("break", ""))')
    }, 'next' => sub {
        my($self, $level, $wantarray) = @_;
        $Perlito5::THROW = 1;
        my $label = $self->{'arguments'}->[0]->{'code'} || '';
        Perlito5::Javascript2::emit_wrap_statement_javascript2($level, $wantarray, 'throw(new p5_error("next", ' . Perlito5::Javascript2::escape_string($label) . '))')
    }, 'last' => sub {
        my($self, $level, $wantarray) = @_;
        $Perlito5::THROW = 1;
        my $label = $self->{'arguments'}->[0]->{'code'} || '';
        Perlito5::Javascript2::emit_wrap_statement_javascript2($level, $wantarray, 'throw(new p5_error("last", ' . Perlito5::Javascript2::escape_string($label) . '))')
    }, 'redo' => sub {
        my($self, $level, $wantarray) = @_;
        $Perlito5::THROW = 1;
        my $label = $self->{'arguments'}->[0]->{'code'} || '';
        Perlito5::Javascript2::emit_wrap_statement_javascript2($level, $wantarray, 'throw(new p5_error("redo", ' . Perlito5::Javascript2::escape_string($label) . '))')
    }, 'return' => sub {
        my($self, $level, $wantarray) = @_;
        $Perlito5::THROW = 1;
        Perlito5::Javascript2::emit_wrap_statement_javascript2($level, $wantarray, 'throw(' . Perlito5::Javascript2::to_runtime_context($self->{'arguments'}, $level + 1) . ')')
    }, 'goto' => sub {
        my($self, $level, $wantarray) = @_;
        $Perlito5::THROW = 1;
        Perlito5::Javascript2::emit_wrap_statement_javascript2($level, $wantarray, 'throw(' . $self->{'arguments'}->[0]->emit_javascript2($level) . ')')
    }, 'do' => sub {
        my($self, $level, $wantarray) = @_;
        my $arg = $self->{'arguments'}->[0];
        if ($arg->isa('Perlito5::AST::Block')) {
            my $block = $arg->{'stmts'};
            return Perlito5::Javascript2::emit_wrap_javascript2($level, $wantarray, (Perlito5::Javascript2::LexicalBlock::->new('block' => $block))->emit_javascript2($level + 1, $wantarray))
        }
        my $tmp_strict = $Perlito5::STRICT;
        $Perlito5::STRICT = 0;
        my $ast = Perlito5::AST::Apply::->new('code' => 'eval', 'namespace' => '', 'arguments' => [Perlito5::AST::Apply::->new('code' => 'do_file', 'namespace' => 'Perlito5::Grammar::Use', 'arguments' => $self->{'arguments'})], '_scope' => Perlito5::Grammar::Scope::->new_base_scope());
        my $js = $ast->emit_javascript2($level, $wantarray);
        $Perlito5::STRICT = $tmp_strict;
        return $js
    }, 'eval' => sub {
        my($self, $level, $wantarray) = @_;
        $Perlito5::THROW = 1;
        my $arg = $self->{'arguments'}->[0];
        my $eval;
        if ($arg->isa('Perlito5::AST::Block')) {
            $eval = Perlito5::AST::Apply::->new('code' => 'do', 'arguments' => [$arg])->emit_javascript2($level + 1, $wantarray)
        }
        else {
            my $scope_perl5 = Perlito5::Dumper::ast_dumper([$self->{'_scope'}]);
            my $m = Perlito5::Grammar::Expression::term_square($scope_perl5, 0);
            if (!$m || $m->{'to'} < length($scope_perl5)) {
                die('invalid internal scope in eval' . chr(10))
            }
            $m = Perlito5::Grammar::Expression::expand_list(Perlito5::Match::flat($m)->[2]);
            my $scope_js = '(new p5ArrayRef(' . Perlito5::Javascript2::to_list($m) . '))';
            $eval = 'eval(p5pkg["Perlito5::Javascript2::Runtime"].perl5_to_js([' . Perlito5::Javascript2::to_str($arg) . ', ' . Perlito5::Javascript2::escape_string($Perlito5::PKG_NAME) . ', ' . Perlito5::Javascript2::escape_string($wantarray) . ', ' . $scope_js . ']))'
        }
        my $context = Perlito5::Javascript2::to_context($wantarray);
        Perlito5::Javascript2::emit_wrap_javascript2($level, $wantarray, ($context eq 'p5want' ? () : 'var p5want = ' . $context . ';'), 'var r;', 'p5pkg["main"]["v_@"] = "";', 'var p5strict = p5pkg["Perlito5"]["v_STRICT"];', 'p5pkg["Perlito5"]["v_STRICT"] = ' . $Perlito5::STRICT . ';', 'try {', ['r = ' . $eval . ''], '}', 'catch(err) {', ['if ( err instanceof p5_error || err instanceof Error ) {', ['p5pkg["main"]["v_@"] = err;', 'if (p5str(p5pkg["main"]["v_@"]).substr(-1, 1) != "' . chr(92) . 'n") {', ['try {' . '', ['p5pkg["main"]["v_@"] = p5pkg["main"]["v_@"] + "' . chr(92) . 'n" + err.stack + "' . chr(92) . 'n";'], '}', 'catch(err) { }'], '}'], '}', 'else {', ['return(err);'], '}'], '}', 'p5pkg["Perlito5"]["v_STRICT"] = p5strict;', 'return r;')
    }, 'substr' => sub {
        my($self, $level, $wantarray) = @_;
        my $length = $self->{'arguments'}->[2];
        if ($length && $length->isa('Perlito5::AST::Int') && $length->{'int'} > 0) {
            return Perlito5::Javascript2::to_str($self->{'arguments'}->[0]) . '.substr(' . Perlito5::Javascript2::to_num($self->{'arguments'}->[1]) . ', ' . Perlito5::Javascript2::to_num($self->{'arguments'}->[2]) . ')'
        }
        my $arg_list = Perlito5::Javascript2::to_list_preprocess($self->{'arguments'});
        my $arg_code = Perlito5::Javascript2::to_list($arg_list);
        return 'CORE.substr(' . $arg_code . ', ' . Perlito5::Javascript2::to_context($wantarray) . ')'
    }, 'undef' => sub {
        my($self, $level, $wantarray) = @_;
        if ($self->{'arguments'} && @{$self->{'arguments'}}) {
            my $arg = $self->{'arguments'}->[0];
            if (ref($arg) eq 'Perlito5::AST::Var' && $arg->{'sigil'} eq '&') {
                return '(delete p5pkg[' . Perlito5::Javascript2::escape_string(($arg->{'namespace'} || $Perlito5::PKG_NAME)) . '][' . Perlito5::Javascript2::escape_string($arg->{'name'}) . '])'
            }
            return '(' . $arg->emit_javascript2() . ' = null)'
        }
        return 'null'
    }, 'defined' => sub {
        my($self, $level, $wantarray) = @_;
        my $arg = $self->{'arguments'}->[0];
        my $invocant;
        if (ref($arg) eq 'Perlito5::AST::Apply' && $arg->{'code'} eq 'prefix:<&>') {
            my $arg2 = $arg->{'arguments'}->[0];
            $invocant = 'p5code_lookup_by_name(' . Perlito5::Javascript2::escape_string($Perlito5::PKG_NAME) . ', ' . $arg2->emit_javascript2($level) . ')'
        }
        elsif (ref($arg) eq 'Perlito5::AST::Var' && $arg->{'sigil'} eq '&') {
            $invocant = 'p5pkg[' . Perlito5::Javascript2::escape_string(($arg->{'namespace'} || $Perlito5::PKG_NAME)) . '][' . Perlito5::Javascript2::escape_string($arg->{'name'}) . ']'
        }
        else {
            $invocant = $arg->emit_javascript2($level, 'scalar')
        }
        '(' . $invocant . ' != null)'
    }, 'shift' => sub {
        my($self, $level, $wantarray) = @_;
        if ($self->{'arguments'} && @{$self->{'arguments'}}) {
            return $self->{'arguments'}->[0]->emit_javascript2($level) . '.shift()'
        }
        return 'List__.shift()'
    }, 'pop' => sub {
        my($self, $level, $wantarray) = @_;
        if ($self->{'arguments'} && @{$self->{'arguments'}}) {
            return $self->{'arguments'}->[0]->emit_javascript2($level) . '.pop()'
        }
        return 'List__.pop()'
    }, 'unshift' => sub {
        my($self, $level, $wantarray) = @_;
        my @arguments = @{$self->{'arguments'}};
        my $v = shift(@arguments);
        return $v->emit_javascript2($level) . '.p5unshift(' . Perlito5::Javascript2::to_list(\@arguments) . ')'
    }, 'push' => sub {
        my($self, $level, $wantarray) = @_;
        my @arguments = @{$self->{'arguments'}};
        my $v = shift(@arguments);
        return $v->emit_javascript2($level) . '.p5push(' . Perlito5::Javascript2::to_list(\@arguments) . ')'
    }, 'tie' => sub {
        my($self, $level, $wantarray) = @_;
        my @arguments = @{$self->{'arguments'}};
        my $v = shift(@arguments);
        my $meth;
        if ($v->isa('Perlito5::AST::Var') && $v->sigil() eq '%') {
            $meth = 'hash'
        }
        elsif ($v->isa('Perlito5::AST::Var') && $v->sigil() eq '@') {
            $meth = 'array'
        }
        elsif ($v->isa('Perlito5::AST::Var') && $v->sigil() eq '$') {
            $meth = 'scalar'
        }
        else {
            die('tie ' . chr(39), ref($v), chr(39) . ' not implemented')
        }
        return 'p5tie_' . $meth . '(' . $v->emit_javascript2($level) . ', ' . Perlito5::Javascript2::to_list(\@arguments) . ')'
    }, 'untie' => sub {
        my($self, $level, $wantarray) = @_;
        my @arguments = @{$self->{'arguments'}};
        my $v = shift(@arguments);
        my $meth;
        if ($v->isa('Perlito5::AST::Var') && $v->sigil() eq '%') {
            $meth = 'hash'
        }
        elsif ($v->isa('Perlito5::AST::Var') && $v->sigil() eq '@') {
            $meth = 'array'
        }
        elsif ($v->isa('Perlito5::AST::Var') && $v->sigil() eq '$') {
            $meth = 'scalar'
        }
        else {
            die('tie ' . chr(39), ref($v), chr(39) . ' not implemented')
        }
        return 'p5untie_' . $meth . '(' . $v->emit_javascript2($level) . ')'
    }, 'print' => sub {
        my($self, $level, $wantarray) = @_;
        my @in = @{$self->{'arguments'}};
        my $fun;
        if ($self->{'special_arg'}) {
            $fun = $self->{'special_arg'}->emit_javascript2($level)
        }
        else {
            $fun = '"STDOUT"'
        }
        my $list = Perlito5::Javascript2::to_list(\@in);
        'p5pkg["Perlito5::IO"].print(' . $fun . ', ' . $list . ')'
    }, 'say' => sub {
        my($self, $level, $wantarray) = @_;
        my @in = @{$self->{'arguments'}};
        my $fun;
        if ($self->{'special_arg'}) {
            $fun = $self->{'special_arg'}->emit_javascript2($level)
        }
        else {
            $fun = '"STDOUT"'
        }
        my $list = Perlito5::Javascript2::to_list(\@in);
        'p5pkg["Perlito5::IO"].say(' . $fun . ', ' . $list . ')'
    }, 'printf' => sub {
        my($self, $level, $wantarray) = @_;
        my @in = @{$self->{'arguments'}};
        my $fun;
        if ($self->{'special_arg'}) {
            $fun = $self->{'special_arg'}->emit_javascript2($level)
        }
        else {
            $fun = '"STDOUT"'
        }
        my $list = Perlito5::Javascript2::to_list(\@in);
        'p5pkg["Perlito5::IO"].printf(' . $fun . ', ' . $list . ')'
    }, 'close' => sub {
        my($self, $level, $wantarray) = @_;
        my @in = @{$self->{'arguments'}};
        my $fun = shift(@in);
        'p5pkg["Perlito5::IO"].close(' . $fun->emit_javascript2($level) . ', [])'
    }, 'open' => sub {
        my($self, $level, $wantarray) = @_;
        my @in = @{$self->{'arguments'}};
        my $fun = shift(@in);
        if (ref($fun) ne 'Perlito5::AST::Apply') {
            return Perlito5::Javascript2::emit_wrap_javascript2($level, $wantarray, $fun->emit_javascript2($level) . ' = CORE.bless([ {file_handle : {id : null}}, "GLOB" ]);', 'return CORE.open(' . Perlito5::Javascript2::to_list($self->{'arguments'}, $level) . ')')
        }
        else {
            $Perlito5::STRICT = 0;
            return 'CORE.open(' . Perlito5::Javascript2::to_list($self->{'arguments'}, $level) . ')'
        }
    }, 'chomp' => sub {
        my($self, $level, $wantarray) = @_;
        my $v = $self->{'arguments'}->[0];
        return Perlito5::Javascript2::emit_wrap_javascript2($level, $wantarray, 'var r = p5chomp(' . $v->emit_javascript2($level) . ');', $v->emit_javascript2($level) . ' = r[1];', 'return r[0]')
    }, 'chop' => sub {
        my($self, $level, $wantarray) = @_;
        my $v = $self->{'arguments'}->[0];
        return Perlito5::Javascript2::emit_wrap_javascript2($level, $wantarray, 'var r = p5chop(' . $v->emit_javascript2($level) . ');', $v->emit_javascript2($level) . ' = r[1];', 'return r[0]')
    }, 'read' => sub {
        my($self, $level, $wantarray) = @_;
        my @in = @{$self->{'arguments'}};
        my $fun = shift(@in);
        my $scalar = shift(@in);
        my $length = shift(@in);
        return Perlito5::Javascript2::emit_wrap_javascript2($level, $wantarray, 'var r = p5pkg["Perlito5::IO"].read(' . $fun->emit_javascript2($level) . ', [' . $length->emit_javascript2($level) . ']);', $scalar->emit_javascript2($level) . ' = r[1];', 'return r[0]')
    }, 'readline' => sub {
        my($self, $level, $wantarray) = @_;
        my @in = @{$self->{'arguments'}};
        my $fun = shift(@in) || bless({'arguments' => [], 'bareword' => 1, 'code' => 'ARGV', 'namespace' => ''}, 'Perlito5::AST::Apply');
        return 'CORE.readline([' . $fun->emit_javascript2($level) . '])'
    }, 'map' => sub {
        my($self, $level, $wantarray) = @_;
        my @in = @{$self->{'arguments'}};
        my $fun;
        if ($self->{'special_arg'}) {
            $fun = $self->{'special_arg'}
        }
        else {
            $fun = shift(@in)
        }
        my $list = Perlito5::Javascript2::to_list(\@in);
        if (ref($fun) eq 'Perlito5::AST::Block') {
            $fun = $fun->{'stmts'}
        }
        else {
            $fun = [$fun]
        }
        'p5map(' . Perlito5::Javascript2::pkg() . ', ' . 'function (p5want) {' . chr(10) . Perlito5::Javascript2::tab($level + 1) . (Perlito5::Javascript2::LexicalBlock::->new('block' => $fun))->emit_javascript2($level + 1, $wantarray) . chr(10) . Perlito5::Javascript2::tab($level) . '}, ' . $list . ')'
    }, 'grep' => sub {
        my($self, $level, $wantarray) = @_;
        my @in = @{$self->{'arguments'}};
        my $fun;
        if ($self->{'special_arg'}) {
            $fun = $self->{'special_arg'}
        }
        else {
            $fun = shift(@in)
        }
        my $list = Perlito5::Javascript2::to_list(\@in);
        if (ref($fun) eq 'Perlito5::AST::Block') {
            $fun = $fun->{'stmts'}
        }
        else {
            $fun = [$fun]
        }
        'p5grep(' . Perlito5::Javascript2::pkg() . ', ' . 'function (p5want) {' . chr(10) . Perlito5::Javascript2::tab($level + 1) . (Perlito5::Javascript2::LexicalBlock::->new('block' => $fun))->emit_javascript2($level + 1, $wantarray) . chr(10) . Perlito5::Javascript2::tab($level) . '}, ' . $list . ')'
    }, 'sort' => sub {
        my($self, $level, $wantarray) = @_;
        my @in = @{$self->{'arguments'}};
        my $fun;
        my $list;
        if ($self->{'special_arg'}) {
            $fun = $self->{'special_arg'}
        }
        elsif (ref($in[0]) eq 'Perlito5::AST::Block') {
            $fun = shift(@in)
        }
        if (ref($fun) eq 'Perlito5::AST::Block') {
            $fun = 'function (p5want) {' . chr(10) . Perlito5::Javascript2::tab($level + 1) . (Perlito5::Javascript2::LexicalBlock::->new('block' => $fun->{'stmts'}))->emit_javascript2($level + 1, $wantarray) . chr(10) . Perlito5::Javascript2::tab($level) . '}'
        }
        else {
            $fun = 'null'
        }
        $list = Perlito5::Javascript2::to_list(\@in);
        'p5sort(' . Perlito5::Javascript2::pkg() . ', ' . $fun . ', ' . $list . ')'
    }, 'infix:<//>' => sub {
        my($self, $level, $wantarray) = @_;
        'p5defined_or' . '(' . $self->{'arguments'}->[0]->emit_javascript2($level, 'scalar') . ', ' . Perlito5::Javascript2::emit_function_javascript2($level, $wantarray, $self->{'arguments'}->[1]) . ')'
    }, 'exists' => sub {
        my($self, $level, $wantarray) = @_;
        my $arg = $self->{'arguments'}->[0];
        if ($arg->isa('Perlito5::AST::Lookup')) {
            my $v = $arg->obj();
            if ($v->isa('Perlito5::AST::Var') && $v->sigil() eq '$') {
                $v->{'sigil'} = '%';
                return '(' . $v->emit_javascript2() . ').hasOwnProperty(' . $arg->autoquote($arg->{'index_exp'})->emit_javascript2($level) . ')'
            }
            return '(' . $v->emit_javascript2() . ')._hash_.hasOwnProperty(' . $arg->autoquote($arg->{'index_exp'})->emit_javascript2($level) . ')'
        }
        if ($arg->isa('Perlito5::AST::Index')) {
            my $v = $arg->obj();
            if ($v->isa('Perlito5::AST::Var') && $v->sigil() eq '$') {
                return '(' . $v->emit_javascript2() . ').hasOwnProperty(' . $arg->{'index_exp'}->emit_javascript2($level) . ')'
            }
            return '(' . $v->emit_javascript2() . ')._array_.hasOwnProperty(' . $arg->{'index_exp'}->emit_javascript2($level) . ')'
        }
        if ($arg->isa('Perlito5::AST::Call')) {
            if ($arg->method() eq 'postcircumfix:<{ }>') {
                return '(' . $arg->invocant()->emit_javascript2() . ')._hash_.hasOwnProperty(' . Perlito5::AST::Lookup::->autoquote($arg->{'arguments'})->emit_javascript2($level) . ')'
            }
            if ($arg->method() eq 'postcircumfix:<[ ]>') {
                return '(' . $arg->invocant()->emit_javascript2() . ')._array_.hasOwnProperty(' . $arg->{'arguments'}->emit_javascript2($level) . ')'
            }
        }
        if ($arg->isa('Perlito5::AST::Var') && $arg->sigil() eq '&') {
            my $name = $arg->{'name'};
            my $namespace = $arg->{'namespace'} || $Perlito5::PKG_NAME;
            return 'p5pkg[' . Perlito5::Javascript2::escape_string($namespace) . '].hasOwnProperty(' . Perlito5::Javascript2::escape_string($name) . ')'
        }
        if ($arg->isa('Perlito5::AST::Apply') && $arg->{'code'} eq 'prefix:<&>') {
            my $arg2 = $arg->{'arguments'}->[0];
            return 'p5sub_exists(' . Perlito5::Javascript2::to_str($arg2) . ', ' . Perlito5::Javascript2::escape_string($Perlito5::PKG_NAME) . ')'
        }
    }, 'prototype' => sub {
        my($self, $level, $wantarray) = @_;
        my $arg = $self->{'arguments'}->[0];
        return 'p5sub_prototype(' . $arg->emit_javascript2() . ', ' . Perlito5::Javascript2::escape_string($Perlito5::PKG_NAME) . ')'
    }, 'split' => sub {
        my($self, $level, $wantarray) = @_;
        my @js;
        my $arg = $self->{'arguments'}->[0];
        if ($arg && $arg->isa('Perlito5::AST::Apply') && $arg->{'code'} eq 'p5:m') {
            push(@js, 'new RegExp(' . $arg->{'arguments'}->[0]->emit_javascript2() . ', ' . Perlito5::Javascript2::escape_string($arg->{'arguments'}->[1]->{'buf'}) . ')');
            shift(@{$self->{'arguments'}})
        }
        return 'CORE.split(' . '[' . join(', ', @js, map($_->emit_javascript2(), @{$self->{'arguments'}})) . '], ' . Perlito5::Javascript2::to_context($wantarray) . ')'
    });
    sub Perlito5::AST::Apply::emit_javascript2 {
        my($self, $level, $wantarray) = @_;
        my $apply = $self->op_assign();
        if ($apply) {
            return $apply->emit_javascript2($level)
        }
        my $apply = $self->op_auto();
        if ($apply) {
            return $apply->emit_javascript2($level)
        }
        my $code = $self->{'code'};
        if (ref($code) ne '') {
            my @args = ();
            push(@args, $_->emit_javascript2())
                for @{$self->{'arguments'}};
            return '(' . $self->{'code'}->emit_javascript2($level) . ')(' . join(',', @args) . ')'
        }
        exists($emit_js{$code}) && return $emit_js{$code}->($self, $level, $wantarray);
        if (exists($Perlito5::Javascript2::op_infix_js_str{$code})) {
            return '(' . join($Perlito5::Javascript2::op_infix_js_str{$code}, map {
                Perlito5::Javascript2::to_str($_, $level)
            } @{$self->{'arguments'}}) . ')'
        }
        if (exists($Perlito5::Javascript2::op_infix_js_num{$code})) {
            return '(' . join($Perlito5::Javascript2::op_infix_js_num{$code}, map {
                Perlito5::Javascript2::to_num($_, $level)
            } @{$self->{'arguments'}}) . ')'
        }
        if (exists($Perlito5::Javascript2::op_prefix_js_str{$code})) {
            return $Perlito5::Javascript2::op_prefix_js_str{$code} . '(' . Perlito5::Javascript2::to_str($self->{'arguments'}->[0]) . ')'
        }
        if ($self->{'namespace'}) {
            if ($self->{'namespace'} eq 'JS' && $code eq 'inline') {
                if ($self->{'arguments'}->[0]->isa('Perlito5::AST::Buf')) {
                    return $self->{'arguments'}->[0]->{'buf'}
                }
                else {
                    die('JS::inline needs a string constant')
                }
            }
            $code = 'p5pkg[' . Perlito5::Javascript2::escape_string($self->{'namespace'}) . '].' . $code
        }
        else {
            $code = Perlito5::Javascript2::pkg() . '.' . $code
        }
        my $sig;
        my $may_need_autoload;
        {
            my $name = $self->{'code'};
            my $namespace = $self->{'namespace'} || $Perlito5::PKG_NAME;
            my $effective_name = $namespace . '::' . $self->{'code'};
            if (exists($Perlito5::PROTO->{$effective_name})) {
                $sig = $Perlito5::PROTO->{$effective_name}
            }
            elsif ((!$self->{'namespace'} || $namespace eq 'CORE') && exists($Perlito5::CORE_PROTO->{'CORE::' . $name})) {
                $effective_name = 'CORE::' . $name;
                $sig = $Perlito5::CORE_PROTO->{$effective_name}
            }
            else {
                if ($self->{'bareword'}) {
                    if ($Perlito5::STRICT) {
                        die('Bareword ' . Perlito5::Javascript2::escape_string($name) . ' not allowed while "strict subs" in use')
                    }
                    return Perlito5::Javascript2::escape_string(($self->{'namespace'} ? $self->{'namespace'} . '::' : '') . $name)
                }
                $may_need_autoload = 1
            }
            (exists($self->{'proto'})) && ($sig = $self->{'proto'})
        }
        if ($sig) {
            my @out = ();
            my @in = @{$self->{'arguments'} || []};
            my $close = ']';
            my $optional = 0;
            while (length($sig)) {
                my $c = substr($sig, 0, 1);
                if ($c eq ';') {
                    $optional = 1
                }
                elsif ($c eq '$' || $c eq '_') {
                    (@in || !$optional) && push(@out, shift(@in)->emit_javascript2($level + 1, 'scalar'))
                }
                elsif ($c eq '@') {
                    (@in || !$optional) && ($close = '].concat(' . Perlito5::Javascript2::to_list(\@in, $level + 1) . ')');
                    @in = ()
                }
                elsif ($c eq '&') {
                    push(@out, shift(@in)->emit_javascript2($level + 1, 'scalar'))
                }
                elsif ($c eq '*') {
                    if (@in || !$optional) {
                        my $arg = shift(@in);
                        if ($arg->{'bareword'}) {
                            push(@out, Perlito5::Javascript2::escape_string($arg->{'code'}))
                        }
                        else {
                            push(@out, $arg->emit_javascript2($level + 1, 'scalar'))
                        }
                    }
                }
                elsif ($c eq chr(92)) {
                    if (substr($sig, 0, 2) eq chr(92) . '$') {
                        $sig = substr($sig, 1);
                        (@in || !$optional) && push(@out, shift(@in)->emit_javascript2($level + 1, 'scalar'))
                    }
                    elsif (substr($sig, 0, 2) eq chr(92) . '@' || substr($sig, 0, 2) eq chr(92) . '%') {
                        $sig = substr($sig, 1);
                        (@in || !$optional) && push(@out, shift(@in)->emit_javascript2($level + 1, 'list'))
                    }
                    elsif (substr($sig, 0, 5) eq chr(92) . '[@%]') {
                        $sig = substr($sig, 4);
                        (@in || !$optional) && push(@out, shift(@in)->emit_javascript2($level + 1, 'list'))
                    }
                    elsif (substr($sig, 0, 6) eq chr(92) . '[$@%]') {
                        $sig = substr($sig, 5);
                        (@in || !$optional) && push(@out, shift(@in)->emit_javascript2($level + 1, 'list'))
                    }
                }
                $sig = substr($sig, 1)
            }
            return $code . '([' . join(', ', @out) . $close . ', ' . Perlito5::Javascript2::to_context($wantarray) . ')'
        }
        my $arg_list = Perlito5::Javascript2::to_list_preprocess($self->{'arguments'});
        my $arg_code = $self->{'code'} eq 'scalar' ? '[' . join(', ', map($_->emit_javascript2($level), @{$arg_list})) . ']' : Perlito5::Javascript2::to_list($arg_list);
        if ($may_need_autoload) {
            my $name = $self->{'code'};
            my $namespace = $self->{'namespace'} || $Perlito5::PKG_NAME;
            return 'p5call_sub(' . Perlito5::Javascript2::escape_string($namespace) . ', ' . Perlito5::Javascript2::escape_string($name) . ', ' . $arg_code . ', ' . Perlito5::Javascript2::to_context($wantarray) . ')'
        }
        $code . '(' . $arg_code . ', ' . Perlito5::Javascript2::to_context($wantarray) . ')'
    }
    sub Perlito5::AST::Apply::emit_javascript2_set_list {
        my($self, $level, $list) = @_;
        if ($self->code() eq 'undef') {
            return $list . '.shift()'
        }
        if ($self->code() eq 'prefix:<$>') {
            return 'p5scalar_deref_set(' . Perlito5::Javascript2::emit_javascript2_autovivify($self->{'arguments'}->[0], $level + 1, 'scalar') . ', ' . $list . '.shift()' . ', ' . Perlito5::Javascript2::escape_string($Perlito5::PKG_NAME) . ')'
        }
        die('not implemented: assign to ', $self->code())
    }
    sub Perlito5::AST::Apply::emit_javascript2_get_decl {
        my $self = shift;
        my $code = $self->{'code'};
        if ($code eq 'my' || $code eq 'our' || $code eq 'state' || $code eq 'local') {
            return (map {
                ref($_) eq 'Perlito5::AST::Var' ? Perlito5::AST::Decl::->new('decl' => $code, 'type' => '', 'var' => $_) : ()
            } @{$self->{'arguments'}})
        }
        if ($code ne 'do' && $code ne 'eval') {
            $self->{'arguments'} && return (map(+($_->emit_javascript2_get_decl()), @{$self->{'arguments'}}))
        }
        return ()
    }
    sub Perlito5::AST::Apply::emit_javascript2_has_regex {
        my $self = shift;
        my $code = $self->{'code'};
        if ($code eq 'p5:m' || $code eq 'p5:s' || $code eq 'infix:<=~>' || $code eq 'infix:<!~>') {
            return 1
        }
        return ()
    }
}
package Perlito5::AST::If;
{
    sub Perlito5::AST::If::emit_javascript2 {
        my($self, $level, $wantarray) = @_;
        my $cond = $self->{'cond'};
        my @str;
        my $old_level = $level;
        if ($cond) {
            my @var_decl = $cond->emit_javascript2_get_decl();
            for my $arg (@var_decl) {
                $level = $old_level + 1;
                push(@str, $arg->emit_javascript2_init($level, $wantarray))
            }
        }
        my $body = ref($self->{'body'}) ne 'Perlito5::AST::Block' ? $self->{'body'} : (!@{$self->{'body'}->stmts()}) ? undef : $wantarray ne 'void' ? Perlito5::Javascript2::LexicalBlock::->new('block' => $self->{'body'}->stmts()) : Perlito5::Javascript2::LexicalBlock::->new('block' => $self->{'body'}->stmts(), 'create_context' => 1);
        my $otherwise = ref($self->{'otherwise'}) ne 'Perlito5::AST::Block' ? $self->{'otherwise'} : (!@{$self->{'otherwise'}->stmts()}) ? undef : $wantarray ne 'void' ? Perlito5::Javascript2::LexicalBlock::->new('block' => $self->{'otherwise'}->stmts()) : Perlito5::Javascript2::LexicalBlock::->new('block' => $self->{'otherwise'}->stmts(), 'create_context' => 1);
        my $s = 'if ( ' . Perlito5::Javascript2::to_bool($cond, $level + 1) . ' ) {';
        if ($body) {
            $s = $s . chr(10) . Perlito5::Javascript2::tab($level + 1) . $body->emit_javascript2($level + 1, $wantarray) . chr(10) . Perlito5::Javascript2::tab($level) . '}'
        }
        else {
            $s = $s . '}'
        }
        if ($otherwise) {
            if (@{$otherwise->{'block'}} == 1 && ref($otherwise->{'block'}->[0]) eq 'Perlito5::AST::If') {
                $s = $s . chr(10) . Perlito5::Javascript2::tab($level) . 'else ' . $otherwise->{'block'}->[0]->emit_javascript2($level, $wantarray)
            }
            else {
                $s = $s . chr(10) . Perlito5::Javascript2::tab($level) . 'else {' . chr(10) . Perlito5::Javascript2::tab($level + 1) . $otherwise->emit_javascript2($level + 1, $wantarray) . chr(10) . Perlito5::Javascript2::tab($level) . '}'
            }
        }
        push(@str, $s);
        if (@str) {
            $level = $old_level;
            return ($wantarray ne 'void' ? 'return ' : '') . Perlito5::Javascript2::emit_wrap_javascript2($level, $wantarray, @str)
        }
        else {
            return join(chr(10) . Perlito5::Javascript2::tab($level), @str)
        }
    }
    sub Perlito5::AST::If::emit_javascript2_get_decl {
        ()
    }
    sub Perlito5::AST::If::emit_javascript2_has_regex {
        ()
    }
}
package Perlito5::AST::When;
{
    sub Perlito5::AST::When::emit_javascript2 {
        die(chr(39) . 'when' . chr(39) . ' is not implemented')
    }
    sub Perlito5::AST::When::emit_javascript2_get_decl {
        ()
    }
    sub Perlito5::AST::When::emit_javascript2_has_regex {
        ()
    }
}
package Perlito5::AST::While;
{
    sub Perlito5::AST::While::emit_javascript2 {
        my($self, $level, $wantarray) = @_;
        my $cond = $self->{'cond'};
        my $do_at_least_once = ref($self->{'body'}) eq 'Perlito5::AST::Apply' && $self->{'body'}->{'code'} eq 'do' ? 1 : 0;
        my $body = ref($self->{'body'}) ne 'Perlito5::AST::Block' ? [$self->{'body'}] : $self->{'body'}->{'stmts'};
        my @str;
        my $old_level = $level;
        if ($cond) {
            my @var_decl = $cond->emit_javascript2_get_decl();
            for my $arg (@var_decl) {
                $level = $old_level + 1;
                push(@str, $arg->emit_javascript2_init($level, $wantarray))
            }
        }
        push(@str, 'p5while(' . 'function () {' . chr(10) . Perlito5::Javascript2::tab($level + 2) . (Perlito5::Javascript2::LexicalBlock::->new('block' => $body))->emit_javascript2($level + 2, $wantarray) . chr(10) . Perlito5::Javascript2::tab($level + 1) . '}, ' . Perlito5::Javascript2::emit_function_javascript2($level + 1, 'void', $cond) . ', ' . Perlito5::AST::Block::emit_javascript2_continue($self, $level, $wantarray) . ', ' . Perlito5::Javascript2::escape_string($self->{'label'} || '') . ', ' . $do_at_least_once . ')');
        if (@str) {
            $level = $old_level;
            return Perlito5::Javascript2::emit_wrap_javascript2($level, $wantarray, @str)
        }
        else {
            return join(chr(10) . Perlito5::Javascript2::tab($level), @str)
        }
    }
    sub Perlito5::AST::While::emit_javascript2_get_decl {
        ()
    }
    sub Perlito5::AST::While::emit_javascript2_has_regex {
        ()
    }
}
package Perlito5::AST::For;
{
    sub Perlito5::AST::For::emit_javascript2 {
        my($self, $level, $wantarray) = @_;
        my $body = ref($self->{'body'}) ne 'Perlito5::AST::Block' ? [$self->{'body'}] : $self->{'body'}->{'stmts'};
        my @str;
        my $old_level = $level;
        my $cond = ref($self->{'cond'}) eq 'ARRAY' ? $self->{'cond'} : [$self->{'cond'}];
        for my $expr (@{$cond}, $self->{'topic'}) {
            if ($expr) {
                my @var_decl = $expr->emit_javascript2_get_decl();
                for my $arg (@var_decl) {
                    $level = $old_level + 1;
                    push(@str, $arg->emit_javascript2_init($level, $wantarray))
                }
            }
        }
        if (ref($self->{'cond'}) eq 'ARRAY') {
            push(@str, Perlito5::Javascript2::emit_wrap_javascript2($level, $wantarray, 'var label = ' . Perlito5::Javascript2::escape_string(($self->{'label'} || '')) . ';', 'for ( ' . ($self->{'cond'}->[0] ? $self->{'cond'}->[0]->emit_javascript2($level + 1) . '; ' : '; ') . ($self->{'cond'}->[1] ? Perlito5::Javascript2::to_bool($self->{'cond'}->[1], $level + 1) . '; ' : '; ') . ($self->{'cond'}->[2] ? $self->{'cond'}->[2]->emit_javascript2($level + 1) . ' ' : '') . ') {', ['var _redo = true;', 'while(_redo) {', ['_redo = false;', 'try {', [Perlito5::Javascript2::LexicalBlock::->new('block' => $body)->emit_javascript2($level + 4, $wantarray)], '}', 'catch(err) {', ['if (err instanceof p5_error && (err.v == label || err.v == ' . chr(39) . chr(39) . ')) {', ['if (err.type == ' . chr(39) . 'last' . chr(39) . ') { return }', 'else if (err.type == ' . chr(39) . 'redo' . chr(39) . ') { _redo = true }', 'else if (err.type != ' . chr(39) . 'next' . chr(39) . ') { throw(err) }'], '}', 'else {', ['throw(err)'], '}'], '}'], '}'], '}'))
        }
        else {
            my $cond = Perlito5::Javascript2::to_list([$self->{'cond'}], $level + 1);
            my $topic = $self->{'topic'};
            my $decl = '';
            my $v = $topic;
            if ($v->{'decl'}) {
                $decl = $v->{'decl'};
                $v = $v->{'var'}
            }
            else {
                $decl = $v->{'_decl'} || 'global'
            }
            my $namespace = $v->{'namespace'} || $v->{'_namespace'} || $Perlito5::PKG_NAME;
            my $s;
            if ($decl eq 'my' || $decl eq 'state') {
                my $sig = $v->emit_javascript2($level + 1);
                push(@str, 'p5for_lex(' . 'function (' . $sig . ') {' . chr(10) . Perlito5::Javascript2::tab($level + 2) . (Perlito5::Javascript2::LexicalBlock::->new('block' => $body))->emit_javascript2($level + 2, $wantarray) . chr(10) . Perlito5::Javascript2::tab($level + 1) . '}, ' . $cond . ', ' . Perlito5::AST::Block::emit_javascript2_continue($self, $level, $wantarray) . ', ' . Perlito5::Javascript2::escape_string($self->{'label'} || '') . ')')
            }
            else {
                push(@str, 'p5for(' . 'p5make_package(' . Perlito5::Javascript2::escape_string($namespace) . '), ' . '"v_' . $v->{'name'} . '", ' . 'function () {' . chr(10) . Perlito5::Javascript2::tab($level + 2) . (Perlito5::Javascript2::LexicalBlock::->new('block' => $body))->emit_javascript2($level + 2, $wantarray) . chr(10) . Perlito5::Javascript2::tab($level + 1) . '}, ' . $cond . ', ' . Perlito5::AST::Block::emit_javascript2_continue($self, $level, $wantarray) . ', ' . Perlito5::Javascript2::escape_string($self->{'label'} || '') . ')')
            }
        }
        if (@str > 1) {
            $level = $old_level;
            return Perlito5::Javascript2::emit_wrap_javascript2($level, $wantarray, @str)
        }
        else {
            return join(chr(10) . Perlito5::Javascript2::tab($level), @str)
        }
    }
    sub Perlito5::AST::For::emit_javascript2_get_decl {
        ()
    }
    sub Perlito5::AST::For::emit_javascript2_has_regex {
        ()
    }
}
package Perlito5::AST::Sub;
{
    sub Perlito5::AST::Sub::emit_javascript2 {
        my($self, $level, $wantarray) = @_;
        my $prototype = defined($self->{'sig'}) ? Perlito5::Javascript2::escape_string($self->{'sig'}) : 'null';
        my $sub_ref = Perlito5::Javascript2::get_label();
        local $Perlito5::AST::Sub::SUB_REF = $sub_ref;
        my $js_block = Perlito5::Javascript2::LexicalBlock::->new('block' => $self->{'block'}->{'stmts'})->emit_javascript2_subroutine_body($level + 2, 'runtime');
        my $s = Perlito5::Javascript2::emit_wrap_javascript2($level, 'scalar', 'var ' . $sub_ref . ';', $sub_ref . ' = function (List__, p5want) {', [$js_block], '};', $sub_ref . '._prototype_ = ' . $prototype . ';', 'return ' . $sub_ref);
        if ($self->{'name'}) {
            return 'p5typeglob_set(' . Perlito5::Javascript2::escape_string($self->{'namespace'}) . ', ' . Perlito5::Javascript2::escape_string($self->{'name'}) . ', ' . $s . ')'
        }
        else {
            return $s
        }
    }
    sub Perlito5::AST::Sub::emit_javascript2_get_decl {
        ()
    }
    sub Perlito5::AST::Sub::emit_javascript2_has_regex {
        ()
    }
}
package Perlito5::AST::Use;
{
    sub Perlito5::AST::Use::emit_javascript2 {
        my($self, $level, $wantarray) = @_;
        Perlito5::Grammar::Use::emit_time_eval($self);
        if ($wantarray ne 'void') {
            return 'p5context([], p5want)'
        }
        else {
            return '// ' . $self->{'code'} . ' ' . $self->{'mod'} . chr(10)
        }
    }
    sub Perlito5::AST::Use::emit_javascript2_get_decl {
        ()
    }
    sub Perlito5::AST::Use::emit_javascript2_has_regex {
        ()
    }
}
# use Perlito5::Javascript2::Emitter
package main;
undef();
package Perlito5::Javascript2::Runtime;
sub Perlito5::Javascript2::Runtime::perl5_to_js {
    my($source, $namespace, $want, $scope_js) = @_;
    my $strict_old = $Perlito5::STRICT;
    local $Perlito5::BASE_SCOPE = $scope_js->[0];
    local @Perlito5::SCOPE_STMT;
    local $Perlito5::SCOPE = $Perlito5::BASE_SCOPE;
    local $Perlito5::SCOPE_DEPTH = 0;
    local $Perlito5::PKG_NAME = $namespace;
    my $match = Perlito5::Grammar::exp_stmts($source, 0);
    if (!$match || $match->{'to'} != length($source)) {
        die('Syntax error in eval near pos ', $match->{'to'})
    }
    my $ast = Perlito5::AST::Apply::->new('code' => 'do', 'arguments' => [Perlito5::AST::Block::->new('stmts' => $match->{'capture'})]);
    my $js_code = $ast->emit_javascript2(0, $want);
    $Perlito5::STRICT = $strict_old;
    return $js_code
}
sub Perlito5::Javascript2::Runtime::emit_javascript2 {
    return '//' . chr(10) . '// lib/Perlito5/Javascript2/Runtime.js' . chr(10) . '//' . chr(10) . '// Runtime for "Perlito" Perl5-in-Javascript2' . chr(10) . '//' . chr(10) . '// AUTHORS' . chr(10) . '//' . chr(10) . '// Flavio Soibelmann Glock  fglock@gmail.com' . chr(10) . '//' . chr(10) . '// COPYRIGHT' . chr(10) . '//' . chr(10) . '// Copyright 2009, 2010, 2011, 2012 by Flavio Soibelmann Glock and others.' . chr(10) . '//' . chr(10) . '// This program is free software; you can redistribute it and/or modify it' . chr(10) . '// under the same terms as Perl itself.' . chr(10) . '//' . chr(10) . '// See http://www.perl.com/perl/misc/Artistic.html' . chr(10) . chr(10) . '"use strict";' . chr(10) . 'var isNode = typeof require != "undefined";' . chr(10) . chr(10) . 'if (typeof p5pkg !== "object") {' . chr(10) . '    var p5pkg = {};' . chr(10) . '    var p5LOCAL = [];' . chr(10) . chr(10) . '    var universal = function () {};' . chr(10) . '    p5pkg.UNIVERSAL = new universal();' . chr(10) . '    p5pkg.UNIVERSAL._ref_ = "UNIVERSAL";' . chr(10) . '    p5pkg.UNIVERSAL.isa = function (List__) {' . chr(10) . '        // TODO - use @ISA' . chr(10) . '        return List__[0]._class_._ref_ == List__[1]' . chr(10) . '    };' . chr(10) . '    p5pkg.UNIVERSAL.can = function (List__) {' . chr(10) . '        var o = List__[0];' . chr(10) . '        var s = List__[1];' . chr(10) . '        if ( s.indexOf("::") == -1 ) {' . chr(10) . '            return p5method_lookup(s, o._class_._ref__, {})' . chr(10) . '        }' . chr(10) . '        var c = s.split("::");' . chr(10) . '        s = c.pop(); ' . chr(10) . '        return p5method_lookup(s, c.join("::"), {});' . chr(10) . '    };' . chr(10) . '    p5pkg.UNIVERSAL.DOES = p5pkg.UNIVERSAL.can;' . chr(10) . chr(10) . '    var core = function () {};' . chr(10) . '    p5pkg["CORE"] = new core();' . chr(10) . '    p5pkg["CORE"]._ref_ = "CORE";' . chr(10) . chr(10) . '    var core_global = function () {};' . chr(10) . '    core_global.prototype = p5pkg.CORE;' . chr(10) . '    p5pkg["CORE::GLOBAL"] = new core_global();' . chr(10) . '    p5pkg["CORE::GLOBAL"]._ref_ = "CORE::GLOBAL";' . chr(10) . chr(10) . '    var p5_error = function (type, v) {' . chr(10) . '        this.type = type;' . chr(10) . '        this.v = this.message = v;' . chr(10) . '        this.toString = function(){' . chr(10) . '            if (this.type == ' . chr(39) . 'break' . chr(39) . ') {' . chr(10) . '                return ' . chr(39) . 'Can' . chr(92) . chr(39) . 't "break" outside a given block' . chr(39) . chr(10) . '            }' . chr(10) . '            if (this.type == ' . chr(39) . 'next' . chr(39) . ' || this.type == ' . chr(39) . 'last' . chr(39) . ' || this.type == ' . chr(39) . 'redo' . chr(39) . ') {' . chr(10) . '                if (this.v == "") { return ' . chr(39) . 'Can' . chr(92) . chr(39) . 't "' . chr(39) . ' + this.type + ' . chr(39) . '" outside a loop block' . chr(39) . ' }' . chr(10) . '                return ' . chr(39) . 'Label not found for "' . chr(39) . ' + this.type + ' . chr(39) . ' ' . chr(39) . ' + this.v + ' . chr(39) . '"' . chr(39) . ';' . chr(10) . '            }' . chr(10) . '            return this.v;' . chr(10) . '        };' . chr(10) . '    };' . chr(10) . '    p5_error.prototype = Error.prototype;' . chr(10) . '}' . chr(10) . chr(10) . 'function p5make_package(pkg_name) {' . chr(10) . '    if (!p5pkg.hasOwnProperty(pkg_name)) {' . chr(10) . '        var tmp = function () {};' . chr(10) . '        tmp.prototype = p5pkg["CORE::GLOBAL"];' . chr(10) . '        p5pkg[pkg_name] = new tmp();' . chr(10) . '        p5pkg[pkg_name]._ref_ = pkg_name;' . chr(10) . '        p5pkg[pkg_name]._class_ = p5pkg[pkg_name];  // XXX memory leak' . chr(10) . '        p5pkg[pkg_name]._is_package_ = 1;' . chr(10) . chr(10) . '        // TODO - add the other package global variables' . chr(10) . '        p5pkg[pkg_name]["List_ISA"] = [];' . chr(10) . '        p5pkg[pkg_name]["v_a"] = null;' . chr(10) . '        p5pkg[pkg_name]["v_b"] = null;' . chr(10) . '        p5pkg[pkg_name]["v__"] = null;' . chr(10) . '        p5pkg[pkg_name]["v_AUTOLOAD"] = null;' . chr(10) . '    }' . chr(10) . '    return p5pkg[pkg_name];' . chr(10) . '}' . chr(10) . chr(10) . 'function p5code_lookup_by_name(package_name, sub_name) {' . chr(10) . '    // sub_name can be a function already' . chr(10) . '    if (typeof sub_name === "function") {' . chr(10) . '        return sub_name;' . chr(10) . '    }' . chr(10) . '    // sub_name can have an optional namespace' . chr(10) . '    var parts = sub_name.split(/::/);' . chr(10) . '    if (parts.length > 1) {' . chr(10) . '        sub_name = parts.pop();' . chr(10) . '        package_name = parts.join("::");' . chr(10) . '    }' . chr(10) . '    if (p5pkg.hasOwnProperty(package_name)) {' . chr(10) . '        var c = p5pkg[package_name];' . chr(10) . '        if ( c.hasOwnProperty(sub_name) ) {' . chr(10) . '            return c[sub_name]' . chr(10) . '        }' . chr(10) . '    }' . chr(10) . '    return null;' . chr(10) . '}' . chr(10) . chr(10) . 'function p5get_class_for_method(method, class_name, seen) {' . chr(10) . '    // default mro' . chr(10) . '    // TODO - cache the methods that were already looked up' . chr(10) . '    if ( p5pkg[class_name].hasOwnProperty(method) ) {' . chr(10) . '        return class_name' . chr(10) . '    }' . chr(10) . '    var isa = p5pkg[class_name].List_ISA;' . chr(10) . '    if (isa) {' . chr(10) . '        for (var i = 0; i < isa.length; i++) {' . chr(10) . '            if (!seen[isa[i]]) {' . chr(10) . '                var m = p5get_class_for_method(method, isa[i], seen);' . chr(10) . '                if (m) {' . chr(10) . '                    return m ' . chr(10) . '                }' . chr(10) . '                seen[isa[i]]++;' . chr(10) . '            }' . chr(10) . '        }' . chr(10) . '    }' . chr(10) . '}' . chr(10) . chr(10) . 'function p5method_lookup(method, class_name, seen) {' . chr(10) . '    var c = p5get_class_for_method(method, class_name, seen);' . chr(10) . '    if (c) {' . chr(10) . '        return p5pkg[c][method]' . chr(10) . '    }' . chr(10) . '    if ( p5pkg.UNIVERSAL.hasOwnProperty(method) ) {' . chr(10) . '        return p5pkg.UNIVERSAL[method]' . chr(10) . '    }' . chr(10) . '}' . chr(10) . chr(10) . 'function p5call(invocant, method, list, p5want) {' . chr(10) . '    var invocant_original = invocant;' . chr(10) . '    if (typeof invocant === "string") {' . chr(10) . '        list.unshift(invocant);' . chr(10) . '        invocant = p5make_package(invocant);' . chr(10) . '    }' . chr(10) . '    else if ( invocant.hasOwnProperty("_is_package_") ) {' . chr(10) . '        list.unshift(invocant._ref_);   // invocant is a "package" object' . chr(10) . '    }' . chr(10) . '    else {' . chr(10) . '        list.unshift(invocant);' . chr(10) . '    }' . chr(10) . chr(10) . '    if ( invocant.hasOwnProperty("_class_") ) {' . chr(10) . chr(10) . '        if ( invocant._class_.hasOwnProperty(method) ) {' . chr(10) . '            return invocant._class_[method](list, p5want)' . chr(10) . '        }' . chr(10) . '        var m = p5method_lookup(method, invocant._class_._ref_, {});' . chr(10) . '        if (m) {' . chr(10) . '            return m(list, p5want)' . chr(10) . '        }' . chr(10) . chr(10) . '        // method can have an optional namespace' . chr(10) . '        var pkg_name = method.split(/::/);' . chr(10) . '        if (pkg_name.length > 1) {' . chr(10) . '            var name = pkg_name.pop();' . chr(10) . '            pkg_name = pkg_name.join("::");' . chr(10) . '            m = p5method_lookup(name, pkg_name, {});' . chr(10) . '            if (m) {' . chr(10) . '                return m(list, p5want)' . chr(10) . '            }' . chr(10) . '            p5pkg.CORE.die(["method not found: ", name, " in class ", pkg_name]);' . chr(10) . '        }' . chr(10) . chr(10) . '        if (method == "print" || method == "printf" || method == "say" || method == "close") {' . chr(10) . '            list.shift();' . chr(10) . '            return p5pkg[' . chr(39) . 'Perlito5::IO' . chr(39) . '][method]( invocant_original, list, p5want);' . chr(10) . '        }' . chr(10) . chr(10) . '        pkg_name = p5get_class_for_method(' . chr(39) . 'AUTOLOAD' . chr(39) . ', invocant._class_._ref_, {}) || p5get_class_for_method(' . chr(39) . 'AUTOLOAD' . chr(39) . ', "UNIVERSAL", {});' . chr(10) . '        if (pkg_name) {' . chr(10) . '            p5pkg[pkg_name]["v_AUTOLOAD"] = invocant._class_._ref_ + "::" + method;' . chr(10) . '            return p5pkg[pkg_name]["AUTOLOAD"](list, p5want);' . chr(10) . '        }' . chr(10) . chr(10) . '        p5pkg.CORE.die(["method not found: ", method, " in class ", invocant._class_._ref_]);' . chr(10) . chr(10) . '    }' . chr(10) . chr(10) . '    p5pkg.CORE.die(["Can' . chr(39) . 't call method ", method, " on unblessed reference"]);' . chr(10) . chr(10) . '}' . chr(10) . chr(10) . 'function p5call_sub(namespace, name, list, p5want) {' . chr(10) . '    if(p5pkg[namespace].hasOwnProperty(name)) {' . chr(10) . '        return p5pkg[namespace][name](list, p5want)' . chr(10) . '    }' . chr(10) . '    if(p5pkg[namespace].hasOwnProperty("AUTOLOAD")) {' . chr(10) . '        p5pkg[namespace]["v_AUTOLOAD"] = namespace + "::" + name;' . chr(10) . '        return p5pkg[namespace]["AUTOLOAD"](list, p5want)' . chr(10) . '    }' . chr(10) . '    p5pkg.CORE.die(["Undefined subroutine &" + namespace + "::" + name]);' . chr(10) . '}' . chr(10) . chr(10) . 'function p5sub_exists(name, current_pkg_name) {' . chr(10) . '    var v = name;' . chr(10) . '    var pkg_name = v.split(/::/);' . chr(10) . '    if (pkg_name.length > 1) {' . chr(10) . '        v = pkg_name.pop();' . chr(10) . '        pkg_name = pkg_name.join("::");' . chr(10) . '    }' . chr(10) . '    else {' . chr(10) . '        pkg_name = current_pkg_name;' . chr(10) . '    }' . chr(10) . '    var c = v.charCodeAt(0);' . chr(10) . '    if (c < 27) {' . chr(10) . '        v = String.fromCharCode(c + 64) + v.substr(1);' . chr(10) . '        pkg_name = ' . chr(39) . 'main' . chr(39) . ';' . chr(10) . '    }' . chr(10) . '    return p5pkg.hasOwnProperty(pkg_name) && p5pkg[pkg_name].hasOwnProperty(v) ' . chr(10) . '}' . chr(10) . chr(10) . 'function p5sub_prototype(name, current_pkg_name) {' . chr(10) . '    if (!name) {' . chr(10) . '        return null;' . chr(10) . '    }' . chr(10) . '    if (typeof name === "function") {' . chr(10) . '        return name._prototype_;' . chr(10) . '    }' . chr(10) . '    var v = name;' . chr(10) . '    var pkg_name = v.split(/::/);' . chr(10) . '    if (pkg_name.length > 1) {' . chr(10) . '        v = pkg_name.pop();' . chr(10) . '        pkg_name = pkg_name.join("::");' . chr(10) . '    }' . chr(10) . '    else {' . chr(10) . '        pkg_name = current_pkg_name;' . chr(10) . '    }' . chr(10) . '    var c = v.charCodeAt(0);' . chr(10) . '    if (c < 27) {' . chr(10) . '        v = String.fromCharCode(c + 64) + v.substr(1);' . chr(10) . '        pkg_name = ' . chr(39) . 'main' . chr(39) . ';' . chr(10) . '    }' . chr(10) . '    if (p5pkg.hasOwnProperty(pkg_name) && p5pkg[pkg_name].hasOwnProperty(v)) {' . chr(10) . '        return p5pkg[pkg_name][v]._prototype_' . chr(10) . '    }' . chr(10) . '    return p5pkg["Perlito5"].v_PROTO._hash_[name] || p5pkg["Perlito5"].v_CORE_PROTO._hash_[name]' . chr(10) . '}' . chr(10) . chr(10) . 'function p5scalar_deref(v, current_pkg_name, autoviv_type) {' . chr(10) . '    if (typeof v === "string") {' . chr(10) . '        var pkg_name = v.split(/::/);' . chr(10) . '        if (pkg_name.length > 1) {' . chr(10) . '            v = pkg_name.pop();' . chr(10) . '            pkg_name = pkg_name.join("::");' . chr(10) . '        }' . chr(10) . '        else {' . chr(10) . '            pkg_name = current_pkg_name;' . chr(10) . '        }' . chr(10) . '        var c = v.charCodeAt(0);' . chr(10) . '        if (c < 27) {' . chr(10) . '            v = String.fromCharCode(c + 64) + v.substr(1);' . chr(10) . '            pkg_name = ' . chr(39) . 'main' . chr(39) . ';' . chr(10) . '        }' . chr(10) . '        var name = "v_"+v;' . chr(10) . '        if (!p5make_package(pkg_name)[name]) {' . chr(10) . '            if (autoviv_type == ' . chr(39) . 'array' . chr(39) . ') {' . chr(10) . '                p5pkg[pkg_name][name] = new p5ArrayRef([]);' . chr(10) . '            }' . chr(10) . '            else if (autoviv_type == ' . chr(39) . 'hash' . chr(39) . ') {' . chr(10) . '                p5pkg[pkg_name][name] = new p5HashRef([]);' . chr(10) . '            }' . chr(10) . '            else if (autoviv_type == ' . chr(39) . 'scalar' . chr(39) . ') {' . chr(10) . '                p5pkg[pkg_name][name] = new p5ScalarRef([]);' . chr(10) . '            }' . chr(10) . '        }' . chr(10) . '        return p5pkg[pkg_name][name];' . chr(10) . '    }' . chr(10) . '    if (!v._scalar_) {' . chr(10) . '        if (autoviv_type == ' . chr(39) . 'array' . chr(39) . ') {' . chr(10) . '            v._scalar_ = new p5ArrayRef([]);' . chr(10) . '        }' . chr(10) . '        else if (autoviv_type == ' . chr(39) . 'hash' . chr(39) . ') {' . chr(10) . '            v._scalar_ = new p5HashRef([]);' . chr(10) . '        }' . chr(10) . '        else if (autoviv_type == ' . chr(39) . 'scalar' . chr(39) . ') {' . chr(10) . '            v._scalar_ = new p5ScalarRef([]);' . chr(10) . '        }' . chr(10) . '    }' . chr(10) . '    return v._scalar_;' . chr(10) . '}' . chr(10) . chr(10) . 'function p5scalar_deref_set(v, n, current_pkg_name) {' . chr(10) . '    if (typeof v === "string") {' . chr(10) . '        var pkg_name = v.split(/::/);' . chr(10) . '        if (pkg_name.length > 1) {' . chr(10) . '            v = pkg_name.pop();' . chr(10) . '            pkg_name = pkg_name.join("::");' . chr(10) . '        }' . chr(10) . '        else {' . chr(10) . '            pkg_name = current_pkg_name;' . chr(10) . '        }' . chr(10) . '        var c = v.charCodeAt(0);' . chr(10) . '        if (c < 27) {' . chr(10) . '            v = String.fromCharCode(c + 64) + v.substr(1);' . chr(10) . '            pkg_name = ' . chr(39) . 'main' . chr(39) . ';' . chr(10) . '        }' . chr(10) . '        var name = "v_"+v;' . chr(10) . '        p5make_package(pkg_name)[name] = n;' . chr(10) . '        return p5pkg[pkg_name][name];' . chr(10) . '    }' . chr(10) . '    v._scalar_ = n;' . chr(10) . '    return v._scalar_;' . chr(10) . '}' . chr(10) . chr(10) . 'function p5array_deref(v, current_pkg_name) {' . chr(10) . '    if (typeof v === "string") {' . chr(10) . '        var pkg_name = v.split(/::/);' . chr(10) . '        if (pkg_name.length > 1) {' . chr(10) . '            v = pkg_name.pop();' . chr(10) . '            pkg_name = pkg_name.join("::");' . chr(10) . '        }' . chr(10) . '        else {' . chr(10) . '            pkg_name = current_pkg_name;' . chr(10) . '        }' . chr(10) . '        var c = v.charCodeAt(0);' . chr(10) . '        if (c < 27) {' . chr(10) . '            v = String.fromCharCode(c + 64) + v.substr(1);' . chr(10) . '            pkg_name = ' . chr(39) . 'main' . chr(39) . ';' . chr(10) . '        }' . chr(10) . '        var name = "List_"+v;' . chr(10) . '        if (!p5make_package(pkg_name)[name]) {' . chr(10) . '                p5pkg[pkg_name][name] = [];' . chr(10) . '        }' . chr(10) . '        return p5pkg[pkg_name][name];' . chr(10) . '    }' . chr(10) . '    return v._array_;' . chr(10) . '}' . chr(10) . chr(10) . 'function p5hash_deref(v, current_pkg_name) {' . chr(10) . '    if (typeof v === "string") {' . chr(10) . '        var pkg_name = v.split(/::/);' . chr(10) . '        if (pkg_name.length > 1) {' . chr(10) . '            v = pkg_name.pop();' . chr(10) . '            pkg_name = pkg_name.join("::");' . chr(10) . '        }' . chr(10) . '        else {' . chr(10) . '            pkg_name = current_pkg_name;' . chr(10) . '        }' . chr(10) . '        var c = v.charCodeAt(0);' . chr(10) . '        if (c < 27) {' . chr(10) . '            v = String.fromCharCode(c + 64) + v.substr(1);' . chr(10) . '            pkg_name = ' . chr(39) . 'main' . chr(39) . ';' . chr(10) . '        }' . chr(10) . '        var name = "Hash_"+v;' . chr(10) . '        if (!p5make_package(pkg_name)[name]) {' . chr(10) . '                p5pkg[pkg_name][name] = [];' . chr(10) . '        }' . chr(10) . '        return p5pkg[pkg_name][name];' . chr(10) . '    }' . chr(10) . '    return v._hash_;' . chr(10) . '}' . chr(10) . chr(10) . '// regex globals' . chr(10) . 'p5make_package("Regex");' . chr(10) . 'var p5_last_regex = new RegExp("", "");' . chr(10) . 'var p5_regex_capture = [];' . chr(10) . chr(10) . 'p5make_package("main");' . chr(10) . 'p5make_package("Perlito5");' . chr(10) . 'p5pkg["Perlito5"].v_PKG_NAME = "main";' . chr(10) . 'p5make_package("main::STDIN").file_handle = { id : 0, readline_buffer : ' . chr(39) . chr(39) . ' };' . chr(10) . 'p5make_package("main::STDOUT").file_handle = { id : 1 };' . chr(10) . 'p5make_package("main::STDERR").file_handle = { id : 2 };' . chr(10) . 'p5make_package("ARGV").file_handle = { id : null };' . chr(10) . 'p5pkg["STDOUT"] = p5pkg["main::STDOUT"];' . chr(10) . 'p5pkg["STDERR"] = p5pkg["main::STDERR"];' . chr(10) . 'p5pkg["STDIN"] = p5pkg["main::STDIN"];' . chr(10) . 'p5pkg["Perlito5"].v_SELECT = "main::STDOUT";' . chr(10) . 'p5pkg["main"]["v_@"] = [];      // $@' . chr(10) . 'p5pkg["main"]["v_|"] = 0;       // $|' . chr(10) . 'p5pkg["main"]["v_/"] = "' . chr(92) . 'n";    // $/' . chr(10) . 'p5pkg["main"][' . chr(39) . 'v_"' . chr(39) . '] = " ";     // $"' . chr(10) . 'p5pkg["main"]["List_#"] = [];   // @#' . chr(10) . 'p5scalar_deref_set(String.fromCharCode(15), isNode ? "node.js" : "javascript2");  // $^O' . chr(10) . 'p5pkg["main"]["List_INC"] = [];' . chr(10) . 'p5pkg["main"]["Hash_INC"] = {};' . chr(10) . 'p5pkg["main"]["List_ARGV"] = [];' . chr(10) . 'p5pkg["main"]["Hash_ENV"] = {};' . chr(10) . 'p5pkg["main"]["Hash_SIG"] = {};' . chr(10) . 'if (isNode) {' . chr(10) . '    p5pkg["main"]["List_ARGV"] = process.argv.splice(2);' . chr(10) . chr(10) . '    p5pkg["main"]["Hash_ENV"] = {};' . chr(10) . '    for (var e in process.env) p5pkg["main"]["Hash_ENV"][e] = process.env[e];' . chr(10) . chr(10) . '    p5pkg["main"]["v_$"] = process.pid;   // $$' . chr(10) . '    p5scalar_deref_set(String.fromCharCode(24), process.argv[0]);  // $^X' . chr(10) . '} else if (typeof arguments === "object") {' . chr(10) . '    p5pkg["main"]["List_ARGV"] = arguments;' . chr(10) . '}' . chr(10) . chr(10) . 'p5make_package("Perlito5::IO");' . chr(10) . 'p5make_package("Perlito5::Runtime");' . chr(10) . 'p5make_package("Perlito5::Grammar");' . chr(10) . chr(10) . 'var sigils = { ' . chr(39) . '@' . chr(39) . ' : ' . chr(39) . 'List_' . chr(39) . ', ' . chr(39) . '%' . chr(39) . ' : ' . chr(39) . 'Hash_' . chr(39) . ', ' . chr(39) . '$' . chr(39) . ' : ' . chr(39) . 'v_' . chr(39) . ', ' . chr(39) . '&' . chr(39) . ' : ' . chr(39) . chr(39) . ' };' . chr(10) . chr(10) . 'function p5typeglob_set(namespace, name, obj) {' . chr(10) . '    p5make_package(namespace);' . chr(10) . '    if ( obj.hasOwnProperty("_ref_") ) {' . chr(10) . '        if ( obj._ref_ == "HASH" ) {' . chr(10) . '            p5pkg[namespace][sigils[' . chr(39) . '%' . chr(39) . '] + name] = obj._hash_;' . chr(10) . '        }' . chr(10) . '        else if ( obj._ref_ == "ARRAY" ) {' . chr(10) . '            p5pkg[namespace][sigils[' . chr(39) . '@' . chr(39) . '] + name] = obj._array_;' . chr(10) . '        }' . chr(10) . '        else if ( obj._ref_ == "SCALAR" ) {' . chr(10) . '            p5pkg[namespace][sigils[' . chr(39) . '$' . chr(39) . '] + name] = obj._scalar_;' . chr(10) . '        }' . chr(10) . '        else if ( obj._ref_ == "CODE" ) {' . chr(10) . '            p5pkg[namespace][sigils[' . chr(39) . '&' . chr(39) . '] + name] = obj._code_;' . chr(10) . '        }' . chr(10) . '        else if ( obj._ref_ == "GLOB" ) {' . chr(10) . '            // TODO' . chr(10) . '            p5pkg[namespace][name] = obj;' . chr(10) . '        }' . chr(10) . '    }' . chr(10) . '    else {' . chr(10) . '        p5pkg[namespace][name] = obj;   // native CODE' . chr(10) . '        // TODO - non-reference' . chr(10) . '    }' . chr(10) . '    return p5pkg[namespace][name];  // TODO - return GLOB' . chr(10) . '}' . chr(10) . chr(10) . 'function p5typeglob_deref_set(v, obj, current_pkg_name) {' . chr(10) . '    if (typeof v === "string") {' . chr(10) . '        var pkg_name = v.split(/::/);' . chr(10) . '        if (pkg_name.length > 1) {' . chr(10) . '            v = pkg_name.pop();' . chr(10) . '            pkg_name = pkg_name.join("::");' . chr(10) . '        }' . chr(10) . '        else {' . chr(10) . '            pkg_name = current_pkg_name;' . chr(10) . '        }' . chr(10) . '        return p5typeglob_set(pkg_name, v, obj);' . chr(10) . '    }' . chr(10) . '    CORE.die(["TODO: can' . chr(39) . 't p5typeglob_deref_set()"]);' . chr(10) . '}' . chr(10) . chr(10) . 'function p5cleanup_local(idx, value) {' . chr(10) . '    while (p5LOCAL.length > idx) {' . chr(10) . '        var l = p5LOCAL.pop();' . chr(10) . '        l();' . chr(10) . '    }' . chr(10) . '    return value;' . chr(10) . '}' . chr(10) . chr(10) . '//-------- Reference' . chr(10) . chr(10) . 'var p5id = Math.floor(Math.random() * 1000000000) + 1000000000;' . chr(10) . chr(10) . 'function p5HashRef(o) {' . chr(10) . '    this._hash_ = o;' . chr(10) . '    this._ref_ = "HASH";' . chr(10) . '    this.bool = function() { return 1 };' . chr(10) . '}' . chr(10) . chr(10) . 'function p5ArrayRef(o) {' . chr(10) . '    this._array_ = o;' . chr(10) . '    this._ref_ = "ARRAY";' . chr(10) . '    this.bool = function() { return 1 };' . chr(10) . '}' . chr(10) . chr(10) . 'function p5ScalarRef(o) {' . chr(10) . '    this._scalar_ = o;' . chr(10) . '    this._ref_ = "SCALAR";' . chr(10) . '    this.bool = function() { return 1 };' . chr(10) . '}' . chr(10) . chr(10) . 'function p5GlobRef(o) {' . chr(10) . '    this._scalar_ = o;' . chr(10) . '    this._ref_ = "GLOB";' . chr(10) . '    this.bool = function() { return 1 };' . chr(10) . '}' . chr(10) . chr(10) . 'function p5CodeRef(o) {' . chr(10) . '    this._code_ = o;' . chr(10) . '    this._ref_ = "CODE";' . chr(10) . '    this.bool = function() { return 1 };' . chr(10) . '}' . chr(10) . chr(10) . '//-------- Hash ' . chr(10) . chr(10) . 'Object.defineProperty( Object.prototype, "p5hget", {' . chr(10) . '    enumerable : false,' . chr(10) . '    value : function (i) { return this[i] }' . chr(10) . '});' . chr(10) . 'Object.defineProperty( Object.prototype, "p5hset", {' . chr(10) . '    enumerable : false,' . chr(10) . '    value : function (i, v) { this[i] = v; return this[i] }' . chr(10) . '});' . chr(10) . chr(10) . 'Object.defineProperty( Object.prototype, "p5incr", {' . chr(10) . '    enumerable : false,' . chr(10) . '    value : function (i) {' . chr(10) . '        this[i] = p5incr_(this[i]);' . chr(10) . '        return this[i];' . chr(10) . '    }' . chr(10) . '});' . chr(10) . 'Object.defineProperty( Object.prototype, "p5postincr", {' . chr(10) . '    enumerable : false,' . chr(10) . '    value : function (i) {' . chr(10) . '        var v = this[i];' . chr(10) . '        this[i] = p5incr_(this[i]);' . chr(10) . '        return v;' . chr(10) . '    }' . chr(10) . '});' . chr(10) . 'Object.defineProperty( Object.prototype, "p5decr", {' . chr(10) . '    enumerable : false,' . chr(10) . '    value : function (i) {' . chr(10) . '        this[i] = p5decr_(this[i]);' . chr(10) . '        return this[i];' . chr(10) . '    }' . chr(10) . '});' . chr(10) . 'Object.defineProperty( Object.prototype, "p5postdecr", {' . chr(10) . '    enumerable : false,' . chr(10) . '    value : function (i) {' . chr(10) . '        var v = this[i];' . chr(10) . '        this[i] = p5decr_(this[i]);' . chr(10) . '        return v;' . chr(10) . '    }' . chr(10) . '});' . chr(10) . chr(10) . 'Object.defineProperty( Object.prototype, "p5hget_array", {' . chr(10) . '    enumerable : false,' . chr(10) . '    value : function (i) {' . chr(10) . '        if (this[i] == null) { this[i] = new p5ArrayRef([]) }' . chr(10) . '        return this[i]' . chr(10) . '    }' . chr(10) . '});' . chr(10) . 'Object.defineProperty( Object.prototype, "p5hget_hash", {' . chr(10) . '    enumerable : false,' . chr(10) . '    value : function (i) {' . chr(10) . '        if (this[i] == null) { this[i] = new p5HashRef({}) }' . chr(10) . '        return this[i]' . chr(10) . '    }' . chr(10) . '});' . chr(10) . chr(10) . '//-------' . chr(10) . chr(10) . chr(10) . 'var p5context = function(List__, p5want) {' . chr(10) . '    if (p5want) {' . chr(10) . '        return p5list_to_a(List__);' . chr(10) . '    }' . chr(10) . '    // scalar: return the last value' . chr(10) . '    var o = List__;' . chr(10) . '    if (o instanceof Array) {' . chr(10) . '        o =   o.length' . chr(10) . '            ? o[o.length-1]' . chr(10) . '            : null;' . chr(10) . '    }' . chr(10) . '    if (o instanceof Array) {' . chr(10) . '        o =   o.length' . chr(10) . '    }' . chr(10) . '    return o;' . chr(10) . '}' . chr(10) . chr(10) . 'var p5list_to_a = function(args) {' . chr(10) . '    var res = [];' . chr(10) . '    for (var i = 0; i < args.length; i++) {' . chr(10) . '        var o = args[i];' . chr(10) . '        if  (  o == null' . chr(10) . '            || o._class_    // perl5 blessed reference' . chr(10) . '            || o._ref_      // perl5 un-blessed reference' . chr(10) . '            )' . chr(10) . '        {' . chr(10) . '            res.push(o);' . chr(10) . '        }' . chr(10) . '        else if (o instanceof Array) {' . chr(10) . '            // perl5 array' . chr(10) . '            for (var j = 0; j < o.length; j++) {' . chr(10) . '                res.push(o[j]);' . chr(10) . '            }' . chr(10) . '        }' . chr(10) . '        else if (typeof o === "object") {' . chr(10) . '            // perl5 hash' . chr(10) . '            for(var j in o) {' . chr(10) . '                if (o.hasOwnProperty(j)) {' . chr(10) . '                    res.push(j);' . chr(10) . '                    res.push(o[j]);' . chr(10) . '                }' . chr(10) . '            }' . chr(10) . '        }' . chr(10) . '        else {' . chr(10) . '            // non-ref' . chr(10) . '            res.push(o);' . chr(10) . '        }' . chr(10) . '    }' . chr(10) . '    return res;' . chr(10) . '};' . chr(10) . chr(10) . 'var p5_list_of_refs = function(a) {' . chr(10) . '    // implements ' . chr(92) . '( @a )' . chr(10) . '    var res = [];' . chr(10) . '    for (var i = 0; i < a.length; i++) {' . chr(10) . '        res.push(new p5ScalarRef(a[i]));' . chr(10) . '    }' . chr(10) . '    return res;' . chr(10) . '};' . chr(10) . chr(10) . 'var p5a_to_h = function(a) {' . chr(10) . '    var res = {};' . chr(10) . '    for (var i = 0; i < a.length; i+=2) {' . chr(10) . '        res[p5str(a[i])] = a[i+1];' . chr(10) . '    }' . chr(10) . '    return res;' . chr(10) . '};' . chr(10) . chr(10) . 'var p5idx = function(a, i) {' . chr(10) . '    return i >= 0 ? i : a.length + i' . chr(10) . '};' . chr(10) . chr(10) . 'var p5str = function(o) {' . chr(10) . '    if (o == null) {' . chr(10) . '        return "";' . chr(10) . '    }' . chr(10) . '    if (typeof o === "object") {' . chr(10) . '        if (o instanceof Array) {' . chr(10) . '            return CORE.join([""].concat(o));' . chr(10) . '        }' . chr(10) . '        if ( o.hasOwnProperty("_ref_") ) {' . chr(10) . '            var class_name = ' . chr(39) . chr(39) . ';' . chr(10) . '            if (o._class_ && typeof o._class_._ref_ === "string") {' . chr(10) . '                // blessed reference' . chr(10) . '                // test for overload' . chr(10) . '                var meth = p5method_lookup(' . chr(39) . '(""' . chr(39) . ', o._class_._ref_, {});' . chr(10) . '                if (meth) {' . chr(10) . '                    return p5str(meth([o], 0));' . chr(10) . '                }' . chr(10) . '                // TODO - test the "fallback" flag' . chr(10) . '                meth = p5method_lookup(' . chr(39) . '(0+' . chr(39) . ', o._class_._ref_, {});' . chr(10) . '                if (meth) {' . chr(10) . '                    return p5str(meth([o], 0));' . chr(10) . '                }' . chr(10) . '                // no overload, strigify the reference instead' . chr(10) . '                class_name = o._class_._ref_ + ' . chr(39) . '=' . chr(39) . ';' . chr(10) . '            }' . chr(10) . '            if (!o._id_) { o._id_ = p5id++ }' . chr(10) . '            return [class_name, o._ref_, ' . chr(39) . '(0x' . chr(39) . ', o._id_.toString( 16 ), ' . chr(39) . ')' . chr(39) . '].join(' . chr(39) . chr(39) . ');' . chr(10) . '        }' . chr(10) . '    }' . chr(10) . '    if (typeof o === "function") {' . chr(10) . '        var class_name = ' . chr(39) . chr(39) . ';' . chr(10) . '        if (o._class_ && typeof o._class_._ref_ === "string") {' . chr(10) . '            // blessed reference' . chr(10) . '            class_name = o._class_._ref_ + ' . chr(39) . '=' . chr(39) . ';' . chr(10) . '        }' . chr(10) . '        if (!o._id_) { o._id_ = p5id++ }' . chr(10) . '        return [class_name, ' . chr(39) . 'CODE(0x' . chr(39) . ', o._id_.toString( 16 ), ' . chr(39) . ')' . chr(39) . '].join(' . chr(39) . chr(39) . ');' . chr(10) . '    }' . chr(10) . '    if (typeof o == "number" && Math.abs(o) < 0.0001 && o != 0) {' . chr(10) . '        return o.toExponential().replace(/e-(' . chr(92) . 'd)$/,"e-0$1");' . chr(10) . '    }' . chr(10) . '    if (typeof o === "boolean") {' . chr(10) . '        return o ? "1" : "";' . chr(10) . '    }' . chr(10) . '    if (typeof o !== "string") {' . chr(10) . '        return "" + o;' . chr(10) . '    }' . chr(10) . '    return o;' . chr(10) . '};' . chr(10) . chr(10) . 'var p5num = function(o) {' . chr(10) . '    if (o == null) {' . chr(10) . '        return 0;' . chr(10) . '    }' . chr(10) . '    if (typeof o === "object") {' . chr(10) . '        if (o instanceof Array) {' . chr(10) . '            return o.length;' . chr(10) . '        }' . chr(10) . '        if ( o.hasOwnProperty("_ref_") ) {' . chr(10) . '            if (o._class_ && typeof o._class_._ref_ === "string") {' . chr(10) . '                // blessed reference' . chr(10) . '                // test for overload' . chr(10) . '                var meth = p5method_lookup(' . chr(39) . '(0+' . chr(39) . ', o._class_._ref_, {});' . chr(10) . '                if (meth) {' . chr(10) . '                    return p5num(meth([o], 0));' . chr(10) . '                }' . chr(10) . '                // TODO - test the "fallback" flag' . chr(10) . '                meth = p5method_lookup(' . chr(39) . '(""' . chr(39) . ', o._class_._ref_, {});' . chr(10) . '                if (meth) {' . chr(10) . '                    return p5num(meth([o], 0));' . chr(10) . '                }' . chr(10) . '            }' . chr(10) . '        }' . chr(10) . '    }' . chr(10) . '    if (typeof o !== "number") {' . chr(10) . '        var s = p5str(o).trim();' . chr(10) . '        var s1 = s.substr(0, 3).toUpperCase();' . chr(10) . '        if ( s1 == "NAN" ) { return NaN };' . chr(10) . '        if ( s1 == "INF" ) { return Infinity };' . chr(10) . '        s1 = s.substr(0, 4).toUpperCase();' . chr(10) . '        if ( s1 == "-NAN" ) { return NaN };' . chr(10) . '        if ( s1 == "-INF" ) { return -Infinity };' . chr(10) . '        s1 = parseFloat(s);' . chr(10) . '        if ( isNaN(s1) ) { return 0 };' . chr(10) . '        return s1;' . chr(10) . '    }' . chr(10) . '    return o;' . chr(10) . '};' . chr(10) . chr(10) . 'var p5bool = function(o) {' . chr(10) . '    if (o) {' . chr(10) . '        if (typeof o === "boolean") {' . chr(10) . '            return o;' . chr(10) . '        }' . chr(10) . '        if (typeof o === "number") {' . chr(10) . '            return o;' . chr(10) . '        }' . chr(10) . '        if (typeof o === "string") {' . chr(10) . '            return o != "" && o != "0";' . chr(10) . '        }' . chr(10) . '        if (typeof o.length === "number") {' . chr(10) . '            return o.length;' . chr(10) . '        }' . chr(10) . '        if (o instanceof Error) {' . chr(10) . '            return true;' . chr(10) . '        }' . chr(10) . '        for (var i in o) {' . chr(10) . '            return true;' . chr(10) . '        }' . chr(10) . '    }' . chr(10) . '    return false;' . chr(10) . '};' . chr(10) . chr(10) . 'var p5incr_ = function(o) {' . chr(10) . '    if (typeof o === "number") {' . chr(10) . '        return o + 1;' . chr(10) . '    }' . chr(10) . '    return p5str_inc(p5str(o));' . chr(10) . '};' . chr(10) . chr(10) . 'var p5decr_ = function(o) {' . chr(10) . '    if (typeof o === "number") {' . chr(10) . '        return o - 1;' . chr(10) . '    }' . chr(10) . '    return p5num(o) - 1;' . chr(10) . '};' . chr(10) . chr(10) . 'var p5modulo = function(o, k) {' . chr(10) . '    var m = o % k;' . chr(10) . '    if ( k < 0 && m > 0 ) {' . chr(10) . '        m = m + k;' . chr(10) . '    }' . chr(10) . '    else if ( k > 0 && m < 0 ) {' . chr(10) . '        m = m + k;' . chr(10) . '    }' . chr(10) . '    return m;' . chr(10) . '};' . chr(10) . chr(10) . 'var p5shift_left = function(o, k) {' . chr(10) . '    return k < 31 ? o << k : o * Math.pow(2, k);' . chr(10) . '};' . chr(10) . chr(10) . 'var p5and = function(a, fb) {' . chr(10) . '    if (p5bool(a)) {' . chr(10) . '        return fb();' . chr(10) . '    }' . chr(10) . '    return a;' . chr(10) . '};' . chr(10) . chr(10) . 'var p5or = function(a, fb) {' . chr(10) . '    if (p5bool(a)) {' . chr(10) . '        return a;' . chr(10) . '    }' . chr(10) . '    return fb();' . chr(10) . '};' . chr(10) . chr(10) . 'var p5defined_or = function(a, fb) {' . chr(10) . '    if (a == null) {' . chr(10) . '        return fb();' . chr(10) . '    }' . chr(10) . '    return a;' . chr(10) . '};' . chr(10) . chr(10) . 'var p5xor = function(a, fb) {' . chr(10) . '    return p5bool(a) ? !p5bool(fb()) : fb()' . chr(10) . '};' . chr(10) . chr(10) . 'var p5cmp = function(a, b) {' . chr(10) . '    return a > b ? 1 : a < b ? -1 : 0 ' . chr(10) . '};' . chr(10) . chr(10) . 'var p5complement = function(a) {' . chr(10) . '    return a < 0 ? ~a : 4294967295 - a' . chr(10) . '    // return a < 0 ? ~a : 18446744073709551615 - a' . chr(10) . '};' . chr(10) . chr(10) . 'var p5str_replicate = function(o, n) {' . chr(10) . '    n = Math.floor(n);' . chr(10) . '    return n > 0 ? Array(n + 1).join(o) : "";' . chr(10) . '};' . chr(10) . chr(10) . 'var p5list_replicate = function(o, n, want) {' . chr(10) . '    o = p5list_to_a([o]);' . chr(10) . '    n = p5num(n);' . chr(10) . chr(10) . '    if (!want) {' . chr(10) . '        return p5str_replicate(o.pop(), n);   // scalar context' . chr(10) . '    }' . chr(10) . chr(10) . '    var out = [];' . chr(10) . '    for(var i = 0; i < n; i++) {' . chr(10) . '        for(var j = 0; j < o.length; j++) {' . chr(10) . '            out.push(o[j]);' . chr(10) . '        }' . chr(10) . '    }' . chr(10) . '    return (want ? out : out.length)' . chr(10) . '};' . chr(10) . chr(10) . 'var p5list_slice = function(o, ix, want) {' . chr(10) . '    var out = [];' . chr(10) . '    for (var i=0, l=ix.length; i<l; ++i) {' . chr(10) . '        if (ix[i] < o.length) {' . chr(10) . '            out[i] = o[ix[i]];' . chr(10) . '        }' . chr(10) . '    }' . chr(10) . '    if (want) { return out }' . chr(10) . '    return out.length ? out[out.length-1] : null;' . chr(10) . '}' . chr(10) . chr(10) . 'var p5hash_slice = function(o, ix, want) {' . chr(10) . '    var out = [];' . chr(10) . '    for (var i=0, l=ix.length; i<l; ++i) {' . chr(10) . '        out.push(ix[i]);' . chr(10) . '        out.push(o[ix[i]]);' . chr(10) . '    }' . chr(10) . '    if (want) { return out }' . chr(10) . '    return out.length ? out[out.length-1] : null;' . chr(10) . '}' . chr(10) . chr(10) . 'var p5list_lookup_slice = function(o, ix, want) {' . chr(10) . '    var out = [];' . chr(10) . '    for (var i=0, l=ix.length; i<l; ++i) {' . chr(10) . '        out[i] = o[ix[i]];' . chr(10) . '    }' . chr(10) . '    if (want) { return out }' . chr(10) . '    return out.length ? out[out.length-1] : null;' . chr(10) . '}' . chr(10) . chr(10) . 'var p5hash_lookup_slice = function(o, ix, want) {' . chr(10) . '    var out = [];' . chr(10) . '    for (var i=0, l=ix.length; i<l; ++i) {' . chr(10) . '        out.push(ix[i]);' . chr(10) . '        out.push(o[ix[i]]);' . chr(10) . '    }' . chr(10) . '    if (want) { return out }' . chr(10) . '    return out.length ? out[out.length-1] : null;' . chr(10) . '}' . chr(10) . chr(10) . 'var p5str_inc = function(s) {' . chr(10) . '    s = p5str(s);' . chr(10) . '    if (s.match(/^[0123456789]/)) {' . chr(10) . '        return p5str(p5num(s)+1);' . chr(10) . '    }' . chr(10) . '    if (s.length < 2) {' . chr(10) . '        if (s.match(/[012345678ABCDEFGHIJKLMNOPQRSTUVWXYabcdefghijklmnopqrstuvwxy]/)) {' . chr(10) . '            return String.fromCharCode(s.charCodeAt(0) + 1);' . chr(10) . '        }' . chr(10) . '        if (s == "9") {' . chr(10) . '            return "10";' . chr(10) . '        }' . chr(10) . '        if (s == "Z") {' . chr(10) . '            return "AA";' . chr(10) . '        }' . chr(10) . '        if (s == "z") {' . chr(10) . '            return "aa";' . chr(10) . '        }' . chr(10) . '        return "1";' . chr(10) . '    }' . chr(10) . '    var c = p5str_inc(s.substr(s.length-1, 1));' . chr(10) . '    if (c.length == 1) {' . chr(10) . '        return s.substr(0, s.length-1) + c;' . chr(10) . '    }' . chr(10) . '    return p5str_inc(s.substr(0, s.length-1)) + c.substr(c.length-1, 1);' . chr(10) . '};' . chr(10) . chr(10) . 'var p5range_state = {};' . chr(10) . 'var p5range = function(a, b, p5want, id, three_dots) {' . chr(10) . '    if (p5want) {' . chr(10) . '        // list context' . chr(10) . '        var tmp = [];' . chr(10) . '        if (typeof a === "number" || typeof b === "number") {' . chr(10) . '            a = p5num(a);' . chr(10) . '            b = p5num(b);' . chr(10) . '            while (a <= b) {' . chr(10) . '                tmp.push(a);' . chr(10) . '                a++;' . chr(10) . '            }' . chr(10) . '        }' . chr(10) . '        else {' . chr(10) . '            a = p5str(a);' . chr(10) . '            b = p5str(b);' . chr(10) . '            var c = a.substr(0, 1);' . chr(10) . '            if ( c == ' . chr(39) . '+' . chr(39) . ' ) {' . chr(10) . '                if (a == "+") {' . chr(10) . '                    return [a]' . chr(10) . '                }' . chr(10) . '                a = a.substr(1)' . chr(10) . '            }' . chr(10) . '            else if ( c == ' . chr(39) . '-' . chr(39) . ' ) {' . chr(10) . '                if (a == "-") {' . chr(10) . '                    return [a]' . chr(10) . '                }' . chr(10) . '                return p5range(p5num(a), b, p5want, id, three_dots)' . chr(10) . '            }' . chr(10) . '            c = b.substr(0, 1);' . chr(10) . '            if ( c == ' . chr(39) . '+' . chr(39) . ' ) {' . chr(10) . '                b = b.substr(1)' . chr(10) . '            }' . chr(10) . '            while (  (a.length < b.length)' . chr(10) . '                  || (a.length == b.length && a <= b) ) {' . chr(10) . '                tmp.push(a);' . chr(10) . '                a = p5incr_(a);' . chr(10) . '            }' . chr(10) . '        }' . chr(10) . '        return tmp;' . chr(10) . '    }' . chr(10) . '    // flip-flop operator' . chr(10) . '    var v;' . chr(10) . '    if (p5range_state[id]) {' . chr(10) . '        v = ++p5range_state[id];' . chr(10) . '        if (p5bool(b)) {' . chr(10) . '            p5range_state[id] = 0;' . chr(10) . '            v = v + "E0";' . chr(10) . '        }' . chr(10) . '        return v;' . chr(10) . '    }' . chr(10) . '    else {' . chr(10) . '        p5range_state[id] = 0;' . chr(10) . '        if (p5bool(a)) {' . chr(10) . '            p5range_state[id]++;' . chr(10) . '            v = p5range_state[id];' . chr(10) . '        }' . chr(10) . '        if (v && !three_dots && p5bool(b)) {' . chr(10) . '            p5range_state[id] = 0;' . chr(10) . '            v = v + "E0";' . chr(10) . '        }' . chr(10) . '        return v;' . chr(10) . '    }' . chr(10) . '};' . chr(10) . chr(10) . 'var p5negative = function(o) {' . chr(10) . '    if (o == null) {' . chr(10) . '        return ' . chr(39) . '-0' . chr(39) . ';' . chr(10) . '    }' . chr(10) . '    if (typeof o === "object" && (o instanceof Array)) {' . chr(10) . '        return -(o.length);' . chr(10) . '    }' . chr(10) . '    if (typeof o !== "number") {' . chr(10) . '        var s = p5str(o);' . chr(10) . '        var c = s.substr(0, 1);' . chr(10) . '        if ( c == ' . chr(39) . '+' . chr(39) . ' ) { s = s.substr(1); return ' . chr(39) . '-' . chr(39) . ' + s }' . chr(10) . '        if ( c == ' . chr(39) . '-' . chr(39) . ' ) { s = s.substr(1); return ' . chr(39) . '+' . chr(39) . ' + s }' . chr(10) . '        var s1 = parseFloat(s.trim());' . chr(10) . '        if ( isNaN(s1) ) {' . chr(10) . '            if ( c.length && !c.match(/[ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz]/) ) {' . chr(10) . '                if ( s.trim().substr(0,1) == "-" ) { return 0 };' . chr(10) . '                return ' . chr(39) . '-0' . chr(39) . ';' . chr(10) . '            };' . chr(10) . '            return ' . chr(39) . '-' . chr(39) . ' + s' . chr(10) . '        };' . chr(10) . '        return -s1;' . chr(10) . '    }' . chr(10) . '    return -o;' . chr(10) . '};' . chr(10) . chr(10) . 'var p5qr = function(search, modifier) {' . chr(10) . '    // TODO - "Regex" stringification' . chr(10) . '    var re = new RegExp(search, modifier);' . chr(10) . '    return CORE.bless([(new p5ScalarRef(re)), ' . chr(39) . 'Regex' . chr(39) . ']);' . chr(10) . '};' . chr(10) . chr(10) . 'var p5m = function(s, search, modifier, want) {' . chr(10) . '    // TODO - captures' . chr(10) . '    var re;' . chr(10) . '    if (search.hasOwnProperty(' . chr(39) . '_scalar_' . chr(39) . ')) {' . chr(10) . '        // search is a Regex object' . chr(10) . '        re = search._scalar_;' . chr(10) . '    }' . chr(10) . '    else {' . chr(10) . '        re = new RegExp(search, modifier);' . chr(10) . '    }' . chr(10) . chr(10) . '    p5_regex_capture = [];' . chr(10) . '    var res = [];' . chr(10) . '    var myArray;' . chr(10) . '    while ((myArray = re.exec(s)) !== null) {' . chr(10) . '        var m = myArray.shift();' . chr(10) . '        if (myArray.length) {' . chr(10) . '            res = res.concat(myArray);' . chr(10) . '            p5_regex_capture = p5_regex_capture.concat(myArray);' . chr(10) . '        }' . chr(10) . '        else {' . chr(10) . '            res.push(m);' . chr(10) . '        }' . chr(10) . '        if (re.lastIndex == 0) {' . chr(10) . '            return (want ? res : res.length)' . chr(10) . '        }' . chr(10) . '    }' . chr(10) . '    return (want ? res : res.length)' . chr(10) . '};' . chr(10) . chr(10) . 'var p5s = function(s, search, fun_replace, modifier, want) {' . chr(10) . '    // TODO - captures' . chr(10) . '    var count = null;' . chr(10) . '    var re;' . chr(10) . '    if (search.hasOwnProperty(' . chr(39) . '_scalar_' . chr(39) . ')) {' . chr(10) . '        // search is a Regex object' . chr(10) . '        re = search._scalar_;' . chr(10) . '    }' . chr(10) . '    else {' . chr(10) . '        re = new RegExp(search, modifier);' . chr(10) . '    }' . chr(10) . chr(10) . '    p5_regex_capture = [];' . chr(10) . '    var res = [];' . chr(10) . '    var myArray;' . chr(10) . '    var last_index = 0;' . chr(10) . '    while ((myArray = re.exec(s)) !== null) {' . chr(10) . '        var m = myArray.shift();' . chr(10) . '        p5_regex_capture = [].concat(myArray);' . chr(10) . '        if (myArray.index > last_index) {' . chr(10) . '            res.push(s.substr(last_index, myArray.index - last_index));' . chr(10) . '        }' . chr(10) . '        res.push(fun_replace());' . chr(10) . '        last_index = re.lastIndex;' . chr(10) . '        if (last_index == 0) {' . chr(10) . '            count = 1;' . chr(10) . '            last_index = myArray.index + m.length;' . chr(10) . '            if (s.length > last_index) {' . chr(10) . '                res.push(s.substr(last_index, s.length - last_index));' . chr(10) . '            }' . chr(10) . '            return [res.join(' . chr(39) . chr(39) . '), count]' . chr(10) . '        }' . chr(10) . '        count++;' . chr(10) . '    }' . chr(10) . '    if (s.length > last_index) {' . chr(10) . '        res.push(s.substr(last_index, s.length - last_index));' . chr(10) . '    }' . chr(10) . '    return [res.join(' . chr(39) . chr(39) . '), count]' . chr(10) . '};' . chr(10) . chr(10) . 'var p5tr = function(s, search, replace, modifier, want) {' . chr(10) . '    var count = 0;' . chr(10) . '    // TODO - expand character lists in spec' . chr(10) . '    // TODO - modifiers' . chr(10) . '    search = search.split("");' . chr(10) . '    replace = replace.split("");' . chr(10) . '    while (search.length > replace.length) {' . chr(10) . '        replace.push(replace[replace.length-1]);' . chr(10) . '    }' . chr(10) . '    var tr = {};' . chr(10) . '    for(var i = 0; i < search.length; i++) {' . chr(10) . '        tr[search[i]] = replace[i];' . chr(10) . '    }' . chr(10) . '    var res = s.split("");' . chr(10) . '    for(var i = 0; i < res.length; i++) {' . chr(10) . '        if (tr.hasOwnProperty(res[i])) {' . chr(10) . '            res[i] = tr[res[i]];' . chr(10) . '            count++;' . chr(10) . '        }' . chr(10) . '    }' . chr(10) . '    return [res.join(' . chr(39) . chr(39) . '), count]' . chr(10) . '};' . chr(10) . chr(10) . 'var p5chop = function(s) {' . chr(10) . '    // TODO - array, hash' . chr(10) . '    return [s.substr(-1,1), s.substr(0,s.length-1)]' . chr(10) . '};' . chr(10) . chr(10) . 'var p5chomp = function(s) {' . chr(10) . '    // TODO - array, hash' . chr(10) . '    // TODO - special cases of $/ - empty string, reference' . chr(10) . '    var sep = p5pkg["main"]["v_/"];  // $/' . chr(10) . '    var c = s.substr(-sep.length);' . chr(10) . '    if (c == sep) {' . chr(10) . '        return [c.length, s.substr(0,s.length-sep.length)]' . chr(10) . '    }' . chr(10) . '    else {' . chr(10) . '        return [0, s]' . chr(10) . '    }' . chr(10) . '};' . chr(10) . chr(10) . 'var p5for = function(namespace, var_name, func, args, cont, label) {' . chr(10) . '    var _redo = false;' . chr(10) . '    var local_idx = p5LOCAL.length;' . chr(10) . '    var v_old = namespace[var_name];' . chr(10) . '    p5LOCAL.push(function(){ namespace[var_name] = v_old });' . chr(10) . '    for(var i = 0; i < args.length; i++) {' . chr(10) . '        namespace[var_name] = args[i];' . chr(10) . '        try {' . chr(10) . '            func()' . chr(10) . '        }' . chr(10) . '        catch(err) {' . chr(10) . '            if (err instanceof p5_error && (err.v == label || err.v == ' . chr(39) . chr(39) . ')) {' . chr(10) . '                if (err.type == ' . chr(39) . 'last' . chr(39) . ') {' . chr(10) . '                    p5cleanup_local(local_idx, null);' . chr(10) . '                    return' . chr(10) . '                }' . chr(10) . '                else if (err.type == ' . chr(39) . 'redo' . chr(39) . ') { i--; _redo = true }' . chr(10) . '                else if (err.type != ' . chr(39) . 'next' . chr(39) . ') { throw(err) }' . chr(10) . '            }' . chr(10) . '            else {' . chr(10) . '                throw(err)' . chr(10) . '            }' . chr(10) . '        }' . chr(10) . '        if (cont) {' . chr(10) . '            try {' . chr(10) . '                if (!_redo) { cont() }' . chr(10) . '            }' . chr(10) . '            catch(err) {' . chr(10) . '                if (err instanceof p5_error && (err.v == label || err.v == ' . chr(39) . chr(39) . ')) {' . chr(10) . '                    if (err.type == ' . chr(39) . 'last' . chr(39) . ') {' . chr(10) . '                        p5cleanup_local(local_idx, null);' . chr(10) . '                        return' . chr(10) . '                    }' . chr(10) . '                    else if (err.type == ' . chr(39) . 'redo' . chr(39) . ') { _redo = true }' . chr(10) . '                    else if (err.type != ' . chr(39) . 'next' . chr(39) . ') { throw(err) }' . chr(10) . '                }            ' . chr(10) . '                else {' . chr(10) . '                    throw(err)' . chr(10) . '                }' . chr(10) . '            }' . chr(10) . '       }' . chr(10) . '    }' . chr(10) . '    p5cleanup_local(local_idx, null);' . chr(10) . '};' . chr(10) . chr(10) . 'var p5for_lex = function(func, args, cont, label) {' . chr(10) . '    var _redo = false;' . chr(10) . '    var local_idx = p5LOCAL.length;' . chr(10) . '    for(var i = 0; i < args.length; i++) {' . chr(10) . '        try {' . chr(10) . '            func(args[i])' . chr(10) . '        }' . chr(10) . '        catch(err) {' . chr(10) . '            if (err instanceof p5_error && (err.v == label || err.v == ' . chr(39) . chr(39) . ')) {' . chr(10) . '                if (err.type == ' . chr(39) . 'last' . chr(39) . ') {' . chr(10) . '                    p5cleanup_local(local_idx, null);' . chr(10) . '                    return' . chr(10) . '                }' . chr(10) . '                else if (err.type == ' . chr(39) . 'redo' . chr(39) . ') { i--; _redo = true }' . chr(10) . '                else if (err.type != ' . chr(39) . 'next' . chr(39) . ') { throw(err) }' . chr(10) . '            }            ' . chr(10) . '            else {' . chr(10) . '                throw(err)' . chr(10) . '            }' . chr(10) . '        }' . chr(10) . '        if (cont) {' . chr(10) . '            try {' . chr(10) . '                if (!_redo) { cont() }' . chr(10) . '            }' . chr(10) . '            catch(err) {' . chr(10) . '                if (err instanceof p5_error && (err.v == label || err.v == ' . chr(39) . chr(39) . ')) {' . chr(10) . '                    if (err.type == ' . chr(39) . 'last' . chr(39) . ') {' . chr(10) . '                        p5cleanup_local(local_idx, null);' . chr(10) . '                        return' . chr(10) . '                    }' . chr(10) . '                    else if (err.type == ' . chr(39) . 'redo' . chr(39) . ') { _redo = true }' . chr(10) . '                    else if (err.type != ' . chr(39) . 'next' . chr(39) . ') { throw(err) }' . chr(10) . '                }            ' . chr(10) . '                else {' . chr(10) . '                    throw(err)' . chr(10) . '                }' . chr(10) . '            }' . chr(10) . '        }' . chr(10) . '    }' . chr(10) . '    p5cleanup_local(local_idx, null);' . chr(10) . '};' . chr(10) . chr(10) . 'var p5while = function(func, cond, cont, label, redo) {' . chr(10) . '    var local_idx = p5LOCAL.length;' . chr(10) . '    while (redo || p5bool(cond())) {' . chr(10) . '        redo = false;' . chr(10) . '        try {' . chr(10) . '            func()' . chr(10) . '        }' . chr(10) . '        catch(err) {' . chr(10) . '            if (err instanceof p5_error && (err.v == label || err.v == ' . chr(39) . chr(39) . ')) {' . chr(10) . '                if (err.type == ' . chr(39) . 'last' . chr(39) . ') {' . chr(10) . '                    p5cleanup_local(local_idx, null);' . chr(10) . '                    return' . chr(10) . '                }' . chr(10) . '                else if (err.type == ' . chr(39) . 'redo' . chr(39) . ') { redo = true }' . chr(10) . '                else if (err.type != ' . chr(39) . 'next' . chr(39) . ') { throw(err) }' . chr(10) . '            }            ' . chr(10) . '            else {' . chr(10) . '                throw(err)' . chr(10) . '            }' . chr(10) . '        }' . chr(10) . '        if (cont) {' . chr(10) . '            try {' . chr(10) . '                if (!redo) { cont() }' . chr(10) . '            }' . chr(10) . '            catch(err) {' . chr(10) . '                if (err instanceof p5_error && (err.v == label || err.v == ' . chr(39) . chr(39) . ')) {' . chr(10) . '                    if (err.type == ' . chr(39) . 'last' . chr(39) . ') {' . chr(10) . '                        p5cleanup_local(local_idx, null);' . chr(10) . '                        return' . chr(10) . '                    }' . chr(10) . '                    else if (err.type == ' . chr(39) . 'redo' . chr(39) . ') { redo = true }' . chr(10) . '                    else if (err.type != ' . chr(39) . 'next' . chr(39) . ') { throw(err) }' . chr(10) . '                }            ' . chr(10) . '                else {' . chr(10) . '                    throw(err)' . chr(10) . '                }' . chr(10) . '            }' . chr(10) . '        }' . chr(10) . '    }' . chr(10) . '    p5cleanup_local(local_idx, null);' . chr(10) . '};' . chr(10) . chr(10) . 'var p5map = function(namespace, func, args) {' . chr(10) . '    var v_old = p5pkg["main"]["v__"];' . chr(10) . '    var out = [];' . chr(10) . '    for(var i = 0; i < args.length; i++) {' . chr(10) . '        p5pkg["main"]["v__"] = args[i];' . chr(10) . '        var o = p5list_to_a([func(1)]);' . chr(10) . '        for(var j = 0; j < o.length; j++) {' . chr(10) . '            out.push(o[j]);' . chr(10) . '        }' . chr(10) . '    }' . chr(10) . '    p5pkg["main"]["v__"] = v_old;' . chr(10) . '    return out;' . chr(10) . '};' . chr(10) . chr(10) . 'var p5grep = function(namespace, func, args) {' . chr(10) . '    var v_old = p5pkg["main"]["v__"];' . chr(10) . '    var out = [];' . chr(10) . '    for(var i = 0; i < args.length; i++) {' . chr(10) . '        p5pkg["main"]["v__"] = args[i];' . chr(10) . '        if (p5bool(func(0))) {' . chr(10) . '            out.push(args[i])' . chr(10) . '        }' . chr(10) . '    }' . chr(10) . '    p5pkg["main"]["v__"] = v_old;' . chr(10) . '    return out;' . chr(10) . '};' . chr(10) . chr(10) . 'var p5sort = function(namespace, func, args) {' . chr(10) . '    var a_old = namespace["v_a"];' . chr(10) . '    var b_old = namespace["v_b"];' . chr(10) . '    var out = ' . chr(10) . '        func == null' . chr(10) . '        ? args.sort()' . chr(10) . '        : args.sort(' . chr(10) . '            function(a, b) {' . chr(10) . '                namespace["v_a"] = a;' . chr(10) . '                namespace["v_b"] = b;' . chr(10) . '                return func(0);' . chr(10) . '            }' . chr(10) . '        );' . chr(10) . '    namespace["v_a"] = a_old;' . chr(10) . '    namespace["v_b"] = b_old;' . chr(10) . '    return out;' . chr(10) . '};' . chr(10) . chr(10)
}
1;
# use Perlito5::Javascript2::Runtime
package main;
undef();
package Perlito5::Javascript2::Array;
sub Perlito5::Javascript2::Array::emit_javascript2 {
    return '//' . chr(10) . '// lib/Perlito5/Javascript2/Runtime.js' . chr(10) . '//' . chr(10) . '// Runtime for "Perlito" Perl5-in-Javascript2' . chr(10) . '//' . chr(10) . '// AUTHORS' . chr(10) . '//' . chr(10) . '// Flavio Soibelmann Glock  fglock@gmail.com' . chr(10) . '//' . chr(10) . '// COPYRIGHT' . chr(10) . '//' . chr(10) . '// Copyright 2009, 2010, 2011, 2012 by Flavio Soibelmann Glock and others.' . chr(10) . '//' . chr(10) . '// This program is free software; you can redistribute it and/or modify it' . chr(10) . '// under the same terms as Perl itself.' . chr(10) . '//' . chr(10) . '// See http://www.perl.com/perl/misc/Artistic.html' . chr(10) . chr(10) . '//-------- Array ' . chr(10) . chr(10) . 'Object.defineProperty( Array.prototype, "p5aget", {' . chr(10) . '    enumerable : false,' . chr(10) . '    value : function (i) {' . chr(10) . '        if (i < 0) { i =  this.length + i };' . chr(10) . '        return this[i] ' . chr(10) . '    }' . chr(10) . '});' . chr(10) . 'Object.defineProperty( Array.prototype, "p5aset", {' . chr(10) . '    enumerable : false,' . chr(10) . '    value : function (i, v) {' . chr(10) . '        if (i < 0) { i =  this.length + i };' . chr(10) . '        this[i] = v;' . chr(10) . '        return this[i]' . chr(10) . '    }' . chr(10) . '});' . chr(10) . chr(10) . 'Object.defineProperty( Array.prototype, "p5incr", {' . chr(10) . '    enumerable : false,' . chr(10) . '    value : function (i) {' . chr(10) . '        if (i < 0) { i =  this.length + i };' . chr(10) . '        this[i] = p5incr_(this[i]);' . chr(10) . '        return this[i];' . chr(10) . '    }' . chr(10) . '});' . chr(10) . 'Object.defineProperty( Array.prototype, "p5postincr", {' . chr(10) . '    enumerable : false,' . chr(10) . '    value : function (i) {' . chr(10) . '        if (i < 0) { i =  this.length + i };' . chr(10) . '        var v = this[i];' . chr(10) . '        this[i] = p5incr_(this[i]);' . chr(10) . '        return v;' . chr(10) . '    }' . chr(10) . '});' . chr(10) . 'Object.defineProperty( Array.prototype, "p5decr", {' . chr(10) . '    enumerable : false,' . chr(10) . '    value : function (i) {' . chr(10) . '        if (i < 0) { i =  this.length + i };' . chr(10) . '        this[i] = p5decr_(this[i]);' . chr(10) . '        return this[i];' . chr(10) . '    }' . chr(10) . '});' . chr(10) . 'Object.defineProperty( Array.prototype, "p5postdecr", {' . chr(10) . '    enumerable : false,' . chr(10) . '    value : function (i) {' . chr(10) . '        if (i < 0) { i =  this.length + i };' . chr(10) . '        var v = this[i];' . chr(10) . '        this[i] = p5decr_(this[i]);' . chr(10) . '        return v;' . chr(10) . '    }' . chr(10) . '});' . chr(10) . chr(10) . 'Object.defineProperty( Array.prototype, "p5aget_array", {' . chr(10) . '    enumerable : false,' . chr(10) . '    value : function (i) {' . chr(10) . '        if (i < 0) { i =  this.length + i };' . chr(10) . '        if (this[i] == null) { this[i] = new p5ArrayRef([]) }' . chr(10) . '        return this[i]' . chr(10) . '    }' . chr(10) . '});' . chr(10) . 'Object.defineProperty( Array.prototype, "p5aget_hash", {' . chr(10) . '    enumerable : false,' . chr(10) . '    value : function (i) {' . chr(10) . '        if (i < 0) { i =  this.length + i };' . chr(10) . '        if (this[i] == null) { this[i] = new p5HashRef({}) }' . chr(10) . '        return this[i]' . chr(10) . '    }' . chr(10) . '});' . chr(10) . 'Object.defineProperty( Array.prototype, "p5unshift", {' . chr(10) . '    enumerable : false,' . chr(10) . '    configurable : true,' . chr(10) . '    value : function (args) { ' . chr(10) . '        for(var i = args.length-1; i >= 0; i--) {' . chr(10) . '            this.unshift(args[i]);' . chr(10) . '        }' . chr(10) . '        return this.length; ' . chr(10) . '    }' . chr(10) . '});' . chr(10) . 'Object.defineProperty( Array.prototype, "p5push", {' . chr(10) . '    enumerable : false,' . chr(10) . '    configurable : true,' . chr(10) . '    value : function (args) { ' . chr(10) . '        for(var i = 0; i < args.length; i++) {' . chr(10) . '            this.push(args[i]);' . chr(10) . '        }' . chr(10) . '        return this.length; ' . chr(10) . '    }' . chr(10) . '});' . chr(10) . chr(10) . 'var p5tie_array = function(v, List__) {' . chr(10) . '    var pkg_name = p5str(List__.shift());' . chr(10) . chr(10) . '    var res = p5call(pkg_name, ' . chr(39) . 'TIEARRAY' . chr(39) . ', List__, null);' . chr(10) . '    ' . chr(10) . '    // TODO' . chr(10) . '    ' . chr(10) . '    //  A class implementing an ordinary array should have the following methods:' . chr(10) . '    //      TIEARRAY pkg_name, LIST' . chr(10) . '    //      FETCH this, key' . chr(10) . '    //      STORE this, key, value' . chr(10) . '    //      FETCHSIZE this' . chr(10) . '    //      STORESIZE this, count' . chr(10) . '    //      CLEAR this' . chr(10) . '    //      PUSH this, LIST' . chr(10) . '    //      POP this' . chr(10) . '    //      SHIFT this' . chr(10) . '    //      UNSHIFT this, LIST' . chr(10) . '    //      SPLICE this, offset, length, LIST' . chr(10) . '    //      EXTEND this, count' . chr(10) . '    //      DESTROY this' . chr(10) . '    //      UNTIE this' . chr(10) . '    ' . chr(10) . '    Object.defineProperty( v, "p5aget", {' . chr(10) . '        enumerable : false,' . chr(10) . '        configurable : true,' . chr(10) . '        value : function (i) {' . chr(10) . '            return p5call(res, ' . chr(39) . 'FETCH' . chr(39) . ', [i]);' . chr(10) . '        }' . chr(10) . '    });' . chr(10) . '    Object.defineProperty( v, "p5aset", {' . chr(10) . '        enumerable : false,' . chr(10) . '        configurable : true,' . chr(10) . '        value : function (i, value) {' . chr(10) . '            p5call(res, ' . chr(39) . 'STORE' . chr(39) . ', [i, value]);' . chr(10) . '            return value;' . chr(10) . '        }' . chr(10) . '    });' . chr(10) . '    Object.defineProperty( v, "p5incr", {' . chr(10) . '        enumerable : false,' . chr(10) . '        configurable : true,' . chr(10) . '        value : function (i) {' . chr(10) . '            var value = p5incr_(p5call(res, ' . chr(39) . 'FETCH' . chr(39) . ', [i]));' . chr(10) . '            p5call(res, ' . chr(39) . 'STORE' . chr(39) . ', [i, value]);' . chr(10) . '            return value;' . chr(10) . '        }' . chr(10) . '    });' . chr(10) . '    Object.defineProperty( v, "p5postincr", {' . chr(10) . '        enumerable : false,' . chr(10) . '        configurable : true,' . chr(10) . '        value : function (i) {' . chr(10) . '            var value = p5call(res, ' . chr(39) . 'FETCH' . chr(39) . ', [i]);' . chr(10) . '            p5call(res, ' . chr(39) . 'STORE' . chr(39) . ', [i, p5incr_(value)]);' . chr(10) . '            return value;' . chr(10) . '        }' . chr(10) . '    });' . chr(10) . '    Object.defineProperty( v, "p5decr", {' . chr(10) . '        enumerable : false,' . chr(10) . '        configurable : true,' . chr(10) . '        value : function (i) {' . chr(10) . '            var value = p5decr_(p5call(res, ' . chr(39) . 'FETCH' . chr(39) . ', [i]));' . chr(10) . '            p5call(res, ' . chr(39) . 'STORE' . chr(39) . ', [i, value]);' . chr(10) . '            return value;' . chr(10) . '        }' . chr(10) . '    });' . chr(10) . '    Object.defineProperty( v, "p5postdecr", {' . chr(10) . '        enumerable : false,' . chr(10) . '        configurable : true,' . chr(10) . '        value : function (i) {' . chr(10) . '            var value = p5call(res, ' . chr(39) . 'FETCH' . chr(39) . ', [i]);' . chr(10) . '            p5call(res, ' . chr(39) . 'STORE' . chr(39) . ', [i, p5decr_(value)]);' . chr(10) . '            return value;' . chr(10) . '        }' . chr(10) . '    });' . chr(10) . '    ' . chr(10) . '    Object.defineProperty( v, "p5aget_array", {' . chr(10) . '        enumerable : false,' . chr(10) . '        configurable : true,' . chr(10) . '        value : function (i) {' . chr(10) . '            var value = p5call(res, ' . chr(39) . 'FETCH' . chr(39) . ', [i]);' . chr(10) . '            if (value == null) {' . chr(10) . '                value = new p5ArrayRef([]);' . chr(10) . '                p5call(res, ' . chr(39) . 'STORE' . chr(39) . ', [i, value]);' . chr(10) . '            }' . chr(10) . '            return value;' . chr(10) . '        }' . chr(10) . '    });' . chr(10) . '    Object.defineProperty( v, "p5aget_hash", {' . chr(10) . '        enumerable : false,' . chr(10) . '        configurable : true,' . chr(10) . '        value : function (i) {' . chr(10) . '            var value = p5call(res, ' . chr(39) . 'FETCH' . chr(39) . ', [i]);' . chr(10) . '            if (value == null) {' . chr(10) . '                value = new p5HashRef({});' . chr(10) . '                p5call(res, ' . chr(39) . 'STORE' . chr(39) . ', [i, value]);' . chr(10) . '            }' . chr(10) . '            return value;' . chr(10) . '        }' . chr(10) . '    });' . chr(10) . '    Object.defineProperty( v, "p5untie", {' . chr(10) . '        enumerable : false,' . chr(10) . '        configurable : true,' . chr(10) . '        value : function (i) { return p5call(res, ' . chr(39) . 'UNTIE' . chr(39) . ', []) }' . chr(10) . '    });' . chr(10) . '    Object.defineProperty( v, "shift", {' . chr(10) . '        enumerable : false,' . chr(10) . '        configurable : true,' . chr(10) . '        value : function () { return p5call(res, ' . chr(39) . 'SHIFT' . chr(39) . ', []) }' . chr(10) . '    });' . chr(10) . '    Object.defineProperty( v, "pop", {' . chr(10) . '        enumerable : false,' . chr(10) . '        configurable : true,' . chr(10) . '        value : function () { return p5call(res, ' . chr(39) . 'POP' . chr(39) . ', []) }' . chr(10) . '    });' . chr(10) . '    Object.defineProperty( v, "p5unshift", {' . chr(10) . '        enumerable : false,' . chr(10) . '        configurable : true,' . chr(10) . '        value : function (args) { ' . chr(10) . '            for(var i = args.length-1; i >= 0; i--) {' . chr(10) . '                p5call(res, ' . chr(39) . 'UNSHIFT' . chr(39) . ', [args[i]]);' . chr(10) . '            }' . chr(10) . '            return p5call(res, ' . chr(39) . 'FETCHSIZE' . chr(39) . ', []); ' . chr(10) . '        }' . chr(10) . '    });' . chr(10) . '    Object.defineProperty( v, "p5push", {' . chr(10) . '        enumerable : false,' . chr(10) . '        configurable : true,' . chr(10) . '        value : function (args) { ' . chr(10) . '            for(var i = 0; i < args.length; i++) {' . chr(10) . '                p5call(res, ' . chr(39) . 'PUSH' . chr(39) . ', [args[i]]);' . chr(10) . '            }' . chr(10) . '            return p5call(res, ' . chr(39) . 'FETCHSIZE' . chr(39) . ', []); ' . chr(10) . '        }' . chr(10) . '    });' . chr(10) . chr(10) . '    return res;' . chr(10) . '};' . chr(10) . chr(10) . 'var p5untie_array = function(v) {' . chr(10) . '    if (v.hasOwnProperty(' . chr(39) . 'p5untie' . chr(39) . ')) {' . chr(10) . '        var res = v.p5untie();  // call UNTIE' . chr(10) . '        delete v.p5aget;' . chr(10) . '        delete v.p5aset;' . chr(10) . '        delete v.p5incr;' . chr(10) . '        delete v.p5postincr;' . chr(10) . '        delete v.p5decr;' . chr(10) . '        delete v.p5postdecr;' . chr(10) . '        delete v.p5aget_array;' . chr(10) . '        delete v.p5aget_hash;' . chr(10) . '        delete v.p5untie;' . chr(10) . '        delete v.shift;' . chr(10) . '        delete v.pop;' . chr(10) . '        delete v.p5unshift;' . chr(10) . '        delete v.p5push;' . chr(10) . '        return res;' . chr(10) . '    }' . chr(10) . '    else {' . chr(10) . '        return null;' . chr(10) . '    }' . chr(10) . '};' . chr(10) . chr(10) . chr(10) . 'function p5ArrayOfAlias(o) {' . chr(10) . chr(10) . '    // this is the structure that represents @_' . chr(10) . '    // _array = [ ref, index,' . chr(10) . '    //            ref, index,' . chr(10) . '    //            ...' . chr(10) . '    //          ]' . chr(10) . chr(10) . '    // TODO - autovivify array cells' . chr(10) . chr(10) . '    this._array_ = o;' . chr(10) . chr(10) . '    this.p5aget = function (i) {' . chr(10) . '        if (i < 0) { i =  this.length + i };' . chr(10) . '        return this._array_[i+i][this._array_[i+i+1]]; ' . chr(10) . '    }' . chr(10) . '    this.p5aset = function (i, v) {' . chr(10) . '        if (i < 0) { i =  this.length + i };' . chr(10) . '        this._array_[i+i][this._array_[i+i+1]] = v;' . chr(10) . '        return this._array_[i+i][this._array_[i+i+1]]' . chr(10) . '    }' . chr(10) . '    this.p5incr = function (i) {' . chr(10) . '        if (i < 0) { i =  this.length + i };' . chr(10) . '        this._array_[i+i][this._array_[i+i+1]] = p5incr_(this._array_[i+i][this._array_[i+i+1]]);' . chr(10) . '        return this._array_[i+i][this._array_[i+i+1]];' . chr(10) . '    }' . chr(10) . '    this.p5postincr = function (i) {' . chr(10) . '        if (i < 0) { i =  this.length + i };' . chr(10) . '        var v = this._array_[i+i][this._array_[i+i+1]];' . chr(10) . '        this._array_[i+i][this._array_[i+i+1]] = p5incr_(this._array_[i+i][this._array_[i+i+1]]);' . chr(10) . '        return v;' . chr(10) . '    }' . chr(10) . '    this.p5decr = function (i) {' . chr(10) . '        if (i < 0) { i =  this.length + i };' . chr(10) . '        this._array_[i+i][this._array_[i+i+1]] = p5decr_(this._array_[i+i][this._array_[i+i+1]]);' . chr(10) . '        return this._array_[i+i][this._array_[i+i+1]];' . chr(10) . '    }' . chr(10) . '    this.p5postdecr = function (i) {' . chr(10) . '        if (i < 0) { i =  this.length + i };' . chr(10) . '        var v = this._array_[i+i][this._array_[i+i+1]];' . chr(10) . '        this._array_[i+i][this._array_[i+i+1]] = p5decr_(this._array_[i+i][this._array_[i+i+1]]);' . chr(10) . '        return v;' . chr(10) . '    }' . chr(10) . '    this.p5aget_array = function (i) {' . chr(10) . '        if (i < 0) { i =  this.length + i };' . chr(10) . '        if (this._array_[i+i][this._array_[i+i+1]] == null) {' . chr(10) . '            this._array_[i+i][this._array_[i+i+1]] = new p5ArrayRef([])' . chr(10) . '        }' . chr(10) . '        return this._array_[i+i][this._array_[i+i+1]]' . chr(10) . '    }' . chr(10) . '    this.p5aget_hash = function (i) {' . chr(10) . '        if (i < 0) { i =  this.length + i };' . chr(10) . '        if (this._array_[i+i][this._array_[i+i+1]] == null) {' . chr(10) . '            this._array_[i+i][this._array_[i+i+1]] = new p5HashRef({})' . chr(10) . '        }' . chr(10) . '        return this._array_[i+i][this._array_[i+i+1]]' . chr(10) . '    }' . chr(10) . '    this.p5unshift = function (args) { ' . chr(10) . '        for(var i = args.length-1; i >= 0; i--) {' . chr(10) . '            this.unshift(0);' . chr(10) . '            this.unshift([args[i]]);' . chr(10) . '        }' . chr(10) . '        return this._array_.length / 2; ' . chr(10) . '    }' . chr(10) . '    this.p5push = function (args) { ' . chr(10) . '        for(var i = 0; i < args.length; i++) {' . chr(10) . '            this.push([args[i]]);' . chr(10) . '            this.push(0);' . chr(10) . '        }' . chr(10) . '        return this._array_.length / 2; ' . chr(10) . '    }' . chr(10) . '    this.shift = function () { ' . chr(10) . '        var v0 = this._array_.shift();' . chr(10) . '        return v0[this._array_.shift()];' . chr(10) . '    }' . chr(10) . '    this.pop = function () { ' . chr(10) . '        var v1 = this._array_.pop();' . chr(10) . '        var v0 = this._array_.pop();' . chr(10) . '        return v0[v1];' . chr(10) . '    }' . chr(10) . '}' . chr(10) . chr(10) . chr(10)
}
1;
# use Perlito5::Javascript2::Array
package main;
undef();
package Perlito5::Javascript2::CORE;
sub Perlito5::Javascript2::CORE::emit_javascript2 {
    return '//' . chr(10) . '//' . chr(10) . '// lib/Perlito5/Javascript2/CORE.js' . chr(10) . '//' . chr(10) . '// CORE functions for "Perlito" Perl5-in-Javascript2' . chr(10) . '//' . chr(10) . '// AUTHORS' . chr(10) . '//' . chr(10) . '// Flavio Soibelmann Glock  fglock@gmail.com' . chr(10) . '//' . chr(10) . '// COPYRIGHT' . chr(10) . '//' . chr(10) . '// Copyright 2009, 2010, 2011, 2012 by Flavio Soibelmann Glock and others.' . chr(10) . '//' . chr(10) . '// This program is free software; you can redistribute it and/or modify it' . chr(10) . '// under the same terms as Perl itself.' . chr(10) . '//' . chr(10) . '// See http://www.perl.com/perl/misc/Artistic.html' . chr(10) . chr(10) . 'var CORE = p5pkg.CORE;' . chr(10) . chr(10) . 'var isNode = typeof require != "undefined";' . chr(10) . chr(10) . 'CORE.bless = function(List__) {' . chr(10) . '    var o        = List__[0];' . chr(10) . '    var pkg_name = List__[1];' . chr(10) . '    if (typeof pkg_name === "object") {' . chr(10) . '        // bless {}, Class' . chr(10) . '        o._class_ = pkg_name;' . chr(10) . '        return o;' . chr(10) . '    }' . chr(10) . '    if (!p5pkg.hasOwnProperty(pkg_name)) {' . chr(10) . '        p5make_package(pkg_name);' . chr(10) . '    }' . chr(10) . '    o._class_ = p5pkg[pkg_name];' . chr(10) . '    return o;' . chr(10) . '};' . chr(10) . chr(10) . 'CORE.caller = function(List__, want) {' . chr(10) . '    if (p5pkg["Perlito5"].v_CALLER && p5pkg["Perlito5"].v_CALLER._array_ && p5pkg["Perlito5"].v_CALLER._array_.p5aget(0) ) {' . chr(10) . '        // TODO' . chr(10) . '        return p5pkg["Perlito5"].v_CALLER._array_.p5aget(0)._array_' . chr(10) . '    }' . chr(10) . '    return p5context([], want);' . chr(10) . '};' . chr(10) . chr(10) . 'CORE.chr = function(List__) {' . chr(10) . '    var v = p5num(List__[0]);' . chr(10) . '    return String.fromCharCode(v >= 0 ? v : 65533);' . chr(10) . '};' . chr(10) . chr(10) . 'CORE.ord = function(List__) {' . chr(10) . '    return p5str(List__[0]).charCodeAt(0);' . chr(10) . '};' . chr(10) . chr(10) . 'CORE.hex = function(List__) {' . chr(10) . '    var v = List__[0];' . chr(10) . chr(10) . '    for(var i = 0; i < v.length; i++) {' . chr(10) . '        if (v.charCodeAt(i) > 255) {' . chr(10) . '            CORE.die(["Wide character in hex"]);' . chr(10) . '        }' . chr(10) . '    }' . chr(10) . chr(10) . '    var b1 = v.substr(0,1);' . chr(10) . '    var b2 = v.substr(0,2);' . chr(10) . '    if (b1 == "x" || b1 == "X" || b2 == "0x" || b2 == "0X") {' . chr(10) . '        return CORE.oct(List__);' . chr(10) . '    }' . chr(10) . '    v = "0x" + v;' . chr(10) . '    return CORE.oct([v]);' . chr(10) . '};' . chr(10) . chr(10) . 'CORE.oct = function(List__) {' . chr(10) . '    var v = List__[0];' . chr(10) . '    v = v.trim();' . chr(10) . chr(10) . '    for(var i = 0; i < v.length; i++) {' . chr(10) . '        if (v.charCodeAt(i) > 255) {' . chr(10) . '            CORE.die(["Wide character in oct"]);' . chr(10) . '        }' . chr(10) . '    }' . chr(10) . chr(10) . '    var b = v.substr(0,1);' . chr(10) . '    if (b == "b" || b == "B" || b == "x" || b == "X") {' . chr(10) . '        v = "0" + v;' . chr(10) . '    }' . chr(10) . '    b = v.substr(0,2);' . chr(10) . chr(10) . '    for(var i = 2; i < v.length; i++) {' . chr(10) . '        if (v.substr(i,2) == "__") {' . chr(10) . '            v = v.substr(0, i);' . chr(10) . '        }' . chr(10) . '    }' . chr(10) . chr(10) . '    var re = new RegExp(' . chr(39) . '_' . chr(39) . ', ' . chr(39) . 'g' . chr(39) . ');' . chr(10) . '    v = v.replace(re, "");' . chr(10) . chr(10) . '    if (b == "0b" || b == "0B") {' . chr(10) . '        for(var i = 2; i < v.length; i++) {' . chr(10) . '            var c = v.substr(i,1);' . chr(10) . '            if (c >= "0" && c <= "1") {}' . chr(10) . '            else {' . chr(10) . '                v = v.substr(0, i);' . chr(10) . '            }' . chr(10) . '        }' . chr(10) . '        if (v.length == 2) { return 0 }' . chr(10) . '        return parseInt(v.substr(2), 2);' . chr(10) . '    }' . chr(10) . chr(10) . '    if (b == "0x" || b == "0X") {' . chr(10) . '        for(var i = 2; i < v.length; i++) {' . chr(10) . '            var c = v.substr(i,1);' . chr(10) . '            if (c >= "0" && c <= "9" || c >= "A" && c <= "F" || c >= "a" && c <= "f") {}' . chr(10) . '            else {' . chr(10) . '                v = v.substr(0, i);' . chr(10) . '            }' . chr(10) . '        }' . chr(10) . '        if (v.length == 2) { return 0 }' . chr(10) . '        return parseInt(v.substr(2), 16);' . chr(10) . '    }' . chr(10) . chr(10) . '    return parseInt(v, 8);' . chr(10) . '};' . chr(10) . chr(10) . 'CORE.abs   = function(List__) { return Math.abs(List__[0]) };' . chr(10) . 'CORE.exp   = function(List__) { return Math.exp(List__[0]) };' . chr(10) . 'CORE.log   = function(List__) { return Math.log(List__[0]) };' . chr(10) . 'CORE.cos   = function(List__) { return Math.cos(List__[0]) };' . chr(10) . 'CORE.sin   = function(List__) { return Math.sin(List__[0]) };' . chr(10) . 'CORE.sqrt  = function(List__) { return Math.sqrt(List__[0]) };' . chr(10) . 'CORE.atan2 = function(List__) { return Math.atan2(List__[0], List__[1]) };' . chr(10) . 'CORE.int   = function(List__) { return List__[0] > 0 ? Math.floor(List__[0]) : Math.ceil(List__[0]) };' . chr(10) . chr(10) . 'CORE.rand = function(List__) {' . chr(10) . '    var v = p5num(List__[0]) || 1;' . chr(10) . '    return Math.random() * v;' . chr(10) . '};' . chr(10) . chr(10) . 'CORE.lc      = function(List__) { return p5str(List__[0]).toLowerCase() };' . chr(10) . 'CORE.uc      = function(List__) { return p5str(List__[0]).toUpperCase() };' . chr(10) . chr(10) . 'CORE.lcfirst = function(List__) {' . chr(10) . '    var s = p5str(List__[0]);' . chr(10) . '    var c = s.length > 0 ? s.slice(0,1).toLowerCase() : "";' . chr(10) . '    s = s.length > 1 ? s.substr(1) : "";' . chr(10) . '    return c + s' . chr(10) . '};' . chr(10) . chr(10) . 'CORE.ucfirst = function(List__) {' . chr(10) . '    var s = p5str(List__[0]);' . chr(10) . '    var c = s.length > 0 ? s.slice(0,1).toUpperCase() : "";' . chr(10) . '    s = s.length > 1 ? s.substr(1) : "";' . chr(10) . '    return c + s' . chr(10) . '};' . chr(10) . chr(10) . 'CORE.quotemeta = function(List__) {' . chr(10) . '    var s = p5str(List__[0]);' . chr(10) . '    var out = [];' . chr(10) . '    for(var i = 0; i < s.length; i++) {' . chr(10) . '        if (s.substr(i, 1).match(/[^0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz]/)) {' . chr(10) . '            out.push(String.fromCharCode(92));' . chr(10) . '        }' . chr(10) . '        out.push(s.substr(i, 1));' . chr(10) . '    }' . chr(10) . '    return out.join("");       ' . chr(10) . '};' . chr(10) . chr(10) . 'CORE.substr = function(List__) {' . chr(10) . '    var expr        = List__[0];' . chr(10) . '    var offset      = List__[1];' . chr(10) . '    var length      = List__[2];' . chr(10) . '    var replacement = List__[3];' . chr(10) . '    if (length < 0) {' . chr(10) . '        var s = p5str(expr);' . chr(10) . '        length = s.length - offset + length;' . chr(10) . '    } ' . chr(10) . '    return p5str(expr).substr(offset, length);' . chr(10) . '};' . chr(10) . chr(10) . 'CORE.values = function(List__, p5want) {' . chr(10) . '    var o = List__[0];' . chr(10) . '    delete o["_each_"];' . chr(10) . '    if (p5want) {' . chr(10) . '        if (o == null) {' . chr(10) . '            return [];' . chr(10) . '        };' . chr(10) . '        if (typeof o.values === "function") {' . chr(10) . '            return o.values();' . chr(10) . '        }' . chr(10) . '        var out = [];' . chr(10) . '        for (var i in o) {' . chr(10) . '            out.push(o[i]);' . chr(10) . '        }' . chr(10) . '        return out;' . chr(10) . '    }' . chr(10) . '    return CORE.keys(List__, p5want);' . chr(10) . '};' . chr(10) . chr(10) . 'CORE.keys = function(List__, p5want) {' . chr(10) . '    var o = List__[0];' . chr(10) . '    delete o["_each_"];' . chr(10) . '    if (p5want) {' . chr(10) . '        if (o == null) {' . chr(10) . '            return [];' . chr(10) . '        }' . chr(10) . '        if (typeof o.keys === "function") {' . chr(10) . '            return o.keys();' . chr(10) . '        }' . chr(10) . '        var out = [];' . chr(10) . '        for (var i in o) {' . chr(10) . '            out.push(i);' . chr(10) . '        }' . chr(10) . '        return out;' . chr(10) . '    }' . chr(10) . '    else {' . chr(10) . '        if (o == null) {' . chr(10) . '            return 0;' . chr(10) . '        }' . chr(10) . '        if (typeof o.keys === "function") {' . chr(10) . '            return p5num(o.keys());' . chr(10) . '        }' . chr(10) . '        var out = 0;' . chr(10) . '        for (var i in o) {' . chr(10) . '            out++;' . chr(10) . '        }' . chr(10) . '        return out;' . chr(10) . '    }' . chr(10) . '};' . chr(10) . chr(10) . 'CORE.each = function(List__, p5want) {' . chr(10) . '    var o = List__[0];' . chr(10) . '    if (o.hasOwnProperty("_each_")) {' . chr(10) . '        return o._each_(p5want)' . chr(10) . '    }' . chr(10) . '    var keys = CORE.keys([o], 1);' . chr(10) . '    var i = 0;' . chr(10) . '    o._each_ = function () {' . chr(10) . '        if (i < keys.length) {' . chr(10) . '            i++;' . chr(10) . '            return p5want ? [keys[i-1], o[keys[i-1]]] : keys[i-1];' . chr(10) . '        }' . chr(10) . '        i = 0;' . chr(10) . '        return p5want ? [] : null;' . chr(10) . '    };' . chr(10) . '    return o._each_(p5want);' . chr(10) . '};' . chr(10) . chr(10) . 'CORE.reverse = function(List__) {' . chr(10) . '    var o = List__;' . chr(10) . '    if (o == null) {' . chr(10) . '        return "";' . chr(10) . '    }' . chr(10) . '    if (typeof o === "string") {' . chr(10) . '        return o.split("").reverse().join("")' . chr(10) . '    }' . chr(10) . '    var out = [];' . chr(10) . '    for(var i = 0; i < o.length; i++) {' . chr(10) . '        out.unshift(o[i]);' . chr(10) . '    }' . chr(10) . '    return out;' . chr(10) . '};' . chr(10) . chr(10) . 'CORE.splice = function(List__, p5want) {' . chr(10) . '    var array  = List__.shift();' . chr(10) . '    // CORE.say([ array ]);' . chr(10) . '    var offset = p5num(List__.shift());' . chr(10) . '    var limit  = List__.length ? p5num(List__.shift()) : (array.length + 1);' . chr(10) . chr(10) . '    if (limit < 0) {' . chr(10) . '        limit = array.length + limit - 1;' . chr(10) . '    }' . chr(10) . chr(10) . '    var list = [offset, limit];' . chr(10) . '    for(var i = 0; i < List__.length; i++) {' . chr(10) . '        list = p5list_to_a([ list, List__[i] ]);' . chr(10) . '    }' . chr(10) . chr(10) . '    var out = array.splice.apply(array, list);' . chr(10) . '    // CORE.say([ CORE.join([":",array]), " ofs=", offset, " lim=", limit, " list=", list, " out=", CORE.join([":",out])  ]);' . chr(10) . '    return p5want ? out : out.pop();' . chr(10) . '};' . chr(10) . chr(10) . 'CORE.join = function(List__) {' . chr(10) . '    var s = List__.shift();' . chr(10) . '    var o = [];' . chr(10) . '    for (var i = 0; i < List__.length; i++) {' . chr(10) . '        o.push(p5str(List__[i]));' . chr(10) . '    }' . chr(10) . '    return o.join(s);' . chr(10) . '};' . chr(10) . chr(10) . 'CORE.index = function(List__) {' . chr(10) . '    var o = List__[0];' . chr(10) . '    var s = List__[1];' . chr(10) . '    try {' . chr(10) . '        return o.indexOf(s, p5num(List__[2]));' . chr(10) . '    }' . chr(10) . '    catch(err) {' . chr(10) . '        return -1;' . chr(10) . '    }' . chr(10) . '};' . chr(10) . 'CORE.rindex = function(List__) {' . chr(10) . '    var o = List__[0];' . chr(10) . '    var s = List__[1];' . chr(10) . '    try {' . chr(10) . '        if (List__.length > 2) {' . chr(10) . '            var i = p5num(List__[2]);' . chr(10) . '            if (i < 0) {' . chr(10) . '                if (s.length == 0) {' . chr(10) . '                    return 0;' . chr(10) . '                }' . chr(10) . '                return -1;' . chr(10) . '            }' . chr(10) . '            return o.lastIndexOf(s, i);' . chr(10) . '        }' . chr(10) . '        return o.lastIndexOf(s);' . chr(10) . '    }' . chr(10) . '    catch(err) {' . chr(10) . '        return -1;' . chr(10) . '    }' . chr(10) . '};' . chr(10) . chr(10) . 'CORE.length = function(List__) {' . chr(10) . '    return p5str(List__[0]).length;' . chr(10) . '};' . chr(10) . chr(10) . 'CORE.pack    = function(List__) { CORE.warn([ "CORE::pack not implemented" ]) };' . chr(10) . 'CORE.unpack  = function(List__) { CORE.warn([ "CORE::unpack not implemented" ]) };' . chr(10) . chr(10) . 'CORE.ref = function(List__) {' . chr(10) . '    var o = List__[0];' . chr(10) . '    if (o == null) {' . chr(10) . '        return "";' . chr(10) . '    }' . chr(10) . '    if (o._class_ && typeof o._class_._ref_ === "string") {' . chr(10) . '        // blessed reference' . chr(10) . '        return o._class_._ref_;' . chr(10) . '    }' . chr(10) . '    if (typeof o._ref_ === "string") {' . chr(10) . '        // un-blessed reference' . chr(10) . '        return o._ref_;' . chr(10) . '    }' . chr(10) . '    if (typeof o === "function") {' . chr(10) . '        return "CODE";' . chr(10) . '    }' . chr(10) . '    return "";' . chr(10) . '};' . chr(10) . chr(10) . 'CORE.split = function(List__, want) {' . chr(10) . '    var pattern = List__[0];' . chr(10) . '    var s       = p5str(List__[1]);' . chr(10) . '    var limit   = p5num(List__[2]);' . chr(10) . '    if (!want) {' . chr(10) . '        // scalar context' . chr(10) . '        return p5num(CORE.split(List__, 1));' . chr(10) . '    }' . chr(10) . '    if (limit == 0) {' . chr(10) . '        // strip trailing empty strings and undef' . chr(10) . '        var res = CORE.split([pattern, s, -1], 1);' . chr(10) . '        while (res.length && (res[res.length - 1] == ' . chr(39) . chr(39) . ' || typeof res[res.length - 1] == "undefined") ) {' . chr(10) . '            res.pop()' . chr(10) . '        }' . chr(10) . '        return res;' . chr(10) . '    }' . chr(10) . '    if (s == ' . chr(39) . chr(39) . ') {' . chr(10) . '        return []' . chr(10) . '    }' . chr(10) . '    // make sure pattern is a RegExp' . chr(10) . '    if (typeof pattern === "object" && (pattern instanceof RegExp)) {' . chr(10) . '        pattern = pattern.source;' . chr(10) . '    }' . chr(10) . '    else {' . chr(10) . '        pattern = p5str(pattern);' . chr(10) . '        if (pattern == " ") {' . chr(10) . '            // single space string is special' . chr(10) . '            pattern = "(?: |' . chr(92) . 't|' . chr(92) . 'n)+";' . chr(10) . '            s = s.replace(/^(?: |' . chr(92) . 't|' . chr(92) . 'n)+/, "");' . chr(10) . '        }' . chr(10) . '    }' . chr(10) . '    // add "g", "m" modifiers' . chr(10) . '    var flags = "g";' . chr(10) . '    if (pattern.substr(0, 1) == "^" || pattern.substr(-1,1) == "$") {' . chr(10) . '        flags = flags + "m";' . chr(10) . '    }' . chr(10) . '    pattern = new RegExp(pattern, flags);' . chr(10) . '    var res = [];' . chr(10) . '    var pos = 0;' . chr(10) . '    var count = 0;' . chr(10) . '    while (1) {' . chr(10) . '        if (limit > 0 && limit <= (count + 1)) {' . chr(10) . '            res.push(s.substr(pos));' . chr(10) . '            return res;' . chr(10) . '        }' . chr(10) . '        var m = pattern.exec(s);' . chr(10) . '        if (m === null) {' . chr(10) . '            // no match' . chr(10) . '            res.push(s.substr(pos));' . chr(10) . '            return res;' . chr(10) . '        }' . chr(10) . '        if (m[0].length == 0 && m.index == pos) {' . chr(10) . '            // pointer didn' . chr(39) . 't move' . chr(10) . '            pattern.lastIndex = pattern.lastIndex + 1;' . chr(10) . '        }' . chr(10) . '        else {' . chr(10) . '            var part = s.substr(pos, m.index - pos);' . chr(10) . '            res.push(part);' . chr(10) . '            count++;' . chr(10) . '            pos = m.index + m[0].length;' . chr(10) . '            pattern.lastIndex = pos;' . chr(10) . '        }' . chr(10) . '        for (var i = 1; i < m.length ; i++) {' . chr(10) . '            res.push(m[i]);     // captured substrings; don' . chr(39) . 't increment count' . chr(10) . '        }' . chr(10) . '    }' . chr(10) . '};' . chr(10) . chr(10) . chr(10)
}
1;
# use Perlito5::Javascript2::CORE
package main;
undef();
package Perlito5::Javascript2::IO;
sub Perlito5::Javascript2::IO::emit_javascript2 {
    return '//' . chr(10) . '//' . chr(10) . '// lib/Perlito5/Javascript2/IO.js' . chr(10) . '//' . chr(10) . '// I/O functions for "Perlito" Perl5-in-Javascript2' . chr(10) . '//' . chr(10) . '// AUTHORS' . chr(10) . '//' . chr(10) . '// Flavio Soibelmann Glock  fglock@gmail.com' . chr(10) . '//' . chr(10) . '// COPYRIGHT' . chr(10) . '//' . chr(10) . '// Copyright 2009, 2010, 2011, 2012 by Flavio Soibelmann Glock and others.' . chr(10) . '//' . chr(10) . '// This program is free software; you can redistribute it and/or modify it' . chr(10) . '// under the same terms as Perl itself.' . chr(10) . '//' . chr(10) . '// See http://www.perl.com/perl/misc/Artistic.html' . chr(10) . chr(10) . 'var isNode = typeof require != "undefined";' . chr(10) . 'if (isNode) {' . chr(10) . chr(10) . '    var fs = require("fs");' . chr(10) . chr(10) . '    p5typeglob_set("Perlito5::IO", "print", function (filehandle, List__, p5want) {' . chr(10) . '        try {' . chr(10) . '            var v = filehandle;' . chr(10) . '            var pkg;' . chr(10) . '            if (CORE.ref([v])) {' . chr(10) . '                // looks like a filehandle' . chr(10) . '                pkg = v;' . chr(10) . '            }' . chr(10) . '            else {' . chr(10) . '                // looks like a package name' . chr(10) . '                pkg = p5make_package(v);' . chr(10) . '            }' . chr(10) . '            if (!pkg.file_handle) {' . chr(10) . '                pkg.file_handle = {};' . chr(10) . '            }' . chr(10) . '            var handle_id = pkg.file_handle.id;' . chr(10) . '            if (handle_id == 1) {' . chr(10) . '                for (var i = 0; i < List__.length; i++) {' . chr(10) . '                    process.stdout.write(p5str(List__[i]));' . chr(10) . '                }' . chr(10) . '            }' . chr(10) . '            else if (handle_id == 2) {' . chr(10) . '                for (var i = 0; i < List__.length; i++) {' . chr(10) . '                    process.stderr.write(p5str(List__[i]));' . chr(10) . '                }' . chr(10) . '            }' . chr(10) . '            else {' . chr(10) . '                for (var i = 0; i < List__.length; i++) {' . chr(10) . '                    fs.writeSync(handle_id, p5str(List__[i]));' . chr(10) . '                }' . chr(10) . '            }' . chr(10) . '            return 1;' . chr(10) . '        }' . chr(10) . '        catch(err) {' . chr(10) . '            p5pkg["main"]["v_!"] = err;' . chr(10) . '            return ' . chr(39) . chr(39) . ';' . chr(10) . '        }' . chr(10) . '    } );' . chr(10) . chr(10) . '    var p5_extra_buffer_size = 100;' . chr(10) . '    p5typeglob_set("Perlito5::IO", "read", function (filehandle, List__, p5want) {' . chr(10) . '        try {' . chr(10) . '            var v = filehandle;' . chr(10) . '            var length = List__.shift();' . chr(10) . '            var pkg;' . chr(10) . '            if (CORE.ref([v])) {' . chr(10) . '                // looks like a filehandle' . chr(10) . '                pkg = v;' . chr(10) . '            }' . chr(10) . '            else {' . chr(10) . '                // looks like a package name' . chr(10) . '                pkg = p5make_package(v);' . chr(10) . '            }' . chr(10) . '            if (!pkg.file_handle) {' . chr(10) . '                pkg.file_handle = {};' . chr(10) . '            }' . chr(10) . '            var handle_id = pkg.file_handle.id;' . chr(10) . chr(10) . '            if (!pkg.file_handle.buffer) {' . chr(10) . '                // we don' . chr(39) . 't have any data yet' . chr(10) . '                var length_wanted = length + 2 * p5_extra_buffer_size;' . chr(10) . '                var buffer = new Buffer(length_wanted);' . chr(10) . '                var bytes_read = fs.readSync(handle_id, buffer, 0, length_wanted, null);' . chr(10) . '                if (bytes_read < length_wanted) {' . chr(10) . '                    pkg.file_handle.buffer_eof = 1;' . chr(10) . '                }' . chr(10) . '                pkg.file_handle.buffer = buffer;' . chr(10) . '                pkg.file_handle.buffer_start = 0;' . chr(10) . '                pkg.file_handle.buffer_end = bytes_read;' . chr(10) . '                pkg.file_handle.buffer_length = pkg.file_handle.buffer_end;' . chr(10) . '            }' . chr(10) . '            else if (pkg.file_handle.buffer_length > (length + p5_extra_buffer_size)) {' . chr(10) . '                // we have enough data' . chr(10) . '            }' . chr(10) . '            else if (!pkg.file_handle.buffer_eof) {' . chr(10) . '                // we have some data; append more data to the internal buffer' . chr(10) . '                var length_wanted = length + 2 * p5_extra_buffer_size;' . chr(10) . '                var buffer = new Buffer(pkg.file_handle.buffer_length + length_wanted);' . chr(10) . '                pkg.file_handle.buffer.copy(buffer, 0, pkg.file_handle.buffer_start, pkg.file_handle.buffer_end);' . chr(10) . '                var bytes_read = fs.readSync(handle_id, buffer, pkg.file_handle.buffer_length, length_wanted, null);' . chr(10) . '                if (bytes_read < length_wanted) {' . chr(10) . '                    pkg.file_handle.buffer_eof = 1;' . chr(10) . '                }' . chr(10) . '                pkg.file_handle.buffer = buffer;' . chr(10) . '                pkg.file_handle.buffer_start = 0;' . chr(10) . '                pkg.file_handle.buffer_end = pkg.file_handle.buffer_length + bytes_read;' . chr(10) . '                pkg.file_handle.buffer_length = pkg.file_handle.buffer_end;' . chr(10) . '            }' . chr(10) . chr(10) . '            var s = pkg.file_handle.buffer.toString(' . chr(39) . 'utf-8' . chr(39) . ', pkg.file_handle.buffer_start, pkg.file_handle.buffer_end).substr(0, length);' . chr(10) . chr(10) . '            // how many bytes we actually used' . chr(10) . '            var buffer_used = Buffer.byteLength(s, ' . chr(39) . 'utf-8' . chr(39) . ');' . chr(10) . chr(10) . '            pkg.file_handle.buffer_start = pkg.file_handle.buffer_start + buffer_used;' . chr(10) . '            pkg.file_handle.buffer_length = pkg.file_handle.buffer_length - buffer_used;' . chr(10) . chr(10) . '            if ( handle_id == 0) {' . chr(10) . '                // STDIN' . chr(10) . '                pkg.file_handle.buffer_eof = (s.length ? 0 : 1);' . chr(10) . '                pkg.file_handle.eof = (s.length ? 0 : 1);' . chr(10) . '            }' . chr(10) . '            else if ( pkg.file_handle.buffer_eof && pkg.file_handle.buffer_length <= 0 ) {' . chr(10) . '                pkg.file_handle.eof = 1;' . chr(10) . '            }' . chr(10) . chr(10) . '            return [s.length, s];' . chr(10) . '        }' . chr(10) . '        catch(err) {' . chr(10) . '            p5pkg["main"]["v_!"] = err;' . chr(10) . '            return [];' . chr(10) . '        }' . chr(10) . '    } );' . chr(10) . chr(10) . '    var p5ARGV = 0;' . chr(10) . '    p5typeglob_set("Perlito5::IO", "readline", function (List__, p5want) {' . chr(10) . '        var filehandle = List__.shift();' . chr(10) . chr(10) . '        if (p5want) {' . chr(10) . '            var out = [];' . chr(10) . '            while (1) {' . chr(10) . '                var s = p5pkg["Perlito5::IO"].readline([filehandle], 0);' . chr(10) . '                if (s == null) {' . chr(10) . '                    return out;' . chr(10) . '                }' . chr(10) . '                out.push(s);' . chr(10) . '            }' . chr(10) . '        }' . chr(10) . chr(10) . '        var v = filehandle;' . chr(10) . '        var pkg;' . chr(10) . '        if (CORE.ref([v])) {' . chr(10) . '            // looks like a filehandle' . chr(10) . '            pkg = v;' . chr(10) . '        }' . chr(10) . '        else {' . chr(10) . '            // looks like a package name' . chr(10) . '            pkg = p5make_package(v);' . chr(10) . '            if (v == "ARGV") {' . chr(10) . '                // ARGV is magical' . chr(10) . '                if (pkg.file_handle.id == null) {' . chr(10) . '                    if (!p5ARGV) {' . chr(10) . '                        if (p5pkg["main"]["List_ARGV"].length == 0) {' . chr(10) . '                            p5pkg["main"]["List_ARGV"].push(' . chr(39) . '-' . chr(39) . ');' . chr(10) . '                        }' . chr(10) . '                    }' . chr(10) . '                    p5ARGV = 1;' . chr(10) . '                    // TODO - open $ARGV[1], ...' . chr(10) . '                    var filename = p5pkg["main"]["List_ARGV"].shift();' . chr(10) . '                    CORE.open([ "ARGV", "<", filename ]) || CORE.die([ p5pkg["main"]["v_!"] ]);' . chr(10) . '                }' . chr(10) . '            }' . chr(10) . '        }' . chr(10) . '        if (!pkg.file_handle) {' . chr(10) . '            pkg.file_handle = {};' . chr(10) . '        }' . chr(10) . chr(10) . '        if (CORE.eof([v])) {' . chr(10) . '            return null;' . chr(10) . '        }' . chr(10) . chr(10) . '        var separator = p5pkg["main"]["v_/"];  // input record separator' . chr(10) . '        var buf = pkg.file_handle.readline_buffer;' . chr(10) . '        var pos;' . chr(10) . chr(10) . '        if (separator) {' . chr(10) . '            pos = buf.indexOf(separator);' . chr(10) . '            while ( pos < 0 && !pkg.file_handle.eof ) {' . chr(10) . '                var r = p5pkg["Perlito5::IO"].read(filehandle, [100]);' . chr(10) . '                buf = buf + r[1];' . chr(10) . '                pos = buf.indexOf(separator);' . chr(10) . '            }' . chr(10) . '        }' . chr(10) . '        else {' . chr(10) . '            // no separator' . chr(10) . '            pos = -1;' . chr(10) . '            while ( !pkg.file_handle.eof ) {' . chr(10) . '                var r = p5pkg["Perlito5::IO"].read(filehandle, [100]);' . chr(10) . '                buf = buf + r[1];' . chr(10) . '            }' . chr(10) . '        }' . chr(10) . chr(10) . '        if (pos < 0) {' . chr(10) . '            pkg.file_handle.readline_buffer = ' . chr(39) . chr(39) . ';' . chr(10) . '            if (!buf.length) {' . chr(10) . '                pkg.file_handle.readline_buffer = ' . chr(39) . chr(39) . ';' . chr(10) . '                pkg.file_handle.eof = 1;' . chr(10) . '                return null' . chr(10) . '            }' . chr(10) . '            return buf;' . chr(10) . '        }' . chr(10) . '        var s = buf.substr(0, pos + separator.length);' . chr(10) . '        pkg.file_handle.readline_buffer = buf.substr(pos + separator.length);' . chr(10) . '        if (!s.length) {' . chr(10) . '            pkg.file_handle.readline_buffer = ' . chr(39) . chr(39) . ';' . chr(10) . '            pkg.file_handle.eof = 1;' . chr(10) . '            return null' . chr(10) . '        }' . chr(10) . '        return s;' . chr(10) . '    } );' . chr(10) . chr(10) . '    p5typeglob_set("Perlito5::IO", "close", function (filehandle, List__, p5want) {' . chr(10) . '        try {' . chr(10) . '            var v = filehandle;' . chr(10) . '            var pkg;' . chr(10) . '            if (CORE.ref([v])) {' . chr(10) . '                // looks like a filehandle' . chr(10) . '                pkg = v;' . chr(10) . '            }' . chr(10) . '            else {' . chr(10) . '                // looks like a package name' . chr(10) . '                pkg = p5make_package(v);' . chr(10) . '            }' . chr(10) . '            if (!pkg.file_handle) {' . chr(10) . '                pkg.file_handle = {};' . chr(10) . '            }' . chr(10) . '            var handle_id = pkg.file_handle.id;' . chr(10) . '            if (handle_id == 1) {' . chr(10) . '                process.stdout.close();' . chr(10) . '            }' . chr(10) . '            else if (handle_id == 2) {' . chr(10) . '                process.stderr.close();' . chr(10) . '            }' . chr(10) . '            else {' . chr(10) . '                fs.closeSync(handle_id);' . chr(10) . '            }' . chr(10) . '            pkg.file_handle.id = null;' . chr(10) . '            return 1;' . chr(10) . '        }' . chr(10) . '        catch(err) {' . chr(10) . '            p5pkg["main"]["v_!"] = err;' . chr(10) . '            return ' . chr(39) . chr(39) . ';' . chr(10) . '        }' . chr(10) . '    } );' . chr(10) . chr(10) . '    CORE.eof = function(List__) {' . chr(10) . '        try {' . chr(10) . '            var filehandle = List__.shift();' . chr(10) . '            var v = filehandle;' . chr(10) . '            var pkg;' . chr(10) . '            if (CORE.ref([v])) {' . chr(10) . '                // looks like a filehandle' . chr(10) . '                pkg = v;' . chr(10) . '            }' . chr(10) . '            else {' . chr(10) . '                // looks like a package name' . chr(10) . '                pkg = p5make_package(v);' . chr(10) . '            }' . chr(10) . '            if (!pkg.file_handle) {' . chr(10) . '                pkg.file_handle = {};' . chr(10) . '            }' . chr(10) . '            var handle_id = pkg.file_handle.id;' . chr(10) . '            if (handle_id == null) {' . chr(10) . '                return 1;  // file is not open' . chr(10) . '            }' . chr(10) . '            return pkg.file_handle.eof && pkg.file_handle.readline_buffer.length == 0;' . chr(10) . '        }' . chr(10) . '        catch(err) {' . chr(10) . '            p5pkg["main"]["v_!"] = err;' . chr(10) . '            return ' . chr(39) . chr(39) . ';' . chr(10) . '        }' . chr(10) . '    };' . chr(10) . chr(10) . '    CORE.open = function(List__) {' . chr(10) . '        try {' . chr(10) . '            var filehandle = List__.shift();' . chr(10) . '            var flags = List__.shift();' . chr(10) . '            var path;' . chr(10) . '            if (List__.length) {' . chr(10) . '                path = List__.shift();' . chr(10) . '            }' . chr(10) . '            else {' . chr(10) . '                // 2-argument open' . chr(10) . '                var re = new RegExp("^([<>+|]*)(.*)$", "");' . chr(10) . '                var capture = re.exec(flags);' . chr(10) . '                flags = capture[1];' . chr(10) . '                path = capture[2];' . chr(10) . '            }' . chr(10) . '            var v = filehandle;' . chr(10) . '            var pkg;' . chr(10) . '            if (CORE.ref([v])) {' . chr(10) . '                // looks like a filehandle' . chr(10) . '                pkg = v;' . chr(10) . '            }' . chr(10) . '            else {' . chr(10) . '                // looks like a package name' . chr(10) . '                pkg = p5make_package(v);' . chr(10) . '                if (path == "-") {' . chr(10) . '                    if (flags == ' . chr(39) . '>' . chr(39) . ' || flags == ' . chr(39) . '>>' . chr(39) . ' || flags == ' . chr(39) . '+>' . chr(39) . ' || flags == ' . chr(39) . '+>>' . chr(39) . ') {' . chr(10) . '                        pkg.file_handle = p5pkg["STDOUT"].file_handle;' . chr(10) . '                    }' . chr(10) . '                    else {' . chr(10) . '                        pkg.file_handle = p5pkg["STDIN"].file_handle;' . chr(10) . '                    }' . chr(10) . '                }' . chr(10) . '            }' . chr(10) . '            if (!pkg.file_handle) {' . chr(10) . '                pkg.file_handle = {};' . chr(10) . '            }' . chr(10) . '            var handle_id = pkg.file_handle.id;' . chr(10) . '            if (handle_id != null) {' . chr(10) . '                if (handle_id < 2) {' . chr(10) . '                    return 1;   // STDIN, STDOUT, STDERR' . chr(10) . '                }' . chr(10) . '                p5pkg["Perlito5::IO"].close(filehandle, []);' . chr(10) . '            }' . chr(10) . '            if (flags == ' . chr(39) . '>' . chr(39) . ') {' . chr(10) . '                flags = ' . chr(39) . 'w' . chr(39) . chr(10) . '            }' . chr(10) . '            else if (flags == ' . chr(39) . '>>' . chr(39) . ') {' . chr(10) . '                flags = ' . chr(39) . 'a' . chr(39) . chr(10) . '            }' . chr(10) . '            else if (flags == ' . chr(39) . '<' . chr(39) . ' || flags == ' . chr(39) . chr(39) . ') {' . chr(10) . '                flags = ' . chr(39) . 'r' . chr(39) . chr(10) . '            }' . chr(10) . '            else if (flags == ' . chr(39) . '+>' . chr(39) . ') {' . chr(10) . '                flags = ' . chr(39) . 'w+' . chr(39) . chr(10) . '            }' . chr(10) . '            else if (flags == ' . chr(39) . '+>>' . chr(39) . ') {' . chr(10) . '                flags = ' . chr(39) . 'a+' . chr(39) . chr(10) . '            }' . chr(10) . '            else if (flags == ' . chr(39) . '+<' . chr(39) . ') {' . chr(10) . '                flags = ' . chr(39) . 'r+' . chr(39) . chr(10) . '            }' . chr(10) . '            else {' . chr(10) . '                CORE.die([ "don' . chr(39) . 't know what to do with MODE ' . chr(39) . '", flags, "' . chr(39) . '" ]);' . chr(10) . '            }' . chr(10) . '            var id = fs.openSync(path, flags);' . chr(10) . '            pkg.file_handle = { id : id, readline_buffer : ' . chr(39) . chr(39) . ' };' . chr(10) . '            return 1;' . chr(10) . '        }' . chr(10) . '        catch(err) {' . chr(10) . '            p5pkg["main"]["v_!"] = err;' . chr(10) . '            return ' . chr(39) . chr(39) . ';' . chr(10) . '        }' . chr(10) . '    };' . chr(10) . chr(10) . '    var p5atime = function(s) {' . chr(10) . '        try {' . chr(10) . '            var stat = fs.statSync(s); return stat["atime"];' . chr(10) . '        }' . chr(10) . '        catch(err) {' . chr(10) . '            return ' . chr(39) . chr(39) . ';' . chr(10) . '        }' . chr(10) . '    };' . chr(10) . '    var p5mtime = function(s) {' . chr(10) . '        try {' . chr(10) . '            var stat = fs.statSync(s); return stat["mtime"];' . chr(10) . '        }' . chr(10) . '        catch(err) {' . chr(10) . '            return ' . chr(39) . chr(39) . ';' . chr(10) . '        }' . chr(10) . '    };' . chr(10) . '    var p5ctime = function(s) {' . chr(10) . '        try {' . chr(10) . '            var stat = fs.statSync(s); return stat["ctime"];' . chr(10) . '        }' . chr(10) . '        catch(err) {' . chr(10) . '            return ' . chr(39) . chr(39) . ';' . chr(10) . '        }' . chr(10) . '    };' . chr(10) . '    var p5size = function(s) {' . chr(10) . '        try {' . chr(10) . '            var stat = fs.statSync(s); return stat["size"];' . chr(10) . '        }' . chr(10) . '        catch(err) {' . chr(10) . '            return ' . chr(39) . chr(39) . ';' . chr(10) . '        }' . chr(10) . '    };' . chr(10) . '    var p5is_file = function(s) {' . chr(10) . '        try {' . chr(10) . '            var stat = fs.statSync(s); return stat.isFile() ? 1 : 0;' . chr(10) . '        }' . chr(10) . '        catch(err) {' . chr(10) . '            return ' . chr(39) . chr(39) . ';' . chr(10) . '        }' . chr(10) . '    };' . chr(10) . '    var p5is_directory = function(s) {' . chr(10) . '        try {' . chr(10) . '            var stat = fs.statSync(s); return stat.isDirectory() ? 1 : 0;' . chr(10) . '        }' . chr(10) . '        catch(err) {' . chr(10) . '            return ' . chr(39) . chr(39) . ';' . chr(10) . '        }' . chr(10) . '    };' . chr(10) . '    var p5file_exists = function(s) {' . chr(10) . '        return p5is_file(s) || p5is_directory(s);' . chr(10) . '    };' . chr(10) . chr(10) . '    CORE.binmode = function(List__) {' . chr(10) . '        try {' . chr(10) . '            // TODO' . chr(10) . '            return 1;' . chr(10) . '        }' . chr(10) . '        catch(err) {' . chr(10) . '            p5pkg["main"]["v_!"] = err;' . chr(10) . '            return ' . chr(39) . chr(39) . ';' . chr(10) . '        }' . chr(10) . '    };' . chr(10) . chr(10) . '    CORE.rmdir = function(List__) {' . chr(10) . '        try {' . chr(10) . '            fs.rmdir(p5str(List__[0]));' . chr(10) . '            return 1;' . chr(10) . '        }' . chr(10) . '        catch(err) {' . chr(10) . '            p5pkg["main"]["v_!"] = err;' . chr(10) . '            return ' . chr(39) . chr(39) . ';' . chr(10) . '        }' . chr(10) . '    };' . chr(10) . chr(10) . '    CORE.chdir = function(List__) {' . chr(10) . '        try {' . chr(10) . '            process.chdir(p5str(List__[0]));' . chr(10) . '            return 1;' . chr(10) . '        }' . chr(10) . '        catch(err) {' . chr(10) . '            p5pkg["main"]["v_!"] = err;' . chr(10) . '            return ' . chr(39) . chr(39) . ';' . chr(10) . '        }' . chr(10) . '    };' . chr(10) . chr(10) . '    CORE.exit = function(List__) {' . chr(10) . '        process.exit(List__[0]);' . chr(10) . '    };' . chr(10) . chr(10) . '    CORE.rename = function(List__) {' . chr(10) . '        try {' . chr(10) . '            fs.renameSync(p5str(List__[0]), p5str(List__[1]));' . chr(10) . '            return 1;' . chr(10) . '        }' . chr(10) . '        catch(err) {' . chr(10) . '            p5pkg["main"]["v_!"] = err;' . chr(10) . '            return ' . chr(39) . chr(39) . ';' . chr(10) . '        }' . chr(10) . '    };' . chr(10) . chr(10) . '    CORE.unlink = function(List__) {' . chr(10) . '        var count = 0;' . chr(10) . '        try {' . chr(10) . '            for(var i = 0; i < List__.length; i++) {' . chr(10) . '                fs.unlinkSync(p5str(List__[i]));' . chr(10) . '                count++;' . chr(10) . '            }' . chr(10) . '            return count;' . chr(10) . '        }' . chr(10) . '        catch(err) {' . chr(10) . '            p5pkg["main"]["v_!"] = err;' . chr(10) . '            return count;' . chr(10) . '        }' . chr(10) . '    };' . chr(10) . chr(10) . '} else {' . chr(10) . '    // not running in node.js' . chr(10) . '    p5typeglob_set("Perlito5::IO", "print", function (filehandle, List__, p5want) {' . chr(10) . '        var i;' . chr(10) . '        for (var i = 0; i < List__.length; i++) {' . chr(10) . '            write(p5str(List__[i]));' . chr(10) . '        }' . chr(10) . '        return 1;' . chr(10) . '    });' . chr(10) . '}' . chr(10) . chr(10) . 'p5typeglob_set("Perlito5::IO", "say", function (filehandle, List__, p5want) {' . chr(10) . '    p5pkg[' . chr(39) . 'Perlito5::IO' . chr(39) . '].print( filehandle, List__);' . chr(10) . '    p5pkg[' . chr(39) . 'Perlito5::IO' . chr(39) . '].print( filehandle, ["' . chr(92) . 'n"]);' . chr(10) . '    return 1;' . chr(10) . '} );' . chr(10) . 'p5typeglob_set("Perlito5::IO", "printf", function (filehandle, List__, p5want) {' . chr(10) . '    p5pkg["Perlito5::IO"].print( filehandle, CORE.sprintf(List__));' . chr(10) . '    return 1;' . chr(10) . '} );' . chr(10) . chr(10) . 'CORE.select = function(List__) {' . chr(10) . '    if (List__.length == 1) {' . chr(10) . '        var v = List__[0];' . chr(10) . '        p5pkg["Perlito5"].v_SELECT = v;' . chr(10) . '    }' . chr(10) . '    return p5pkg["Perlito5"].v_SELECT;' . chr(10) . '};' . chr(10) . chr(10) . 'CORE.die = function(List__) {' . chr(10) . '    var i;' . chr(10) . '    var s = "";' . chr(10) . '    for (var i = 0; i < List__.length; i++) {' . chr(10) . '        s = s + p5str(List__[i]);' . chr(10) . '    }' . chr(10) . '    if (s.substr(-1, 1) != "' . chr(92) . 'n") {' . chr(10) . '        try {' . chr(10) . '            if (s == "") {' . chr(10) . '                s = "Died";' . chr(10) . '            }' . chr(10) . '            s = s + " at " + p5pkg["Perlito5"].v_FILE_NAME + " line " + p5pkg["Perlito5"].v_LINE_NUMBER;' . chr(10) . '            s = s + "' . chr(92) . 'n" + new Error().stack + "' . chr(92) . 'n";' . chr(10) . '        }' . chr(10) . '        catch(err) { }' . chr(10) . '    }' . chr(10) . '    p5pkg["main"]["v_@"] = s;' . chr(10) . '    throw(new p5_error("die", s));' . chr(10) . '};' . chr(10) . chr(10) . 'CORE.say = function(List__) {' . chr(10) . '    return p5pkg[' . chr(39) . 'Perlito5::IO' . chr(39) . '].say( ' . chr(39) . 'STDOUT' . chr(39) . ', List__);' . chr(10) . '};' . chr(10) . 'CORE.print = function(List__) {' . chr(10) . '    return p5pkg[' . chr(39) . 'Perlito5::IO' . chr(39) . '].print( ' . chr(39) . 'STDOUT' . chr(39) . ', List__);' . chr(10) . '};' . chr(10) . 'CORE.printf = function(List__) {' . chr(10) . '    return p5pkg[' . chr(39) . 'Perlito5::IO' . chr(39) . '].printf( ' . chr(39) . 'STDOUT' . chr(39) . ', List__);' . chr(10) . '};' . chr(10) . 'CORE.readline = function(List__, p5want) {' . chr(10) . '    return p5pkg[' . chr(39) . 'Perlito5::IO' . chr(39) . '].readline(List__, p5want);' . chr(10) . '};' . chr(10) . chr(10) . 'CORE.warn = function(List__) {' . chr(10) . '    var i;' . chr(10) . '    var s = "";' . chr(10) . '    for (var i = 0; i < List__.length; i++) {' . chr(10) . '        s = s + p5str(List__[i]);' . chr(10) . '    }' . chr(10) . '    if (s.substr(-1, 1) != "' . chr(92) . 'n") {' . chr(10) . '        try {' . chr(10) . '            if (s == "") {' . chr(10) . '                s = "Warning: something' . chr(39) . 's wrong";' . chr(10) . '            }' . chr(10) . '            s = s + " at " + p5pkg["Perlito5"].v_FILE_NAME + " line " + p5pkg["Perlito5"].v_LINE_NUMBER;' . chr(10) . '            s = s + "' . chr(92) . 'n" + new Error().stack + "' . chr(92) . 'n";' . chr(10) . '        }' . chr(10) . '        catch(err) { }' . chr(10) . '    }' . chr(10) . '    p5pkg[' . chr(39) . 'Perlito5::IO' . chr(39) . '].print( ' . chr(39) . 'STDERR' . chr(39) . ', [s]);' . chr(10) . '};' . chr(10) . chr(10) . chr(10)
}
1;
# use Perlito5::Javascript2::IO
package main;
undef();
package Perlito5::Javascript2::Sprintf;
sub Perlito5::Javascript2::Sprintf::emit_javascript2 {
    return '/**' . chr(10) . ' * Copyright (c) 2010 Jakob Westhoff' . chr(10) . ' *' . chr(10) . ' * Permission is hereby granted, free of charge, to any person obtaining a copy' . chr(10) . ' * of this software and associated documentation files (the "Software"), to deal' . chr(10) . ' * in the Software without restriction, including without limitation the rights' . chr(10) . ' * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell' . chr(10) . ' * copies of the Software, and to permit persons to whom the Software is' . chr(10) . ' * furnished to do so, subject to the following conditions:' . chr(10) . ' * ' . chr(10) . ' * The above copyright notice and this permission notice shall be included in' . chr(10) . ' * all copies or substantial portions of the Software.' . chr(10) . ' * ' . chr(10) . ' * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR' . chr(10) . ' * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,' . chr(10) . ' * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE' . chr(10) . ' * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER' . chr(10) . ' * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,' . chr(10) . ' * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN' . chr(10) . ' * THE SOFTWARE.' . chr(10) . ' */' . chr(10) . chr(10) . 'CORE.sprintf = function(List__) {' . chr(10) . '    var format = List__.shift();' . chr(10) . '    var list = List__;' . chr(10) . chr(10) . '    // Check for format definition' . chr(10) . '    if ( typeof format != ' . chr(39) . 'string' . chr(39) . ' ) {' . chr(10) . '        CORE.die(["sprintf: The first arguments need to be a valid format string."]);' . chr(10) . '    }' . chr(10) . '    ' . chr(10) . '    /**' . chr(10) . '     * Define the regex to match a formating string' . chr(10) . '     * The regex consists of the following parts:' . chr(10) . '     * percent sign to indicate the start' . chr(10) . '     * (optional) sign specifier' . chr(10) . '     * (optional) padding specifier' . chr(10) . '     * (optional) alignment specifier' . chr(10) . '     * (optional) width specifier' . chr(10) . '     * (optional) precision specifier' . chr(10) . '     * type specifier:' . chr(10) . '     *  % - literal percent sign' . chr(10) . '     *  b - binary number' . chr(10) . '     *  c - ASCII character represented by the given value' . chr(10) . '     *  d - signed decimal number' . chr(10) . '     *  f - floating point value' . chr(10) . '     *  o - octal number' . chr(10) . '     *  s - string' . chr(10) . '     *  x - hexadecimal number (lowercase characters)' . chr(10) . '     *  X - hexadecimal number (uppercase characters)' . chr(10) . '     */' . chr(10) . '    var r = new RegExp( /%(' . chr(92) . '+)?([0 ]|' . chr(39) . '(.))?(-)?([0-9]+)?(' . chr(92) . '.([0-9]+))?([%bcdfosxX])/g );' . chr(10) . chr(10) . '    /**' . chr(10) . '     * Each format string is splitted into the following parts:' . chr(10) . '     * 0: Full format string' . chr(10) . '     * 1: sign specifier (+)' . chr(10) . '     * 2: padding specifier (0/<space>/' . chr(39) . '<any char>)' . chr(10) . '     * 3: if the padding character starts with a ' . chr(39) . ' this will be the real ' . chr(10) . '     *    padding character' . chr(10) . '     * 4: alignment specifier' . chr(10) . '     * 5: width specifier' . chr(10) . '     * 6: precision specifier including the dot' . chr(10) . '     * 7: precision specifier without the dot' . chr(10) . '     * 8: type specifier' . chr(10) . '     */' . chr(10) . '    var parts      = [];' . chr(10) . '    var paramIndex = 0;' . chr(10) . '    var part;' . chr(10) . '    while ( part = r.exec( format ) ) {' . chr(10) . '        // Check if an input value has been provided, for the current' . chr(10) . '        // format string' . chr(10) . '        if ( paramIndex >= list.length ) {' . chr(10) . '            CORE.die(["sprintf: At least one argument was missing."]);' . chr(10) . '        }' . chr(10) . chr(10) . '        parts[parts.length] = {' . chr(10) . '            /* beginning of the part in the string */' . chr(10) . '            begin: part.index,' . chr(10) . '            /* end of the part in the string */' . chr(10) . '            end: part.index + part[0].length,' . chr(10) . '            /* force sign */' . chr(10) . '            sign: ( part[1] == ' . chr(39) . '+' . chr(39) . ' ),' . chr(10) . '            /* is the given data negative */' . chr(10) . '            negative: ( parseInt( list[paramIndex] ) < 0 ) ? true : false,' . chr(10) . '            /* padding character (default: <space>) */' . chr(10) . '            padding: ( part[2] == undefined )' . chr(10) . '                     ? ( ' . chr(39) . ' ' . chr(39) . ' ) /* default */' . chr(10) . '                     : ( ( part[2].substring( 0, 1 ) == "' . chr(39) . '" ) ' . chr(10) . '                         ? ( part[3] ) /* use special char */' . chr(10) . '                         : ( part[2] ) /* use normal <space> or zero */' . chr(10) . '                       ),' . chr(10) . '            /* should the output be aligned left?*/' . chr(10) . '            alignLeft: ( part[4] == ' . chr(39) . '-' . chr(39) . ' ),' . chr(10) . '            /* width specifier (number or false) */' . chr(10) . '            width: ( part[5] != undefined ) ? part[5] : false,' . chr(10) . '            /* precision specifier (number or false) */' . chr(10) . '            precision: ( part[7] != undefined ) ? part[7] : false,' . chr(10) . '            /* type specifier */' . chr(10) . '            type: part[8],' . chr(10) . '            /* the given data associated with this part converted to a string */' . chr(10) . '            data: ( part[8] != ' . chr(39) . '%' . chr(39) . ' ) ? String ( list[paramIndex++] ) : false' . chr(10) . '        };' . chr(10) . '    }' . chr(10) . chr(10) . '    var newString = "";' . chr(10) . '    var start = 0;' . chr(10) . '    // Generate our new formated string' . chr(10) . '    for( var i=0; i<parts.length; ++i ) {' . chr(10) . '        // Add first unformated string part' . chr(10) . '        newString += format.substring( start, parts[i].begin );' . chr(10) . '        ' . chr(10) . '        // Mark the new string start' . chr(10) . '        start = parts[i].end;' . chr(10) . chr(10) . '        // Create the appropriate preformat substitution' . chr(10) . '        // This substitution is only the correct type conversion. All the' . chr(10) . '        // different options and flags haven' . chr(39) . 't been applied to it at this' . chr(10) . '        // point' . chr(10) . '        var preSubstitution = "";' . chr(10) . '        switch ( parts[i].type ) {' . chr(10) . '            case ' . chr(39) . '%' . chr(39) . ':' . chr(10) . '                preSubstitution = "%";' . chr(10) . '            break;' . chr(10) . '            case ' . chr(39) . 'b' . chr(39) . ':' . chr(10) . '                preSubstitution = Math.abs( parseInt( parts[i].data ) ).toString( 2 );' . chr(10) . '            break;' . chr(10) . '            case ' . chr(39) . 'c' . chr(39) . ':' . chr(10) . '                preSubstitution = String.fromCharCode( Math.abs( parseInt( parts[i].data ) ) );' . chr(10) . '            break;' . chr(10) . '            case ' . chr(39) . 'd' . chr(39) . ':' . chr(10) . '                preSubstitution = String( Math.abs( parseInt( parts[i].data ) ) );' . chr(10) . '            break;' . chr(10) . '            case ' . chr(39) . 'f' . chr(39) . ':' . chr(10) . '                preSubstitution = ( parts[i].precision == false )' . chr(10) . '                                  ? ( String( ( Math.abs( parseFloat( parts[i].data ) ) ) ) )' . chr(10) . '                                  : ( Math.abs( parseFloat( parts[i].data ) ).toFixed( parts[i].precision ) );' . chr(10) . '            break;' . chr(10) . '            case ' . chr(39) . 'o' . chr(39) . ':' . chr(10) . '                preSubstitution = Math.abs( parseInt( parts[i].data ) ).toString( 8 );' . chr(10) . '            break;' . chr(10) . '            case ' . chr(39) . 's' . chr(39) . ':' . chr(10) . '                preSubstitution = parts[i].data.substring( 0, parts[i].precision ? parts[i].precision : parts[i].data.length ); /* Cut if precision is defined */' . chr(10) . '            break;' . chr(10) . '            case ' . chr(39) . 'x' . chr(39) . ':' . chr(10) . '                preSubstitution = Math.abs( parseInt( parts[i].data ) ).toString( 16 ).toLowerCase();' . chr(10) . '            break;' . chr(10) . '            case ' . chr(39) . 'X' . chr(39) . ':' . chr(10) . '                preSubstitution = Math.abs( parseInt( parts[i].data ) ).toString( 16 ).toUpperCase();' . chr(10) . '            break;' . chr(10) . '            default:' . chr(10) . '                throw ' . chr(39) . 'sprintf: Unknown type "' . chr(39) . ' + parts[i].type + ' . chr(39) . '" detected. This should never happen. Maybe the regex is wrong.' . chr(39) . ';' . chr(10) . '        }' . chr(10) . chr(10) . '        // The % character is a special type and does not need further processing' . chr(10) . '        if ( parts[i].type ==  "%" ) {' . chr(10) . '            newString += preSubstitution;' . chr(10) . '            continue;' . chr(10) . '        }' . chr(10) . chr(10) . '        // Modify the preSubstitution by taking sign, padding and width' . chr(10) . '        // into account' . chr(10) . chr(10) . '        // Pad the string based on the given width' . chr(10) . '        if ( parts[i].width != false ) {' . chr(10) . '            // Padding needed?' . chr(10) . '            if ( parts[i].width > preSubstitution.length ) ' . chr(10) . '            {' . chr(10) . '                var origLength = preSubstitution.length;' . chr(10) . '                for( var j = 0; j < parts[i].width - origLength; ++j ) ' . chr(10) . '                {' . chr(10) . '                    preSubstitution = ( parts[i].alignLeft == true ) ' . chr(10) . '                                      ? ( preSubstitution + parts[i].padding )' . chr(10) . '                                      : ( parts[i].padding + preSubstitution );' . chr(10) . '                }' . chr(10) . '            }' . chr(10) . '        }' . chr(10) . chr(10) . '        // Add a sign symbol if neccessary or enforced, but only if we are' . chr(10) . '        // not handling a string' . chr(10) . '        if ( parts[i].type == ' . chr(39) . 'b' . chr(39) . ' ' . chr(10) . '          || parts[i].type == ' . chr(39) . 'd' . chr(39) . ' ' . chr(10) . '          || parts[i].type == ' . chr(39) . 'o' . chr(39) . ' ' . chr(10) . '          || parts[i].type == ' . chr(39) . 'f' . chr(39) . ' ' . chr(10) . '          || parts[i].type == ' . chr(39) . 'x' . chr(39) . ' ' . chr(10) . '          || parts[i].type == ' . chr(39) . 'X' . chr(39) . ' ) {' . chr(10) . '            if ( parts[i].negative == true ) {' . chr(10) . '                preSubstitution = "-" + preSubstitution;' . chr(10) . '            }' . chr(10) . '            else if ( parts[i].sign == true ) {' . chr(10) . '                preSubstitution = "+" + preSubstitution;' . chr(10) . '            }' . chr(10) . '        }' . chr(10) . chr(10) . '        // Add the substitution to the new string' . chr(10) . '        newString += preSubstitution;' . chr(10) . '    }' . chr(10) . chr(10) . '    // Add the last part of the given format string, which may still be there' . chr(10) . '    newString += format.substring( start, format.length );' . chr(10) . chr(10) . '    return newString;' . chr(10) . '};' . chr(10) . chr(10)
}
1;
# use Perlito5::Javascript2::Sprintf
package main;
undef();
# use Perlito5::AST
# use Perlito5::Dumper
# use feature
package Perlito5::Javascript3;
{
    my %label;
    sub Perlito5::Javascript3::pkg {
        'p5pkg["' . $Perlito5::PKG_NAME . '"]'
    }
    sub Perlito5::Javascript3::pkg_new_var {
        $label{$Perlito5::PKG_NAME} = 'p5' . $Perlito5::ID++
    }
    sub Perlito5::Javascript3::get_label {
        $Perlito5::ID++
    }
    sub Perlito5::Javascript3::tab {
        my $level = shift;
        chr(9) x $level
    }
    our %op_prefix_js_str = ('prefix:<-A>' => 'p5atime', 'prefix:<-C>' => 'p5ctime', 'prefix:<-M>' => 'p5mtime', 'prefix:<-d>' => 'p5is_directory', 'prefix:<-e>' => 'p5file_exists', 'prefix:<-f>' => 'p5is_file', 'prefix:<-s>' => 'p5size');
    our %op_infix_js_str = ('infix:<eq>' => ' == ', 'infix:<ne>' => ' != ', 'infix:<le>' => ' <= ', 'infix:<ge>' => ' >= ', 'infix:<lt>' => ' < ', 'infix:<gt>' => ' > ');
    our %op_infix_js_num = ('infix:<==>' => ' == ', 'infix:<!=>' => ' != ', 'infix:<+>' => ' + ', 'infix:<->' => ' - ', 'infix:<*>' => ' * ', 'infix:</>' => ' / ', 'infix:<%>' => ' % ', 'infix:<>>' => ' > ', 'infix:<<>' => ' < ', 'infix:<>=>' => ' >= ', 'infix:<<=>' => ' <= ', 'infix:<&>' => ' & ', 'infix:<|>' => ' | ', 'infix:<^>' => ' ^ ', 'infix:<>>>' => ' >>> ', 'infix:<<<>' => ' << ');
    our %op_to_bool = map(+($_ => 1), 'prefix:<!>', 'infix:<!=>', 'infix:<==>', 'infix:<<=>', 'infix:<>=>', 'infix:<>>', 'infix:<<>', 'infix:<eq>', 'infix:<ne>', 'infix:<ge>', 'infix:<le>', 'infix:<gt>', 'infix:<lt>', 'prefix:<not>', 'exists', 'defined');
    our %op_to_str = map(+($_ => 1), 'substr', 'join', 'list:<.>', 'chr');
    our %op_to_num = map(+($_ => 1), 'length', 'index', 'ord', 'oct', 'infix:<->', 'infix:<+>', 'infix:<*>', 'infix:</>', 'infix:<%>', 'infix:<**>');
    my %safe_char = (' ' => 1, '!' => 1, '"' => 1, '#' => 1, '$' => 1, '%' => 1, '&' => 1, '(' => 1, ')' => 1, '*' => 1, '+' => 1, ',' => 1, '-' => 1, '.' => 1, '/' => 1, ':' => 1, ';' => 1, '<' => 1, '=' => 1, '>' => 1, '?' => 1, '@' => 1, '[' => 1, ']' => 1, '^' => 1, '_' => 1, '`' => 1, '{' => 1, '|' => 1, '}' => 1, '~' => 1);
    sub Perlito5::Javascript3::escape_string {
        my $s = shift;
        my @out;
        my $tmp = '';
        $s eq '' && return chr(39) . chr(39);
        for my $i (0 .. length($s) - 1) {
            my $c = substr($s, $i, 1);
            if (($c ge 'a' && $c le 'z') || ($c ge 'A' && $c le 'Z') || ($c ge 0 && $c le 9) || exists($safe_char{$c})) {
                $tmp = $tmp . $c
            }
            else {
                $tmp ne '' && push(@out, chr(39) . $tmp . chr(39));
                push(@out, 'String.fromCharCode(' . ord($c) . ')');
                $tmp = ''
            }
        }
        $tmp ne '' && push(@out, chr(39) . $tmp . chr(39));
        return join(' + ', @out)
    }
    sub Perlito5::Javascript3::to_str {
        my $cond = shift;
        my $level = shift;
        my $wantarray = 'scalar';
        if ($cond->isa('Perlito5::AST::Apply') && $cond->code() eq 'circumfix:<( )>' && $cond->{'arguments'} && @{$cond->{'arguments'}}) {
            return to_str($cond->{'arguments'}->[0], $level)
        }
        if (($cond->isa('Perlito5::AST::Buf')) || ($cond->isa('Perlito5::AST::Apply') && exists($op_to_str{$cond->code()}))) {
            return $cond->emit_javascript3($level, $wantarray)
        }
        else {
            return 'p5str(' . $cond->emit_javascript3($level, $wantarray) . ')'
        }
    }
    sub Perlito5::Javascript3::to_num {
        my $cond = shift;
        my $level = shift;
        my $wantarray = 'scalar';
        if ($cond->isa('Perlito5::AST::Int') || $cond->isa('Perlito5::AST::Num') || ($cond->isa('Perlito5::AST::Apply') && exists($op_to_num{$cond->code()}))) {
            return $cond->emit_javascript3($level, $wantarray)
        }
        else {
            return 'p5num(' . $cond->emit_javascript3($level, $wantarray) . ')'
        }
    }
    sub Perlito5::Javascript3::to_bool {
        my $cond = shift;
        my $level = shift;
        my $wantarray = 'scalar';
        if ($cond->isa('Perlito5::AST::Apply') && $cond->code() eq 'circumfix:<( )>' && $cond->{'arguments'} && @{$cond->{'arguments'}}) {
            return to_bool($cond->{'arguments'}->[0], $level)
        }
        if ($cond->isa('Perlito5::AST::Apply') && ($cond->code() eq 'infix:<&&>' || $cond->code() eq 'infix:<and>')) {
            return '(' . to_bool($cond->{'arguments'}->[0], $level) . ' && ' . to_bool($cond->{'arguments'}->[1], $level) . ')'
        }
        if ($cond->isa('Perlito5::AST::Apply') && ($cond->code() eq 'infix:<||>' || $cond->code() eq 'infix:<or>')) {
            return '(' . to_bool($cond->{'arguments'}->[0], $level) . ' || ' . to_bool($cond->{'arguments'}->[1], $level) . ')'
        }
        if (($cond->isa('Perlito5::AST::Int')) || ($cond->isa('Perlito5::AST::Num')) || ($cond->isa('Perlito5::AST::Apply') && exists($op_to_bool{$cond->code()}))) {
            return $cond->emit_javascript3($level, $wantarray)
        }
        else {
            return 'p5bool(' . $cond->emit_javascript3($level, $wantarray) . ')'
        }
    }
    sub Perlito5::Javascript3::is_scalar {
        !$_[0]->isa('Perlito5::AST::Int') && !$_[0]->isa('Perlito5::AST::Num') && !$_[0]->isa('Perlito5::AST::Buf') && !$_[0]->isa('Perlito5::AST::Sub') && !($_[0]->isa('Perlito5::AST::Var') && $_[0]->{'sigil'} eq '$') && !($_[0]->isa('Perlito5::AST::Apply') && (exists($op_to_str{$_[0]->{'code'}}) || exists($op_to_num{$_[0]->{'code'}}) || exists($op_to_bool{$_[0]->{'code'}}) || $_[0]->{'code'} eq 'prefix:<' . chr(92) . '>'))
    }
    sub Perlito5::Javascript3::to_value {
        my $v = shift;
        my $level = shift;
        my $wantarray = shift;
        return !$v ? 'null' : $v->isa('Perlito5::AST::Var') && $v->sigil() eq '$' ? $v->emit_javascript3($level, $wantarray) . '.FETCH()' : $v->emit_javascript3($level, $wantarray)
    }
    sub Perlito5::Javascript3::to_list {
        my $items = to_list_preprocess($_[0]);
        my $level = $_[1];
        my $literal_type = $_[2] || 'array';
        my $wantarray = 'list';
        my $interpolate = 0;
        for $_ (@{$items}) {
            is_scalar($_) && ($interpolate = 1)
        }
        if ($literal_type eq 'hash') {
            if (!$interpolate) {
                my @out;
                my $printable = 1;
                my @in = @{$items};
                while (@in) {
                    my $k = shift(@in);
                    my $v = shift(@in);
                    $k = $k->emit_javascript3($level, 0);
                    $k =~ m![ \[]! && ($printable = 0);
                    $v = to_value($v, $level, $wantarray);
                    push(@out, $k . ' : ' . $v)
                }
                $printable && return '{' . join(', ', @out) . '}'
            }
            return 'p5a_to_h(' . to_list($items, $level, 'array') . ')'
        }
        $interpolate ? ('p5list_to_a(' . join(', ', map($_->emit_javascript3($level, $wantarray), @{$items})) . ')') : ('[' . join(', ', map(to_value($_, $level, $wantarray), @{$items})) . ']')
    }
    sub Perlito5::Javascript3::to_list_preprocess {
        my @items;
        for my $item (@{$_[0]}) {
            if ($item->isa('Perlito5::AST::Apply') && ($item->code() eq 'circumfix:<( )>' || $item->code() eq 'list:<,>' || $item->code() eq 'infix:<=>>')) {
                if ($item->isa('Perlito5::AST::Apply') && $item->code() eq 'infix:<=>>') {
                    $item->{'arguments'}->[0] = Perlito5::AST::Lookup::->autoquote($item->{'arguments'}->[0])
                }
                for my $arg (@{to_list_preprocess($item->arguments())}) {
                    push(@items, $arg)
                }
            }
            else {
                push(@items, $item)
            }
        }
        return \@items
    }
    sub Perlito5::Javascript3::to_scalar {
        my $items = to_scalar_preprocess($_[0]);
        my $level = $_[1];
        my $wantarray = 'scalar';
        @{$items} ? '(' . join(', ', map($_->emit_javascript3($level, $wantarray), @{$items})) . ')' : 'null'
    }
    sub Perlito5::Javascript3::to_scalar_preprocess {
        my @items;
        for my $item (@{$_[0]}) {
            if ($item->isa('Perlito5::AST::Apply') && ($item->code() eq 'list:<,>' || $item->code() eq 'infix:<=>>')) {
                if ($item->isa('Perlito5::AST::Apply') && $item->code() eq 'infix:<=>>') {
                    $item->{'arguments'}->[0] = Perlito5::AST::Lookup::->autoquote($item->{'arguments'}->[0])
                }
                for my $arg (@{to_scalar_preprocess($item->arguments())}) {
                    push(@items, $arg)
                }
            }
            else {
                push(@items, $item)
            }
        }
        return \@items
    }
    sub Perlito5::Javascript3::to_runtime_context {
        my $items = to_scalar_preprocess($_[0]);
        my $level = $_[1];
        my $wantarray = 'runtime';
        @{$items} == 1 && is_scalar($items->[0]) && return $items->[0]->emit_javascript3($level, $wantarray);
        'p5context(' . '[' . join(', ', map($_->emit_javascript3($level, $wantarray), @{$items})) . ']' . ', p5want)'
    }
    sub Perlito5::Javascript3::autoquote {
        my $index = shift;
        my $level = shift;
        if ($index->isa('Perlito5::AST::Apply') && $index->{'bareword'}) {
            my $full_name = ($index->{'namespace'} ? $index->{'namespace'} . '::' : '') . $index->{'code'};
            if (!exists($Perlito5::PROTO->{$full_name})) {
                $index = Perlito5::AST::Buf::->new('buf' => $full_name)
            }
        }
        return to_str($index, $level)
    }
    sub Perlito5::Javascript3::emit_javascript3_autovivify {
        my $obj = shift;
        my $level = shift;
        my $type = shift;
        my $wantarray = 'scalar';
        return $obj->emit_javascript3($level, $wantarray, $type)
    }
    sub Perlito5::Javascript3::emit_function_javascript3 {
        my $level = shift;
        my $wantarray = shift;
        my $argument = shift;
        if ($argument->isa('Perlito5::AST::Apply') && $argument->code() eq 'return') {
            return 'function () { ' . $argument->emit_javascript3($level, $wantarray) . ' }'
        }
        return 'function () { return ' . $argument->emit_javascript3($level, $wantarray) . ' }'
    }
}
package Perlito5::Javascript3::LexicalBlock;
{
    sub Perlito5::Javascript3::LexicalBlock::new {
        my $class = shift;
        bless({@_}, $class)
    }
    sub Perlito5::Javascript3::LexicalBlock::block {
        $_[0]->{'block'}
    }
    sub Perlito5::Javascript3::LexicalBlock::needs_return {
        $_[0]->{'needs_return'}
    }
    sub Perlito5::Javascript3::LexicalBlock::top_level {
        $_[0]->{'top_level'}
    }
    sub Perlito5::Javascript3::LexicalBlock::has_decl {
        my $self = $_[0];
        my $type = $_[1];
        for my $decl (@{$self->{'block'}}) {
            if (defined($decl)) {
                if ($decl->isa('Perlito5::AST::Decl') && $decl->decl() eq $type || $decl->isa('Perlito5::AST::Apply') && $decl->code() eq $type) {
                    return 1
                }
                if ($decl->isa('Perlito5::AST::Apply') && $decl->code() eq 'infix:<=>') {
                    my $var = $decl->arguments()->[0];
                    if ($var->isa('Perlito5::AST::Decl') && $var->decl() eq $type || $decl->isa('Perlito5::AST::Apply') && $decl->code() eq $type) {
                        return 1
                    }
                }
            }
        }
        return 0
    }
    sub Perlito5::Javascript3::LexicalBlock::emit_javascript3 {
        my $self = shift;
        my $level = shift;
        my $wantarray = shift;
        my @block;
        for $_ (@{$self->{'block'}}) {
            if (defined($_)) {
                push(@block, $_)
            }
        }
        if (!@block) {
            return Perlito5::Javascript3::tab($level) . 'null;'
        }
        my $out = '';
        my @str;
        my $has_local = $self->has_decl('local');
        my $create_context = $self->{'create_context'} && $self->has_decl('my');
        my $outer_pkg = $Perlito5::PKG_NAME;
        my $outer_throw = $Perlito5::THROW;
        $self->{'top_level'} && ($Perlito5::THROW = 0);
        $has_local && ($out .= Perlito5::Javascript3::tab($level) . 'var local_idx = p5LOCAL.length;' . chr(10));
        if ($self->{'top_level'}) {
            $level++
        }
        if ($create_context) {
            $out .= Perlito5::Javascript3::tab($level) . '(function () {' . chr(10);
            $level++
        }
        my $tab = Perlito5::Javascript3::tab($level);
        my $last_statement;
        if ($self->{'needs_return'}) {
            $last_statement = pop(@block)
        }
        for my $decl (@block) {
            if (ref($decl) eq 'Perlito5::AST::Apply' && $decl->code() eq 'package') {
                $Perlito5::PKG_NAME = $decl->{'namespace'}
            }
            if ($decl->isa('Perlito5::AST::Decl')) {
                push(@str, $decl->emit_javascript3_init())
            }
            if ($decl->isa('Perlito5::AST::Apply') && $decl->code() eq 'my') {
                for $_ (@{$decl->{'arguments'}}) {
                    if ($_->isa('Perlito5::AST::Var')) {
                        my $d = Perlito5::AST::Decl::->new('decl' => $decl->code(), 'var' => $_);
                        push(@str, $d->emit_javascript3_init())
                    }
                }
            }
            if ($decl->isa('Perlito5::AST::Apply') && $decl->code() eq 'infix:<=>') {
                my $arg = $decl->{'arguments'}->[0];
                if ($arg->isa('Perlito5::AST::Decl')) {
                    push(@str, $arg->emit_javascript3_init())
                }
                if ($arg->isa('Perlito5::AST::Apply') && $arg->code() eq 'my') {
                    for $_ (@{$arg->{'arguments'}}) {
                        if ($_->isa('Perlito5::AST::Var')) {
                            my $d = Perlito5::AST::Decl::->new('decl' => $arg->code(), 'var' => $_);
                            push(@str, $d->emit_javascript3_init())
                        }
                    }
                }
            }
            if (!($decl->isa('Perlito5::AST::Decl') && $decl->decl() eq 'my')) {
                push(@str, $decl->emit_javascript3($level, 'void') . ';')
            }
        }
        if ($self->{'needs_return'} && $last_statement) {
            if ($last_statement->isa('Perlito5::AST::Decl')) {
                push(@str, $last_statement->emit_javascript3_init())
            }
            if ($last_statement->isa('Perlito5::AST::Apply') && $last_statement->code() eq 'infix:<=>') {
                if ($last_statement->{'arguments'}->[0]->isa('Perlito5::AST::Decl')) {
                    push(@str, $last_statement->{'arguments'}->[0]->emit_javascript3_init())
                }
            }
            if ($last_statement->isa('Perlito5::AST::Apply') && $last_statement->code() eq 'return' && $self->{'top_level'} && @{$last_statement->{'arguments'}}) {
                $last_statement = $last_statement->{'arguments'}->[0]
            }
            if ($last_statement->isa('Perlito5::AST::If')) {
                my $cond = $last_statement->cond();
                my $body = $last_statement->body();
                my $otherwise = $last_statement->otherwise();
                $body = Perlito5::Javascript3::LexicalBlock::->new('block' => $body->stmts(), 'needs_return' => 1);
                push(@str, 'if ( ' . Perlito5::Javascript3::to_bool($cond, $level + 1) . ' ) {' . chr(10) . $body->emit_javascript3($level + 1) . chr(10) . Perlito5::Javascript3::tab($level) . '}');
                if ($otherwise) {
                    $otherwise = Perlito5::Javascript3::LexicalBlock::->new('block' => $otherwise->stmts(), 'needs_return' => 1);
                    push(@str, chr(10) . Perlito5::Javascript3::tab($level) . 'else {' . chr(10) . $otherwise->emit_javascript3($level + 1) . chr(10) . Perlito5::Javascript3::tab($level) . '}')
                }
            }
            elsif ($last_statement->isa('Perlito5::AST::Block')) {
                my $body = Perlito5::Javascript3::LexicalBlock::->new('block' => $last_statement->{'stmts'}, 'needs_return' => 1);
                push(@str, 'for (var i_ = 0; i_ < 1 ; i_++) {' . chr(10) . $body->emit_javascript3($level + 1) . chr(10) . Perlito5::Javascript3::tab($level) . '}')
            }
            elsif ($last_statement->isa('Perlito5::AST::For') || $last_statement->isa('Perlito5::AST::While') || $last_statement->isa('Perlito5::AST::Apply') && $last_statement->code() eq 'goto' || $last_statement->isa('Perlito5::AST::Apply') && $last_statement->code() eq 'return') {
                push(@str, $last_statement->emit_javascript3($level, 'runtime'))
            }
            elsif ($has_local) {
                push(@str, 'return p5cleanup_local(local_idx, (' . Perlito5::Javascript3::to_runtime_context([$last_statement], $level) . '));')
            }
            else {
                push(@str, 'return (' . Perlito5::Javascript3::to_runtime_context([$last_statement], $level) . ');')
            }
        }
        if ($has_local) {
            push(@str, 'p5cleanup_local(local_idx, null);')
        }
        if ($create_context) {
            $level--;
            push(@str, '})();')
        }
        if ($self->{'top_level'} && $Perlito5::THROW) {
            $level--;
            $out .= Perlito5::Javascript3::tab($level) . 'try {' . chr(10) . join(chr(10), map($tab . $_, @str)) . chr(10) . Perlito5::Javascript3::tab($level) . '}' . chr(10) . Perlito5::Javascript3::tab($level) . 'catch(err) {' . chr(10) . Perlito5::Javascript3::tab($level + 1) . 'if ( err instanceof Error ) {' . chr(10) . Perlito5::Javascript3::tab($level + 2) . 'throw(err);' . chr(10) . Perlito5::Javascript3::tab($level + 1) . '}' . chr(10) . Perlito5::Javascript3::tab($level + 1) . 'else {' . chr(10) . Perlito5::Javascript3::tab($level + 2) . ($has_local ? 'return p5cleanup_local(local_idx, err)' : 'return(err)') . ';' . chr(10) . Perlito5::Javascript3::tab($level + 1) . '}' . chr(10) . Perlito5::Javascript3::tab($level) . '}'
        }
        else {
            $out .= join(chr(10), map($tab . $_, @str))
        }
        $Perlito5::PKG_NAME = $outer_pkg;
        $self->{'top_level'} && ($Perlito5::THROW = $outer_throw);
        return $out
    }
}
package Perlito5::AST::CompUnit;
{
    sub Perlito5::AST::CompUnit::emit_javascript3 {
        my $self = $_[0];
        my $level = $_[1];
        my $str = '(function () {' . chr(10) . Perlito5::Javascript3::LexicalBlock::->new('block' => $self->{'body'}, 'needs_return' => 0)->emit_javascript3($level + 1) . chr(10) . Perlito5::Javascript3::tab($level) . '})()' . chr(10);
        return $str
    }
    sub Perlito5::AST::CompUnit::emit_javascript3_program {
        my($comp_units, %options) = @_;
        $Perlito5::PKG_NAME = 'main';
        my $str;
        if ($options{'expand_use'}) {
            $str .= Perlito5::Javascript3::Runtime::->emit_javascript2();
            $str .= Perlito5::Javascript3::Array::->emit_javascript2();
            $str .= Perlito5::Javascript3::CORE::->emit_javascript2();
            $str .= Perlito5::Javascript3::IO::->emit_javascript2();
            $str .= Perlito5::Javascript3::Sprintf::->emit_javascript2()
        }
        $str .= 'var p5want = null;' . chr(10) . 'var ' . Perlito5::Javascript3::pkg_new_var() . ' = p5pkg[' . chr(39) . $Perlito5::PKG_NAME . chr(39) . '];' . chr(10);
        for my $comp_unit (@{$comp_units}) {
            $str = $str . $comp_unit->emit_javascript3() . chr(10)
        }
        return $str
    }
}
package Perlito5::AST::Int;
{
    sub Perlito5::AST::Int::emit_javascript3 {
        my $self = shift;
        my $level = shift;
        $self->{'int'}
    }
}
package Perlito5::AST::Num;
{
    sub Perlito5::AST::Num::emit_javascript3 {
        my $self = shift;
        my $level = shift;
        $self->{'num'}
    }
}
package Perlito5::AST::Buf;
{
    sub Perlito5::AST::Buf::emit_javascript3 {
        my $self = shift;
        my $level = shift;
        Perlito5::Javascript3::escape_string($self->{'buf'})
    }
}
package Perlito5::AST::Block;
{
    sub Perlito5::AST::Block::emit_javascript3 {
        my $self = shift;
        my $level = shift;
        my $init = '';
        if ($self->{'name'} eq 'INIT') {
            my $tmp = 'p5pkg.main._tmp' . Perlito5::Javascript3::get_label();
            $init = Perlito5::Javascript3::tab($level + 2) . 'if (' . $tmp . ') { return }; ' . $tmp . ' = 1;' . chr(10)
        }
        return 'p5for_lex(' . 'function () {' . chr(10) . $init . (Perlito5::Javascript3::LexicalBlock::->new('block' => $self->{'stmts'}, 'needs_return' => 0, 'top_level' => 0))->emit_javascript3($level + 2) . chr(10) . Perlito5::Javascript3::tab($level + 1) . '}, ' . '[0], ' . $self->emit_javascript3_continue($level) . ', ' . '"' . ($self->{'label'} || '') . '"' . ')'
    }
    sub Perlito5::AST::Block::emit_javascript3_continue {
        my $self = shift;
        my $level = shift;
        if (!$self->{'continue'} || !@{$self->{'continue'}->{'stmts'}}) {
            return 'false'
        }
        return 'function () {' . chr(10) . (Perlito5::Javascript3::LexicalBlock::->new('block' => $self->{'continue'}->stmts(), 'needs_return' => 0, 'top_level' => 0))->emit_javascript3($level + 2) . chr(10) . Perlito5::Javascript3::tab($level + 1) . '}'
    }
}
package Perlito5::AST::Index;
{
    sub Perlito5::AST::Index::emit_javascript3 {
        my $self = shift;
        my $level = shift;
        my $wantarray = shift;
        my $type = shift;
        $type = $type ? '"' . $type . '"' : 'null';
        if ($self->{'obj'}->isa('Perlito5::AST::Var') && $self->{'obj'}->sigil() eq '$') {
            my $v = Perlito5::AST::Var::->new('sigil' => '@', 'namespace' => $self->{'obj'}->namespace(), 'name' => $self->{'obj'}->name());
            return $v->emit_javascript3($level) . '.aget(' . Perlito5::Javascript3::to_num($self->{'index_exp'}, $level) . ', ' . $type . ')'
        }
        if ($self->{'obj'}->isa('Perlito5::AST::Apply') && $self->{'obj'}->{'code'} eq 'prefix:<$>') {
            return Perlito5::Javascript3::emit_javascript3_autovivify($self->{'obj'}->{'arguments'}->[0], $level, 'array') . '.aget(' . Perlito5::Javascript3::to_num($self->{'index_exp'}) . ', ' . $type . ')'
        }
        return Perlito5::Javascript3::emit_javascript3_autovivify($self->{'obj'}, $level, 'array') . '.aget(' . Perlito5::Javascript3::to_num($self->{'index_exp'}, $level) . ', ' . $type . ')'
    }
    sub Perlito5::AST::Index::emit_javascript3_set {
        my $self = shift;
        my $arguments = shift;
        my $level = shift;
        if ($self->{'obj'}->isa('Perlito5::AST::Var') && $self->{'obj'}->sigil() eq '$') {
            my $v = Perlito5::AST::Var::->new('sigil' => '@', 'namespace' => $self->{'obj'}->namespace(), 'name' => $self->{'obj'}->name());
            return $v->emit_javascript3($level) . '.aset(' . Perlito5::Javascript3::to_num($self->{'index_exp'}, $level + 1) . ', ' . Perlito5::Javascript3::to_scalar([$arguments], $level + 1) . ')'
        }
        if ($self->{'obj'}->isa('Perlito5::AST::Apply') && $self->{'obj'}->{'code'} eq 'prefix:<$>') {
            return Perlito5::Javascript3::emit_javascript3_autovivify($self->{'obj'}->{'arguments'}->[0], $level, 'array') . '.aset(' . Perlito5::Javascript3::to_num($self->{'index_exp'}) . ', ' . Perlito5::Javascript3::to_scalar([$arguments], $level + 1) . ')'
        }
        return Perlito5::Javascript3::emit_javascript3_autovivify($self->{'obj'}, $level, 'array') . '.aset(' . Perlito5::Javascript3::to_num($self->{'index_exp'}, $level + 1) . ', ' . Perlito5::Javascript3::to_scalar([$arguments], $level + 1) . ')'
    }
}
package Perlito5::AST::Lookup;
{
    sub Perlito5::AST::Lookup::emit_javascript3 {
        my $self = shift;
        my $level = shift;
        my $wantarray = shift;
        my $type = shift;
        $type = $type ? '"' . $type . '"' : 'null';
        if ($self->{'obj'}->isa('Perlito5::AST::Var') && $self->{'obj'}->sigil() eq '$') {
            my $v = Perlito5::AST::Var::->new('sigil' => '%', 'namespace' => $self->{'obj'}->namespace(), 'name' => $self->{'obj'}->name());
            return Perlito5::Javascript3::emit_javascript3_autovivify($v, $level, 'hash') . '.hget(' . Perlito5::Javascript3::autoquote($self->{'index_exp'}, $level) . ', ' . $type . ')'
        }
        if ($self->{'obj'}->isa('Perlito5::AST::Apply') && $self->{'obj'}->{'code'} eq 'prefix:<$>') {
            return Perlito5::Javascript3::emit_javascript3_autovivify($self->{'obj'}->{'arguments'}->[0], $level, 'hash') . '.hget(' . Perlito5::Javascript3::autoquote($self->{'index_exp'}, $level, 'list') . ', ' . $type . ')'
        }
        Perlito5::Javascript3::emit_javascript3_autovivify($self->{'obj'}, $level, 'hash') . '.hget(' . Perlito5::Javascript3::autoquote($self->{'index_exp'}, $level) . ', ' . $type . ')'
    }
    sub Perlito5::AST::Lookup::emit_javascript3_set {
        my $self = shift;
        my $arguments = shift;
        my $level = shift;
        if ($self->{'obj'}->isa('Perlito5::AST::Var') && $self->{'obj'}->sigil() eq '$') {
            my $v = Perlito5::AST::Var::->new('sigil' => '%', 'namespace' => $self->{'obj'}->namespace(), 'name' => $self->{'obj'}->name());
            return $v->emit_javascript3($level) . '.hset(' . Perlito5::Javascript3::autoquote($self->{'index_exp'}, $level) . ', ' . Perlito5::Javascript3::to_scalar([$arguments], $level + 1) . ')'
        }
        if ($self->{'obj'}->isa('Perlito5::AST::Apply') && $self->{'obj'}->{'code'} eq 'prefix:<$>') {
            return Perlito5::Javascript3::emit_javascript3_autovivify($self->{'obj'}->{'arguments'}->[0], $level, 'hash') . '.hset(' . Perlito5::Javascript3::autoquote($self->{'index_exp'}, $level, 'list') . ', ' . Perlito5::Javascript3::to_scalar([$arguments], $level + 1) . ')'
        }
        Perlito5::Javascript3::emit_javascript3_autovivify($self->{'obj'}, $level, 'hash') . '.hset(' . Perlito5::Javascript3::autoquote($self->{'index_exp'}, $level) . ', ' . Perlito5::Javascript3::to_scalar([$arguments], $level + 1) . ')'
    }
}
package Perlito5::AST::Var;
{
    my $table = {'$' => 'v_', '@' => 'List_', '%' => 'Hash_', '&' => ''};
    sub Perlito5::AST::Var::emit_javascript3 {
        my $self = shift;
        my $level = shift;
        my $wantarray = shift;
        my $str_name = $self->{'name'};
        $str_name eq chr(92) && ($str_name = chr(92) . chr(92));
        $str_name eq '"' && ($str_name = chr(92) . '"');
        if ($self->{'sigil'} eq '@') {
            if ($wantarray eq 'scalar') {
                return $self->emit_javascript3($level, 'list') . '.FETCHSIZE()'
            }
            if ($wantarray eq 'runtime') {
                return '(p5want' . ' ? ' . $self->emit_javascript3($level, 'list') . ' : ' . $self->emit_javascript3($level, 'list') . '.FETCHSIZE()' . ')'
            }
        }
        if ($self->{'sigil'} eq '&') {
            return 'p5pkg["' . ($self->{'namespace'} || $Perlito5::PKG_NAME) . '"]["' . $str_name . '"]'
        }
        if ($self->{'sigil'} eq '*') {
            return 'p5pkg["' . ($self->{'namespace'} || $Perlito5::PKG_NAME) . '"]["' . $str_name . '"]'
        }
        my $decl_type = $self->{'_decl'} || 'global';
        if ($decl_type eq 'our') {
            my $sigil = $self->{'sigil'} eq '$#' ? '@' : $self->{'sigil'};
            my $s = 'p5pkg["' . ($self->{'namespace'} || $self->{'_namespace'}) . '"]["' . $table->{$sigil} . $str_name . '"]';
            if ($self->{'sigil'} eq '$#') {
                return '(' . $s . '.FETCHSIZE() - 1)'
            }
            return $s
        }
        my $ns = '';
        if ($self->{'namespace'}) {
            {
                if ($self->{'sigil'} eq '$#') {
                    return '(p5global("@", "' . $self->{'namespace'} . '", "' . $str_name . '").FETCHSIZE() - 1)'
                }
                return 'p5global("' . $self->{'sigil'} . '", "' . $self->{'namespace'} . '", "' . $str_name . '")'
            }
        }
        if ($self->{'sigil'} eq '$#') {
            return '(' . $ns . $table->{'@'} . $str_name . '.FETCHSIZE() - 1)'
        }
        $ns . $table->{$self->{'sigil'}} . $str_name
    }
}
package Perlito5::AST::Decl;
{
    sub Perlito5::AST::Decl::emit_javascript3 {
        my $self = shift;
        my $level = shift;
        $self->{'var'}->emit_javascript3($level)
    }
    sub Perlito5::AST::Decl::emit_javascript3_init {
        my $self = shift;
        if ($self->{'decl'} eq 'my') {
            my $str = '';
            $str = $str . 'var ' . $self->{'var'}->emit_javascript3() . ' = ';
            if ($self->{'var'}->sigil() eq '%') {
                $str = $str . 'new p5Hash({});'
            }
            elsif ($self->{'var'}->sigil() eq '@') {
                $str = $str . 'new p5Array([]);'
            }
            else {
                $str = $str . 'new p5Scalar(null);'
            }
            return $str
        }
        elsif ($self->{'decl'} eq 'our') {
            my $str_name = $self->{'var'}->{'name'};
            $str_name eq chr(92) && ($str_name = chr(92) . chr(92));
            $str_name eq '"' && ($str_name = chr(92) . '"');
            return 'p5global("' . $self->{'var'}->{'sigil'} . '", ' . '"' . ($self->{'var'}->{'namespace'} || $Perlito5::PKG_NAME) . '", ' . '"' . $str_name . '")'
        }
        elsif ($self->{'decl'} eq 'local') {
            my $decl_namespace = $self->{'var'}->{'_namespace'};
            my $ns = 'p5pkg["' . ($self->{'var'}->{'namespace'} || $decl_namespace || $Perlito5::PKG_NAME) . '"]';
            return 'p5set_local(' . $ns . ',' . Perlito5::Javascript3::escape_string($self->{'var'}->{'name'}) . ',' . Perlito5::Javascript3::escape_string($self->{'var'}->{'sigil'}) . '); '
        }
        elsif ($self->{'decl'} eq 'state') {
            return '// state ' . $self->{'var'}->emit_javascript3()
        }
        else {
            die('not implemented: Perlito5::AST::Decl ' . chr(39) . $self->{'decl'} . chr(39))
        }
    }
}
package Perlito5::AST::Call;
{
    sub Perlito5::AST::Call::emit_javascript3 {
        my $self = shift;
        my $level = shift;
        my $wantarray = shift;
        my $type = shift;
        $type = $type ? '"' . $type . '"' : 'null';
        my $meth = $self->{'method'};
        if ($meth eq 'postcircumfix:<[ ]>') {
            return Perlito5::Javascript3::emit_javascript3_autovivify($self->{'invocant'}, $level, 'array') . '.aget(' . Perlito5::Javascript3::to_num($self->{'arguments'}) . ', ' . $type . ')'
        }
        if ($meth eq 'postcircumfix:<{ }>') {
            return Perlito5::Javascript3::emit_javascript3_autovivify($self->{'invocant'}, $level, 'hash') . '.hget(' . Perlito5::Javascript3::autoquote($self->{'arguments'}, $level, 'list') . ', ' . $type . ')'
        }
        my $invocant = $self->{'invocant'}->emit_javascript3($level, 'scalar');
        if ($meth eq 'postcircumfix:<( )>') {
            return 'p5code(' . $invocant . ')(' . Perlito5::Javascript3::to_list($self->{'arguments'}) . ', ' . ($wantarray eq 'list' ? 1 : $wantarray eq 'scalar' ? 0 : $wantarray eq 'void' ? 'null' : 'p5want') . ')'
        }
        if (ref($meth) eq 'Perlito5::AST::Var') {
            $meth = $meth->emit_javascript3($level, 'scalar')
        }
        else {
            $meth = '"' . $meth . '"'
        }
        return 'p5call(' . $invocant . ', ' . $meth . ', ' . Perlito5::Javascript3::to_list($self->{'arguments'}) . ', ' . ($wantarray eq 'list' ? 1 : $wantarray eq 'scalar' ? 0 : $wantarray eq 'void' ? 'null' : 'p5want') . ')'
    }
}
package Perlito5::AST::Apply;
{
    sub Perlito5::AST::Apply::emit_regex_javascript3 {
        my $op = shift;
        my $var = shift;
        my $regex = shift;
        if ($regex->isa('Perlito5::AST::Var')) {
            $regex = {'code' => 'p5:m', 'arguments' => [$regex, '']}
        }
        my $str;
        my $code = $regex->{'code'};
        my $regex_args = $regex->{'arguments'};
        if ($code eq 'p5:s') {
            $str = $var->emit_javascript3() . '.assign(p5str(' . $var->emit_javascript3() . ').replace(/' . $regex_args->[0]->{'buf'} . '/' . $regex_args->[2]->{'buf'} . ', ' . $regex_args->[1]->emit_javascript3() . '))'
        }
        elsif ($code eq 'p5:m') {
            my $ast = $regex_args->[0];
            if ($ast->isa('Perlito5::AST::Buf')) {
                $str = '(' . 'p5str(' . $var->emit_javascript3() . ')' . '.match(/' . $ast->{'buf'} . '/' . $regex_args->[1]->{'buf'} . ')' . ' ? 1 : 0)'
            }
            else {
                $str = '(new RegExp(' . $ast->emit_javascript3() . ', ' . '"' . $regex_args->[1]->{'buf'} . '"' . '))' . '.exec(' . 'p5str(' . $var->emit_javascript3() . ')' . ')'
            }
        }
        elsif ($code eq 'p5:tr') {
            $str = 'p5tr(' . $var->emit_javascript3() . ', ' . $regex_args->[0]->emit_javascript3() . ', ' . $regex_args->[1]->emit_javascript3() . ')'
        }
        else {
            die('Error: regex emitter - unknown operator ' . $code)
        }
        if ($op eq '=~') {
            return $str
        }
        if ($op eq '!~') {
            return '!(' . $str . ')'
        }
        die('Error: regex emitter')
    }
    my %emit_js = ('infix:<=~>' => sub {
        my $self = $_[0];
        emit_regex_javascript3('=~', $self->{'arguments'}->[0], $self->{'arguments'}->[1])
    }, 'infix:<!~>' => sub {
        my $self = $_[0];
        emit_regex_javascript3('!~', $self->{'arguments'}->[0], $self->{'arguments'}->[1])
    }, 'p5:s' => sub {
        my $self = $_[0];
        emit_regex_javascript3('=~', Perlito5::AST::Var::->new('sigil' => '$', 'namespace' => '', 'name' => '_'), $self)
    }, 'p5:m' => sub {
        my $self = $_[0];
        emit_regex_javascript3('=~', Perlito5::AST::Var::->new('sigil' => '$', 'namespace' => '', 'name' => '_'), $self)
    }, 'p5:tr' => sub {
        my $self = $_[0];
        emit_regex_javascript3('=~', Perlito5::AST::Var::->new('sigil' => '$', 'namespace' => '', 'name' => '_'), $self)
    }, '__PACKAGE__' => sub {
        my $self = $_[0];
        '"' . $Perlito5::PKG_NAME . '"'
    }, 'wantarray' => sub {
        my $self = $_[0];
        'p5want'
    }, 'package' => sub {
        my $self = $_[0];
        'var ' . Perlito5::Javascript3::pkg_new_var() . ' = p5make_package("' . $self->{'namespace'} . '")'
    }, 'infix:<=>>' => sub {
        my $self = shift;
        my $level = shift;
        my $wantarray = shift;
        Perlito5::Javascript3::autoquote($self->{'arguments'}->[0], $level) . ', ' . $self->{'arguments'}->[1]->emit_javascript3($level)
    }, 'infix:<cmp>' => sub {
        my $self = $_[0];
        'p5cmp(' . join(', ', map(Perlito5::Javascript3::to_str($_), @{$self->{'arguments'}})) . ')'
    }, 'infix:<<=>>' => sub {
        my $self = $_[0];
        'p5cmp(' . join(', ', map(Perlito5::Javascript3::to_num($_), @{$self->{'arguments'}})) . ')'
    }, 'infix:<**>' => sub {
        my $self = $_[0];
        'Math.pow(' . join(', ', map(Perlito5::Javascript3::to_num($_), @{$self->{'arguments'}})) . ')'
    }, 'prefix:<!>' => sub {
        my $self = shift;
        my $level = shift;
        '!( ' . Perlito5::Javascript3::to_bool($self->{'arguments'}->[0], $level) . ')'
    }, 'prefix:<not>' => sub {
        my $self = shift;
        my $level = shift;
        '!( ' . Perlito5::Javascript3::to_bool($self->{'arguments'}->[0], $level) . ')'
    }, 'prefix:<~>' => sub {
        my $self = $_[0];
        'p5complement( ' . Perlito5::Javascript3::to_num($self->{'arguments'}->[0]) . ')'
    }, 'prefix:<->' => sub {
        my $self = shift;
        my $level = shift;
        my $wantarray = shift;
        '-( ' . $self->{'arguments'}->[0]->emit_javascript3($level, 'scalar') . ')'
    }, 'prefix:<+>' => sub {
        my $self = shift;
        my $level = shift;
        my $wantarray = shift;
        '(' . $self->{'arguments'}->[0]->emit_javascript3($level, $wantarray) . ')'
    }, 'require' => sub {
        my $self = $_[0];
        my $level = $_[1];
        my $arg = $self->{'arguments'}->[0];
        if ($arg->isa('Perlito5::AST::Num')) {
            return 1
        }
        'p5pkg["Perlito5::Grammar::Use"].require([' . Perlito5::Javascript3::to_str($self->{'arguments'}->[0]) . ', ' . ($self->{'arguments'}->[0]->{'bareword'} ? 1 : 0) . '])'
    }, 'prefix:<$>' => sub {
        my $self = $_[0];
        my $level = $_[1];
        my $arg = $self->{'arguments'}->[0];
        Perlito5::Javascript3::emit_javascript3_autovivify($arg, $level, 'scalar') . '.sderef()'
    }, 'prefix:<@>' => sub {
        my $self = $_[0];
        my $level = $_[1];
        my $arg = $self->{'arguments'}->[0];
        Perlito5::Javascript3::emit_javascript3_autovivify($arg, $level, 'array') . '.aderef()'
    }, 'prefix:<$#>' => sub {
        my $self = $_[0];
        my $level = $_[1];
        my $arg = $self->{'arguments'}->[0];
        '(' . Perlito5::Javascript3::emit_javascript3_autovivify($arg, $level, 'array') . '.aderef().FETCHSIZE() - 1)'
    }, 'prefix:<%>' => sub {
        my $self = $_[0];
        my $level = $_[1];
        my $arg = $self->{'arguments'}->[0];
        Perlito5::Javascript3::emit_javascript3_autovivify($arg, $level, 'hash') . '.hderef()'
    }, 'prefix:<&>' => sub {
        my $self = $_[0];
        my $level = $_[1];
        my $arg = $self->{'arguments'}->[0];
        'p5code_lookup_by_name("' . $Perlito5::PKG_NAME . '", ' . $arg->emit_javascript3($level) . ')'
    }, 'circumfix:<[ ]>' => sub {
        my $self = $_[0];
        my $level = $_[1];
        '(new p5ArrayRef(new p5Array(' . Perlito5::Javascript3::to_list($self->{'arguments'}) . ')))'
    }, 'circumfix:<{ }>' => sub {
        my $self = $_[0];
        my $level = $_[1];
        '(new p5HashRef(new p5Hash(' . Perlito5::Javascript3::to_list($self->{'arguments'}, $level, 'hash') . ')))'
    }, 'prefix:<' . chr(92) . '>' => sub {
        my $self = $_[0];
        my $level = $_[1];
        my $arg = $self->{'arguments'}->[0];
        if ($arg->isa('Perlito5::AST::Var')) {
            if ($arg->sigil() eq '@') {
                return '(new p5ArrayRef(' . $arg->emit_javascript3($level) . '))'
            }
            if ($arg->sigil() eq '%') {
                return '(new p5HashRef(' . $arg->emit_javascript3($level) . '))'
            }
            if ($arg->sigil() eq '*') {
                return '(new p5GlobRef(' . $arg->emit_javascript3($level) . '))'
            }
            if ($arg->sigil() eq '&') {
                if ($arg->{'namespace'}) {
                    return 'p5pkg["' . $arg->{'namespace'} . '"].' . $arg->{'name'}
                }
                else {
                    return Perlito5::Javascript3::pkg() . '.' . $arg->{'name'}
                }
            }
        }
        return '(new p5ScalarRef(' . $arg->emit_javascript3($level) . '))'
    }, 'postfix:<++>' => sub {
        my $self = $_[0];
        my $level = $_[1];
        Perlito5::Javascript3::emit_javascript3_autovivify($self->{'arguments'}->[0], $level, 'lvalue') . '.p5postincr()'
    }, 'postfix:<-->' => sub {
        my $self = $_[0];
        my $level = $_[1];
        Perlito5::Javascript3::emit_javascript3_autovivify($self->{'arguments'}->[0], $level, 'lvalue') . '.p5postdecr()'
    }, 'prefix:<++>' => sub {
        my $self = $_[0];
        my $level = $_[1];
        Perlito5::Javascript3::emit_javascript3_autovivify($self->{'arguments'}->[0], $level, 'lvalue') . '.p5incr()'
    }, 'prefix:<-->' => sub {
        my $self = $_[0];
        my $level = $_[1];
        Perlito5::Javascript3::emit_javascript3_autovivify($self->{'arguments'}->[0], $level, 'lvalue') . '.p5decr()'
    }, 'infix:<x>' => sub {
        my $self = $_[0];
        'p5str_replicate(' . join(', ', map($_->emit_javascript3(), @{$self->{'arguments'}})) . ')'
    }, 'list:<.>' => sub {
        my $self = $_[0];
        '(' . join(' + ', map(Perlito5::Javascript3::to_str($_), @{$self->{'arguments'}})) . ')'
    }, 'list:<,>' => sub {
        my $self = $_[0];
        Perlito5::Javascript3::to_list($self->{'arguments'})
    }, 'infix:<..>' => sub {
        my $self = $_[0];
        '(function (a) { ' . 'for (var i=' . $self->{'arguments'}->[0]->emit_javascript3() . ', l=' . $self->{'arguments'}->[1]->emit_javascript3() . '; ' . 'i<=l; ++i)' . '{ ' . 'a.push(i) ' . '}; ' . 'return a ' . '})([])'
    }, 'delete' => sub {
        my $self = $_[0];
        '(delete ' . $self->{'arguments'}->[0]->emit_javascript3() . ')'
    }, 'scalar' => sub {
        my $self = $_[0];
        my $level = $_[1];
        Perlito5::Javascript3::to_scalar($self->{'arguments'}, $level + 1)
    }, 'ternary:<? :>' => sub {
        my $self = shift;
        my $level = shift;
        my $wantarray = shift;
        '( ' . Perlito5::Javascript3::to_bool($self->{'arguments'}->[0]) . ' ? ' . ($self->{'arguments'}->[1])->emit_javascript3($level, $wantarray) . ' : ' . ($self->{'arguments'}->[2])->emit_javascript3($level, $wantarray) . ')'
    }, 'my' => sub {
        my $self = shift;
        my $level = shift;
        my $wantarray = shift;
        'p5context(' . '[' . join(', ', map($_->emit_javascript3($level, $wantarray), @{$self->{'arguments'}})) . '], ' . ($wantarray eq 'runtime' ? 'p5want' : $wantarray eq 'list' ? 1 : 0) . ')'
    }, 'our' => sub {
        my $self = shift;
        my $level = shift;
        my $wantarray = shift;
        'p5context(' . '[' . join(', ', map($_->emit_javascript3($level, $wantarray), @{$self->{'arguments'}})) . '], ' . ($wantarray eq 'runtime' ? 'p5want' : $wantarray eq 'list' ? 1 : 0) . ')'
    }, 'local' => sub {
        my $self = shift;
        my $level = shift;
        my $wantarray = shift;
        'p5context(' . '[' . join(', ', map($_->emit_javascript3($level, $wantarray), @{$self->{'arguments'}})) . '], ' . ($wantarray eq 'runtime' ? 'p5want' : $wantarray eq 'list' ? 1 : 0) . ')'
    }, 'circumfix:<( )>' => sub {
        my $self = shift;
        my $level = shift;
        my $wantarray = shift;
        'p5context(' . '[' . join(', ', map($_->emit_javascript3($level, $wantarray), @{$self->{'arguments'}})) . '], ' . ($wantarray eq 'runtime' ? 'p5want' : $wantarray eq 'list' ? 1 : 0) . ')'
    }, 'infix:<=>' => sub {
        my $self = shift;
        my $level = shift;
        my $wantarray = shift;
        my $parameters = $self->{'arguments'}->[0];
        my $arguments = $self->{'arguments'}->[1];
        if ($parameters->isa('Perlito5::AST::Apply') && $parameters->code() eq 'prefix:<*>') {
            return 'p5set_glob(' . $parameters->{'arguments'}->[0]->emit_javascript3() . ', ' . Perlito5::Javascript3::to_scalar([$arguments], $level + 1) . ')'
        }
        if ($parameters->isa('Perlito5::AST::Apply') && ($parameters->code() eq 'my' || $parameters->code() eq 'our' || $parameters->code() eq 'local' || $parameters->code() eq 'circumfix:<( )>')) {
            my $tmp = 'tmp' . Perlito5::Javascript3::get_label();
            my $tmp2 = 'tmp' . Perlito5::Javascript3::get_label();
            return '(function () { ' . 'var ' . $tmp . ' = ' . Perlito5::Javascript3::to_list([$arguments], $level + 1) . '; ' . 'var ' . $tmp2 . ' = ' . $tmp . '.slice(0); ' . join('; ', (map(+($_->isa('Perlito5::AST::Apply') && $_->code() eq 'undef' ? $tmp . '.shift()' : $_->sigil() eq '$' ? $_->emit_javascript3() . '.assign(' . $tmp . '.shift())' : $_->sigil() eq '@' ? $_->emit_javascript3() . '.assign(' . $tmp . '); ' . $tmp . ' = []' : $_->sigil() eq '%' ? $_->emit_javascript3() . '.assign(p5a_to_h(' . $tmp . ')); ' . $tmp . ' = []' : die('not implemented')), @{$parameters->arguments()})), 'return ' . $tmp2) . ' })()'
        }
        if ($parameters->isa('Perlito5::AST::Var') && $parameters->sigil() eq '$' || $parameters->isa('Perlito5::AST::Decl') && $parameters->var()->sigil() eq '$') {
            return '' . $parameters->emit_javascript3() . '.assign(' . Perlito5::Javascript3::to_scalar([$arguments], $level + 1) . ')'
        }
        if ($parameters->isa('Perlito5::AST::Call') && $parameters->{'method'} eq 'postcircumfix:<[ ]>') {
            return Perlito5::Javascript3::emit_javascript3_autovivify($parameters->{'invocant'}, $level, 'array') . '.aset(' . Perlito5::Javascript3::to_num($parameters->{'arguments'}) . ', ' . Perlito5::Javascript3::to_scalar([$arguments], $level + 1) . ')'
        }
        elsif ($parameters->isa('Perlito5::AST::Call') && $parameters->{'method'} eq 'postcircumfix:<{ }>') {
            return Perlito5::Javascript3::emit_javascript3_autovivify($parameters->{'invocant'}, $level, 'hash') . '.hset(' . Perlito5::Javascript3::autoquote($parameters->{'arguments'}, $level) . ', ' . Perlito5::Javascript3::to_scalar([$arguments], $level + 1) . ')'
        }
        elsif ($parameters->isa('Perlito5::AST::Index')) {
            return $parameters->emit_javascript3_set($arguments, $level + 1)
        }
        elsif ($parameters->isa('Perlito5::AST::Lookup')) {
            return $parameters->emit_javascript3_set($arguments, $level + 1)
        }
        if ($parameters->isa('Perlito5::AST::Var') && $parameters->sigil() eq '@') {
            return $parameters->emit_javascript3() . '.assign(new p5Array(' . Perlito5::Javascript3::to_list([$arguments], $level + 1) . '))'
        }
        elsif ($parameters->isa('Perlito5::AST::Decl') && $parameters->var()->sigil() eq '@') {
            return $parameters->var()->emit_javascript3() . '.assign(new p5Array(' . Perlito5::Javascript3::to_list([$arguments], $level + 1) . '))'
        }
        elsif ($parameters->isa('Perlito5::AST::Var') && $parameters->sigil() eq '%' || $parameters->isa('Perlito5::AST::Decl') && $parameters->var()->sigil() eq '%') {
            return $parameters->emit_javascript3() . '.assign(new p5Hash(' . Perlito5::Javascript3::to_list([$arguments], $level + 1, 'hash') . '))'
        }
        if ($parameters->isa('Perlito5::AST::Var') && $parameters->sigil() eq '*') {
            return '(' . $parameters->emit_javascript3($level) . ' = ' . $arguments->emit_javascript3($level + 1) . ')'
        }
        say(Perlito5::Dumper::ast_dumper($parameters));
        die('assignment: don' . chr(39) . 't know what to do with left side isa ', ref($parameters))
    }, 'break' => sub {
        my $self = shift;
        my $level = shift;
        $Perlito5::THROW = 1;
        'throw(new p5_error("break", ""))'
    }, 'next' => sub {
        my $self = shift;
        my $level = shift;
        $Perlito5::THROW = 1;
        my $label = $self->{'arguments'}->[0]->{'code'} || '';
        'throw(new p5_error("next", "' . $label . '"))'
    }, 'last' => sub {
        my $self = shift;
        my $level = shift;
        $Perlito5::THROW = 1;
        my $label = $self->{'arguments'}->[0]->{'code'} || '';
        'throw(new p5_error("last", "' . $label . '"))'
    }, 'redo' => sub {
        my $self = shift;
        my $level = shift;
        $Perlito5::THROW = 1;
        my $label = $self->{'arguments'}->[0]->{'code'} || '';
        'throw(new p5_error("redo", "' . $label . '"))'
    }, 'return' => sub {
        my $self = shift;
        my $level = shift;
        $Perlito5::THROW = 1;
        'throw(' . Perlito5::Javascript3::to_runtime_context($self->{'arguments'}, $level) . ')'
    }, 'goto' => sub {
        my $self = $_[0];
        $Perlito5::THROW = 1;
        'throw((' . $self->{'arguments'}->[0]->emit_javascript3() . ')([List__, p5want]))'
    }, 'do' => sub {
        my $self = shift;
        my $level = shift;
        my $wantarray = shift;
        my $ast = Perlito5::AST::Apply::->new('code' => 'eval', 'namespace' => '', 'arguments' => [Perlito5::AST::Apply::->new('code' => 'do_file', 'namespace' => 'Perlito5::Grammar::Use', 'arguments' => $self->{'arguments'})]);
        $ast->emit_javascript3($level)
    }, 'eval' => sub {
        my $self = shift;
        my $level = shift;
        my $wantarray = shift;
        $Perlito5::THROW = 1;
        my $arg = $self->{'arguments'}->[0];
        my $eval;
        if ($arg->isa('Perlito5::AST::Block')) {
            my $block = $arg->{'stmts'};
            return Perlito5::Javascript3::emit_wrap_javascript3($level, $wantarray, (Perlito5::Javascript3::LexicalBlock::->new('block' => $block, 'needs_return' => 1))->emit_javascript2($level + 1, $wantarray))
        }
        else {
            my $var_env_perl5 = Perlito5::Dumper::ast_dumper([]);
            my $m = Perlito5::Grammar::Expression::term_square($var_env_perl5, 0);
            $m = Perlito5::Grammar::Expression::expand_list(Perlito5::Match::flat($m)->[2]);
            my $var_env_js = '(new p5ArrayRef(new p5Array(' . Perlito5::Javascript3::to_list($m) . ')))';
            $eval = 'eval(perl5_to_js(' . Perlito5::Javascript3::to_str($arg) . ', ' . '"' . $Perlito5::PKG_NAME . '", ' . $var_env_js . ', ' . '"' . $wantarray . '"' . '))'
        }
        '(function (p5want) {' . chr(10) . 'var r = null;' . chr(10) . 'p5pkg["main"]["v_@"].assign("");' . chr(10) . 'try {' . chr(10) . 'r = ' . $eval . chr(10) . '}' . chr(10) . 'catch(err) {' . chr(10) . 'if ( err instanceof p5_error ) {' . chr(10) . 'p5pkg["main"]["v_@"].assign(err);' . chr(10) . '}' . chr(10) . 'else if ( err instanceof Error ) {' . chr(10) . 'p5pkg["main"]["v_@"].assign(err);' . chr(10) . '}' . chr(10) . 'else {' . chr(10) . 'return(err);' . chr(10) . '}' . chr(10) . '}' . chr(10) . 'return r;' . chr(10) . '})(' . ($wantarray eq 'list' ? 1 : $wantarray eq 'scalar' ? 0 : $wantarray eq 'void' ? 'null' : 'p5want') . ')'
    }, 'undef' => sub {
        my $self = shift;
        my $level = shift;
        my $wantarray = shift;
        if ($self->{'arguments'} && @{$self->{'arguments'}}) {
            return $self->{'arguments'}->[0]->emit_javascript3() . '.assign(null)'
        }
        return 'null'
    }, 'shift' => sub {
        my $self = shift;
        my $level = shift;
        my $wantarray = shift;
        if ($self->{'arguments'} && @{$self->{'arguments'}}) {
            return Perlito5::Javascript3::pkg() . '.shift([' . join(', ', map($_->emit_javascript3($level), @{$self->{'arguments'}})) . '])'
        }
        return Perlito5::Javascript3::pkg() . '.shift([List__])'
    }, 'map' => sub {
        my $self = shift;
        my $level = shift;
        my $wantarray = shift;
        my @in = @{$self->{'arguments'}};
        my $fun = shift(@in);
        my $list = Perlito5::Javascript3::to_list(\@in);
        if (ref($fun) eq 'Perlito5::AST::Block') {
            $fun = $fun->{'stmts'}
        }
        else {
            $fun = [$fun]
        }
        'p5map(' . Perlito5::Javascript3::pkg() . ', ' . 'function (p5want) {' . chr(10) . (Perlito5::Javascript3::LexicalBlock::->new('block' => $fun, 'needs_return' => 1, 'top_level' => 0))->emit_javascript3($level + 1) . chr(10) . Perlito5::Javascript3::tab($level) . '}, ' . $list . ')'
    }, 'grep' => sub {
        my $self = shift;
        my $level = shift;
        my $wantarray = shift;
        my @in = @{$self->{'arguments'}};
        my $fun = shift(@in);
        my $list = Perlito5::Javascript3::to_list(\@in);
        if (ref($fun) eq 'Perlito5::AST::Block') {
            $fun = $fun->{'stmts'}
        }
        else {
            $fun = [$fun]
        }
        'p5grep(' . Perlito5::Javascript3::pkg() . ', ' . 'function (p5want) {' . chr(10) . (Perlito5::Javascript3::LexicalBlock::->new('block' => $fun, 'needs_return' => 1, 'top_level' => 0))->emit_javascript3($level + 1) . chr(10) . Perlito5::Javascript3::tab($level) . '}, ' . $list . ')'
    }, 'sort' => sub {
        my $self = shift;
        my $level = shift;
        my $wantarray = shift;
        my @in = @{$self->{'arguments'}};
        my $fun;
        my $list;
        if (ref($in[0]) eq 'Perlito5::AST::Block') {
            $fun = shift(@in);
            $fun = 'function (p5want) {' . chr(10) . (Perlito5::Javascript3::LexicalBlock::->new('block' => $fun->{'stmts'}, 'needs_return' => 1, 'top_level' => 0))->emit_javascript3($level + 1) . chr(10) . Perlito5::Javascript3::tab($level) . '}'
        }
        else {
            $fun = 'null'
        }
        $list = Perlito5::Javascript3::to_list(\@in);
        'p5sort(' . Perlito5::Javascript3::pkg() . ', ' . $fun . ', ' . $list . ')'
    }, 'infix:<//>' => sub {
        my $self = shift;
        my $level = shift;
        my $wantarray = shift;
        'p5defined_or' . '(' . $self->{'arguments'}->[0]->emit_javascript3($level, 'scalar') . ', ' . Perlito5::Javascript3::emit_function_javascript3($level, $wantarray, $self->{'arguments'}->[1]) . ')'
    }, 'exists' => sub {
        my $self = shift;
        my $level = shift;
        my $wantarray = shift;
        my $arg = $self->{'arguments'}->[0];
        if ($arg->isa('Perlito5::AST::Lookup')) {
            my $v = $arg->obj();
            if ($v->isa('Perlito5::AST::Var') && $v->sigil() eq '$') {
                $v = Perlito5::AST::Var::->new('sigil' => '%', 'namespace' => $v->namespace(), 'name' => $v->name());
                return '(' . $v->emit_javascript3() . ').exists(' . Perlito5::Javascript3::autoquote($arg->{'index_exp'}, $level) . ')'
            }
            return '(' . $v->emit_javascript3() . ').hderef().exists(' . Perlito5::Javascript3::autoquote($arg->{'index_exp'}, $level) . ')'
        }
        if ($arg->isa('Perlito5::AST::Call')) {
            if ($arg->method() eq 'postcircumfix:<{ }>') {
                return '(' . $arg->invocant()->emit_javascript3() . ').hderef().exists(' . Perlito5::Javascript3::autoquote($arg->{'arguments'}, $level) . ')'
            }
        }
    });
    sub Perlito5::AST::Apply::emit_javascript3 {
        my $self = shift;
        my $level = shift;
        my $wantarray = shift;
        my $apply = $self->op_assign();
        if ($apply) {
            return $apply->emit_javascript3($level)
        }
        my $code = $self->{'code'};
        if (ref($code) ne '') {
            my @args = ();
            push(@args, $_->emit_javascript3())
                for @{$self->{'arguments'}};
            return 'p5code(' . $self->{'code'}->emit_javascript3($level) . ')(' . join(',', @args) . ')'
        }
        exists($emit_js{$code}) && return $emit_js{$code}->($self, $level, $wantarray);
        if (exists($Perlito5::Javascript3::op_infix_js_str{$code})) {
            return '(' . join($Perlito5::Javascript3::op_infix_js_str{$code}, map(Perlito5::Javascript3::to_str($_), @{$self->{'arguments'}})) . ')'
        }
        if (exists($Perlito5::Javascript3::op_infix_js_num{$code})) {
            return '(' . join($Perlito5::Javascript3::op_infix_js_num{$code}, map(Perlito5::Javascript3::to_num($_), @{$self->{'arguments'}})) . ')'
        }
        if (exists($Perlito5::Javascript3::op_prefix_js_str{$code})) {
            return $Perlito5::Javascript3::op_prefix_js_str{$code} . '(' . Perlito5::Javascript3::to_str($self->{'arguments'}->[0]) . ')'
        }
        if ($code eq 'infix:<&&>' || $code eq 'infix:<and>') {
            return 'p5and' . '(' . $self->{'arguments'}->[0]->emit_javascript3($level, 'scalar') . ', ' . Perlito5::Javascript3::emit_function_javascript3($level, $wantarray, $self->{'arguments'}->[1]) . ')'
        }
        if ($code eq 'infix:<||>' || $code eq 'infix:<or>') {
            return 'p5or' . '(' . $self->{'arguments'}->[0]->emit_javascript3($level, 'scalar') . ', ' . Perlito5::Javascript3::emit_function_javascript3($level, $wantarray, $self->{'arguments'}->[1]) . ')'
        }
        if ($self->{'namespace'}) {
            if ($self->{'namespace'} eq 'JS' && $code eq 'inline') {
                if ($self->{'arguments'}->[0]->isa('Perlito5::AST::Buf')) {
                    return $self->{'arguments'}->[0]->{'buf'}
                }
                else {
                    die('JS::inline needs a string constant')
                }
            }
            $code = 'p5pkg["' . $self->{'namespace'} . '"].' . $code
        }
        else {
            $code = Perlito5::Javascript3::pkg() . '.' . $code
        }
        my $sig;
        my $may_need_autoload;
        {
            my $name = $self->{'code'};
            my $namespace = $self->{'namespace'} || $Perlito5::PKG_NAME;
            my $effective_name = $namespace . '::' . $self->{'code'};
            if (exists($Perlito5::PROTO->{$effective_name})) {
                $sig = $Perlito5::PROTO->{$effective_name}
            }
            elsif ((!$self->{'namespace'} || $namespace eq 'CORE') && exists($Perlito5::CORE_PROTO->{'CORE::' . $name})) {
                $effective_name = 'CORE::' . $name;
                $sig = $Perlito5::CORE_PROTO->{$effective_name}
            }
            else {
                if ($self->{'bareword'}) {
                    if ($Perlito5::STRICT) {
                        die('Bareword "' . $name . '" not allowed while "strict subs" in use')
                    }
                    return Perlito5::Javascript3::escape_string(($self->{'namespace'} ? $self->{'namespace'} . '::' : '') . $name)
                }
                $may_need_autoload = 1
            }
        }
        if (($self->{'code'} eq 'say' || $self->{'code'} eq 'print') && !$self->{'namespace'} && $self->{'bareword'}) {
            $self->{'arguments'} = [Perlito5::AST::Var::->new('sigil' => '$', 'namespace' => '', 'name' => '_')]
        }
        if ($sig) {
            my @out = ();
            my @in = @{$self->{'arguments'} || []};
            my $optional = 0;
            while (length($sig)) {
                my $c = substr($sig, 0, 1);
                if ($c eq ';') {
                    $optional = 1
                }
                elsif ($c eq '$' || $c eq '_') {
                    (@in || !$optional) && push(@out, shift(@in)->emit_javascript3($level, 'scalar'))
                }
                elsif ($c eq '@') {
                    (@in || !$optional) && push(@out, 'new p5Array(' . Perlito5::Javascript3::to_list(\@in) . ')');
                    @in = ()
                }
                elsif ($c eq '*') {
                    if (@in || !$optional) {
                        my $arg = shift(@in);
                        if ($arg->{'bareword'}) {
                            push(@out, 'p5pkg["' . ($arg->{'namespace'} || $Perlito5::PKG_NAME) . '"]["f_' . $arg->{'code'} . '"]')
                        }
                        else {
                            push(@out, $arg->emit_javascript3($level, 'scalar'))
                        }
                    }
                }
                elsif ($c eq chr(92)) {
                    if (substr($sig, 0, 2) eq chr(92) . '$') {
                        $sig = substr($sig, 1);
                        (@in || !$optional) && push(@out, shift(@in)->emit_javascript3($level, 'scalar'))
                    }
                    elsif (substr($sig, 0, 2) eq chr(92) . '@' || substr($sig, 0, 2) eq chr(92) . '%') {
                        $sig = substr($sig, 1);
                        (@in || !$optional) && push(@out, shift(@in)->emit_javascript3($level, 'list'))
                    }
                    elsif (substr($sig, 0, 5) eq chr(92) . '[@%]') {
                        $sig = substr($sig, 4);
                        (@in || !$optional) && push(@out, shift(@in)->emit_javascript3($level, 'list'))
                    }
                }
                $sig = substr($sig, 1)
            }
            return $code . '([' . join(', ', @out) . '], ' . ($wantarray eq 'list' ? 1 : $wantarray eq 'scalar' ? 0 : $wantarray eq 'void' ? 'null' : 'p5want') . ')'
        }
        my @args = ();
        my $arg_list = Perlito5::Javascript3::to_list_preprocess($self->{'arguments'});
        push(@args, $_->emit_javascript3($level))
            for @{$arg_list};
        my $arg_code = $self->{'code'} eq 'scalar' ? '[' . join(', ', @args) . ']' : 'p5param_list(' . join(', ', map($_->emit_javascript3($level, 'list', 'lvalue'), @{$arg_list})) . ')';
        if ($may_need_autoload) {
            my $name = $self->{'code'};
            my $namespace = $self->{'namespace'} || $Perlito5::PKG_NAME;
            return 'p5call_sub(' . '"' . $namespace . '", ' . '"' . $name . '", ' . $arg_code . ', ' . ($wantarray eq 'list' ? 1 : $wantarray eq 'scalar' ? 0 : $wantarray eq 'void' ? 'null' : 'p5want') . ')'
        }
        $code . '(' . $arg_code . ', ' . ($wantarray eq 'list' ? 1 : $wantarray eq 'scalar' ? 0 : $wantarray eq 'void' ? 'null' : 'p5want') . ')'
    }
}
package Perlito5::AST::If;
{
    sub Perlito5::AST::If::emit_javascript3 {
        my $self = shift;
        my $level = shift;
        my $cond = $self->{'cond'};
        my $body = Perlito5::Javascript3::LexicalBlock::->new('block' => $self->{'body'}->stmts(), 'needs_return' => 0, 'create_context' => 1);
        my $s = 'if ( ' . Perlito5::Javascript3::to_bool($cond, $level + 1) . ' ) {' . chr(10) . $body->emit_javascript3($level + 1) . chr(10) . Perlito5::Javascript3::tab($level) . '}';
        if (@{$self->{'otherwise'}->stmts()}) {
            my $otherwise = Perlito5::Javascript3::LexicalBlock::->new('block' => $self->{'otherwise'}->stmts(), 'needs_return' => 0, 'create_context' => 1);
            $s = $s . chr(10) . Perlito5::Javascript3::tab($level) . 'else {' . chr(10) . $otherwise->emit_javascript3($level + 1) . chr(10) . Perlito5::Javascript3::tab($level) . '}'
        }
        return $s
    }
}
package Perlito5::AST::When;
{
    sub Perlito5::AST::When::emit_javascript3 {
        my $self = shift;
        my $level = shift;
        my $cond = $self->{'cond'};
        my $body = Perlito5::Javascript3::LexicalBlock::->new('block' => $self->{'body'}->stmts(), 'needs_return' => 0, 'create_context' => 1);
        my $expr = Perlito5::AST::Apply::->new('code' => 'infix:<==>', 'arguments' => [Perlito5::AST::Var::->new('sigil' => '$', 'namespace' => '', 'name' => '_'), $cond]);
        my $label = '';
        my $s = 'if ( ' . Perlito5::Javascript3::to_bool($expr, $level + 1) . ' ) {' . chr(10) . $body->emit_javascript3($level + 1) . chr(10) . Perlito5::Javascript3::tab($level + 1) . 'throw(new p5_error("next", "' . $label . '"))' . Perlito5::Javascript3::tab($level) . '}';
        return $s
    }
}
package Perlito5::AST::While;
{
    sub Perlito5::AST::While::emit_javascript3 {
        my $self = shift;
        my $level = shift;
        my $cond = $self->{'cond'};
        return 'p5while(' . 'function () {' . chr(10) . (Perlito5::Javascript3::LexicalBlock::->new('block' => $self->{'body'}->stmts(), 'needs_return' => 0, 'top_level' => 0))->emit_javascript3($level + 2) . chr(10) . Perlito5::Javascript3::tab($level + 1) . '}, ' . Perlito5::Javascript3::emit_function_javascript3($level, 0, $cond) . ', ' . Perlito5::AST::Block::emit_javascript3_continue($self, $level) . ', ' . '"' . ($self->{'label'} || '') . '"' . ')'
    }
}
package Perlito5::AST::For;
{
    sub Perlito5::AST::For::emit_javascript3 {
        my $self = shift;
        my $level = shift;
        if (ref($self->{'cond'}) eq 'ARRAY') {
            my $body = Perlito5::Javascript3::LexicalBlock::->new('block' => $self->{'body'}->stmts(), 'needs_return' => 0, 'create_context' => 1);
            return 'for ( ' . ($self->{'cond'}->[0] ? $self->{'cond'}->[0]->emit_javascript3($level + 1) . '; ' : '; ') . ($self->{'cond'}->[1] ? $self->{'cond'}->[1]->emit_javascript3($level + 1) . '; ' : '; ') . ($self->{'cond'}->[2] ? $self->{'cond'}->[2]->emit_javascript3($level + 1) . ' ' : ' ') . ') {' . chr(10) . $body->emit_javascript3($level + 1) . chr(10) . Perlito5::Javascript3::tab($level) . '}'
        }
        my $cond = Perlito5::Javascript3::to_list([$self->{'cond'}], $level + 1);
        if ($self->{'topic'}) {
            my $v = $self->{'topic'};
            my $sig = $v->emit_javascript3($level + 1);
            return 'p5for_lex(' . 'function (' . $sig . ') {' . chr(10) . (Perlito5::Javascript3::LexicalBlock::->new('block' => $self->{'body'}->stmts(), 'needs_return' => 0, 'top_level' => 0))->emit_javascript3($level + 2) . chr(10) . Perlito5::Javascript3::tab($level + 1) . '}, ' . $cond . ', ' . Perlito5::AST::Block::emit_javascript3_continue($self, $level) . ', ' . '"' . ($self->{'label'} || '') . '"' . ')'
        }
        else {
            return 'p5for(' . Perlito5::Javascript3::pkg() . ', ' . 'function () {' . chr(10) . (Perlito5::Javascript3::LexicalBlock::->new('block' => $self->{'body'}->stmts(), 'needs_return' => 0, 'top_level' => 0))->emit_javascript3($level + 2) . chr(10) . Perlito5::Javascript3::tab($level + 1) . '}, ' . $cond . ', ' . Perlito5::AST::Block::emit_javascript3_continue($self, $level) . ', ' . '"' . ($self->{'label'} || '') . '"' . ')'
        }
    }
}
package Perlito5::AST::Sub;
{
    sub Perlito5::AST::Sub::emit_javascript3 {
        my $self = shift;
        my $level = shift;
        my $s = 'function (List__, p5want) {' . chr(10) . Perlito5::Javascript3::tab($level + 1) . 'List__ = new p5Array(List__);' . chr(10) . (Perlito5::Javascript3::LexicalBlock::->new('block' => $self->{'block'}, 'needs_return' => 1, 'top_level' => 1))->emit_javascript3($level) . chr(10) . Perlito5::Javascript3::tab($level) . '}';
        if ($self->{'name'}) {
            return 'p5typeglob_set("' . $self->{'namespace'} . '", "' . $self->{'name'} . '", ' . $s . ')'
        }
        else {
            return $s
        }
    }
}
package Perlito5::AST::Use;
{
    sub Perlito5::AST::Use::emit_javascript3 {
        my $self = shift;
        my $level = shift;
        Perlito5::Grammar::Use::emit_time_eval($self);
        '// ' . $self->{'code'} . ' ' . $self->{'mod'} . chr(10)
    }
}
# use Perlito5::Javascript3::Emitter
package main;
undef();
package Perlito5::Javascript3::Runtime;
sub Perlito5::Javascript3::Runtime::emit_javascript3 {
    return '//' . chr(10) . '// lib/Perlito5/Javascript3/Runtime.js' . chr(10) . '//' . chr(10) . '// Runtime for "Perlito" Perl5-in-Javascript3' . chr(10) . '//' . chr(10) . '// AUTHORS' . chr(10) . '//' . chr(10) . '// Flavio Soibelmann Glock  fglock@gmail.com' . chr(10) . '//' . chr(10) . '// COPYRIGHT' . chr(10) . '//' . chr(10) . '// Copyright 2009, 2010, 2011, 2012 by Flavio Soibelmann Glock and others.' . chr(10) . '//' . chr(10) . '// This program is free software; you can redistribute it and/or modify it' . chr(10) . '// under the same terms as Perl itself.' . chr(10) . '//' . chr(10) . '// See http://www.perl.com/perl/misc/Artistic.html' . chr(10) . chr(10) . 'var isNode = typeof require != "undefined";' . chr(10) . chr(10) . 'if (typeof p5pkg !== "object") {' . chr(10) . '    p5pkg = {};' . chr(10) . '    p5LOCAL = [];' . chr(10) . chr(10) . '    var universal = function () {};' . chr(10) . '    p5pkg.UNIVERSAL = new universal();' . chr(10) . '    p5pkg.UNIVERSAL._ref_ = "UNIVERSAL";' . chr(10) . '    p5pkg.UNIVERSAL.isa = function (List__) {' . chr(10) . '        // TODO - use @ISA' . chr(10) . '        var o = List__[0];' . chr(10) . '        var s = p5str(List__[1]);' . chr(10) . '        if (o instanceof p5Scalar) {' . chr(10) . '            o = o.FETCH();' . chr(10) . '        }' . chr(10) . '        return o._class_._ref_ == s' . chr(10) . '    };' . chr(10) . '    p5pkg.UNIVERSAL.can = function (List__) {' . chr(10) . '        var o = List__[0];' . chr(10) . '        var s = p5str(List__[1]);' . chr(10) . '        if (o instanceof p5Scalar) {' . chr(10) . '            o = o.FETCH();' . chr(10) . '        }' . chr(10) . '        if ( s.indexOf("::") == -1 ) {' . chr(10) . '            return p5method_lookup(s, o._class_._ref__, {})' . chr(10) . '        }' . chr(10) . '        var c = s.split("::");' . chr(10) . '        s = c.pop(); ' . chr(10) . '        return p5method_lookup(s, c.join("::"), {});' . chr(10) . '    };' . chr(10) . '    p5pkg.UNIVERSAL.DOES = p5pkg.UNIVERSAL.can;' . chr(10) . chr(10) . '    var core = function () {};' . chr(10) . '    p5pkg["CORE"] = new core();' . chr(10) . '    p5pkg["CORE"]._ref_ = "CORE";' . chr(10) . chr(10) . '    var core_global = function () {};' . chr(10) . '    core_global.prototype = p5pkg.CORE;' . chr(10) . '    p5pkg["CORE::GLOBAL"] = new core_global();' . chr(10) . '    p5pkg["CORE::GLOBAL"]._ref_ = "CORE::GLOBAL";' . chr(10) . chr(10) . '    p5_error = function (type, v) {' . chr(10) . '        this.type = type;' . chr(10) . '        this.v = this.message = v;' . chr(10) . '        this.toString = function(){' . chr(10) . '            if (this.type == ' . chr(39) . 'break' . chr(39) . ') {' . chr(10) . '                return ' . chr(39) . 'Can' . chr(92) . chr(39) . 't "break" outside a given block' . chr(39) . chr(10) . '            }' . chr(10) . '            if (this.type == ' . chr(39) . 'next' . chr(39) . ' || this.type == ' . chr(39) . 'last' . chr(39) . ' || this.type == ' . chr(39) . 'redo' . chr(39) . ') {' . chr(10) . '                if (this.v == "") { return ' . chr(39) . 'Can' . chr(92) . chr(39) . 't "' . chr(39) . ' + this.type + ' . chr(39) . '" outside a loop block' . chr(39) . ' }' . chr(10) . '                return ' . chr(39) . 'Label not found for "' . chr(39) . ' + this.type + ' . chr(39) . ' ' . chr(39) . ' + this.v + ' . chr(39) . '"' . chr(39) . ';' . chr(10) . '            }' . chr(10) . '            return this.v;' . chr(10) . '        };' . chr(10) . '    };' . chr(10) . '    p5_error.prototype = Error.prototype;' . chr(10) . '}' . chr(10) . chr(10) . 'function p5make_package(pkg_name) {' . chr(10) . '    if (!p5pkg.hasOwnProperty(pkg_name)) {' . chr(10) . '        var tmp = function () {};' . chr(10) . '        tmp.prototype = p5pkg["CORE::GLOBAL"];' . chr(10) . '        p5pkg[pkg_name] = new tmp();' . chr(10) . '        p5pkg[pkg_name]._ref_ = pkg_name;' . chr(10) . '        p5pkg[pkg_name]._class_ = p5pkg[pkg_name];  // XXX memory leak' . chr(10) . chr(10) . '        // TODO - add the other package global variables' . chr(10) . '        p5pkg[pkg_name]["List_ISA"] = new p5Array([]);' . chr(10) . '        p5pkg[pkg_name]["v_a"] = new p5Scalar(null);' . chr(10) . '        p5pkg[pkg_name]["v_b"] = new p5Scalar(null);' . chr(10) . '        p5pkg[pkg_name]["v__"] = new p5Scalar(null);' . chr(10) . '        p5pkg[pkg_name]["v_AUTOLOAD"] = new p5Scalar(null);' . chr(10) . '    }' . chr(10) . '    return p5pkg[pkg_name];' . chr(10) . '}' . chr(10) . chr(10) . 'function p5code_lookup_by_name(package_name, sub_name) {' . chr(10) . '    // sub_name can have an optional namespace' . chr(10) . '    var parts = sub_name.split(/::/);' . chr(10) . '    if (parts.length > 1) {' . chr(10) . '        sub_name = parts.pop();' . chr(10) . '        package_name = parts.join("::");' . chr(10) . '    }' . chr(10) . '    if (p5pkg.hasOwnProperty(package_name)) {' . chr(10) . '        var c = p5pkg[package_name];' . chr(10) . '        if ( c.hasOwnProperty(sub_name) ) {' . chr(10) . '            return c[sub_name]' . chr(10) . '        }' . chr(10) . '    }' . chr(10) . '    return null;' . chr(10) . '}' . chr(10) . chr(10) . 'function p5get_class_for_method(method, class_name, seen) {' . chr(10) . '    // default mro' . chr(10) . '    // TODO - cache the methods that were already looked up' . chr(10) . '    if ( p5pkg[class_name].hasOwnProperty(method) ) {' . chr(10) . '        return class_name' . chr(10) . '    }' . chr(10) . '    var isa = p5pkg[class_name].List_ISA;' . chr(10) . '    for (var i = 0; i < isa.length; i++) {' . chr(10) . '        if (!seen[isa[i]]) {' . chr(10) . '            var m = p5get_class_for_method(method, isa[i], seen);' . chr(10) . '            if (m) {' . chr(10) . '                return m ' . chr(10) . '            }' . chr(10) . '            seen[isa[i]]++;' . chr(10) . '        }' . chr(10) . '    }' . chr(10) . '}' . chr(10) . chr(10) . 'function p5method_lookup(method, class_name, seen) {' . chr(10) . '    var c = p5get_class_for_method(method, class_name, seen);' . chr(10) . '    if (c) {' . chr(10) . '        return p5pkg[c][method]' . chr(10) . '    }' . chr(10) . '    if ( p5pkg.UNIVERSAL.hasOwnProperty(method) ) {' . chr(10) . '        return p5pkg.UNIVERSAL[method]' . chr(10) . '    }' . chr(10) . '}' . chr(10) . chr(10) . 'function p5call(invocant, method, list, p5want) {' . chr(10) . '    list.unshift(invocant);' . chr(10) . chr(10) . '    if (invocant instanceof p5Scalar) {' . chr(10) . '        // TODO - move p5call() to p5Scalar method' . chr(10) . '        invocant = invocant.FETCH();' . chr(10) . '    }' . chr(10) . chr(10) . '    if ( invocant.hasOwnProperty("_class_") ) {' . chr(10) . chr(10) . '        if ( invocant._class_.hasOwnProperty(method) ) {' . chr(10) . '            return invocant._class_[method](list, p5want)' . chr(10) . '        }' . chr(10) . '        var m = p5method_lookup(method, invocant._class_._ref_, {});' . chr(10) . '        if (m) {' . chr(10) . '            return m(list, p5want)' . chr(10) . '        }' . chr(10) . chr(10) . '        // method can have an optional namespace' . chr(10) . '        var pkg_name = method.split(/::/);' . chr(10) . '        if (pkg_name.length > 1) {' . chr(10) . '            var name = pkg_name.pop();' . chr(10) . '            pkg_name = pkg_name.join("::");' . chr(10) . '            m = p5method_lookup(name, pkg_name, {});' . chr(10) . '            if (m) {' . chr(10) . '                return m(list, p5want)' . chr(10) . '            }' . chr(10) . '            p5pkg.CORE.die(["method not found: ", name, " in class ", pkg_name]);' . chr(10) . '        }' . chr(10) . chr(10) . '        pkg_name = p5get_class_for_method(' . chr(39) . 'AUTOLOAD' . chr(39) . ', invocant._class_._ref_, {}) || p5get_class_for_method(' . chr(39) . 'AUTOLOAD' . chr(39) . ', "UNIVERSAL", {});' . chr(10) . '        if (pkg_name) {' . chr(10) . '            p5pkg[pkg_name]["v_AUTOLOAD"] = invocant._class_._ref_ + "::" + method;' . chr(10) . '            return p5pkg[pkg_name]["AUTOLOAD"](list, p5want);' . chr(10) . '        }' . chr(10) . chr(10) . '        p5pkg.CORE.die(["method not found: ", method, " in class ", invocant._class_._ref_]);' . chr(10) . chr(10) . '    }' . chr(10) . chr(10) . '    // the invocant doesn' . chr(39) . 't have a class' . chr(10) . chr(10) . '    if (typeof invocant === "string") {' . chr(10) . '        var aclass = p5make_package(invocant);' . chr(10) . '        return p5call(aclass, method, list, p5want);' . chr(10) . '    }' . chr(10) . chr(10) . '    p5pkg.CORE.die(["Can' . chr(39) . 't call method ", method, " on unblessed reference"]);' . chr(10) . chr(10) . '}' . chr(10) . chr(10) . 'function p5call_sub(namespace, name, list, p5want) {' . chr(10) . '    if(p5pkg[namespace].hasOwnProperty(name)) {' . chr(10) . '        return p5pkg[namespace][name](list, p5want)' . chr(10) . '    }' . chr(10) . '    if(p5pkg[namespace].hasOwnProperty("AUTOLOAD")) {' . chr(10) . '        p5pkg[namespace]["v_AUTOLOAD"] = namespace + "::" + name;' . chr(10) . '        return p5pkg[namespace]["AUTOLOAD"](list, p5want)' . chr(10) . '    }' . chr(10) . '    p5pkg.CORE.die(["Undefined subroutine &" + namespace + "::" + name]);' . chr(10) . '}' . chr(10) . chr(10) . 'function p5scalar_deref(v) {' . chr(10) . '    if (typeof v === "string") {' . chr(10) . '        var pkg_name = v.split(/::/);' . chr(10) . '        if (pkg_name.length > 1) {' . chr(10) . '            v = pkg_name.pop();' . chr(10) . '            pkg_name = pkg_name.join("::");' . chr(10) . '        }' . chr(10) . '        else {' . chr(10) . '            pkg_name = p5pkg["Perlito5"].v_PKG_NAME;' . chr(10) . '        }' . chr(10) . '        var c = v.charCodeAt(0);' . chr(10) . '        if (c < 27) {' . chr(10) . '            v = String.fromCharCode(c + 64) + v.substr(1);' . chr(10) . '            pkg_name = ' . chr(39) . 'main' . chr(39) . ';' . chr(10) . '        }' . chr(10) . '        return p5pkg[pkg_name]["v_"+v];' . chr(10) . '    }' . chr(10) . '    return v._scalar_;' . chr(10) . '}' . chr(10) . chr(10) . 'function p5scalar_deref_set(v, n) {' . chr(10) . '    if (typeof v === "string") {' . chr(10) . '        var pkg_name = v.split(/::/);' . chr(10) . '        if (pkg_name.length > 1) {' . chr(10) . '            v = pkg_name.pop();' . chr(10) . '            pkg_name = pkg_name.join("::");' . chr(10) . '        }' . chr(10) . '        else {' . chr(10) . '            pkg_name = p5pkg["Perlito5"].v_PKG_NAME;' . chr(10) . '        }' . chr(10) . '        var c = v.charCodeAt(0);' . chr(10) . '        if (c < 27) {' . chr(10) . '            v = String.fromCharCode(c + 64) + v.substr(1);' . chr(10) . '            pkg_name = ' . chr(39) . 'main' . chr(39) . ';' . chr(10) . '        }' . chr(10) . '        p5pkg[pkg_name]["v_"+v] = n;' . chr(10) . '        return p5pkg[pkg_name]["v_"+v];' . chr(10) . '    }' . chr(10) . '    v._scalar_ = n;' . chr(10) . '    return v._scalar_;' . chr(10) . '}' . chr(10) . chr(10) . 'p5make_package("main");' . chr(10) . 'p5make_package("Perlito5");' . chr(10) . 'p5pkg["Perlito5"].v_PKG_NAME = "main";' . chr(10) . 'p5pkg["main"]["v_@"]       = new p5Scalar("");  // $@' . chr(10) . 'p5pkg["main"]["v_|"]       = new p5Scalar(0);   // $|' . chr(10) . 'p5pkg["main"]["List_#"]    = new p5Array([]);   // @#' . chr(10) . 'p5scalar_deref_set(String.fromCharCode(15), isNode ? "node.js" : "javascript2");  // $^O' . chr(10) . 'p5pkg["main"]["List_INC"]  = new p5Array([]);' . chr(10) . 'p5pkg["main"]["Hash_INC"]  = new p5Hash({});' . chr(10) . 'p5pkg["main"]["List_ARGV"] = new p5Array([]);' . chr(10) . 'p5pkg["main"]["Hash_ENV"]  = new p5Hash({});' . chr(10) . 'if (isNode) {' . chr(10) . '    p5pkg["main"]["List_ARGV"] = new p5Array(process.argv.splice(2));' . chr(10) . '    p5pkg["main"]["Hash_ENV"]  = new p5Hash(process.env);' . chr(10) . '    p5pkg["main"]["v_$"]       = new p5Scalar(process.pid);' . chr(10) . '} else if (typeof arguments === "object") {' . chr(10) . '    p5pkg["main"]["List_ARGV"] = new p5Array(arguments);' . chr(10) . '}' . chr(10) . chr(10) . 'p5make_package("Perlito5::IO");' . chr(10) . 'p5make_package("Perlito5::Runtime");' . chr(10) . 'p5make_package("Perlito5::Grammar");' . chr(10) . chr(10) . 'function p5typeglob_set(pkg_name, sub_name, func) {' . chr(10) . '    p5make_package(pkg_name);' . chr(10) . '    p5pkg[pkg_name][sub_name] = func;' . chr(10) . '}' . chr(10) . chr(10) . 'function p5set_glob(name, data) {' . chr(10) . '    if ( name.indexOf("::") == -1 ) {' . chr(10) . '        p5pkg[ p5pkg["Perlito5"].v_PKG_NAME.FETCH() ][name] = data;' . chr(10) . '        return data;' . chr(10) . '    }' . chr(10) . '    var c = name.split("::");' . chr(10) . '    s = c.pop(); ' . chr(10) . '    var pkg = c.join("::");' . chr(10) . '    p5make_package(pkg);' . chr(10) . '    p5pkg[pkg][s] = data;' . chr(10) . '    return data;' . chr(10) . '}' . chr(10) . chr(10) . 'var sigils = { ' . chr(39) . '@' . chr(39) . ' : ' . chr(39) . 'List_' . chr(39) . ', ' . chr(39) . '%' . chr(39) . ' : ' . chr(39) . 'Hash_' . chr(39) . ', ' . chr(39) . '$' . chr(39) . ' : ' . chr(39) . 'v_' . chr(39) . ' };' . chr(10) . chr(10) . 'function p5set_local(namespace, name, sigil) {' . chr(10) . '    var vname = sigils[sigil] + name;' . chr(10) . '    p5LOCAL.push([namespace, vname, namespace[vname]]);' . chr(10) . chr(10) . '    if (sigil == ' . chr(39) . '$' . chr(39) . ') {' . chr(10) . '        namespace[vname] = new p5Scalar(null);' . chr(10) . '    }' . chr(10) . '    else if (sigil == ' . chr(39) . '@' . chr(39) . ') {' . chr(10) . '        namespace[vname] = new p5Array([]);' . chr(10) . '    }' . chr(10) . '    else if (sigil == ' . chr(39) . '%' . chr(39) . ') {' . chr(10) . '        namespace[vname] = new p5Hash({});' . chr(10) . '    }' . chr(10) . '    return namespace[vname];' . chr(10) . '}' . chr(10) . chr(10) . 'function p5cleanup_local(idx, value) {' . chr(10) . '    while (p5LOCAL.length > idx) {' . chr(10) . '        l = p5LOCAL.pop();' . chr(10) . '        l[0][l[1]] = l[2];' . chr(10) . '    }' . chr(10) . '    return value;' . chr(10) . '}' . chr(10) . chr(10) . 'function p5global(sigil, namespace, name) {' . chr(10) . '    // TODO - autovivify namespace' . chr(10) . '    var vname = sigils[sigil] + name;' . chr(10) . '    var v = p5pkg[namespace][vname];' . chr(10) . '    if (v != null) {' . chr(10) . '        return v;' . chr(10) . '    }' . chr(10) . '    if (sigil == ' . chr(39) . '$' . chr(39) . ') {' . chr(10) . '        p5pkg[namespace][vname] = new p5Scalar(null);' . chr(10) . '    }' . chr(10) . '    else if (sigil == ' . chr(39) . '@' . chr(39) . ') {' . chr(10) . '        p5pkg[namespace][vname] = new p5Array([]);' . chr(10) . '    }' . chr(10) . '    else if (sigil == ' . chr(39) . '%' . chr(39) . ') {' . chr(10) . '        p5pkg[namespace][vname] = new p5Hash({});' . chr(10) . '    }' . chr(10) . '    return p5pkg[namespace][vname];' . chr(10) . '}' . chr(10) . chr(10) . 'function p5HashRef(o) {' . chr(10) . '    this._href_ = o;' . chr(10) . '    this._ref_ = "HASH";' . chr(10) . '    this.p5bool = function() { return 1 };' . chr(10) . '    this.p5string = function() {' . chr(10) . '        return "HASH(0x0000)";  // TODO' . chr(10) . '    };' . chr(10) . '    this.hderef = function() {' . chr(10) . '        return this._href_;' . chr(10) . '    };' . chr(10) . '    this.hset = function(i, v) {' . chr(10) . '        return this._href_.hset(i, v);' . chr(10) . '    };' . chr(10) . '    this.hget = function(i, autoviv) {' . chr(10) . '        return this._href_.hget(i, autoviv);' . chr(10) . '    }' . chr(10) . '}' . chr(10) . chr(10) . 'function p5ArrayRef(o) {' . chr(10) . '    this._aref_ = o;' . chr(10) . '    this._ref_ = "ARRAY";' . chr(10) . '    this.p5bool = function() { return 1 };' . chr(10) . '    this.p5string = function() {' . chr(10) . '        return "ARRAY(0x0000)";  // TODO' . chr(10) . '    };' . chr(10) . '    this.aderef = function() {' . chr(10) . '        return this._aref_;' . chr(10) . '    };' . chr(10) . '    this.aset = function(i, v) {' . chr(10) . '        return this._aref_.aset(i, v);' . chr(10) . '    }' . chr(10) . '    this.aget = function(i, autoviv) {' . chr(10) . '        return this._aref_.aget(i, autoviv);' . chr(10) . '    }' . chr(10) . '}' . chr(10) . chr(10) . 'function p5ScalarRef(o) {' . chr(10) . '    this._scalar_ = o;' . chr(10) . '    this._ref_ = "SCALAR";' . chr(10) . '    this.p5bool = function() { return 1 };' . chr(10) . '    this.p5string = function() {' . chr(10) . '        return "SCALAR(0x0000)";  // TODO' . chr(10) . '    };' . chr(10) . '    this.sderef = function() {' . chr(10) . '        return this._scalar_;' . chr(10) . '    };' . chr(10) . '}' . chr(10) . chr(10) . 'function p5GlobRef(o) {' . chr(10) . '    this._scalar_ = o;' . chr(10) . '    this._ref_ = "GLOB";' . chr(10) . '    this.p5bool = function() { return 1 };' . chr(10) . '    this.p5string = function() {' . chr(10) . '        return "GLOB(0x0000)";  // TODO' . chr(10) . '    };' . chr(10) . '}' . chr(10) . chr(10) . 'function p5Array(o) {' . chr(10) . '    // TODO - array slice' . chr(10) . '    this._array_ = o;' . chr(10) . '    this._ref_ = "";' . chr(10) . '    this.p5bool = function() {' . chr(10) . '        return this._array_.length != 0' . chr(10) . '    };' . chr(10) . '    this.p5string = function() {' . chr(10) . '        return ' . chr(39) . chr(39) . ' + this._array_.length;' . chr(10) . '    };' . chr(10) . '    this.p5num = function() {' . chr(10) . '        return this._array_.length;' . chr(10) . '    };' . chr(10) . '    this.aset = function(i, v) {' . chr(10) . '        if (i < 0) {' . chr(10) . '            i = this._array_.length + i;' . chr(10) . '        }' . chr(10) . '        if (this._array_[i] instanceof p5Scalar) {' . chr(10) . '            this._array_[i].assign(v);' . chr(10) . '        }' . chr(10) . '        else {' . chr(10) . '            if (v instanceof p5Scalar) {' . chr(10) . '                this._array_[i] = v.FETCH();' . chr(10) . '            }' . chr(10) . '            else {' . chr(10) . '                this._array_[i] = v;' . chr(10) . '            }' . chr(10) . '        }' . chr(10) . '        return v;' . chr(10) . '    };' . chr(10) . '    this.aget = function(i, autoviv) {' . chr(10) . '        if (i < 0) {' . chr(10) . '            i = this._array_.length + i;' . chr(10) . '        }' . chr(10) . '        if (autoviv) {' . chr(10) . '            if (autoviv == ' . chr(39) . 'lvalue' . chr(39) . ') {' . chr(10) . '                if (this._array_.length < i) {' . chr(10) . '                    // don' . chr(39) . 't vivify yet; create a proxy object' . chr(10) . '                    return new p5ArrayProxy(this, i);' . chr(10) . '                }' . chr(10) . '                if (!(this._array_[i] instanceof p5Scalar)) {' . chr(10) . '                    this._array_[i] = new p5Scalar(this._array_[i]);' . chr(10) . '                }' . chr(10) . '            }' . chr(10) . '            else if (autoviv == ' . chr(39) . 'array' . chr(39) . ') {' . chr(10) . '                if (!(this._array_[i] instanceof p5ArrayRef) &&' . chr(10) . '                    !(this._array_[i] instanceof p5Scalar))' . chr(10) . '                {' . chr(10) . '                    this._array_[i] = new p5ArrayRef(new p5Array([]));' . chr(10) . '                }' . chr(10) . '            }' . chr(10) . '            else if (autoviv == ' . chr(39) . 'hash' . chr(39) . ') {' . chr(10) . '                if (!(this._array_[i] instanceof p5HashRef) &&' . chr(10) . '                    !(this._array_[i] instanceof p5Scalar))' . chr(10) . '                {' . chr(10) . '                    this._array_[i] = new p5HashRef(new p5Hash({}));' . chr(10) . '                }' . chr(10) . '            }' . chr(10) . '        }' . chr(10) . '        return this._array_[i];' . chr(10) . '    };' . chr(10) . '    this.get_values = function(o) {' . chr(10) . '        // add values to the param (a native js list)' . chr(10) . '        for(var i = 0; i < this._array_.length; i++) {' . chr(10) . '            o.push(this._array_[i]);' . chr(10) . '        }' . chr(10) . '        return o;' . chr(10) . '    };' . chr(10) . '    this.get_lvalues = function(o) {' . chr(10) . '        // add lvalues to the param (a native js list)' . chr(10) . '        for(var i = 0; i < this._array_.length; i++) {' . chr(10) . '            o.push(this._array_[i] instanceof p5Scalar ? this._array_[i] : this.aget(i, "lvalue"));' . chr(10) . '        }' . chr(10) . '        return o;' . chr(10) . '    };' . chr(10) . '    this.assign = function(a) {' . chr(10) . '        if (a instanceof Array) {' . chr(10) . '            // TODO - cleanup, this shouldn' . chr(39) . 't happen' . chr(10) . '            this._array_ = a;' . chr(10) . '        }' . chr(10) . '        else {' . chr(10) . '            this._array_ = a._array_;' . chr(10) . '        }' . chr(10) . '        return this;' . chr(10) . '    };' . chr(10) . chr(10) . '    // operations that can be tie()' . chr(10) . '    this.FETCHSIZE = function() {' . chr(10) . '        return this._array_.length;' . chr(10) . '    };' . chr(10) . '    this.PUSH = function(v) {' . chr(10) . '        for(var i = 0; i < v._array_.length; i++) {' . chr(10) . '            this._array_.push(v._array_[i] instanceof p5Scalar ? v._array_[i].FETCH() :  v._array_[i]);' . chr(10) . '        }' . chr(10) . '        return this._array_.length;' . chr(10) . '    };' . chr(10) . '    this.UNSHIFT = function(v) {' . chr(10) . '        for(var i = v._array_.length-1; i >= 0; i--) {' . chr(10) . '            this._array_.unshift(v._array_[i] instanceof p5Scalar ? v._array_[i].FETCH() :  v._array_[i]);' . chr(10) . '        }' . chr(10) . '        return this._array_.length;' . chr(10) . '    };' . chr(10) . '    this.POP = function() {' . chr(10) . '        if (this._array_.length == null) {' . chr(10) . '            return null;' . chr(10) . '        }' . chr(10) . '        return this._array_.pop();' . chr(10) . '    };' . chr(10) . '    this.SHIFT = function(v) {' . chr(10) . '        if (this._array_.length == null) {' . chr(10) . '            return null;' . chr(10) . '        }' . chr(10) . '        return this._array_.shift();' . chr(10) . '    };' . chr(10) . '}' . chr(10) . chr(10) . 'function p5Hash(o) {' . chr(10) . '    // TODO - hash slice' . chr(10) . '    this._hash_ = o;' . chr(10) . '    this._ref_ = "";' . chr(10) . '    this.p5bool = function() {' . chr(10) . '        o = this._hash_;' . chr(10) . '        for (var i in o) {' . chr(10) . '            return true;' . chr(10) . '        }' . chr(10) . '        return false;' . chr(10) . '    };' . chr(10) . '    this.p5string = function() {' . chr(10) . '        return ' . chr(39) . chr(39) . ' + this.p5num() + ' . chr(39) . '/8' . chr(39) . ';' . chr(10) . '    };' . chr(10) . '    this.p5num = function() {' . chr(10) . '        var out = 0;' . chr(10) . '        for (var i in this._hash_) {' . chr(10) . '            out++;' . chr(10) . '        }' . chr(10) . '        return out;' . chr(10) . '    };' . chr(10) . '    this.exists = function(i) {' . chr(10) . '        return this._hash_.hasOwnProperty(i);' . chr(10) . '    };' . chr(10) . '    this.hset = function(i, v) {' . chr(10) . '        if (this._hash_[i] instanceof p5Scalar) {' . chr(10) . '            this._hash_[i].assign(v);' . chr(10) . '        }' . chr(10) . '        else {' . chr(10) . '            if (v instanceof p5Scalar) {' . chr(10) . '                this._hash_[i] = v.FETCH();' . chr(10) . '            }' . chr(10) . '            else {' . chr(10) . '                this._hash_[i] = v;' . chr(10) . '            }' . chr(10) . '        }' . chr(10) . '        return v;' . chr(10) . '    };' . chr(10) . '    this.hget = function(i, autoviv) {' . chr(10) . '        if (autoviv) {' . chr(10) . '            if (autoviv == ' . chr(39) . 'lvalue' . chr(39) . ') {' . chr(10) . '                if (! this._hash_.hasOwnProperty(i)) {' . chr(10) . '                    // don' . chr(39) . 't autovivify yet; create a proxy object' . chr(10) . '                    return new p5HashProxy(this, i);' . chr(10) . '                }' . chr(10) . '                if (!(this._hash_[i] instanceof p5Scalar)) {' . chr(10) . '                    this._hash_[i] = new p5Scalar(this._hash_[i]);' . chr(10) . '                }' . chr(10) . '            }' . chr(10) . '            else if (autoviv == ' . chr(39) . 'array' . chr(39) . ') {' . chr(10) . '                if (!(this._hash_[i] instanceof p5ArrayRef) &&' . chr(10) . '                    !(this._hash_[i] instanceof p5Scalar))' . chr(10) . '                {' . chr(10) . '                    this._hash_[i] = new p5ArrayRef(new p5Array([]));' . chr(10) . '                }' . chr(10) . '            }' . chr(10) . '            else if (autoviv == ' . chr(39) . 'hash' . chr(39) . ') {' . chr(10) . '                if (!(this._hash_[i] instanceof p5HashRef) &&' . chr(10) . '                    !(this._hash_[i] instanceof p5Scalar))' . chr(10) . '                {' . chr(10) . '                    this._hash_[i] = new p5HashRef(new p5Hash({}));' . chr(10) . '                }' . chr(10) . '            }' . chr(10) . '        }' . chr(10) . '        return this._hash_[i];' . chr(10) . '    };' . chr(10) . '    this.get_values = function(o) {' . chr(10) . '        // add a native list of values to the param' . chr(10) . '        for (var i in this._hash_) {' . chr(10) . '            o.push(i);' . chr(10) . '            o.push(this._hash_[i]);' . chr(10) . '        }' . chr(10) . '        return o;' . chr(10) . '    };' . chr(10) . '    this.get_lvalues = function(o) {' . chr(10) . '        // add a native list of lvalues to the param' . chr(10) . '        for (var i in this._hash_) {' . chr(10) . '            o.push(i);' . chr(10) . '            o.push(this._hash_[i] instanceof p5Scalar ? this._hash_[i] : this.hget(i, "lvalue"));' . chr(10) . '        }' . chr(10) . '        return o;' . chr(10) . '    };' . chr(10) . '    this.assign = function(h) {' . chr(10) . '        if (h instanceof p5Hash) {' . chr(10) . '            this._hash_ = h._hash_;' . chr(10) . '        }' . chr(10) . '        else {' . chr(10) . '            // TODO - cleanup, this shouldn' . chr(39) . 't happen' . chr(10) . '            this._hash_ = h;' . chr(10) . '        }' . chr(10) . '        return this;' . chr(10) . '    }' . chr(10) . '}' . chr(10) . chr(10) . 'function p5Scalar(o) {' . chr(10) . '    this._v_ = o;' . chr(10) . '    this._ref_ = "";' . chr(10) . chr(10) . '    // be a value' . chr(10) . '    this.p5bool = function() {' . chr(10) . '        return p5bool(this._v_);' . chr(10) . '    };' . chr(10) . '    this.p5string = function() {' . chr(10) . '        return p5str(this._v_);' . chr(10) . '    };' . chr(10) . '    this.p5num = function() {' . chr(10) . '        return p5num(this._v_);' . chr(10) . '    };' . chr(10) . '    this.p5code = function() {' . chr(10) . '        return p5code(this._v_);' . chr(10) . '    };' . chr(10) . '    this.p5incr = function() {' . chr(10) . '        this._v_ = p5incr(this._v_);' . chr(10) . '        return this._v_;' . chr(10) . '    };' . chr(10) . '    this.p5postincr = function() {' . chr(10) . '        var v = this._v_;' . chr(10) . '        this._v_ = p5incr(this._v_);' . chr(10) . '        return v;' . chr(10) . '    };' . chr(10) . '    this.p5decr = function() {' . chr(10) . '        this._v_ = p5decr(this._v_);' . chr(10) . '        return this._v_;' . chr(10) . '    };' . chr(10) . '    this.p5postdecr = function() {' . chr(10) . '        var v = this._v_;' . chr(10) . '        this._v_ = p5decr(this._v_);' . chr(10) . '        return v;' . chr(10) . '    };' . chr(10) . chr(10) . '    // be a scalar ref' . chr(10) . '    this.sderef = function(i) {' . chr(10) . '        // TODO - autovivify scalar (with proxy object?)' . chr(10) . '        return this._v_.sderef();' . chr(10) . '    };' . chr(10) . chr(10) . '    // be an array ref' . chr(10) . '    this.aderef = function() {' . chr(10) . '        // TODO - autovivify array (with proxy object?)' . chr(10) . '        return this._v_.aderef();' . chr(10) . '    };' . chr(10) . '    this.aget = function(i, autoviv) {' . chr(10) . '        // TODO - autovivify array (with proxy object?)' . chr(10) . '        if (this._v_ == null) {' . chr(10) . '            this._v_ = new p5ArrayRef(new p5Array([]));' . chr(10) . '        }' . chr(10) . '        return this._v_.aget(i, autoviv);' . chr(10) . '    };' . chr(10) . '    this.aset = function(i, v) {' . chr(10) . '        if (this._v_ == null) {' . chr(10) . '            this._v_ = new p5ArrayRef(new p5Array([]));' . chr(10) . '        }' . chr(10) . '        return this._v_.aset(i, v);' . chr(10) . '    };' . chr(10) . chr(10) . '    // be a hash ref' . chr(10) . '    this.hderef = function() {' . chr(10) . '        // TODO - autovivify hash (with proxy object?)' . chr(10) . '        if (this._v_ == null) {' . chr(10) . '            this._v_ = new p5HashRef(new p5Hash([]));' . chr(10) . '        }' . chr(10) . '        return this._v_.hderef();' . chr(10) . '    };' . chr(10) . '    this.hget = function(i, autoviv) {' . chr(10) . '        // TODO - autovivify hash (with proxy object?)' . chr(10) . '        if (this._v_ == null) {' . chr(10) . '            this._v_ = new p5HashRef(new p5Hash([]));' . chr(10) . '        }' . chr(10) . '        return this._v_.hget(i, autoviv);' . chr(10) . '    }' . chr(10) . '    this.hset = function(i, v) {' . chr(10) . '        if (this._v_ == null) {' . chr(10) . '            this._v_ = new p5HashRef(new p5Hash([]));' . chr(10) . '        }' . chr(10) . '        return this._v_.hset(i, v);' . chr(10) . '    }' . chr(10) . chr(10) . '    // be a container' . chr(10) . '    this.get_values = function(o) {' . chr(10) . '        // add a native list of values to the param' . chr(10) . '        o.push(this);' . chr(10) . '        return o;' . chr(10) . '    };' . chr(10) . '    this.get_lvalues = function(o) {' . chr(10) . '        // add a native list of lvalues to the param' . chr(10) . '        o.push(this);' . chr(10) . '        return o;' . chr(10) . '    };' . chr(10) . '    this.assign = function(v) {' . chr(10) . '        if (v instanceof p5Scalar) {' . chr(10) . '            this._v_ = v.FETCH();' . chr(10) . '        }' . chr(10) . '        else {' . chr(10) . '            this._v_ = v;' . chr(10) . '        }' . chr(10) . '        return this;' . chr(10) . '    };' . chr(10) . chr(10) . '    // operations that can be tie()' . chr(10) . '    this.FETCH = function() {' . chr(10) . '        // not an lvalue' . chr(10) . '        return this._v_;' . chr(10) . '    };' . chr(10) . '}' . chr(10) . chr(10) . chr(10) . 'function p5HashProxy(h, k) {' . chr(10) . '    this._hashobj_ = h;' . chr(10) . '    this._key_ = k;' . chr(10) . '    this._v_ = null;' . chr(10) . '    this.assign = function(v) {' . chr(10) . '        // write-through; alternately, use read-through' . chr(10) . '        if (v instanceof p5Scalar) {' . chr(10) . '            this._v_ = v.FETCH();' . chr(10) . '        }' . chr(10) . '        else {' . chr(10) . '            this._v_ = v;' . chr(10) . '        }' . chr(10) . '        return this._hashobj_.hset(this._key_, this._v_);' . chr(10) . '    }' . chr(10) . '}' . chr(10) . 'p5HashProxy.prototype = new p5Scalar();' . chr(10) . chr(10) . chr(10) . 'function p5ArrayProxy(a, k) {' . chr(10) . '    this._arrayobj_ = a;' . chr(10) . '    this._key_ = k;' . chr(10) . '    this._v_ = null;' . chr(10) . '    this.assign = function(v) {' . chr(10) . '        // write-through; alternately, use read-through' . chr(10) . '        if (v instanceof p5Scalar) {' . chr(10) . '            this._v_ = v.FETCH();' . chr(10) . '        }' . chr(10) . '        else {' . chr(10) . '            this._v_ = v;' . chr(10) . '        }' . chr(10) . '        return this._arrayobj_.aset(this._key_, this._v_);' . chr(10) . '    }' . chr(10) . '}' . chr(10) . 'p5ArrayProxy.prototype = new p5Scalar();' . chr(10) . chr(10) . chr(10) . 'p5param_list = function() {' . chr(10) . '    var res = [];' . chr(10) . '    for (i = 0; i < arguments.length; i++) {' . chr(10) . '        if (arguments[i] == null) {' . chr(10) . '            res.push(null)' . chr(10) . '        }' . chr(10) . '        else if (arguments[i].hasOwnProperty("get_lvalues")) {' . chr(10) . '            // container' . chr(10) . '            arguments[i].get_lvalues(res);' . chr(10) . '        }' . chr(10) . '        else if (arguments[i] instanceof Array) {' . chr(10) . '            // js Array -- possibly generated by p5context()' . chr(10) . '            // maybe too late to get lvalues -- needs more testing' . chr(10) . '            // this doesn' . chr(39) . 't handle nested Array' . chr(10) . '            o = arguments[i];' . chr(10) . '            for (j = 0; j < o.length; j++) {' . chr(10) . '                res.push(o[j]);' . chr(10) . '            }' . chr(10) . '        }' . chr(10) . '        else {' . chr(10) . '            // non-container' . chr(10) . '            res.push(arguments[i]);' . chr(10) . '        }' . chr(10) . '    }' . chr(10) . '    return res;' . chr(10) . '};' . chr(10) . chr(10) . 'p5list_to_a = function() {' . chr(10) . '    var res = [];' . chr(10) . '    for (i = 0; i < arguments.length; i++) {' . chr(10) . '        if (arguments[i] == null) {' . chr(10) . '            res.push(null)' . chr(10) . '        }' . chr(10) . '        else if (arguments[i].hasOwnProperty("get_values")) {' . chr(10) . '            // container' . chr(10) . '            arguments[i].get_values(res);' . chr(10) . '        }' . chr(10) . '        else if (arguments[i] instanceof Array) {' . chr(10) . '            // js Array -- possibly generated by p5context()' . chr(10) . '            o = arguments[i];' . chr(10) . '            for (j = 0; j < o.length; j++) {' . chr(10) . '                res.push(o[j]);' . chr(10) . '            }' . chr(10) . '        }' . chr(10) . '        else {' . chr(10) . '            // non-container' . chr(10) . '            res.push(arguments[i]);' . chr(10) . '        }' . chr(10) . '    }' . chr(10) . '    return res;' . chr(10) . '};' . chr(10) . chr(10) . 'p5a_to_h = function(a) {' . chr(10) . '    var res = {};' . chr(10) . '    for (i = 0; i < a.length; i+=2) {' . chr(10) . '        res[p5str(a[i])] = a[i+1];' . chr(10) . '    }' . chr(10) . '    return res;' . chr(10) . '};' . chr(10) . chr(10) . 'if (isNode) {' . chr(10) . '    var fs = require("fs");' . chr(10) . '}' . chr(10) . chr(10) . 'p5context = function(List__, p5want) {' . chr(10) . '    if (p5want) {' . chr(10) . '        return p5list_to_a.apply(null, List__);' . chr(10) . '    }' . chr(10) . '    // scalar: return the last value' . chr(10) . '    var o = List__;' . chr(10) . '    while (o instanceof Array) {' . chr(10) . '        o =   o.length' . chr(10) . '            ? o[o.length-1]' . chr(10) . '            : null;' . chr(10) . '    }' . chr(10) . '    return o;' . chr(10) . '}' . chr(10) . chr(10) . 'p5code = function(o) {' . chr(10) . '    if (typeof o === "function") {' . chr(10) . '        return o;' . chr(10) . '    }' . chr(10) . '    return o.p5code();' . chr(10) . '};' . chr(10) . chr(10) . 'p5str = function(o) {' . chr(10) . '    if (o == null) {' . chr(10) . '        return "";' . chr(10) . '    }' . chr(10) . '    if (typeof o === "object" && (o instanceof Array)) {' . chr(10) . '        return CORE.join(["", o]);' . chr(10) . '    }' . chr(10) . '    if (typeof o.p5string === "function") {' . chr(10) . '        return o.p5string();' . chr(10) . '    }' . chr(10) . '    if (typeof o == "number" && Math.abs(o) < 0.0001 && o != 0) {' . chr(10) . '        return o.toExponential().replace(/e-(' . chr(92) . 'd)$/,"e-0$1");' . chr(10) . '    }' . chr(10) . '    if (typeof o === "boolean") {' . chr(10) . '        return o ? "1" : "";' . chr(10) . '    }' . chr(10) . '    if (typeof o !== "string") {' . chr(10) . '        return "" + o;' . chr(10) . '    }' . chr(10) . '    return o;' . chr(10) . '};' . chr(10) . chr(10) . 'p5num = function(o) {' . chr(10) . '    if (o == null) {' . chr(10) . '        return 0;' . chr(10) . '    }' . chr(10) . '    if (typeof o === "object" && (o instanceof Array)) {' . chr(10) . '        return o.length;' . chr(10) . '    }' . chr(10) . '    if (typeof o.p5num === "function") {' . chr(10) . '        return o.p5num();' . chr(10) . '    }' . chr(10) . '    if (typeof o !== "number") {' . chr(10) . '        return parseFloat(p5str(o));' . chr(10) . '    }' . chr(10) . '    return o;' . chr(10) . '};' . chr(10) . chr(10) . 'p5bool = function(o) {' . chr(10) . '    if (o) {' . chr(10) . '        if (typeof o === "boolean") {' . chr(10) . '            return o;' . chr(10) . '        }' . chr(10) . '        if (typeof o === "number") {' . chr(10) . '            return o;' . chr(10) . '        }' . chr(10) . '        if (typeof o === "string") {' . chr(10) . '            return o != "" && o != "0";' . chr(10) . '        }' . chr(10) . '        if (typeof o.p5bool === "function") {' . chr(10) . '            return o.p5bool();' . chr(10) . '        }' . chr(10) . '        if (typeof o.length === "number") {' . chr(10) . '            return o.length;' . chr(10) . '        }' . chr(10) . '        if (o instanceof Error) {' . chr(10) . '            return true;' . chr(10) . '        }' . chr(10) . '        for (var i in o) {' . chr(10) . '            return true;' . chr(10) . '        }' . chr(10) . '    }' . chr(10) . '    return false;' . chr(10) . '};' . chr(10) . chr(10) . 'p5incr = function(o) {' . chr(10) . '    if (typeof o === "number") {' . chr(10) . '        return o + 1;' . chr(10) . '    }' . chr(10) . '    return p5str_inc(p5str(o));' . chr(10) . '};' . chr(10) . chr(10) . 'p5decr = function(o) {' . chr(10) . '    if (typeof o === "number") {' . chr(10) . '        return o - 1;' . chr(10) . '    }' . chr(10) . '    return p5num(o) - 1;' . chr(10) . '};' . chr(10) . chr(10) . 'p5and = function(a, fb) {' . chr(10) . '    if (p5bool(a)) {' . chr(10) . '        return fb();' . chr(10) . '    }' . chr(10) . '    return a;' . chr(10) . '};' . chr(10) . chr(10) . 'p5or = function(a, fb) {' . chr(10) . '    if (p5bool(a)) {' . chr(10) . '        return a;' . chr(10) . '    }' . chr(10) . '    return fb();' . chr(10) . '};' . chr(10) . chr(10) . 'p5defined_or = function(a, fb) {' . chr(10) . '    if (a == null) {' . chr(10) . '        return fb();' . chr(10) . '    }' . chr(10) . '    return a;' . chr(10) . '};' . chr(10) . chr(10) . 'p5cmp = function(a, b) {' . chr(10) . '    return a > b ? 1 : a < b ? -1 : 0 ' . chr(10) . '};' . chr(10) . chr(10) . 'p5complement = function(a) {' . chr(10) . '    return a < 0 ? ~a : 4294967295 - a' . chr(10) . '    // return a < 0 ? ~a : 18446744073709551615 - a' . chr(10) . '};' . chr(10) . chr(10) . 'p5str_replicate = function(o, n) {' . chr(10) . '    n = p5num(n);' . chr(10) . '    return n ? Array(n + 1).join(o) : "";' . chr(10) . '};' . chr(10) . chr(10) . 'p5str_inc = function(s) {' . chr(10) . '    s = p5str(s);' . chr(10) . '    if (s.length < 2) {' . chr(10) . '        if (s.match(/[012345678ABCDEFGHIJKLMNOPQRSTUVWXYabcdefghijklmnopqrstuvwxy]/)) {' . chr(10) . '            return String.fromCharCode(s.charCodeAt(0) + 1);' . chr(10) . '        }' . chr(10) . '        if (s == "9") {' . chr(10) . '            return "10";' . chr(10) . '        }' . chr(10) . '        if (s == "Z") {' . chr(10) . '            return "AA";' . chr(10) . '        }' . chr(10) . '        if (s == "z") {' . chr(10) . '            return "aa";' . chr(10) . '        }' . chr(10) . '        return "1";' . chr(10) . '    }' . chr(10) . '    var c = p5str_inc(s.substr(s.length-1, 1));' . chr(10) . '    if (c.length == 1) {' . chr(10) . '        return s.substr(0, s.length-1) + c;' . chr(10) . '    }' . chr(10) . '    return p5str_inc(s.substr(0, s.length-1)) + c.substr(c.length-1, 1);' . chr(10) . '};' . chr(10) . chr(10) . 'p5for = function(namespace, func, args, cont, label) {' . chr(10) . '    var _redo = false;' . chr(10) . chr(10) . '    var v_old = namespace["v__"];' . chr(10) . '    namespace["v__"] = new p5Scalar(null);' . chr(10) . chr(10) . '    for(var i = 0; i < args.length; i++) {' . chr(10) . '        namespace["v__"].assign(args[i]);   // ??? - should this be a bind?' . chr(10) . '        try {' . chr(10) . '            func()' . chr(10) . '        }' . chr(10) . '        catch(err) {' . chr(10) . '            if (err instanceof p5_error && err.v == label) {' . chr(10) . '                if (err.type == ' . chr(39) . 'last' . chr(39) . ') { return }' . chr(10) . '                else if (err.type == ' . chr(39) . 'redo' . chr(39) . ') { i--; _redo = true }' . chr(10) . '                else if (err.type != ' . chr(39) . 'next' . chr(39) . ') { throw(err) }' . chr(10) . '            }' . chr(10) . '            else {' . chr(10) . '                throw(err)' . chr(10) . '            }' . chr(10) . '        }' . chr(10) . '        if (cont) {' . chr(10) . '            try {' . chr(10) . '                if (!_redo) { cont() }' . chr(10) . '            }' . chr(10) . '            catch(err) {' . chr(10) . '                if (err instanceof p5_error && err.v == label) {' . chr(10) . '                    if (err.type == ' . chr(39) . 'last' . chr(39) . ') { return }' . chr(10) . '                    else if (err.type == ' . chr(39) . 'redo' . chr(39) . ') { _redo = true }' . chr(10) . '                    else if (err.type != ' . chr(39) . 'next' . chr(39) . ') { throw(err) }' . chr(10) . '                }            ' . chr(10) . '                else {' . chr(10) . '                    throw(err)' . chr(10) . '                }' . chr(10) . '            }' . chr(10) . '        }' . chr(10) . '    }' . chr(10) . '    namespace["v__"] = v_old;' . chr(10) . '};' . chr(10) . chr(10) . 'p5for_lex = function(func, args, cont, label) {' . chr(10) . '    var _redo = false;' . chr(10) . '    var _arg  = new p5Scalar(null);' . chr(10) . '    for(var i = 0; i < args.length; i++) {' . chr(10) . '        try {' . chr(10) . '            _arg.assign(args[i]);' . chr(10) . '            func(_arg)' . chr(10) . '        }' . chr(10) . '        catch(err) {' . chr(10) . '            if (err instanceof p5_error && err.v == label) {' . chr(10) . '                if (err.type == ' . chr(39) . 'last' . chr(39) . ') { return }' . chr(10) . '                else if (err.type == ' . chr(39) . 'redo' . chr(39) . ') { i--; _redo = true }' . chr(10) . '                else if (err.type != ' . chr(39) . 'next' . chr(39) . ') { throw(err) }' . chr(10) . '            }            ' . chr(10) . '            else {' . chr(10) . '                throw(err)' . chr(10) . '            }' . chr(10) . '        }' . chr(10) . '        if (cont) {' . chr(10) . '            try {' . chr(10) . '                if (!_redo) { cont() }' . chr(10) . '            }' . chr(10) . '            catch(err) {' . chr(10) . '                if (err instanceof p5_error && err.v == label) {' . chr(10) . '                    if (err.type == ' . chr(39) . 'last' . chr(39) . ') { return }' . chr(10) . '                    else if (err.type == ' . chr(39) . 'redo' . chr(39) . ') { _redo = true }' . chr(10) . '                    else if (err.type != ' . chr(39) . 'next' . chr(39) . ') { throw(err) }' . chr(10) . '                }            ' . chr(10) . '                else {' . chr(10) . '                    throw(err)' . chr(10) . '                }' . chr(10) . '            }' . chr(10) . '        }' . chr(10) . '    }' . chr(10) . '};' . chr(10) . chr(10) . 'p5while = function(func, cond, cont, label) {' . chr(10) . '    var _redo = false;' . chr(10) . '    while (_redo || p5bool(cond())) {' . chr(10) . '        _redo = false;' . chr(10) . '        try {' . chr(10) . '            func()' . chr(10) . '        }' . chr(10) . '        catch(err) {' . chr(10) . '            if (err instanceof p5_error && err.v == label) {' . chr(10) . '                if (err.type == ' . chr(39) . 'last' . chr(39) . ') { return }' . chr(10) . '                else if (err.type == ' . chr(39) . 'redo' . chr(39) . ') { _redo = true }' . chr(10) . '                else if (err.type != ' . chr(39) . 'next' . chr(39) . ') { throw(err) }' . chr(10) . '            }            ' . chr(10) . '            else {' . chr(10) . '                throw(err)' . chr(10) . '            }' . chr(10) . '        }' . chr(10) . '        if (cont) {' . chr(10) . '            try {' . chr(10) . '                if (!_redo) { cont() }' . chr(10) . '            }' . chr(10) . '            catch(err) {' . chr(10) . '                if (err instanceof p5_error && err.v == label) {' . chr(10) . '                    if (err.type == ' . chr(39) . 'last' . chr(39) . ') { return }' . chr(10) . '                    else if (err.type == ' . chr(39) . 'redo' . chr(39) . ') { _redo = true }' . chr(10) . '                    else if (err.type != ' . chr(39) . 'next' . chr(39) . ') { throw(err) }' . chr(10) . '                }            ' . chr(10) . '                else {' . chr(10) . '                    throw(err)' . chr(10) . '                }' . chr(10) . '            }' . chr(10) . '        }' . chr(10) . '    }' . chr(10) . '};' . chr(10) . chr(10) . 'p5map = function(namespace, func, args) {' . chr(10) . '    var v_old = namespace["v__"];' . chr(10) . '    namespace["v__"] = new p5Scalar(null);' . chr(10) . chr(10) . '    var out = [];' . chr(10) . '    for(var i = 0; i < args.length; i++) {' . chr(10) . '        namespace["v__"].assign(args[i]);' . chr(10) . '        var o = p5list_to_a(func(1));' . chr(10) . '        for(var j = 0; j < o.length; j++) {' . chr(10) . '            out.push(o[j]);' . chr(10) . '        }' . chr(10) . '    }' . chr(10) . '    namespace["v__"] = v_old;' . chr(10) . '    return out;' . chr(10) . '};' . chr(10) . chr(10) . 'p5grep = function(namespace, func, args) {' . chr(10) . '    var v_old = namespace["v__"];' . chr(10) . '    namespace["v__"] = new p5Scalar(null);' . chr(10) . chr(10) . '    var out = [];' . chr(10) . '    for(var i = 0; i < args.length; i++) {' . chr(10) . '        namespace["v__"].assign(args[i]);' . chr(10) . '        if (p5bool(func(0))) {' . chr(10) . '            out.push(args[i])' . chr(10) . '        }' . chr(10) . '    }' . chr(10) . '    namespace["v__"] = v_old;' . chr(10) . '    return out;' . chr(10) . '};' . chr(10) . chr(10) . 'p5sort = function(namespace, func, args) {' . chr(10) . '    var a_old = namespace["v_a"];' . chr(10) . '    var b_old = namespace["v_b"];' . chr(10) . '    namespace["v_a"] = new p5Scalar(null);' . chr(10) . '    namespace["v_b"] = new p5Scalar(null);' . chr(10) . chr(10) . '    var out = ' . chr(10) . '        func == null' . chr(10) . '        ? args.sort()' . chr(10) . '        : args.sort(' . chr(10) . '            function(a, b) {' . chr(10) . '                namespace["v_a"].assign(a);' . chr(10) . '                namespace["v_b"].assign(b);' . chr(10) . '                return func(0);' . chr(10) . '            }' . chr(10) . '        );' . chr(10) . '    namespace["v_a"] = a_old;' . chr(10) . '    namespace["v_b"] = b_old;' . chr(10) . '    return out;' . chr(10) . '};' . chr(10) . chr(10) . 'perl5_to_js = function( source, namespace, var_env_js, p5want ) {' . chr(10) . '    // CORE.say(["source: [" + source + "]"]);' . chr(10) . chr(10) . '    var strict_old = p5global("$", "Perlito5", "STRICT").FETCH();' . chr(10) . chr(10) . '    var namespace_old = p5global("$", "Perlito5", "PKG_NAME").FETCH();' . chr(10) . '    p5pkg["Perlito5"].v_PKG_NAME.assign(namespace);' . chr(10) . chr(10) . '    match = p5call(p5pkg["Perlito5::Grammar"], "exp_stmts", [source, 0]);' . chr(10) . chr(10) . '    if ( !p5bool(match) || p5str(match.hget("to")) != source.length ) {' . chr(10) . '        CORE.die(["Syntax error in eval near pos ", match.hget("to") ]);' . chr(10) . '    }' . chr(10) . chr(10) . '    ast = p5pkg.CORE.bless([' . chr(10) . '        new p5HashRef(new p5Hash({' . chr(10) . '            code: "do",' . chr(10) . '            arguments: [ p5pkg.CORE.bless([' . chr(10) . '                        new p5HashRef(new p5Hash({' . chr(10) . '                            stmts:   p5pkg["Perlito5::Match"].flat([match])' . chr(10) . '                        })),' . chr(10) . '                        p5pkg["Perlito5::AST::Block"]' . chr(10) . '                    ]) ]' . chr(10) . '        })),' . chr(10) . '        p5pkg["Perlito5::AST::Apply"]' . chr(10) . '    ]);' . chr(10) . chr(10) . '    // CORE.say(["ast: [" + ast + "]"]);' . chr(10) . '    js_code = p5call(ast, "emit_javascript3", [0, p5want]);' . chr(10) . '    // CORE.say(["js-source: [" + js_code + "]"]);' . chr(10) . chr(10) . '    p5pkg["Perlito5"].v_PKG_NAME.assign(namespace_old);' . chr(10) . '    p5pkg["Perlito5"].v_STRICT.assign(strict_old);' . chr(10) . '    return js_code;' . chr(10) . '}' . chr(10) . chr(10)
}
1;
# use Perlito5::Javascript3::Runtime
package main;
undef();
package Perlito5::Javascript3::CORE;
sub Perlito5::Javascript3::CORE::emit_javascript3 {
    return '//' . chr(10) . '//' . chr(10) . '// lib/Perlito5/Javascript3/CORE.js' . chr(10) . '//' . chr(10) . '// CORE functions for "Perlito" Perl5-in-Javascript3' . chr(10) . '//' . chr(10) . '// AUTHORS' . chr(10) . '//' . chr(10) . '// Flavio Soibelmann Glock  fglock@gmail.com' . chr(10) . '//' . chr(10) . '// COPYRIGHT' . chr(10) . '//' . chr(10) . '// Copyright 2009, 2010, 2011, 2012 by Flavio Soibelmann Glock and others.' . chr(10) . '//' . chr(10) . '// This program is free software; you can redistribute it and/or modify it' . chr(10) . '// under the same terms as Perl itself.' . chr(10) . '//' . chr(10) . '// See http://www.perl.com/perl/misc/Artistic.html' . chr(10) . chr(10) . 'var CORE = p5pkg.CORE;' . chr(10) . chr(10) . 'var isNode = typeof require != "undefined";' . chr(10) . 'if (isNode) {' . chr(10) . '    CORE.print = function(List__) {' . chr(10) . '        var i;' . chr(10) . '        for (i = 0; i < List__.length; i++) {' . chr(10) . '            process.stdout.write(p5str(List__[i]));' . chr(10) . '        }' . chr(10) . '        return 1;' . chr(10) . '    }' . chr(10) . '} else {' . chr(10) . '    CORE.print = function(List__) {' . chr(10) . '        var i;' . chr(10) . '        for (i = 0; i < List__.length; i++) {' . chr(10) . '            write(p5str(List__[i]));' . chr(10) . '        }' . chr(10) . '        return 1;' . chr(10) . '    };' . chr(10) . '}' . chr(10) . chr(10) . 'CORE.say = function(List__) {' . chr(10) . '    CORE.print(List__);' . chr(10) . '    return CORE.print(["' . chr(92) . 'n"]);' . chr(10) . '};' . chr(10) . chr(10) . 'CORE.die = function(List__) {' . chr(10) . '    var o = List__[0]._array_;   // prototype is ' . chr(39) . '@' . chr(39) . chr(10) . '    var i;' . chr(10) . '    var s = "";' . chr(10) . '    for (i = 0; i < o.length; i++) {' . chr(10) . '        s = s + p5str(o[i]);' . chr(10) . '    }' . chr(10) . '    try {' . chr(10) . '        s = s + "' . chr(92) . 'n" + new Error().stack;' . chr(10) . '    }' . chr(10) . '    catch(err) { }' . chr(10) . '    p5pkg["main"]["v_@"].assign("Died: " + s);' . chr(10) . '    throw(new p5_error("die", "Died: " + s));' . chr(10) . '};' . chr(10) . chr(10) . 'CORE.warn = function(List__) {' . chr(10) . '    var o = List__[0]._array_;   // prototype is ' . chr(39) . '@' . chr(39) . chr(10) . '    var i;' . chr(10) . '    var s = "";' . chr(10) . '    for (i = 0; i < o.length; i++) {' . chr(10) . '        s = s + p5str(o[i]);' . chr(10) . '    }' . chr(10) . '    try {' . chr(10) . '        s = s + "' . chr(92) . 'n" + new Error().stack;' . chr(10) . '    }' . chr(10) . '    catch(err) { }' . chr(10) . '    CORE.print(["Warning: " + s + "' . chr(92) . 'n"]);' . chr(10) . '};' . chr(10) . chr(10) . 'CORE.bless = function(List__) {' . chr(10) . '    var o        = List__[0];' . chr(10) . '    var pkg_name = List__[1];' . chr(10) . '    if (o instanceof p5Scalar) {' . chr(10) . '        o = o.FETCH();' . chr(10) . '    }' . chr(10) . '    if (pkg_name instanceof p5Scalar) {' . chr(10) . '        pkg_name = pkg_name.FETCH();' . chr(10) . '    }' . chr(10) . '    if (typeof pkg_name === "object") {' . chr(10) . '        // bless {}, Class' . chr(10) . '        o._class_ = pkg_name;' . chr(10) . '        return o;' . chr(10) . '    }' . chr(10) . '    if (!p5pkg.hasOwnProperty(pkg_name)) {' . chr(10) . '        p5make_package(pkg_name);' . chr(10) . '    }' . chr(10) . '    o._class_ = p5pkg[pkg_name];' . chr(10) . '    return o;' . chr(10) . '};' . chr(10) . chr(10) . 'CORE.caller = function(List__, p5want) {' . chr(10) . '    if (p5want) {' . chr(10) . '        return p5pkg["Perlito5"]["CALLER"][0];' . chr(10) . '    }' . chr(10) . '    return p5pkg["Perlito5"]["CALLER"][0][0];' . chr(10) . '};' . chr(10) . chr(10) . 'CORE.chr = function(List__) {' . chr(10) . '    var v = p5num(List__[0]);' . chr(10) . '    return String.fromCharCode(v >= 0 ? v : 65533);' . chr(10) . '};' . chr(10) . chr(10) . 'CORE.ord = function(List__) {' . chr(10) . '    return p5str(List__[0]).charCodeAt(0);' . chr(10) . '};' . chr(10) . chr(10) . 'CORE.oct = function(List__) {' . chr(10) . '    var v = p5str(List__[0]);' . chr(10) . '    var b = v.substr(0,2);' . chr(10) . '    v = v.replace("_", "");' . chr(10) . '    if (b == "0b" || b == "0B") { return parseInt(v.substr(2), 2)  }' . chr(10) . '    if (b == "0x" || b == "0X") { return parseInt(v.substr(2), 16) }' . chr(10) . '    return parseInt(v, 8);' . chr(10) . '};' . chr(10) . chr(10) . 'CORE.abs   = function(List__) { return Math.abs(p5num(List__[0])) };' . chr(10) . 'CORE.exp   = function(List__) { return Math.exp(p5num(List__[0])) };' . chr(10) . 'CORE.log   = function(List__) { return Math.log(p5num(List__[0])) };' . chr(10) . 'CORE.cos   = function(List__) { return Math.cos(p5num(List__[0])) };' . chr(10) . 'CORE.sin   = function(List__) { return Math.sin(p5num(List__[0])) };' . chr(10) . 'CORE.sqrt  = function(List__) { return Math.sqrt(p5num(List__[0])) };' . chr(10) . 'CORE.atan2 = function(List__) { return Math.atan2(p5num(List__[0]), p5num(List__[1])) };' . chr(10) . 'CORE.int   = function(List__) { ' . chr(10) . '    var v = p5num(List__[0]);' . chr(10) . '    return v > 0 ? Math.floor(v) : Math.ceil(v)' . chr(10) . '};' . chr(10) . chr(10) . 'CORE.rand = function(List__) {' . chr(10) . '    var v = p5num(List__[0]) || 1;' . chr(10) . '    return Math.random() * v;' . chr(10) . '};' . chr(10) . chr(10) . 'CORE.lc      = function(List__) { return p5str(List__[0]).toLowerCase() };' . chr(10) . 'CORE.uc      = function(List__) { return p5str(List__[0]).toUpperCase() };' . chr(10) . chr(10) . 'CORE.lcfirst = function(List__) {' . chr(10) . '    var s = p5str(List__[0]);' . chr(10) . '    var c = s.length > 0 ? s.slice(0,1).toLowerCase() : "";' . chr(10) . '    s = s.length > 1 ? s.substr(1) : "";' . chr(10) . '    return c + s' . chr(10) . '};' . chr(10) . chr(10) . 'CORE.ucfirst = function(List__) {' . chr(10) . '    var s = p5str(List__[0]);' . chr(10) . '    var c = s.length > 0 ? s.slice(0,1).toUpperCase() : "";' . chr(10) . '    s = s.length > 1 ? s.substr(1) : "";' . chr(10) . '    return c + s' . chr(10) . '};' . chr(10) . chr(10) . 'CORE.quotemeta = function(List__) {' . chr(10) . '    var s = p5str(List__[0]);' . chr(10) . '    var out = [];' . chr(10) . '    for(var i = 0; i < s.length; i++) {' . chr(10) . '        if (s.substr(i, 1).match(/[^0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz]/)) {' . chr(10) . '            out.push(String.fromCharCode(92));' . chr(10) . '        }' . chr(10) . '        out.push(s.substr(i, 1));' . chr(10) . '    }' . chr(10) . '    return out.join("");       ' . chr(10) . '};' . chr(10) . chr(10) . 'CORE.substr = function(List__) {' . chr(10) . chr(10) . '    // TODO - lvalue substr()' . chr(10) . chr(10) . '    var s           = p5str(List__[0]);' . chr(10) . '    var offset      = p5num(List__[1]);' . chr(10) . '    var length      = List__.length > 2 ? p5num(List__[2]) : s.length;' . chr(10) . '    var replacement = List__[3];' . chr(10) . chr(10) . '    if (length < 0) {' . chr(10) . '        length = s.length - offset + length;' . chr(10) . '    }' . chr(10) . '    return s.substr(offset, length);' . chr(10) . '};' . chr(10) . chr(10) . 'CORE.defined = function(List__) {' . chr(10) . '    return (List__[0] instanceof p5Scalar) ? ( List__[0].FETCH() != null ) : ( List__[0] != null )' . chr(10) . '};' . chr(10) . chr(10) . 'CORE.values = function(List__, p5want) {' . chr(10) . '    var o = List__[0]._hash_;' . chr(10) . '    delete o["_each_"];' . chr(10) . '    if (p5want) {' . chr(10) . '        if (o == null) {' . chr(10) . '            return new p5Array([]);' . chr(10) . '        };' . chr(10) . '        if (typeof o.values === "function") {' . chr(10) . '            return o.values();' . chr(10) . '        }' . chr(10) . '        var out = [];' . chr(10) . '        for (var i in o) {' . chr(10) . '            out.push(o[i]);' . chr(10) . '        }' . chr(10) . '        return new p5Array(out);' . chr(10) . '    }' . chr(10) . '    return CORE.keys(List__, p5want);' . chr(10) . '};' . chr(10) . chr(10) . 'CORE.keys = function(List__, p5want) {' . chr(10) . '    var o = List__[0]._hash_;' . chr(10) . '    delete o["_each_"];' . chr(10) . '    if (p5want) {' . chr(10) . '        if (o == null) {' . chr(10) . '            return new p5Array([]);' . chr(10) . '        }' . chr(10) . '        if (typeof o.keys === "function") {' . chr(10) . '            return o.keys();' . chr(10) . '        }' . chr(10) . '        var out = [];' . chr(10) . '        for (var i in o) {' . chr(10) . '            out.push(i);' . chr(10) . '        }' . chr(10) . '        return new p5Array(out);' . chr(10) . '    }' . chr(10) . '    else {' . chr(10) . '        if (o == null) {' . chr(10) . '            return 0;' . chr(10) . '        }' . chr(10) . '        if (typeof o.keys === "function") {' . chr(10) . '            return CORE.scalar([o.keys()]);' . chr(10) . '        }' . chr(10) . '        var out = 0;' . chr(10) . '        for (var i in o) {' . chr(10) . '            out++;' . chr(10) . '        }' . chr(10) . '        return out;' . chr(10) . '    }' . chr(10) . '};' . chr(10) . chr(10) . 'CORE.each = function(List__, p5want) {' . chr(10) . '    var o = List__[0];' . chr(10) . '    if (o.hasOwnProperty("_each_")) {' . chr(10) . '        return o._each_(p5want)' . chr(10) . '    }' . chr(10) . '    var keys = CORE.keys([o], 1);' . chr(10) . '    var i = 0;' . chr(10) . '    o._each_ = function () {' . chr(10) . '        if (i < keys.length) {' . chr(10) . '            i++;' . chr(10) . '            return p5want ? [keys[i-1], o[keys[i-1]]] : keys[i-1];' . chr(10) . '        }' . chr(10) . '        i = 0;' . chr(10) . '        return p5want ? [] : null;' . chr(10) . '    };' . chr(10) . '    return o._each_(p5want);' . chr(10) . '};' . chr(10) . chr(10) . 'CORE.reverse = function(List__) {' . chr(10) . '    var o = List__[0];' . chr(10) . '    if (o instanceof p5Scalar) {' . chr(10) . '        o = o.FETCH();' . chr(10) . '    }' . chr(10) . '    if (o == null) {' . chr(10) . '        return "";' . chr(10) . '    }' . chr(10) . '    if (typeof o === "string") {' . chr(10) . '        return o.split("").reverse().join("")' . chr(10) . '    }' . chr(10) . '    var out = [];' . chr(10) . '    for(var i = 0; i < o.length; i++) {' . chr(10) . '        out.unshift(o[i]);' . chr(10) . '    }' . chr(10) . '    return out;' . chr(10) . '};' . chr(10) . chr(10) . 'CORE.splice = function(List__, p5want) {' . chr(10) . '    var array  = List__.shift()._array_;' . chr(10) . '    // CORE.say([ array ]);' . chr(10) . '    var offset = p5num(List__.shift());' . chr(10) . '    var limit  = List__.length ? p5num(List__.shift()) : (array.length + 1);' . chr(10) . chr(10) . '    if (limit < 0) {' . chr(10) . '        limit = array.length + limit - 1;' . chr(10) . '    }' . chr(10) . chr(10) . '    var list = [offset, limit];' . chr(10) . '    for(var i = 0; i < List__.length; i++) {' . chr(10) . '        list = p5list_to_a( list, List__[i]);' . chr(10) . '    }' . chr(10) . chr(10) . '    out = array.splice.apply(array, list);' . chr(10) . '    // CORE.say([ CORE.join([":",array]), " ofs=", offset, " lim=", limit, " list=", list, " out=", CORE.join([":",out])  ]);' . chr(10) . '    return p5want ? out : out.pop();' . chr(10) . '};' . chr(10) . chr(10) . 'CORE.pop = function(List__) {' . chr(10) . '    return List__[0].POP();' . chr(10) . '};' . chr(10) . chr(10) . 'CORE.shift = function(List__) {' . chr(10) . '    return List__[0].SHIFT();' . chr(10) . '};' . chr(10) . chr(10) . 'CORE.push = function(List__) {' . chr(10) . '    return List__[0].PUSH(List__[1]);' . chr(10) . '};' . chr(10) . chr(10) . 'CORE.unshift = function(List__) {' . chr(10) . '    return List__[0].UNSHIFT(List__[1]);' . chr(10) . '};' . chr(10) . chr(10) . 'CORE.join = function(List__) {' . chr(10) . '    var s = List__[0];' . chr(10) . '    var o = List__[1]._array_;' . chr(10) . '    var a = [];' . chr(10) . '    for (i = 0; i < o.length; i++) {' . chr(10) . '        a.push( p5str(o[i]) );' . chr(10) . '    }' . chr(10) . '    return a.join(s);' . chr(10) . '};' . chr(10) . chr(10) . 'CORE.index = function(List__) {' . chr(10) . '    try {' . chr(10) . '        return p5str(List__[0]).indexOf(p5str(List__[1]), p5num(List__[2]));' . chr(10) . '    }' . chr(10) . '    catch(err) {' . chr(10) . '        return -1;' . chr(10) . '    }' . chr(10) . '};' . chr(10) . 'CORE.rindex = function(List__) {' . chr(10) . '    var o = p5str(List__[0]);' . chr(10) . '    var s = List__[1];' . chr(10) . '    try {' . chr(10) . '        if (List__.length > 2) {' . chr(10) . '            var i = p5num(List__[2]);' . chr(10) . '            if (i < 0) {' . chr(10) . '                if (s.length == 0) {' . chr(10) . '                    return 0;' . chr(10) . '                }' . chr(10) . '                return -1;' . chr(10) . '            }' . chr(10) . '            return o.lastIndexOf(s, i);' . chr(10) . '        }' . chr(10) . '        return o.lastIndexOf(s);' . chr(10) . '    }' . chr(10) . '    catch(err) {' . chr(10) . '        return -1;' . chr(10) . '    }' . chr(10) . '};' . chr(10) . chr(10) . 'CORE.length = function(List__) {' . chr(10) . '    var o = p5str(List__[0]);' . chr(10) . '    return o.length;' . chr(10) . '};' . chr(10) . chr(10) . 'CORE.pack    = function(List__) { CORE.warn([ "CORE::pack not implemented" ]) };' . chr(10) . 'CORE.unpack  = function(List__) { CORE.warn([ "CORE::unpack not implemented" ]) };' . chr(10) . chr(10) . 'CORE.ref = function(List__) {' . chr(10) . '    var o = List__[0];' . chr(10) . '    if (o instanceof p5Scalar) {' . chr(10) . '        o = o.FETCH();' . chr(10) . '    }' . chr(10) . '    if (o == null) {' . chr(10) . '        return "";' . chr(10) . '    }' . chr(10) . '    if (o._class_ && typeof o._class_._ref_ === "string") {' . chr(10) . '        // blessed reference' . chr(10) . '        return o._class_._ref_;' . chr(10) . '    }' . chr(10) . '    if (typeof o._ref_ === "string") {' . chr(10) . '        // un-blessed reference' . chr(10) . '        return o._ref_;' . chr(10) . '    }' . chr(10) . '    if (typeof o === "function") {' . chr(10) . '        return "CODE";' . chr(10) . '    }' . chr(10) . '    return "";' . chr(10) . '};' . chr(10) . chr(10) . 'CORE.split = function(List__) {' . chr(10) . '    var pattern = List__[0];' . chr(10) . '    var s       = p5str(List__[1]);' . chr(10) . '    var limit   = List__[2];' . chr(10) . '    if (typeof pattern === "string") {' . chr(10) . '        if (pattern == " ") {' . chr(10) . '            var res = [];' . chr(10) . '            for (var i_ = 0, a_ = s.split(/(?: |' . chr(92) . 'n)+/); i_ < a_.length ; i_++) {' . chr(10) . '                if (a_[i_] != "") {' . chr(10) . '                    res.push(a_[i_])' . chr(10) . '                }' . chr(10) . '            }' . chr(10) . '            return res;' . chr(10) . '        }' . chr(10) . '        return s.split(pattern);' . chr(10) . '    }' . chr(10) . '    CORE.die(["not implemented"]);' . chr(10) . '};' . chr(10) . chr(10) . 'CORE.prototype = function(List__, data) {' . chr(10) . '    var name = List__[0];' . chr(10) . '    // TODO - fully qualify "name" using information from "data"' . chr(10) . '    // XXX - lookup in CORE::GLOBAL?' . chr(10) . '    p5pkg["Perlito5"].v_PROTO._hash_[name] || p5pkg["Perlito5"].v_CORE_PROTO._hash_[name]' . chr(10) . '};' . chr(10) . chr(10)
}
1;
# use Perlito5::Javascript3::CORE
package main;
undef();
package Perlito5::Javascript3::IO;
sub Perlito5::Javascript3::IO::emit_javascript3 {
    return '//' . chr(10) . '//' . chr(10) . '// lib/Perlito5/Javascript3/IO.js' . chr(10) . '//' . chr(10) . '// I/O functions for "Perlito" Perl5-in-Javascript3' . chr(10) . '//' . chr(10) . '// AUTHORS' . chr(10) . '//' . chr(10) . '// Flavio Soibelmann Glock  fglock@gmail.com' . chr(10) . '//' . chr(10) . '// COPYRIGHT' . chr(10) . '//' . chr(10) . '// Copyright 2009, 2010, 2011, 2012 by Flavio Soibelmann Glock and others.' . chr(10) . '//' . chr(10) . '// This program is free software; you can redistribute it and/or modify it' . chr(10) . '// under the same terms as Perl itself.' . chr(10) . '//' . chr(10) . '// See http://www.perl.com/perl/misc/Artistic.html' . chr(10) . chr(10) . 'var isNode = typeof require != "undefined";' . chr(10) . 'if (isNode) {' . chr(10) . chr(10) . '    var fs = require("fs");' . chr(10) . chr(10) . '    p5atime = function(s) {' . chr(10) . '        s = p5str(s);' . chr(10) . '        try {' . chr(10) . '            var stat = fs.statSync(s); return stat["atime"];' . chr(10) . '        }' . chr(10) . '        catch(err) {' . chr(10) . '            return ' . chr(39) . chr(39) . ';' . chr(10) . '        }' . chr(10) . '    };' . chr(10) . '    p5mtime = function(s) {' . chr(10) . '        s = p5str(s);' . chr(10) . '        try {' . chr(10) . '            var stat = fs.statSync(s); return stat["mtime"];' . chr(10) . '        }' . chr(10) . '        catch(err) {' . chr(10) . '            return ' . chr(39) . chr(39) . ';' . chr(10) . '        }' . chr(10) . '    };' . chr(10) . '    p5ctime = function(s) {' . chr(10) . '        s = p5str(s);' . chr(10) . '        try {' . chr(10) . '            var stat = fs.statSync(s); return stat["ctime"];' . chr(10) . '        }' . chr(10) . '        catch(err) {' . chr(10) . '            return ' . chr(39) . chr(39) . ';' . chr(10) . '        }' . chr(10) . '    };' . chr(10) . '    p5size = function(s) {' . chr(10) . '        s = p5str(s);' . chr(10) . '        try {' . chr(10) . '            var stat = fs.statSync(s); return stat["size"];' . chr(10) . '        }' . chr(10) . '        catch(err) {' . chr(10) . '            return ' . chr(39) . chr(39) . ';' . chr(10) . '        }' . chr(10) . '    };' . chr(10) . '    p5is_file = function(s) {' . chr(10) . '        s = p5str(s);' . chr(10) . '        try {' . chr(10) . '            var stat = fs.statSync(s); return stat.isFile() ? 1 : 0;' . chr(10) . '        }' . chr(10) . '        catch(err) {' . chr(10) . '            return ' . chr(39) . chr(39) . ';' . chr(10) . '        }' . chr(10) . '    };' . chr(10) . '    p5is_directory = function(s) {' . chr(10) . '        s = p5str(s);' . chr(10) . '        try {' . chr(10) . '            var stat = fs.statSync(s); return stat.isDirectory() ? 1 : 0;' . chr(10) . '        }' . chr(10) . '        catch(err) {' . chr(10) . '            return ' . chr(39) . chr(39) . ';' . chr(10) . '        }' . chr(10) . '    };' . chr(10) . '    p5file_exists = function(s) {' . chr(10) . '        s = p5str(s);' . chr(10) . '        return p5is_file(s) || p5is_directory(s);' . chr(10) . '    };' . chr(10) . chr(10) . '    CORE.chdir = function(List__) {' . chr(10) . '        try {' . chr(10) . '            process.chdir(p5str(List__[0]));' . chr(10) . '            return 1;' . chr(10) . '        }' . chr(10) . '        catch(err) {' . chr(10) . '            return ' . chr(39) . chr(39) . ';' . chr(10) . '        }' . chr(10) . '    };' . chr(10) . chr(10) . '    CORE.close = function(List__) {' . chr(10) . '        try {' . chr(10) . '            fs.closeSync(p5str(List__[0]));' . chr(10) . '            return 1;' . chr(10) . '        }' . chr(10) . '        catch(err) {' . chr(10) . '            p5pkg["main"]["v_!"] = err;' . chr(10) . '            return ' . chr(39) . chr(39) . ';' . chr(10) . '        }' . chr(10) . '    };' . chr(10) . chr(10) . '    CORE.exit = function(List__) {' . chr(10) . '        process.exit(List__[0]);' . chr(10) . '    };' . chr(10) . chr(10) . '    CORE.rename = function(List__) {' . chr(10) . '        try {' . chr(10) . '            fs.renameSync(p5str(List__[0]), p5str(List__[1]));' . chr(10) . '            return 1;' . chr(10) . '        }' . chr(10) . '        catch(err) {' . chr(10) . '            p5pkg["main"]["v_!"] = err;' . chr(10) . '            return ' . chr(39) . chr(39) . ';' . chr(10) . '        }' . chr(10) . '    };' . chr(10) . chr(10) . '    CORE.unlink = function(List__) {' . chr(10) . '        var count = 0;' . chr(10) . '        try {' . chr(10) . '            for(var i = 0; i < List__.length; i++) {' . chr(10) . '                fs.unlinkSync(p5str(List__[i]));' . chr(10) . '                count++;' . chr(10) . '            }' . chr(10) . '            return count;' . chr(10) . '        }' . chr(10) . '        catch(err) {' . chr(10) . '            p5pkg["main"]["v_!"] = err;' . chr(10) . '            return count;' . chr(10) . '        }' . chr(10) . '    };' . chr(10) . chr(10) . '}' . chr(10) . chr(10)
}
1;
# use Perlito5::Javascript3::IO
package main;
undef();
package Perlito5::Javascript3::Sprintf;
sub Perlito5::Javascript3::Sprintf::emit_javascript3 {
    return '/**' . chr(10) . ' * Copyright (c) 2010 Jakob Westhoff' . chr(10) . ' *' . chr(10) . ' * Permission is hereby granted, free of charge, to any person obtaining a copy' . chr(10) . ' * of this software and associated documentation files (the "Software"), to deal' . chr(10) . ' * in the Software without restriction, including without limitation the rights' . chr(10) . ' * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell' . chr(10) . ' * copies of the Software, and to permit persons to whom the Software is' . chr(10) . ' * furnished to do so, subject to the following conditions:' . chr(10) . ' * ' . chr(10) . ' * The above copyright notice and this permission notice shall be included in' . chr(10) . ' * all copies or substantial portions of the Software.' . chr(10) . ' * ' . chr(10) . ' * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR' . chr(10) . ' * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,' . chr(10) . ' * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE' . chr(10) . ' * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER' . chr(10) . ' * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,' . chr(10) . ' * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN' . chr(10) . ' * THE SOFTWARE.' . chr(10) . ' */' . chr(10) . chr(10) . 'CORE.sprintf = function(List__) {' . chr(10) . '    var format = List__[0];' . chr(10) . '    var list = List__[1];' . chr(10) . chr(10) . '    // Check for format definition' . chr(10) . '    if ( typeof format != ' . chr(39) . 'string' . chr(39) . ' ) {' . chr(10) . '        CORE.die(["sprintf: The first arguments need to be a valid format string."]);' . chr(10) . '    }' . chr(10) . '    ' . chr(10) . '    /**' . chr(10) . '     * Define the regex to match a formating string' . chr(10) . '     * The regex consists of the following parts:' . chr(10) . '     * percent sign to indicate the start' . chr(10) . '     * (optional) sign specifier' . chr(10) . '     * (optional) padding specifier' . chr(10) . '     * (optional) alignment specifier' . chr(10) . '     * (optional) width specifier' . chr(10) . '     * (optional) precision specifier' . chr(10) . '     * type specifier:' . chr(10) . '     *  % - literal percent sign' . chr(10) . '     *  b - binary number' . chr(10) . '     *  c - ASCII character represented by the given value' . chr(10) . '     *  d - signed decimal number' . chr(10) . '     *  f - floating point value' . chr(10) . '     *  o - octal number' . chr(10) . '     *  s - string' . chr(10) . '     *  x - hexadecimal number (lowercase characters)' . chr(10) . '     *  X - hexadecimal number (uppercase characters)' . chr(10) . '     */' . chr(10) . '    var r = new RegExp( /%(' . chr(92) . '+)?([0 ]|' . chr(39) . '(.))?(-)?([0-9]+)?(' . chr(92) . '.([0-9]+))?([%bcdfosxX])/g );' . chr(10) . chr(10) . '    /**' . chr(10) . '     * Each format string is splitted into the following parts:' . chr(10) . '     * 0: Full format string' . chr(10) . '     * 1: sign specifier (+)' . chr(10) . '     * 2: padding specifier (0/<space>/' . chr(39) . '<any char>)' . chr(10) . '     * 3: if the padding character starts with a ' . chr(39) . ' this will be the real ' . chr(10) . '     *    padding character' . chr(10) . '     * 4: alignment specifier' . chr(10) . '     * 5: width specifier' . chr(10) . '     * 6: precision specifier including the dot' . chr(10) . '     * 7: precision specifier without the dot' . chr(10) . '     * 8: type specifier' . chr(10) . '     */' . chr(10) . '    var parts      = [];' . chr(10) . '    var paramIndex = 0;' . chr(10) . '    while ( part = r.exec( format ) ) {' . chr(10) . '        // Check if an input value has been provided, for the current' . chr(10) . '        // format string' . chr(10) . '        if ( paramIndex >= list.length ) {' . chr(10) . '            CORE.die(["sprintf: At least one argument was missing."]);' . chr(10) . '        }' . chr(10) . chr(10) . '        parts[parts.length] = {' . chr(10) . '            /* beginning of the part in the string */' . chr(10) . '            begin: part.index,' . chr(10) . '            /* end of the part in the string */' . chr(10) . '            end: part.index + part[0].length,' . chr(10) . '            /* force sign */' . chr(10) . '            sign: ( part[1] == ' . chr(39) . '+' . chr(39) . ' ),' . chr(10) . '            /* is the given data negative */' . chr(10) . '            negative: ( parseInt( list[paramIndex] ) < 0 ) ? true : false,' . chr(10) . '            /* padding character (default: <space>) */' . chr(10) . '            padding: ( part[2] == undefined )' . chr(10) . '                     ? ( ' . chr(39) . ' ' . chr(39) . ' ) /* default */' . chr(10) . '                     : ( ( part[2].substring( 0, 1 ) == "' . chr(39) . '" ) ' . chr(10) . '                         ? ( part[3] ) /* use special char */' . chr(10) . '                         : ( part[2] ) /* use normal <space> or zero */' . chr(10) . '                       ),' . chr(10) . '            /* should the output be aligned left?*/' . chr(10) . '            alignLeft: ( part[4] == ' . chr(39) . '-' . chr(39) . ' ),' . chr(10) . '            /* width specifier (number or false) */' . chr(10) . '            width: ( part[5] != undefined ) ? part[5] : false,' . chr(10) . '            /* precision specifier (number or false) */' . chr(10) . '            precision: ( part[7] != undefined ) ? part[7] : false,' . chr(10) . '            /* type specifier */' . chr(10) . '            type: part[8],' . chr(10) . '            /* the given data associated with this part converted to a string */' . chr(10) . '            data: ( part[8] != ' . chr(39) . '%' . chr(39) . ' ) ? String ( list[paramIndex++] ) : false' . chr(10) . '        };' . chr(10) . '    }' . chr(10) . chr(10) . '    var newString = "";' . chr(10) . '    var start = 0;' . chr(10) . '    // Generate our new formated string' . chr(10) . '    for( var i=0; i<parts.length; ++i ) {' . chr(10) . '        // Add first unformated string part' . chr(10) . '        newString += format.substring( start, parts[i].begin );' . chr(10) . '        ' . chr(10) . '        // Mark the new string start' . chr(10) . '        start = parts[i].end;' . chr(10) . chr(10) . '        // Create the appropriate preformat substitution' . chr(10) . '        // This substitution is only the correct type conversion. All the' . chr(10) . '        // different options and flags haven' . chr(39) . 't been applied to it at this' . chr(10) . '        // point' . chr(10) . '        var preSubstitution = "";' . chr(10) . '        switch ( parts[i].type ) {' . chr(10) . '            case ' . chr(39) . '%' . chr(39) . ':' . chr(10) . '                preSubstitution = "%";' . chr(10) . '            break;' . chr(10) . '            case ' . chr(39) . 'b' . chr(39) . ':' . chr(10) . '                preSubstitution = Math.abs( parseInt( parts[i].data ) ).toString( 2 );' . chr(10) . '            break;' . chr(10) . '            case ' . chr(39) . 'c' . chr(39) . ':' . chr(10) . '                preSubstitution = String.fromCharCode( Math.abs( parseInt( parts[i].data ) ) );' . chr(10) . '            break;' . chr(10) . '            case ' . chr(39) . 'd' . chr(39) . ':' . chr(10) . '                preSubstitution = String( Math.abs( parseInt( parts[i].data ) ) );' . chr(10) . '            break;' . chr(10) . '            case ' . chr(39) . 'f' . chr(39) . ':' . chr(10) . '                preSubstitution = ( parts[i].precision == false )' . chr(10) . '                                  ? ( String( ( Math.abs( parseFloat( parts[i].data ) ) ) ) )' . chr(10) . '                                  : ( Math.abs( parseFloat( parts[i].data ) ).toFixed( parts[i].precision ) );' . chr(10) . '            break;' . chr(10) . '            case ' . chr(39) . 'o' . chr(39) . ':' . chr(10) . '                preSubstitution = Math.abs( parseInt( parts[i].data ) ).toString( 8 );' . chr(10) . '            break;' . chr(10) . '            case ' . chr(39) . 's' . chr(39) . ':' . chr(10) . '                preSubstitution = parts[i].data.substring( 0, parts[i].precision ? parts[i].precision : parts[i].data.length ); /* Cut if precision is defined */' . chr(10) . '            break;' . chr(10) . '            case ' . chr(39) . 'x' . chr(39) . ':' . chr(10) . '                preSubstitution = Math.abs( parseInt( parts[i].data ) ).toString( 16 ).toLowerCase();' . chr(10) . '            break;' . chr(10) . '            case ' . chr(39) . 'X' . chr(39) . ':' . chr(10) . '                preSubstitution = Math.abs( parseInt( parts[i].data ) ).toString( 16 ).toUpperCase();' . chr(10) . '            break;' . chr(10) . '            default:' . chr(10) . '                throw ' . chr(39) . 'sprintf: Unknown type "' . chr(39) . ' + parts[i].type + ' . chr(39) . '" detected. This should never happen. Maybe the regex is wrong.' . chr(39) . ';' . chr(10) . '        }' . chr(10) . chr(10) . '        // The % character is a special type and does not need further processing' . chr(10) . '        if ( parts[i].type ==  "%" ) {' . chr(10) . '            newString += preSubstitution;' . chr(10) . '            continue;' . chr(10) . '        }' . chr(10) . chr(10) . '        // Modify the preSubstitution by taking sign, padding and width' . chr(10) . '        // into account' . chr(10) . chr(10) . '        // Pad the string based on the given width' . chr(10) . '        if ( parts[i].width != false ) {' . chr(10) . '            // Padding needed?' . chr(10) . '            if ( parts[i].width > preSubstitution.length ) ' . chr(10) . '            {' . chr(10) . '                var origLength = preSubstitution.length;' . chr(10) . '                for( var j = 0; j < parts[i].width - origLength; ++j ) ' . chr(10) . '                {' . chr(10) . '                    preSubstitution = ( parts[i].alignLeft == true ) ' . chr(10) . '                                      ? ( preSubstitution + parts[i].padding )' . chr(10) . '                                      : ( parts[i].padding + preSubstitution );' . chr(10) . '                }' . chr(10) . '            }' . chr(10) . '        }' . chr(10) . chr(10) . '        // Add a sign symbol if neccessary or enforced, but only if we are' . chr(10) . '        // not handling a string' . chr(10) . '        if ( parts[i].type == ' . chr(39) . 'b' . chr(39) . ' ' . chr(10) . '          || parts[i].type == ' . chr(39) . 'd' . chr(39) . ' ' . chr(10) . '          || parts[i].type == ' . chr(39) . 'o' . chr(39) . ' ' . chr(10) . '          || parts[i].type == ' . chr(39) . 'f' . chr(39) . ' ' . chr(10) . '          || parts[i].type == ' . chr(39) . 'x' . chr(39) . ' ' . chr(10) . '          || parts[i].type == ' . chr(39) . 'X' . chr(39) . ' ) {' . chr(10) . '            if ( parts[i].negative == true ) {' . chr(10) . '                preSubstitution = "-" + preSubstitution;' . chr(10) . '            }' . chr(10) . '            else if ( parts[i].sign == true ) {' . chr(10) . '                preSubstitution = "+" + preSubstitution;' . chr(10) . '            }' . chr(10) . '        }' . chr(10) . chr(10) . '        // Add the substitution to the new string' . chr(10) . '        newString += preSubstitution;' . chr(10) . '    }' . chr(10) . chr(10) . '    // Add the last part of the given format string, which may still be there' . chr(10) . '    newString += format.substring( start, format.length );' . chr(10) . chr(10) . '    return newString;' . chr(10) . '};' . chr(10) . chr(10) . 'CORE.printf = function(List__) {' . chr(10) . '    return CORE.print([ CORE.sprintf(List__) ]);' . chr(10) . '};' . chr(10) . chr(10)
}
1;
# use Perlito5::Javascript3::Sprintf
package main;
undef();
# use Perlito5::AST
# use strict
package Perlito5::Perl5;
{
    sub Perlito5::Perl5::escape_string {
        return Perlito5::Dumper::escape_string($_[0])
    }
    sub Perlito5::Perl5::emit_perl5_block {
        my $block = $_[0];
        return ['block', map {
            defined($_) && $_->emit_perl5()
        } @{$block}]
    }
}
package Perlito5::AST::CompUnit;
{
    sub Perlito5::AST::CompUnit::emit_perl5 {
        my $self = $_[0];
        return (['stmt' => ['keyword' => 'package'], ['bareword' => $self->{'name'}]], map {
            defined($_) && $_->emit_perl5()
        } @{$self->{'body'}})
    }
    sub Perlito5::AST::CompUnit::emit_perl5_program {
        my $comp_units = $_[0];
        return map {
            $_->emit_perl5()
        } @{$comp_units}
    }
}
package Perlito5::AST::Int;
{
    sub Perlito5::AST::Int::emit_perl5 {
        my $self = $_[0];
        ['number' => $self->{'int'}]
    }
}
package Perlito5::AST::Num;
{
    sub Perlito5::AST::Num::emit_perl5 {
        my $self = $_[0];
        ['number' => $self->{'num'}]
    }
}
package Perlito5::AST::Buf;
{
    sub Perlito5::AST::Buf::emit_perl5 {
        my $self = $_[0];
        Perlito5::Perl5::escape_string($self->{'buf'})
    }
}
package Perlito5::AST::Block;
{
    sub Perlito5::AST::Block::emit_perl5 {
        my $self = $_[0];
        my @out;
        $self->{'label'} && push(@out, ['label' => $self->{'label'}]);
        if ($self->{'name'}) {
            push(@out, ['stmt' => ['keyword' => $self->{'name'}], Perlito5::Perl5::emit_perl5_block($self->{'stmts'})])
        }
        else {
            push(@out, Perlito5::Perl5::emit_perl5_block($self->{'stmts'}))
        }
        if ($self->{'continue'} && @{$self->{'continue'}->{'stmts'}}) {
            push(@out, ['stmt' => ['keyword' => 'continue'], Perlito5::Perl5::emit_perl5_block($self->{'continue'}->{'stmts'})])
        }
        return @out
    }
}
package Perlito5::AST::Index;
{
    sub Perlito5::AST::Index::emit_perl5 {
        my $self = $_[0];
        if (($self->{'obj'}->isa('Perlito5::AST::Apply') && $self->{'obj'}->{'code'} eq 'prefix:<@>') || ($self->{'obj'}->isa('Perlito5::AST::Var') && ($self->{'obj'}->sigil() eq '$' || $self->{'obj'}->sigil() eq '@'))) {
            return ['apply' => '[', $self->{'obj'}->emit_perl5(), $self->{'index_exp'}->emit_perl5()]
        }
        if (($self->{'obj'}->isa('Perlito5::AST::Apply') && $self->{'obj'}->{'code'} eq 'prefix:<%>') || ($self->{'obj'}->isa('Perlito5::AST::Var') && ($self->{'obj'}->sigil() eq '%'))) {
            return ['apply' => '[', $self->{'obj'}->emit_perl5(), $self->{'index_exp'}->emit_perl5()]
        }
        if ($self->{'obj'}->isa('Perlito5::AST::Apply') && $self->{'obj'}->{'code'} eq 'prefix:<$>') {
            return ['op' => 'infix:<->>', $self->{'obj'}->{'arguments'}->[0]->emit_perl5(), ['op' => 'circumfix:<[ ]>', $self->{'index_exp'}->emit_perl5()]]
        }
        return ['op' => 'infix:<->>', $self->{'obj'}->emit_perl5(), ['op' => 'circumfix:<[ ]>', $self->{'index_exp'}->emit_perl5()]]
    }
}
package Perlito5::AST::Lookup;
{
    sub Perlito5::AST::Lookup::emit_perl5 {
        my $self = $_[0];
        if (($self->{'obj'}->isa('Perlito5::AST::Apply') && $self->{'obj'}->{'code'} eq 'prefix:<@>') || ($self->{'obj'}->isa('Perlito5::AST::Var') && ($self->{'obj'}->sigil() eq '$' || $self->{'obj'}->sigil() eq '@'))) {
            return ['apply' => '{', $self->{'obj'}->emit_perl5(), $self->autoquote($self->{'index_exp'})->emit_perl5()]
        }
        if (($self->{'obj'}->isa('Perlito5::AST::Apply') && $self->{'obj'}->{'code'} eq 'prefix:<%>') || ($self->{'obj'}->isa('Perlito5::AST::Var') && ($self->{'obj'}->sigil() eq '%'))) {
            return ['apply' => '{', $self->{'obj'}->emit_perl5(), $self->autoquote($self->{'index_exp'})->emit_perl5()]
        }
        if ($self->{'obj'}->isa('Perlito5::AST::Apply') && $self->{'obj'}->{'code'} eq 'prefix:<$>') {
            return ['op' => 'infix:<->>', $self->{'obj'}->{'arguments'}->[0]->emit_perl5(), ['op' => 'circumfix:<{ }>', $self->autoquote($self->{'index_exp'})->emit_perl5()]]
        }
        return ['op' => 'infix:<->>', $self->{'obj'}->emit_perl5(), ['op' => 'circumfix:<{ }>', $self->autoquote($self->{'index_exp'})->emit_perl5()]]
    }
}
package Perlito5::AST::Var;
{
    sub Perlito5::AST::Var::emit_perl5 {
        my $self = $_[0];
        my $str_name = $self->{'name'};
        $str_name eq chr(92) && ($str_name = chr(92) . chr(92));
        $str_name eq chr(39) && ($str_name = chr(92) . chr(39));
        my $ns = '';
        if ($self->{'namespace'}) {
            $self->{'sigil'} eq '::' && return $self->{'namespace'} . '::';
            if ($self->{'namespace'} eq 'main' && substr($self->{'name'}, 0, 1) eq '^') {
                return $self->{'sigil'} . '{' . $self->{'name'} . '}'
            }
            else {
                $ns = $self->{'namespace'} . '::'
            }
        }
        my $c = substr($self->{'name'}, 0, 1);
        if (($c ge 'a' && $c le 'z') || ($c ge 'A' && $c le 'Z') || ($c eq '_')) {
            return $self->{'sigil'} . $ns . $self->{'name'}
        }
        return $self->{'sigil'} . '{' . chr(39) . $ns . $str_name . chr(39) . '}'
    }
}
package Perlito5::AST::Call;
{
    sub Perlito5::AST::Call::emit_perl5 {
        my $self = $_[0];
        my $invocant = $self->{'invocant'}->emit_perl5();
        if ($self->{'method'} eq 'postcircumfix:<[ ]>') {
            return ['op' => 'infix:<->>', $invocant, ['op' => 'circumfix:<[ ]>', $self->{'arguments'}->emit_perl5()]]
        }
        if ($self->{'method'} eq 'postcircumfix:<{ }>') {
            return ['op' => 'infix:<->>', $invocant, ['op' => 'circumfix:<{ }>', Perlito5::AST::Lookup::->autoquote($self->{'arguments'})->emit_perl5()]]
        }
        my $meth = $self->{'method'};
        if ($meth eq 'postcircumfix:<( )>') {
            if ((ref($self->{'invocant'}) eq 'Perlito5::AST::Var' && $self->{'invocant'}->{'sigil'} eq '&') || (ref($self->{'invocant'}) eq 'Perlito5::AST::Apply' && $self->{'invocant'}->{'code'} eq 'prefix:<&>')) {
                return ['apply' => '(', $invocant, map {
                    $_->emit_perl5()
                } @{$self->{'arguments'}}]
            }
            $meth = ''
        }
        if (ref($meth) eq 'Perlito5::AST::Var') {
            $meth = $meth->emit_perl5()
        }
        if ($meth) {
            return ['call' => $invocant, $meth, map {
                $_->emit_perl5()
            } @{$self->{'arguments'}}]
        }
        return ['op' => 'infix:<->>', $invocant, ['op' => 'list:<,>', map {
            $_->emit_perl5()
        } @{$self->{'arguments'}}]]
    }
}
package Perlito5::AST::Apply;
{
    sub Perlito5::AST::Apply::emit_perl5_args {
        my $self = $_[0];
        !$self->{'arguments'} && return ();
        return map {
            $_->emit_perl5()
        } @{$self->{'arguments'}}
    }
    sub Perlito5::AST::Apply::emit_perl5 {
        my $self = $_[0];
        if (ref($self->{'code'})) {
            return ['op' => 'infix:<->>', $self->{'code'}->emit_perl5(), $self->emit_perl5_args()]
        }
        if ($self->{'code'} eq 'infix:<=>>') {
            return ['op' => $self->{'code'}, Perlito5::AST::Lookup::->autoquote($self->{'arguments'}->[0])->emit_perl5(), $self->{'arguments'}->[1]->emit_perl5()]
        }
        if ($Perlito5::Perl5::PrettyPrinter::op{$self->{'code'}}) {
            return ['op' => $self->{'code'}, $self->emit_perl5_args()]
        }
        my $ns = '';
        if ($self->{'namespace'}) {
            $ns = $self->{'namespace'} . '::'
        }
        my $code = $ns . $self->{'code'};
        if ($self->{'code'} eq 'p5:s') {
            return 's!' . $self->{'arguments'}->[0]->{'buf'} . '!' . $self->{'arguments'}->[1]->{'buf'} . '!' . $self->{'arguments'}->[2]->{'buf'}
        }
        if ($self->{'code'} eq 'p5:m') {
            my $s;
            if ($self->{'arguments'}->[0]->isa('Perlito5::AST::Buf')) {
                $s = $self->{'arguments'}->[0]->{'buf'}
            }
            else {
                for my $ast (@{$self->{'arguments'}->[0]->{'arguments'}}) {
                    if ($ast->isa('Perlito5::AST::Buf')) {
                        $s .= $ast->{'buf'}
                    }
                    else {
                        $s .= $ast->emit_perl5()
                    }
                }
            }
            return 'm!' . $s . '!' . $self->{'arguments'}->[1]->{'buf'}
        }
        if ($self->{'code'} eq 'p5:tr') {
            return 'tr!' . $self->{'arguments'}->[0]->{'buf'} . '!' . $self->{'arguments'}->[1]->{'buf'} . '!'
        }
        if ($self->{'code'} eq 'package') {
            return ['stmt' => 'package', ['bareword' => $self->{'namespace'}]]
        }
        if ($code eq 'map' || $code eq 'grep' || $code eq 'sort') {
            if ($self->{'special_arg'}) {
                return ['op' => 'prefix:<' . $code . '>', ['block', map {
                    $_->emit_perl5()
                } @{$self->{'special_arg'}->{'stmts'}}], ['op' => 'list:<,>', $self->emit_perl5_args()]]
            }
            return ['apply' => '(', $code, $self->emit_perl5_args()]
        }
        if (($code eq 'eval' || $code eq 'do') && ref($self->{'arguments'}->[0]) eq 'Perlito5::AST::Block') {
            return ['op' => 'prefix:<' . $code . '>', $self->{'arguments'}->[0]->emit_perl5()]
        }
        if ($code eq 'readline') {
            return ['paren' => '<', $self->emit_perl5_args()]
        }
        if ($self->{'bareword'} && !@{$self->{'arguments'}}) {
            return ['bareword' => $code]
        }
        return ['apply' => '(', $code, $self->emit_perl5_args()]
    }
}
package Perlito5::AST::If;
{
    sub Perlito5::AST::If::emit_perl5 {
        my $self = $_[0];
        if ($self->{'body'} && ref($self->{'body'}) ne 'Perlito5::AST::Block') {
            return ['stmt_modifier' => $self->{'body'}->emit_perl5(), ['stmt' => 'if', $self->{'cond'}->emit_perl5()]]
        }
        if ($self->{'otherwise'} && ref($self->{'otherwise'}) ne 'Perlito5::AST::Block') {
            return ['stmt_modifier' => $self->{'otherwise'}->emit_perl5(), ['stmt' => 'unless', $self->{'cond'}->emit_perl5()]]
        }
        my @out = (['stmt' => ['keyword' => 'if'], ['paren' => '(', $self->{'cond'}->emit_perl5()], Perlito5::Perl5::emit_perl5_block($self->{'body'}->stmts())]);
        my $otherwise = $self->{'otherwise'};
        while ($otherwise && @{$otherwise->{'stmts'}} == 1 && ref($otherwise->{'stmts'}->[0]) eq 'Perlito5::AST::If' && ($otherwise->{'stmts'}->[0]->{'body'} && ref($otherwise->{'stmts'}->[0]->{'body'}) eq 'Perlito5::AST::Block')) {
            push(@out, ['stmt' => ['keyword' => 'elsif'], ['paren' => '(', $otherwise->{'stmts'}->[0]->{'cond'}->emit_perl5()], Perlito5::Perl5::emit_perl5_block($otherwise->{'stmts'}->[0]->{'body'}->{'stmts'})]);
            $otherwise = $otherwise->{'stmts'}->[0]->{'otherwise'}
        }
        !($otherwise && scalar(@{$otherwise->stmts()})) && return @out;
        push(@out, ['stmt' => ['keyword' => 'else'], Perlito5::Perl5::emit_perl5_block($otherwise->stmts())]);
        return @out
    }
}
package Perlito5::AST::When;
{
    sub Perlito5::AST::When::emit_perl5 {
        my $self = $_[0];
        return ['stmt' => ['keyword' => 'when'], ['paren' => '(', $self->{'cond'}->emit_perl5()], Perlito5::Perl5::emit_perl5_block($self->{'body'}->stmts())]
    }
}
package Perlito5::AST::While;
{
    sub Perlito5::AST::While::emit_perl5 {
        my $self = $_[0];
        my @out;
        $self->{'label'} && push(@out, ['label' => $self->{'label'}]);
        if ($self->{'body'} && ref($self->{'body'}) ne 'Perlito5::AST::Block') {
            return @out, ['stmt_modifier' => $self->{'body'}->emit_perl5(), ['stmt' => ['keyword' => 'while'], $self->{'cond'}->emit_perl5()]]
        }
        push(@out, ['stmt' => ['keyword' => 'while'], ['paren' => '(', $self->{'cond'}->emit_perl5()], Perlito5::Perl5::emit_perl5_block($self->{'body'}->stmts())]);
        if ($self->{'continue'} && @{$self->{'continue'}->{'stmts'}}) {
            push(@out, ['stmt' => ['keyword' => 'continue'], Perlito5::Perl5::emit_perl5_block($self->{'continue'}->{'stmts'})])
        }
        return @out
    }
}
package Perlito5::AST::For;
{
    sub Perlito5::AST::For::emit_perl5 {
        my $self = $_[0];
        my @out;
        $self->{'label'} && push(@out, ['label' => $self->{'label'}]);
        if ($self->{'body'} && ref($self->{'body'}) ne 'Perlito5::AST::Block') {
            return @out, ['stmt_modifier' => $self->{'body'}->emit_perl5(), ['stmt' => 'for', $self->{'cond'}->emit_perl5()]]
        }
        my $cond;
        if (ref($self->{'cond'}) eq 'ARRAY') {
            $cond = ['paren_semicolon' => '(', ($self->{'cond'}->[0] ? $self->{'cond'}->[0]->emit_perl5() : []), ($self->{'cond'}->[1] ? $self->{'cond'}->[1]->emit_perl5() : []), ($self->{'cond'}->[2] ? $self->{'cond'}->[2]->emit_perl5() : [])]
        }
        else {
            $cond = ['paren' => '(', $self->{'cond'}->emit_perl5()]
        }
        my @sig;
        my $sig_ast = $self->{'topic'};
        if (!$sig_ast) {}
        else {
            @sig = $sig_ast->emit_perl5()
        }
        push(@out, ['stmt' => ['keyword' => 'for'], @sig, $cond, Perlito5::Perl5::emit_perl5_block($self->{'body'}->stmts())]);
        if ($self->{'continue'} && @{$self->{'continue'}->{'stmts'}}) {
            push(@out, ['stmt' => ['keyword' => 'continue'], Perlito5::Perl5::emit_perl5_block($self->{'continue'}->{'stmts'})])
        }
        return @out
    }
}
package Perlito5::AST::Decl;
{
    sub Perlito5::AST::Decl::emit_perl5 {
        my $self = $_[0];
        return ['op' => 'prefix:<' . $self->{'decl'} . '>', ($self->{'type'} ? $self->{'type'} : ()), $self->{'var'}->emit_perl5()]
    }
}
package Perlito5::AST::Sub;
{
    sub Perlito5::AST::Sub::emit_perl5 {
        my $self = $_[0];
        my @parts;
        defined($self->{'sig'}) && push(@parts, ['paren' => '(', ['bareword' => $self->{'sig'}]]);
        defined($self->{'block'}) && push(@parts, Perlito5::Perl5::emit_perl5_block($self->{'block'}->{'stmts'}));
        !$self->{'name'} && return ['op' => 'prefix:<sub>', @parts];
        return ['stmt' => ['keyword' => 'sub'], ['bareword' => $self->{'namespace'} . '::' . $self->{'name'}], @parts]
    }
}
package Perlito5::AST::Use;
{
    sub Perlito5::AST::Use::emit_perl5 {
        my $self = shift;
        Perlito5::Grammar::Use::emit_time_eval($self);
        return ['comment' => '# ' . $self->{'code'} . ' ' . $self->{'mod'}]
    }
}
# use Perlito5::Perl5::Emitter
package main;
package Perlito5::Perl5::PrettyPrinter;
# use strict
# use warnings
my %dispatch = ('stmt' => sub {
    statement(@_)
}, 'stmt_modifier' => sub {
    statement_modifier(@_)
}, 'block' => sub {
    block(@_)
}, 'keyword' => sub {
    keyword(@_)
}, 'bareword' => sub {
    bareword(@_)
}, 'number' => sub {
    number(@_)
}, 'op' => sub {
    op(@_)
}, 'paren' => sub {
    paren(@_)
}, 'paren_semicolon' => sub {
    paren_semicolon(@_)
}, 'apply' => sub {
    apply(@_)
}, 'call' => sub {
    call(@_)
}, 'comment' => sub {
    comment(@_)
}, 'label' => sub {
    label(@_)
});
my %pair = ('(' => ')', '[' => ']', '{' => '}', '<' => '>');
our %op = ('prefix:<$>' => {'fix' => 'deref', 'prec' => 0, 'str' => '$'}, 'prefix:<@>' => {'fix' => 'deref', 'prec' => 0, 'str' => '@'}, 'prefix:<%>' => {'fix' => 'deref', 'prec' => 0, 'str' => '%'}, 'prefix:<&>' => {'fix' => 'deref', 'prec' => 0, 'str' => '&'}, 'prefix:<*>' => {'fix' => 'deref', 'prec' => 0, 'str' => '*'}, 'prefix:<$#>' => {'fix' => 'deref', 'prec' => 0, 'str' => '$#'}, 'circumfix:<[ ]>' => {'fix' => 'circumfix', 'prec' => 0, 'str' => '['}, 'circumfix:<{ }>' => {'fix' => 'circumfix', 'prec' => 0, 'str' => '{'}, 'circumfix:<( )>' => {'fix' => 'circumfix', 'prec' => 0, 'str' => '('}, 'infix:<->>' => {'fix' => 'infix', 'prec' => -1, 'str' => '->'}, 'prefix:<-->' => {'fix' => 'prefix', 'prec' => 1, 'str' => '--'}, 'prefix:<++>' => {'fix' => 'prefix', 'prec' => 1, 'str' => '++'}, 'postfix:<-->' => {'fix' => 'postfix', 'prec' => 1, 'str' => '--'}, 'postfix:<++>' => {'fix' => 'postfix', 'prec' => 1, 'str' => '++'}, 'infix:<**>' => {'fix' => 'infix', 'prec' => 2, 'str' => '**'}, 'prefix:<' . chr(92) . '>' => {'fix' => 'prefix', 'prec' => 3, 'str' => chr(92)}, 'prefix:<+>' => {'fix' => 'prefix', 'prec' => 3, 'str' => '+'}, 'prefix:<->' => {'fix' => 'prefix', 'prec' => 3, 'str' => '-'}, 'prefix:<~>' => {'fix' => 'prefix', 'prec' => 3, 'str' => '~'}, 'prefix:<!>' => {'fix' => 'prefix', 'prec' => 3, 'str' => '!'}, 'infix:<=~>' => {'fix' => 'infix', 'prec' => 4, 'str' => ' =~ '}, 'infix:<!~>' => {'fix' => 'infix', 'prec' => 4, 'str' => ' !~ '}, 'infix:<*>' => {'fix' => 'infix', 'prec' => 5, 'str' => ' * '}, 'infix:</>' => {'fix' => 'infix', 'prec' => 5, 'str' => ' / '}, 'infix:<%>' => {'fix' => 'infix', 'prec' => 5, 'str' => ' % '}, 'infix:<x>' => {'fix' => 'infix', 'prec' => 5, 'str' => ' x '}, 'infix:<+>' => {'fix' => 'infix', 'prec' => 6, 'str' => ' + '}, 'infix:<->' => {'fix' => 'infix', 'prec' => 6, 'str' => ' - '}, 'list:<.>' => {'fix' => 'list', 'prec' => 6, 'str' => ' . '}, 'infix:<<<>' => {'fix' => 'infix', 'prec' => 7, 'str' => ' << '}, 'infix:<>>>' => {'fix' => 'infix', 'prec' => 7, 'str' => ' >> '}, 'infix:<lt>' => {'fix' => 'infix', 'prec' => 9, 'str' => ' lt '}, 'infix:<le>' => {'fix' => 'infix', 'prec' => 9, 'str' => ' le '}, 'infix:<gt>' => {'fix' => 'infix', 'prec' => 9, 'str' => ' gt '}, 'infix:<ge>' => {'fix' => 'infix', 'prec' => 9, 'str' => ' ge '}, 'infix:<<=>' => {'fix' => 'infix', 'prec' => 9, 'str' => ' <= '}, 'infix:<>=>' => {'fix' => 'infix', 'prec' => 9, 'str' => ' >= '}, 'infix:<<>' => {'fix' => 'infix', 'prec' => 9, 'str' => ' < '}, 'infix:<>>' => {'fix' => 'infix', 'prec' => 9, 'str' => ' > '}, 'infix:<<=>>' => {'fix' => 'infix', 'prec' => 10, 'str' => ' <=> '}, 'infix:<cmp>' => {'fix' => 'infix', 'prec' => 10, 'str' => ' cmp '}, 'infix:<==>' => {'fix' => 'infix', 'prec' => 10, 'str' => ' == '}, 'infix:<!=>' => {'fix' => 'infix', 'prec' => 10, 'str' => ' != '}, 'infix:<ne>' => {'fix' => 'infix', 'prec' => 10, 'str' => ' ne '}, 'infix:<eq>' => {'fix' => 'infix', 'prec' => 10, 'str' => ' eq '}, 'infix:<&>' => {'fix' => 'infix', 'prec' => 11, 'str' => ' & '}, 'infix:<|>' => {'fix' => 'infix', 'prec' => 12, 'str' => ' | '}, 'infix:<^>' => {'fix' => 'infix', 'prec' => 12, 'str' => ' ^ '}, 'infix:<..>' => {'fix' => 'infix', 'prec' => 13, 'str' => ' .. '}, 'infix:<...>' => {'fix' => 'infix', 'prec' => 13, 'str' => ' ... '}, 'infix:<~~>' => {'fix' => 'infix', 'prec' => 13, 'str' => ' ~~ '}, 'infix:<&&>' => {'fix' => 'infix', 'prec' => 14, 'str' => ' && '}, 'infix:<||>' => {'fix' => 'infix', 'prec' => 15, 'str' => ' || '}, 'infix:<//>' => {'fix' => 'infix', 'prec' => 15, 'str' => ' // '}, 'ternary:<? :>' => {'fix' => 'ternary', 'prec' => 16}, 'infix:<=>' => {'fix' => 'infix', 'prec' => 17, 'str' => ' = '}, 'infix:<**=>' => {'fix' => 'infix', 'prec' => 17, 'str' => ' **= '}, 'infix:<+=>' => {'fix' => 'infix', 'prec' => 17, 'str' => ' += '}, 'infix:<-=>' => {'fix' => 'infix', 'prec' => 17, 'str' => ' -= '}, 'infix:<*=>' => {'fix' => 'infix', 'prec' => 17, 'str' => ' *= '}, 'infix:</=>' => {'fix' => 'infix', 'prec' => 17, 'str' => ' /= '}, 'infix:<x=>' => {'fix' => 'infix', 'prec' => 17, 'str' => ' x= '}, 'infix:<|=>' => {'fix' => 'infix', 'prec' => 17, 'str' => ' |= '}, 'infix:<&=>' => {'fix' => 'infix', 'prec' => 17, 'str' => ' &= '}, 'infix:<.=>' => {'fix' => 'infix', 'prec' => 17, 'str' => ' .= '}, 'infix:<<<=>' => {'fix' => 'infix', 'prec' => 17, 'str' => ' <<= '}, 'infix:<>>=>' => {'fix' => 'infix', 'prec' => 17, 'str' => ' >>= '}, 'infix:<%=>' => {'fix' => 'infix', 'prec' => 17, 'str' => ' %= '}, 'infix:<||=>' => {'fix' => 'infix', 'prec' => 17, 'str' => ' ||= '}, 'infix:<&&=>' => {'fix' => 'infix', 'prec' => 17, 'str' => ' &&= '}, 'infix:<^=>' => {'fix' => 'infix', 'prec' => 17, 'str' => ' ^= '}, 'infix:<//=>' => {'fix' => 'infix', 'prec' => 17, 'str' => ' //= '}, 'infix:<=>>' => {'fix' => 'infix', 'prec' => 18, 'str' => ' => '}, 'list:<,>' => {'fix' => 'list', 'prec' => 19, 'str' => ', '}, 'prefix:<not>' => {'fix' => 'prefix', 'prec' => 20, 'str' => ' not '}, 'infix:<and>' => {'fix' => 'infix', 'prec' => 21, 'str' => ' and '}, 'infix:<or>' => {'fix' => 'infix', 'prec' => 22, 'str' => ' or '}, 'infix:<xor>' => {'fix' => 'infix', 'prec' => 22, 'str' => ' xor '});
$op{'prefix:<' . $_ . '>'} = {'fix' => 'prefix', 'prec' => 8, 'str' => $_ . ' '}
    for '-r', '-w', '-x', '-o', '-R', '-W', '-X', '-O', '-e', '-z', '-s', '-f', '-d', '-l', '-p', '-S', '-b', '-c', '-t', '-u', '-g', '-k', '-T', '-B', '-M', '-A', '-C';
$op{'prefix:<' . $_ . '>'} = {'fix' => 'parsed', 'prec' => 8, 'str' => $_}
    for 'do', 'sub', 'my', 'our', 'state', 'local', 'eval', 'map', 'grep', 'sort';
my %tab;
sub Perlito5::Perl5::PrettyPrinter::tab {
    my $level = $_[0];
    $tab{$level} //= '    ' x $level
}
sub Perlito5::Perl5::PrettyPrinter::render {
    my($data, $level, $out) = @_;
    if (ref($data)) {
        $dispatch{$data->[0]}->($data, $level, $out)
    }
    else {
        push(@{$out}, $data)
    }
}
sub Perlito5::Perl5::PrettyPrinter::op_precedence {
    my($data) = @_;
    !ref($data) && return 0;
    $data->[0] ne 'op' && return 0;
    return $op{$data->[1]}->{'prec'} || 0
}
sub Perlito5::Perl5::PrettyPrinter::statement_need_semicolon {
    my($data) = @_;
    !ref($data) && return 1;
    ($data->[0] eq 'block' || $data->[0] eq 'comment' || $data->[0] eq 'label') && return 0;
    if ($data->[0] eq 'stmt') {
        if (ref($data->[1])) {
            my $dd = $data->[1];
            if ($dd->[0] eq 'keyword') {
                ref($data->[-1]) && $data->[-1]->[0] eq 'block' && return 0
            }
        }
    }
    return 1
}
sub Perlito5::Perl5::PrettyPrinter::op_render {
    my($data, $level, $out, $current_op) = @_;
    if (ref($data)) {
        my $this_prec = op_precedence($data);
        $this_prec && $current_op->{'prec'} && $current_op->{'prec'} < $this_prec && push(@{$out}, '(');
        render($data, $level, $out);
        $this_prec && $current_op->{'prec'} && $current_op->{'prec'} < $this_prec && push(@{$out}, ')')
    }
    else {
        push(@{$out}, $data)
    }
}
sub Perlito5::Perl5::PrettyPrinter::op {
    my($data, $level, $out) = @_;
    my $op = $data->[1];
    my $spec = $op{$op} || die('unknown op: ' . $op);
    if ($spec->{'fix'} eq 'infix') {
        op_render($data->[2], $level, $out, $spec);
        push(@{$out}, $spec->{'str'});
        op_render($data->[3], $level, $out, $spec)
    }
    elsif ($spec->{'fix'} eq 'prefix') {
        push(@{$out}, $spec->{'str'});
        op_render($data->[2], $level, $out, $spec)
    }
    elsif ($spec->{'fix'} eq 'postfix') {
        op_render($data->[2], $level, $out, $spec);
        push(@{$out}, $spec->{'str'})
    }
    elsif ($spec->{'fix'} eq 'ternary') {
        op_render($data->[2], $level, $out, $spec);
        push(@{$out}, ' ? ');
        op_render($data->[3], $level, $out, $spec);
        push(@{$out}, ' : ');
        op_render($data->[4], $level, $out, $spec)
    }
    elsif ($spec->{'fix'} eq 'deref') {
        push(@{$out}, $spec->{'str'}, '{');
        op_render($data->[2], $level, $out, $spec);
        push(@{$out}, '}')
    }
    elsif ($spec->{'fix'} eq 'circumfix') {
        push(@{$out}, $spec->{'str'});
        for my $line (2 .. $#{$data}) {
            op_render($data->[$line], $level, $out, $spec);
            $line != $#{$data} && push(@{$out}, ', ')
        }
        push(@{$out}, $pair{$spec->{'str'}})
    }
    elsif ($spec->{'fix'} eq 'list') {
        for my $line (2 .. $#{$data}) {
            op_render($data->[$line], $level, $out, $spec);
            $line != $#{$data} && push(@{$out}, $spec->{'str'})
        }
    }
    elsif ($spec->{'fix'} eq 'parsed') {
        push(@{$out}, $spec->{'str'});
        for my $line (2 .. $#{$data}) {
            my $d = $data->[$line];
            push(@{$out}, ' ');
            render($d, $level, $out)
        }
    }
    else {
        die('unknown fixity: ' . $spec->{'fix'})
    }
    return 
}
sub Perlito5::Perl5::PrettyPrinter::call {
    my($data, $level, $out) = @_;
    my @dd = @{$data};
    shift(@dd);
    my $open = '(';
    render(shift(@dd), $level, $out);
    push(@{$out}, '->');
    my $d = $dd[0];
    render($d, $level, $out);
    $dd[0] = 'list:<,>';
    push(@{$out}, $open);
    op(['op' => @dd], $level, $out);
    push(@{$out}, $pair{$open})
}
sub Perlito5::Perl5::PrettyPrinter::apply {
    my($data, $level, $out) = @_;
    my @dd = @{$data};
    shift(@dd);
    my $open = shift(@dd);
    my $d = $dd[0];
    if ($d eq 'return') {
        $open = ' '
    }
    render($d, $level, $out);
    $dd[0] = 'list:<,>';
    push(@{$out}, $open);
    op(['op' => @dd], $level, $out);
    push(@{$out}, $pair{$open})
}
sub Perlito5::Perl5::PrettyPrinter::paren {
    my($data, $level, $out) = @_;
    my @dd = @{$data};
    shift(@dd);
    my $open = $dd[0];
    $dd[0] = 'list:<,>';
    push(@{$out}, $open);
    op(['op' => @dd], $level, $out);
    push(@{$out}, $pair{$open})
}
sub Perlito5::Perl5::PrettyPrinter::paren_semicolon {
    my($data, $level, $out) = @_;
    push(@{$out}, $data->[1]);
    for my $line (2 .. $#{$data}) {
        @{$data->[$line]} && render($data->[$line], $level, $out);
        if ($line != $#{$data}) {
            if (@{$data->[$line + 1]}) {
                push(@{$out}, '; ')
            }
            else {
                push(@{$out}, ';')
            }
        }
    }
    push(@{$out}, $pair{$data->[1]})
}
sub Perlito5::Perl5::PrettyPrinter::label {
    my($data, $level, $out) = @_;
    push(@{$out}, $data->[1], ':');
    return 
}
sub Perlito5::Perl5::PrettyPrinter::keyword {
    my($data, $level, $out) = @_;
    push(@{$out}, $data->[1]);
    return 
}
sub Perlito5::Perl5::PrettyPrinter::bareword {
    my($data, $level, $out) = @_;
    push(@{$out}, $data->[1]);
    return 
}
sub Perlito5::Perl5::PrettyPrinter::number {
    my($data, $level, $out) = @_;
    push(@{$out}, $data->[1]);
    return 
}
sub Perlito5::Perl5::PrettyPrinter::comment {
    my($data, $level, $out) = @_;
    push(@{$out}, $data->[1]);
    return 
}
sub Perlito5::Perl5::PrettyPrinter::statement {
    my($data, $level, $out) = @_;
    for my $line (1 .. $#{$data}) {
        my $d = $data->[$line];
        render($d, $level, $out);
        $line != $#{$data} && push(@{$out}, ' ')
    }
}
sub Perlito5::Perl5::PrettyPrinter::statement_modifier {
    my($data, $level, $out) = @_;
    render($data->[1], $level, $out);
    push(@{$out}, chr(10), tab($level + 1));
    render($data->[2], $level, $out)
}
sub Perlito5::Perl5::PrettyPrinter::block {
    my($data, $level, $out) = @_;
    if (@{$data} == 1) {
        push(@{$out}, '{}');
        return 
    }
    push(@{$out}, '{', chr(10));
    $level++;
    for my $line (1 .. $#{$data}) {
        my $d = $data->[$line];
        push(@{$out}, tab($level));
        render($d, $level, $out);
        $line != $#{$data} && statement_need_semicolon($d) && push(@{$out}, ';');
        push(@{$out}, chr(10))
    }
    $level--;
    push(@{$out}, tab($level), '}')
}
sub Perlito5::Perl5::PrettyPrinter::pretty_print {
    my($data, $level, $out) = @_;
    for my $line (0 .. $#{$data}) {
        my $d = $data->[$line];
        push(@{$out}, tab($level));
        render($d, $level, $out);
        $line != $#{$data} && statement_need_semicolon($d) && push(@{$out}, ';');
        push(@{$out}, chr(10))
    }
}
1;
# use Perlito5::Perl5::PrettyPrinter
package main;
package Perlito5::Perl5::Runtime;
sub Perlito5::Perl5::Runtime::emit_perl5 {
    return chr(10) . 'use v5.10;' . chr(10) . 'use feature ' . chr(39) . 'say' . chr(39) . ';' . chr(10) . chr(10)
}
1;
# use Perlito5::Perl5::Runtime
package main;
package Data::Dumper;
# use Perlito5::Dumper
sub Data::Dumper::import {
    my $pkg = shift;
    my $callpkg = caller(0);
    *{$callpkg . '::Dumper'} = \&Dumper;
    return 
}
sub Data::Dumper::Dumper {
    my $seen = {};
    my $level = '    ';
    my @out;
    for my $i (0 .. $#_) {
        my $pos = '$VAR' . ($i + 1);
        push(@out, $pos . ' = ' . Perlito5::Dumper::_dumper($_[$i], $level, $seen, $pos) . ';' . chr(10))
    }
    return join('', @out)
}
1;
package main;
package Perlito5::TreeGrammar;
# use Data::Dumper
# use strict
my %dispatch = ('Ref' => sub {
    Ref(@_)
}, 'Lookup' => sub {
    Lookup(@_)
}, 'Index' => sub {
    Index(@_)
}, 'Value' => sub {
    Value(@_)
}, 'And' => sub {
    And(@_)
}, 'Or' => sub {
    Or(@_)
}, 'Not' => sub {
    Not(@_)
}, 'Action' => sub {
    Action(@_)
}, 'Progn' => sub {
    Progn(@_)
}, 'Star' => sub {
    Star(@_)
});
sub Perlito5::TreeGrammar::render {
    my($rule, $node) = @_;
    return $dispatch{$rule->[0]}->($rule, $node)
}
sub Perlito5::TreeGrammar::scan {
    my($rule, $node) = @_;
    $rule && render($rule, $node);
    if (ref($node) eq 'ARRAY') {
        scan($rule, $_)
            for @{$node}
    }
    elsif (ref($node)) {
        scan($rule, $_)
            for values(%{$node})
    }
    return 
}
sub Perlito5::TreeGrammar::Action {
    my($rule, $node) = @_;
    $rule->[1]->($node);
    return 1
}
sub Perlito5::TreeGrammar::Not {
    my($rule, $node) = @_;
    my $result;
    render($rule->[1], $node) && return ;
    return 1
}
sub Perlito5::TreeGrammar::Star {
    my($rule, $node) = @_;
    my $result;
    while (1) {
        render($rule->[1], $node) || return 
    }
}
sub Perlito5::TreeGrammar::Progn {
    my($rule, $node) = @_;
    my $result;
    for $_ (@{$rule}[1 .. $#{$rule}]) {
        $result = render($_, $node)
    }
    return $result
}
sub Perlito5::TreeGrammar::And {
    my($rule, $node) = @_;
    my $result;
    for $_ (@{$rule}[1 .. $#{$rule}]) {
        $result = render($_, $node) or return 
    }
    return $result
}
sub Perlito5::TreeGrammar::Or {
    my($rule, $node) = @_;
    my $result;
    for $_ (@{$rule}[1 .. $#{$rule}]) {
        $result = render($_, $node) and return $result
    }
    return 
}
sub Perlito5::TreeGrammar::Ref {
    my($rule, $node) = @_;
    ref($node) ne $rule->[1] && return ;
    !$rule->[2] && return 1;
    return render($rule->[2], $node)
}
sub Perlito5::TreeGrammar::Lookup {
    my($rule, $node) = @_;
    (!ref($node) || ref($node) eq 'ARRAY' || !exists($node->{$rule->[1]})) && return ;
    !$rule->[2] && return 1;
    return render($rule->[2], $node->{$rule->[1]})
}
sub Perlito5::TreeGrammar::Index {
    my($rule, $node) = @_;
    (!ref($node) || ref($node) ne 'ARRAY' || !exists($node->[$rule->[1]])) && return ;
    !$rule->[2] && return 1;
    return render($rule->[2], $node->[$rule->[1]])
}
sub Perlito5::TreeGrammar::Value {
    my($rule, $node) = @_;
    (ref($node) || $node ne $rule->[1]) && return ;
    !$rule->[2] && return 1;
    return render($rule->[2], $node)
}
1;
package main;
package Perlito5::Perl6::TreeGrammar;
# use Data::Dumper
# use strict
# use Perlito5::TreeGrammar
sub Perlito5::Perl6::TreeGrammar::refactor_range_operator {
    my($class, $in) = @_;
    Perlito5::TreeGrammar::render(['And' => ['Lookup' => 'code', ['Value' => 'infix:<..>']], ['Lookup' => 'arguments', ['And' => ['Index' => 0, ['And' => ['Ref' => 'Perlito5::AST::Int'], ['Lookup' => 'int', ['Value' => 0]]]], ['Index' => 1, ['Or' => ['And' => ['Ref' => 'Perlito5::AST::Int'], ['Action' => sub {
        $in->{'code'} = 'p6_prefix:<^>';
        $_[0]->{'int'}++;
        shift(@{$in->{'arguments'}})
    }]], ['And' => ['Ref' => 'Perlito5::AST::Apply'], ['Lookup' => 'code', ['Value' => 'prefix:<$#>']], ['Action' => sub {
        bless($in, 'Perlito5::AST::Call');
        delete($in->{'code'});
        $in->{'method'} = 'keys';
        shift(@{$in->{'arguments'}});
        my $invocant = shift(@{$in->{'arguments'}});
        $in->{'invocant'} = $invocant->{'arguments'}->[0]
    }]], ['And' => ['Ref' => 'Perlito5::AST::Var'], ['Lookup' => 'sigil', ['Value' => '$#']], ['Action' => sub {
        bless($in, 'Perlito5::AST::Call');
        delete($in->{'code'});
        $in->{'method'} = 'keys';
        $in->{'arguments'} = [];
        my $invocant = $_[0];
        $invocant->{'sigil'} = '@';
        $in->{'invocant'} = $invocant
    }]]]]]]], $in)
}
sub Perlito5::Perl6::TreeGrammar::refactor_while_glob {
    my($class, $in) = @_;
    Perlito5::TreeGrammar::render(['Ref' => 'Perlito5::AST::While', ['Lookup' => 'cond', ['And' => ['Ref' => 'Perlito5::AST::Apply'], ['Lookup' => 'code', ['Value' => 'readline']], ['Action' => sub {
        bless($in, 'Perlito5::AST::For')
    }]]]], $in)
}
sub Perlito5::Perl6::TreeGrammar::refactor_sub_arguments {
    my($class, $in) = @_;
    my($rule, $result);
    $rule = Perlito5::Perl6::TreeGrammar::is_sub(['Action' => sub {
        my $sub = $_[0];
        my $stmts;
        my $var;
        Perlito5::TreeGrammar::render(['Lookup' => 'block', ['Progn' => ['Action' => sub {
            $stmts = $_[0]
        }], ['Star' => ['Index' => 0, Perlito5::Perl6::TreeGrammar::operator_eq('infix:<=>', ['Lookup' => 'arguments', ['And' => ['Index' => 0, Perlito5::Perl6::TreeGrammar::my_var(['Action' => sub {
            $var = $_[0]->{'var'}
        }])], ['Index' => 1, Perlito5::Perl6::TreeGrammar::shift_arg()], ['Action' => sub {
            push(@{$sub->{'args'}}, $var);
            shift(@{$stmts})
        }]]])]]]], $sub)
    }]);
    $result = Perlito5::TreeGrammar::scan($rule, $in)
}
sub Perlito5::Perl6::TreeGrammar::is_sub {
    ['Ref' => 'Perlito5::AST::Sub', (@_ ? ['Progn' => @_] : ())]
}
sub Perlito5::Perl6::TreeGrammar::named_sub {
    ['Ref' => 'Perlito5::AST::Sub', ['And' => ['Lookup' => 'name', ['Not' => ['Value' => '']]], (@_ ? ['Progn' => @_] : ())]]
}
sub Perlito5::Perl6::TreeGrammar::operator_eq {
    my $name = shift;
    ['Ref' => 'Perlito5::AST::Apply', ['And' => ['Lookup' => 'code', ['Value' => $name]], (@_ ? ['Progn' => @_] : ())]]
}
sub Perlito5::Perl6::TreeGrammar::my_var {
    ['Ref' => 'Perlito5::AST::Decl', ['And' => ['Lookup' => 'decl', ['Value' => 'my']], (@_ ? ['Progn' => @_] : ())]]
}
sub Perlito5::Perl6::TreeGrammar::var_is_at {
    ['Ref' => 'Perlito5::AST::Var', ['And' => ['Lookup' => 'sigil', ['Value' => '@']], ['Lookup' => 'name', ['Value' => '_']], (@_ ? ['Progn' => @_] : ())]]
}
sub Perlito5::Perl6::TreeGrammar::shift_arg {
    ['Ref' => 'Perlito5::AST::Apply', ['And' => ['Lookup' => 'code', ['Value' => 'shift']], ['Or' => ['Lookup' => 'arguments', ['Not' => ['Index' => 0]]], ['Lookup' => 'arguments', ['Index' => 0, var_is_at()]]], (@_ ? ['Progn' => @_] : ())]]
}
1;
package main;
undef();
# use Perlito5::AST
# use strict
# use Perlito5::Perl6::TreeGrammar
{
    package Perlito5::Perl6;
    sub Perlito5::Perl6::emit_perl6_block {
        my $block = $_[0];
        return ['block', map {
            defined($_) && $_->emit_perl6()
        } @{$block}]
    }
    my %safe_char = (' ' => 1, '!' => 1, '"' => 1, '#' => 1, '$' => 1, '%' => 1, '&' => 1, '(' => 1, ')' => 1, '*' => 1, '+' => 1, ',' => 1, '-' => 1, '.' => 1, '/' => 1, ':' => 1, ';' => 1, '<' => 1, '=' => 1, '>' => 1, '?' => 1, '@' => 1, '[' => 1, ']' => 1, '^' => 1, '_' => 1, '`' => 1, '{' => 1, '|' => 1, '}' => 1, '~' => 1);
    sub Perlito5::Perl6::escape_string {
        my $s = shift;
        my @out;
        my $tmp = '';
        $s eq '' && return chr(39) . chr(39);
        for my $i (0 .. length($s) - 1) {
            my $c = substr($s, $i, 1);
            if (($c ge 'a' && $c le 'z') || ($c ge 'A' && $c le 'Z') || ($c ge 0 && $c le 9) || exists($safe_char{$c})) {
                $tmp = $tmp . $c
            }
            else {
                $tmp ne '' && push(@out, chr(39) . $tmp . chr(39));
                push(@out, 'chr(' . ord($c) . ')');
                $tmp = ''
            }
        }
        $tmp ne '' && push(@out, chr(39) . $tmp . chr(39));
        @out < 2 && return @out;
        return ['op' => 'list:<~>', @out]
    }
}
package Perlito5::AST::CompUnit;
{
    sub Perlito5::AST::CompUnit::emit_perl6 {
        my $self = $_[0];
        my @body = grep {
            defined($_)
        } @{$self->{'body'}};
        my @out;
        my $pkg = {'name' => 'main', 'body' => []};
        for my $stmt (@body) {
            if (ref($stmt) eq 'Perlito5::AST::Apply' && $stmt->{'code'} eq 'package') {
                $Perlito5::PKG_NAME = $stmt->{'namespace'};
                @{$pkg->{'body'}} && push(@out, ['stmt' => ['keyword' => 'class'], ['bareword' => $pkg->{'name'}], ['block' => map {
                    $_->emit_perl6()
                } @{$pkg->{'body'}}]]);
                $pkg = {'name' => $stmt->{'namespace'}, 'body' => []}
            }
            else {
                push(@{$pkg->{'body'}}, $stmt)
            }
        }
        @{$pkg->{'body'}} && push(@out, ['stmt' => ['keyword' => 'class'], ['bareword' => $pkg->{'name'}], ['block' => map {
            $_->emit_perl6()
        } @{$pkg->{'body'}}]]);
        return @out
    }
    sub Perlito5::AST::CompUnit::emit_perl6_program {
        my $comp_units = $_[0];
        my @body = @{$comp_units};
        my @out;
        my $pkg = {'name' => 'main', 'body' => []};
        for my $stmt (@body) {
            if (ref($stmt) eq 'Perlito5::AST::Apply' && $stmt->{'code'} eq 'package') {
                $Perlito5::PKG_NAME = $stmt->{'namespace'};
                if (@{$pkg->{'body'}}) {
                    if ($pkg->{'name'} eq 'main') {
                        push(@out, map {
                            $_->emit_perl6()
                        } @{$pkg->{'body'}})
                    }
                    else {
                        push(@out, ['stmt' => ['keyword' => 'class'], ['bareword' => $pkg->{'name'}], ['block' => map {
                            $_->emit_perl6()
                        } @{$pkg->{'body'}}]])
                    }
                }
                $pkg = {'name' => $stmt->{'namespace'}, 'body' => []}
            }
            else {
                push(@{$pkg->{'body'}}, $stmt)
            }
        }
        if (@{$pkg->{'body'}}) {
            if ($pkg->{'name'} eq 'main') {
                push(@out, map {
                    $_->emit_perl6()
                } @{$pkg->{'body'}})
            }
            else {
                push(@out, ['stmt' => ['keyword' => 'class'], ['bareword' => $pkg->{'name'}], ['block' => map {
                    $_->emit_perl6()
                } @{$pkg->{'body'}}]])
            }
        }
        return @out
    }
}
package Perlito5::AST::Int;
{
    sub Perlito5::AST::Int::emit_perl6 {
        my $self = $_[0];
        ['number' => $self->{'int'}]
    }
}
package Perlito5::AST::Num;
{
    sub Perlito5::AST::Num::emit_perl6 {
        my $self = $_[0];
        ['number' => $self->{'num'}]
    }
}
package Perlito5::AST::Buf;
{
    sub Perlito5::AST::Buf::emit_perl6 {
        my $self = $_[0];
        Perlito5::Perl6::escape_string($self->{'buf'})
    }
}
package Perlito5::AST::Block;
{
    sub Perlito5::AST::Block::emit_perl6 {
        my $self = $_[0];
        my @out;
        $self->{'label'} && push(@out, ['label' => $self->{'label'}]);
        if ($self->{'name'}) {
            push(@out, ['stmt' => ['keyword' => $self->{'name'}], Perlito5::Perl6::emit_perl6_block($self->{'stmts'})])
        }
        else {
            push(@out, Perlito5::Perl6::emit_perl6_block($self->{'stmts'}))
        }
        if ($self->{'continue'} && @{$self->{'continue'}->{'stmts'}}) {
            push(@out, ['stmt' => ['keyword' => 'continue'], Perlito5::Perl6::emit_perl6_block($self->{'continue'}->{'stmts'})])
        }
        return @out
    }
}
package Perlito5::AST::Index;
{
    sub Perlito5::AST::Index::emit_perl6_index {
        my $self = $_[0];
        my $index = $self->{'index_exp'};
        if ($index->isa('Perlito5::AST::Apply') && $index->{'code'} eq 'prefix:<->') {
            my $arg = $index->{'arguments'}->[0];
            if ($arg->isa('Perlito5::AST::Int')) {
                return ['op' => 'infix:<->', ['bareword' => '*'], $arg->emit_perl6()]
            }
        }
        return $self->{'index_exp'}->emit_perl6()
    }
    sub Perlito5::AST::Index::emit_perl6 {
        my $self = $_[0];
        if ($self->{'obj'}->isa('Perlito5::AST::Apply') && $self->{'obj'}->{'code'} eq 'prefix:<@>') {
            return ['apply' => '[', $self->{'obj'}->emit_perl6(), $self->emit_perl6_index()]
        }
        if ($self->{'obj'}->isa('Perlito5::AST::Var') && ($self->{'obj'}->sigil() eq '$' || $self->{'obj'}->sigil() eq '@')) {
            $self->{'obj'}->{'sigil'} = '@';
            return ['apply' => '[', $self->{'obj'}->emit_perl6(), $self->emit_perl6_index()]
        }
        if ($self->{'obj'}->isa('Perlito5::AST::Apply') && $self->{'obj'}->{'code'} eq 'prefix:<$>') {
            return ['apply' => '[', $self->{'obj'}->{'arguments'}->[0]->emit_perl6(), $self->emit_perl6_index()]
        }
        return ['op' => 'infix:<.>', $self->{'obj'}->emit_perl6(), ['op' => 'circumfix:<[ ]>', $self->emit_perl6_index()]]
    }
}
package Perlito5::AST::Lookup;
{
    sub Perlito5::AST::Lookup::emit_perl6 {
        my $self = $_[0];
        if ($self->{'obj'}->isa('Perlito5::AST::Apply') && $self->{'obj'}->{'code'} eq 'prefix:<@>') {
            $self->{'obj'}->{'sigil'} = '%';
            return ['apply' => '{', $self->{'obj'}->emit_perl6(), $self->autoquote($self->{'index_exp'})->emit_perl6()]
        }
        if ($self->{'obj'}->isa('Perlito5::AST::Var') && ($self->{'obj'}->sigil() eq '$' || $self->{'obj'}->sigil() eq '@')) {
            $self->{'obj'}->{'sigil'} = '%';
            return ['apply' => '{', $self->{'obj'}->emit_perl6(), $self->autoquote($self->{'index_exp'})->emit_perl6()]
        }
        if ($self->{'obj'}->isa('Perlito5::AST::Apply') && $self->{'obj'}->{'code'} eq 'prefix:<$>') {
            return ['apply' => '{', $self->{'obj'}->{'arguments'}->[0]->emit_perl6(), $self->autoquote($self->{'index_exp'})->emit_perl6()]
        }
        return ['op' => 'infix:<.>', $self->{'obj'}->emit_perl6(), ['op' => 'circumfix:<{ }>', $self->autoquote($self->{'index_exp'})->emit_perl6()]]
    }
}
package Perlito5::AST::Var;
{
    sub Perlito5::AST::Var::emit_perl6 {
        my $self = $_[0];
        if ($self->{'sigil'} eq '$#') {
            my $v = Perlito5::AST::Var::->new(%{$self}, 'sigil' => '@');
            return ['op' => 'infix:<.>', $v->emit_perl6(), ['keyword' => 'end']]
        }
        my $str_name = $self->{'name'};
        $str_name eq chr(92) && ($str_name = chr(92) . chr(92));
        $str_name eq '"' && ($str_name = chr(92) . '"');
        if ($self->{'sigil'} eq '::') {
            if ($self->{'namespace'} eq '__PACKAGE__') {
                return ['bareword' => '$?PACKAGE']
            }
            return $self->{'namespace'}
        }
        my $ns = '';
        if ($self->{'namespace'}) {
            if ($self->{'namespace'} eq 'main' && substr($self->{'name'}, 0, 1) eq '^') {
                return $self->{'sigil'} . '{' . $self->{'name'} . '}'
            }
            else {
                $ns = $self->{'namespace'} . '::'
            }
        }
        my $bareword = $ns . $str_name;
        my $c = substr($self->{'name'}, 0, 1);
        if (($c ge 'a' && $c le 'z') || ($c ge 'A' && $c le 'Z') || ($c eq '_')) {
            $self->{'sigil'} eq '@' && $bareword eq 'ARGV' && return '@*ARGS';
            return $self->{'sigil'} . $bareword
        }
        if ($self->{'sigil'} eq '$') {
            $bareword eq '/' && return '"' . chr(92) . 'n"';
            $bareword eq '$' && return '$*PID';
            $bareword eq 0 && return '$*PROGRAM_NAME';
            $bareword eq '@' && return '$!';
            $bareword >= 1 && return '$' . ($bareword - 1)
        }
        my $str = $self->{'sigil'} . '{' . chr(39) . $bareword . chr(39) . '}';
        return $str
    }
}
package Perlito5::AST::Call;
{
    sub Perlito5::AST::Call::emit_perl6 {
        my $self = $_[0];
        my $invocant = $self->{'invocant'}->emit_perl6();
        if ($self->{'method'} eq 'postcircumfix:<[ ]>') {
            return ['op' => 'infix:<.>', $invocant, ['op' => 'circumfix:<[ ]>', $self->{'arguments'}->emit_perl6()]]
        }
        if ($self->{'method'} eq 'postcircumfix:<{ }>') {
            return ['op' => 'infix:<.>', $invocant, ['op' => 'circumfix:<{ }>', Perlito5::AST::Lookup::->autoquote($self->{'arguments'})->emit_perl6()]]
        }
        my $meth = $self->{'method'};
        if ($meth eq 'postcircumfix:<( )>') {
            if ((ref($self->{'invocant'}) eq 'Perlito5::AST::Var' && $self->{'invocant'}->{'sigil'} eq '&') || (ref($self->{'invocant'}) eq 'Perlito5::AST::Apply' && $self->{'invocant'}->{'code'} eq 'prefix:<&>')) {
                return ['apply' => '(', $invocant, map {
                    $_->emit_perl6()
                } @{$self->{'arguments'}}]
            }
            $meth = ''
        }
        if (ref($meth) eq 'Perlito5::AST::Var') {
            $meth = $meth->emit_perl6()
        }
        if ($meth) {
            return ['call' => $invocant, $meth, map {
                $_->emit_perl6()
            } @{$self->{'arguments'}}]
        }
        return ['op' => 'infix:<.>', $invocant, ['op' => 'list:<,>', map {
            $_->emit_perl6()
        } @{$self->{'arguments'}}]]
    }
}
package Perlito5::AST::Apply;
{
    my %special_var = (chr(15) => '$*VM');
    my %op_translate = ('list:<.>' => 'list:<~>', 'infix:<.=>' => 'infix:<~=>', 'infix:<=~>' => 'infix:<~~>', 'infix:<!~>' => 'infix:<!~~>', 'infix:<cmp>' => 'infix:<leq>', 'ternary:<? :>' => 'ternary:<?? !!>', 'reverse' => 'flip');
    sub Perlito5::AST::Apply::emit_perl6_args {
        my $self = $_[0];
        !$self->{'arguments'} && return ();
        return map {
            $_->emit_perl6()
        } @{$self->{'arguments'}}
    }
    sub Perlito5::AST::Apply::emit_perl6 {
        my $self = $_[0];
        my $code = $self->{'code'};
        if (ref($code)) {
            return ['op' => 'infix:<.>', $code->emit_perl6(), $self->emit_perl6_args()]
        }
        if ($code eq 'infix:<=>>') {
            return ['op' => $code, Perlito5::AST::Lookup::->autoquote($self->{'arguments'}->[0])->emit_perl6(), $self->{'arguments'}->[1]->emit_perl6()]
        }
        if ($code eq 'nan' && !$self->{'namespace'}) {
            return ['keyword' => 'NaN']
        }
        if ($code eq 'inf' && !$self->{'namespace'}) {
            return ['keyword' => 'Inf']
        }
        if ($code eq '__PACKAGE__' && !$self->{'namespace'}) {
            return ['bareword' => '$?PACKAGE']
        }
        if ($code eq 'prefix:<$#>') {
            return ['op' => 'infix:<.>', $self->{'arguments'}->[0]->emit_perl6(), ['keyword' => 'end']]
        }
        if ($code eq 'scalar') {
            my $arg = $self->{'arguments'}->[0];
            if ($arg->isa('Perlito5::AST::Var') && $arg->{'sigil'} eq '@') {
                return ['op' => 'infix:<.>', $arg->emit_perl6(), ['keyword' => 'elems']]
            }
        }
        if (($code eq 'shift' || $code eq 'pop') && !@{$self->{'arguments'}}) {
            return ['apply' => '(', $code, '@_']
        }
        if ($code eq 'readline' && ref($self->{'arguments'}->[0]) eq 'Perlito5::AST::Buf' && $self->{'arguments'}->[0]->{'buf'} eq '') {
            return ['apply' => '(', ['keyword' => 'lines']]
        }
        if ($code eq 'infix:<x>') {
            my $arg = $self->{'arguments'}->[0];
            if (ref($arg) eq 'Perlito5::AST::Apply' && $arg->{'code'} eq 'circumfix:<( )>') {
                $code = 'infix:<xx>'
            }
        }
        if (($code eq 'print' || $code eq 'say') && !@{$self->{'arguments'}}) {
            return ['keyword' => '.' . $code]
        }
        if ($code eq 'infix:<..>') {
            Perlito5::Perl6::TreeGrammar::->refactor_range_operator($self);
            if (ref($self) ne 'Perlito5::AST::Apply') {
                return $self->emit_perl6()
            }
            $code = $self->{'code'}
        }
        $op_translate{$code} && ($code = $op_translate{$code});
        if ($code eq 'prefix:<$>') {
            my $arg = $self->{'arguments'}->[0];
            $arg->isa('Perlito5::AST::Buf') && exists($special_var{$arg->{'buf'}}) && return $special_var{$arg->{'buf'}}
        }
        if ($Perlito5::Perl6::PrettyPrinter::op{$code}) {
            return ['op' => $code, $self->emit_perl6_args()]
        }
        if ($code eq 'undef') {
            if (@{$self->{'arguments'}}) {
                die('TODO - undef(expr)')
            }
            else {
                return 'Any'
            }
        }
        my $ns = '';
        if ($self->{'namespace'}) {
            $ns = $self->{'namespace'} . '::'
        }
        $code = $ns . $code;
        if ($self->{'code'} eq 'p5:s') {
            my $modifier = $self->{'arguments'}->[2]->{'buf'};
            $modifier && ($modifier = ':' . $modifier);
            return 's:P5' . $modifier . '!' . $self->{'arguments'}->[0]->{'buf'} . '!' . $self->{'arguments'}->[1]->{'buf'} . '!'
        }
        if ($self->{'code'} eq 'p5:m') {
            my $s;
            if ($self->{'arguments'}->[0]->isa('Perlito5::AST::Buf')) {
                $s = $self->{'arguments'}->[0]->{'buf'}
            }
            else {
                for my $ast (@{$self->{'arguments'}->[0]->{'arguments'}}) {
                    if ($ast->isa('Perlito5::AST::Buf')) {
                        $s .= $ast->{'buf'}
                    }
                    else {
                        $s .= $ast->emit_perl6()
                    }
                }
            }
            my $modifier = $self->{'arguments'}->[1]->{'buf'};
            $modifier && ($modifier = ':' . $modifier);
            return 'm:P5' . $modifier . '!' . $s . '!'
        }
        if ($self->{'code'} eq 'p5:tr') {
            return 'tr!' . $self->{'arguments'}->[0]->{'buf'} . '!' . $self->{'arguments'}->[1]->{'buf'} . '!'
        }
        if ($self->{'code'} eq 'package') {
            $Perlito5::PKG_NAME = $self->{'namespace'};
            return ['stmt' => 'class', ['bareword' => $self->{'namespace'}]]
        }
        if ($code eq 'map' || $code eq 'grep' || $code eq 'sort') {
            if ($self->{'special_arg'}) {
                return ['op' => 'prefix:<' . $code . '>', ['block', map {
                    $_->emit_perl6()
                } @{$self->{'special_arg'}->{'stmts'}}], ['op' => 'list:<,>', $self->emit_perl6_args()]]
            }
            return ['apply' => '(', $code, $self->emit_perl6_args()]
        }
        if ($self->{'bareword'} && !@{$self->{'arguments'}}) {
            return ['bareword' => $code]
        }
        if ($code eq 'eval') {
            $code = 'EVAL'
        }
        return ['apply' => '(', $code, $self->emit_perl6_args()]
    }
}
package Perlito5::AST::If;
{
    sub Perlito5::AST::If::emit_perl6 {
        my $self = $_[0];
        if ($self->{'body'} && ref($self->{'body'}) ne 'Perlito5::AST::Block') {
            return ['stmt_modifier' => $self->{'body'}->emit_perl6(), ['stmt' => 'if', $self->{'cond'}->emit_perl6()]]
        }
        if ($self->{'otherwise'} && ref($self->{'otherwise'}) ne 'Perlito5::AST::Block') {
            return ['stmt_modifier' => $self->{'otherwise'}->emit_perl6(), ['stmt' => 'unless', $self->{'cond'}->emit_perl6()]]
        }
        my @out = (['stmt' => ['keyword' => 'if'], $self->{'cond'}->emit_perl6(), Perlito5::Perl6::emit_perl6_block($self->{'body'}->stmts())]);
        my $otherwise = $self->{'otherwise'};
        while ($otherwise && @{$otherwise->{'stmts'}} == 1 && ref($otherwise->{'stmts'}->[0]) eq 'Perlito5::AST::If' && ($otherwise->{'stmts'}->[0]->{'body'} && ref($otherwise->{'stmts'}->[0]->{'body'}) eq 'Perlito5::AST::Block')) {
            push(@out, ['stmt' => ['keyword' => 'elsif'], $otherwise->{'stmts'}->[0]->{'cond'}->emit_perl6(), Perlito5::Perl6::emit_perl6_block($otherwise->{'stmts'}->[0]->{'body'}->{'stmts'})]);
            $otherwise = $otherwise->{'stmts'}->[0]->{'otherwise'}
        }
        !($otherwise && scalar(@{$otherwise->stmts()})) && return @out;
        push(@out, ['stmt' => ['keyword' => 'else'], Perlito5::Perl6::emit_perl6_block($otherwise->stmts())]);
        return @out
    }
}
package Perlito5::AST::When;
{
    sub Perlito5::AST::When::emit_perl6 {
        my $self = $_[0];
        return ['stmt' => ['keyword' => 'when'], $self->{'cond'}->emit_perl6(), Perlito5::Perl6::emit_perl6_block($self->{'body'}->stmts())]
    }
}
package Perlito5::AST::While;
{
    sub Perlito5::AST::While::emit_perl6 {
        my $self = $_[0];
        Perlito5::Perl6::TreeGrammar::->refactor_while_glob($self);
        if (ref($self) ne 'Perlito5::AST::While') {
            return $self->emit_perl6()
        }
        my @out;
        $self->{'label'} && push(@out, ['label' => $self->{'label'}]);
        if ($self->{'body'} && ref($self->{'body'}) ne 'Perlito5::AST::Block') {
            return @out, ['stmt_modifier' => $self->{'body'}->emit_perl6(), ['stmt' => ['keyword' => 'while'], $self->{'cond'}->emit_perl6()]]
        }
        push(@out, ['stmt' => ['keyword' => 'while'], $self->{'cond'}->emit_perl6(), Perlito5::Perl6::emit_perl6_block($self->{'body'}->stmts())]);
        if ($self->{'continue'} && @{$self->{'continue'}->{'stmts'}}) {
            push(@out, ['stmt' => ['keyword' => 'continue'], Perlito5::Perl6::emit_perl6_block($self->{'continue'}->{'stmts'})])
        }
        return @out
    }
}
package Perlito5::AST::For;
{
    sub Perlito5::AST::For::emit_perl6 {
        my $self = $_[0];
        my @out;
        $self->{'label'} && push(@out, ['label' => $self->{'label'}]);
        if ($self->{'body'} && ref($self->{'body'}) ne 'Perlito5::AST::Block') {
            return @out, ['stmt_modifier' => $self->{'body'}->emit_perl6(), ['stmt' => 'for', $self->{'cond'}->emit_perl6()]]
        }
        my $cond;
        my $keyword;
        if (ref($self->{'cond'}) eq 'ARRAY') {
            $keyword = 'loop';
            $cond = ['paren_semicolon' => '(', ($self->{'cond'}->[0] ? $self->{'cond'}->[0]->emit_perl6() : []), ($self->{'cond'}->[1] ? $self->{'cond'}->[1]->emit_perl6() : []), ($self->{'cond'}->[2] ? $self->{'cond'}->[2]->emit_perl6() : [])]
        }
        else {
            $keyword = 'for';
            $cond = $self->{'cond'}->emit_perl6()
        }
        my @sig;
        my $sig_ast = $self->{'topic'};
        if (!$sig_ast) {}
        else {
            ref($sig_ast) eq 'Perlito5::AST::Decl' && ($sig_ast = $sig_ast->{'var'});
            @sig = ('->', $sig_ast->emit_perl6())
        }
        push(@out, ['stmt' => ['keyword' => $keyword], $cond, @sig, Perlito5::Perl6::emit_perl6_block($self->{'body'}->stmts())]);
        if ($self->{'continue'} && @{$self->{'continue'}->{'stmts'}}) {
            push(@out, ['stmt' => ['keyword' => 'continue'], Perlito5::Perl6::emit_perl6_block($self->{'continue'}->{'stmts'})])
        }
        return @out
    }
}
package Perlito5::AST::Decl;
{
    sub Perlito5::AST::Decl::emit_perl6 {
        my $self = $_[0];
        return ['op' => 'prefix:<' . $self->{'decl'} . '>', ($self->{'type'} ? $self->{'type'} : ()), $self->{'var'}->emit_perl6()]
    }
}
package Perlito5::AST::Sub;
{
    sub Perlito5::AST::Sub::emit_perl6 {
        my $self = $_[0];
        Perlito5::Perl6::TreeGrammar::->refactor_sub_arguments($self);
        my @parts;
        if ($self->{'args'}) {
            push(@parts, ['paren' => '(', (map {
                ['var' => $_->emit_perl6(), '?']
            } @{$self->{'args'}}), ['var' => '*@_']])
        }
        else {
            push(@parts, ['paren' => '(', ['var' => '*@_']])
        }
        defined($self->{'block'}) && push(@parts, Perlito5::Perl6::emit_perl6_block($self->{'block'}->{'stmts'}));
        !$self->{'name'} && return ['op' => 'prefix:<sub>', @parts];
        my $is_our = 1;
        $self->{'decl'} eq 'my' && ($is_our = 0);
        my $name = $self->{'name'};
        if ($Perlito5::PKG_NAME ne $self->{'namespace'}) {
            $name = $self->{'namespace'} . '::' . $name;
            $is_our = 0
        }
        if ($is_our) {
            return ['stmt' => ['keyword' => 'our'], ['keyword' => 'sub'], ['bareword' => $name], @parts]
        }
        else {
            return ['stmt' => ['keyword' => 'sub'], ['bareword' => $name], @parts]
        }
    }
}
package Perlito5::AST::Use;
{
    sub Perlito5::AST::Use::emit_perl6 {
        my $self = shift;
        Perlito5::Grammar::Use::emit_time_eval($self);
        return ['comment' => '# ' . $self->{'code'} . ' ' . $self->{'mod'}]
    }
}
# use Perlito5::Perl6::Emitter
package main;
package Perlito5::Perl6::PrettyPrinter;
# use strict
# use warnings
my %dispatch = ('stmt' => sub {
    statement(@_)
}, 'stmt_modifier' => sub {
    statement_modifier(@_)
}, 'block' => sub {
    block(@_)
}, 'keyword' => sub {
    keyword(@_)
}, 'bareword' => sub {
    bareword(@_)
}, 'number' => sub {
    number(@_)
}, 'op' => sub {
    op(@_)
}, 'paren' => sub {
    paren(@_)
}, 'paren_semicolon' => sub {
    paren_semicolon(@_)
}, 'apply' => sub {
    apply(@_)
}, 'call' => sub {
    call(@_)
}, 'comment' => sub {
    comment(@_)
}, 'label' => sub {
    label(@_)
}, 'var' => sub {
    var(@_)
});
my %pair = ('(' => ')', '[' => ']', '{' => '}');
our %op = ('prefix:<$>' => {'fix' => 'deref', 'prec' => 0, 'str' => '$'}, 'prefix:<@>' => {'fix' => 'deref', 'prec' => 0, 'str' => '@'}, 'prefix:<%>' => {'fix' => 'deref', 'prec' => 0, 'str' => '%'}, 'prefix:<&>' => {'fix' => 'deref', 'prec' => 0, 'str' => '&'}, 'prefix:<*>' => {'fix' => 'deref', 'prec' => 0, 'str' => '*'}, 'prefix:<$#>' => {'fix' => 'deref', 'prec' => 0, 'str' => '$#'}, 'circumfix:<[ ]>' => {'fix' => 'circumfix', 'prec' => 0, 'str' => '['}, 'circumfix:<{ }>' => {'fix' => 'circumfix', 'prec' => 0, 'str' => '{'}, 'circumfix:<( )>' => {'fix' => 'circumfix', 'prec' => 0, 'str' => '('}, 'infix:<.>' => {'fix' => 'infix', 'prec' => -1, 'str' => '.'}, 'prefix:<-->' => {'fix' => 'prefix', 'prec' => 1, 'str' => '--'}, 'prefix:<++>' => {'fix' => 'prefix', 'prec' => 1, 'str' => '++'}, 'postfix:<-->' => {'fix' => 'postfix', 'prec' => 1, 'str' => '--'}, 'postfix:<++>' => {'fix' => 'postfix', 'prec' => 1, 'str' => '++'}, 'infix:<**>' => {'fix' => 'infix', 'prec' => 2, 'str' => '**'}, 'p6_prefix:<^>' => {'fix' => 'prefix', 'prec' => 3, 'str' => '^'}, 'prefix:<' . chr(92) . '>' => {'fix' => 'prefix', 'prec' => 3, 'str' => chr(92)}, 'prefix:<+>' => {'fix' => 'prefix', 'prec' => 3, 'str' => '+'}, 'prefix:<->' => {'fix' => 'prefix', 'prec' => 3, 'str' => '-'}, 'prefix:<~>' => {'fix' => 'prefix', 'prec' => 3, 'str' => '~'}, 'prefix:<!>' => {'fix' => 'prefix', 'prec' => 3, 'str' => '!'}, 'infix:<=~>' => {'fix' => 'infix', 'prec' => 4, 'str' => ' =~ '}, 'infix:<!~>' => {'fix' => 'infix', 'prec' => 4, 'str' => ' !~ '}, 'infix:<*>' => {'fix' => 'infix', 'prec' => 5, 'str' => ' * '}, 'infix:</>' => {'fix' => 'infix', 'prec' => 5, 'str' => ' / '}, 'infix:<%>' => {'fix' => 'infix', 'prec' => 5, 'str' => ' % '}, 'infix:<+>' => {'fix' => 'infix', 'prec' => 6, 'str' => ' + '}, 'infix:<->' => {'fix' => 'infix', 'prec' => 6, 'str' => ' - '}, 'infix:<x>' => {'fix' => 'infix', 'prec' => 8, 'str' => ' x '}, 'infix:<xx>' => {'fix' => 'infix', 'prec' => 8, 'str' => ' xx '}, 'list:<~>' => {'fix' => 'list', 'prec' => 10, 'str' => ' ~ '}, 'infix:<~>' => {'fix' => 'infix', 'prec' => 10, 'str' => ' ~ '}, 'infix:<<<>' => {'fix' => 'infix', 'prec' => 12, 'str' => ' << '}, 'infix:<>>>' => {'fix' => 'infix', 'prec' => 12, 'str' => ' >> '}, 'infix:<lt>' => {'fix' => 'infix', 'prec' => 90, 'str' => ' lt '}, 'infix:<le>' => {'fix' => 'infix', 'prec' => 90, 'str' => ' le '}, 'infix:<gt>' => {'fix' => 'infix', 'prec' => 90, 'str' => ' gt '}, 'infix:<ge>' => {'fix' => 'infix', 'prec' => 90, 'str' => ' ge '}, 'infix:<<=>' => {'fix' => 'infix', 'prec' => 90, 'str' => ' <= '}, 'infix:<>=>' => {'fix' => 'infix', 'prec' => 90, 'str' => ' >= '}, 'infix:<<>' => {'fix' => 'infix', 'prec' => 90, 'str' => ' < '}, 'infix:<>>' => {'fix' => 'infix', 'prec' => 90, 'str' => ' > '}, 'infix:<<=>>' => {'fix' => 'infix', 'prec' => 100, 'str' => ' <=> '}, 'infix:<cmp>' => {'fix' => 'infix', 'prec' => 100, 'str' => ' cmp '}, 'infix:<leq>' => {'fix' => 'infix', 'prec' => 100, 'str' => ' leq '}, 'infix:<==>' => {'fix' => 'infix', 'prec' => 100, 'str' => ' == '}, 'infix:<!=>' => {'fix' => 'infix', 'prec' => 100, 'str' => ' != '}, 'infix:<ne>' => {'fix' => 'infix', 'prec' => 100, 'str' => ' ne '}, 'infix:<eq>' => {'fix' => 'infix', 'prec' => 100, 'str' => ' eq '}, 'infix:<&>' => {'fix' => 'infix', 'prec' => 110, 'str' => ' & '}, 'infix:<|>' => {'fix' => 'infix', 'prec' => 120, 'str' => ' | '}, 'infix:<^>' => {'fix' => 'infix', 'prec' => 120, 'str' => ' ^ '}, 'infix:<..>' => {'fix' => 'infix', 'prec' => 130, 'str' => ' .. '}, 'infix:<...>' => {'fix' => 'infix', 'prec' => 130, 'str' => ' ... '}, 'infix:<~~>' => {'fix' => 'infix', 'prec' => 130, 'str' => ' ~~ '}, 'infix:<&&>' => {'fix' => 'infix', 'prec' => 140, 'str' => ' && '}, 'infix:<||>' => {'fix' => 'infix', 'prec' => 150, 'str' => ' || '}, 'infix:<//>' => {'fix' => 'infix', 'prec' => 150, 'str' => ' // '}, 'ternary:<?? !!>' => {'fix' => 'ternary', 'prec' => 160}, 'infix:<=>' => {'fix' => 'infix', 'prec' => 170, 'str' => ' = '}, 'infix:<**=>' => {'fix' => 'infix', 'prec' => 170, 'str' => ' **= '}, 'infix:<+=>' => {'fix' => 'infix', 'prec' => 170, 'str' => ' += '}, 'infix:<-=>' => {'fix' => 'infix', 'prec' => 170, 'str' => ' -= '}, 'infix:<*=>' => {'fix' => 'infix', 'prec' => 170, 'str' => ' *= '}, 'infix:</=>' => {'fix' => 'infix', 'prec' => 170, 'str' => ' /= '}, 'infix:<x=>' => {'fix' => 'infix', 'prec' => 170, 'str' => ' x= '}, 'infix:<|=>' => {'fix' => 'infix', 'prec' => 170, 'str' => ' |= '}, 'infix:<&=>' => {'fix' => 'infix', 'prec' => 170, 'str' => ' &= '}, 'infix:<.=>' => {'fix' => 'infix', 'prec' => 170, 'str' => ' .= '}, 'infix:<<<=>' => {'fix' => 'infix', 'prec' => 170, 'str' => ' <<= '}, 'infix:<>>=>' => {'fix' => 'infix', 'prec' => 170, 'str' => ' >>= '}, 'infix:<%=>' => {'fix' => 'infix', 'prec' => 170, 'str' => ' %= '}, 'infix:<||=>' => {'fix' => 'infix', 'prec' => 170, 'str' => ' ||= '}, 'infix:<&&=>' => {'fix' => 'infix', 'prec' => 170, 'str' => ' &&= '}, 'infix:<^=>' => {'fix' => 'infix', 'prec' => 170, 'str' => ' ^= '}, 'infix:<//=>' => {'fix' => 'infix', 'prec' => 170, 'str' => ' //= '}, 'infix:<~=>' => {'fix' => 'infix', 'prec' => 170, 'str' => ' ~= '}, 'infix:<=>>' => {'fix' => 'infix', 'prec' => 180, 'str' => ' => '}, 'list:<,>' => {'fix' => 'list', 'prec' => 190, 'str' => ', '}, 'infix:<:>' => {'fix' => 'infix', 'prec' => 190, 'str' => ':'}, 'prefix:<not>' => {'fix' => 'prefix', 'prec' => 200, 'str' => ' not '}, 'infix:<and>' => {'fix' => 'infix', 'prec' => 210, 'str' => ' and '}, 'infix:<or>' => {'fix' => 'infix', 'prec' => 220, 'str' => ' or '}, 'infix:<xor>' => {'fix' => 'infix', 'prec' => 220, 'str' => ' xor '});
$op{'prefix:<' . $_ . '>'} = {'fix' => 'prefix', 'prec' => 8, 'str' => $_ . ' '}
    for '-r', '-w', '-x', '-o', '-R', '-W', '-X', '-O', '-e', '-z', '-s', '-f', '-d', '-l', '-p', '-S', '-b', '-c', '-t', '-u', '-g', '-k', '-T', '-B', '-M', '-A', '-C';
$op{'prefix:<' . $_ . '>'} = {'fix' => 'parsed', 'prec' => 8, 'str' => $_}
    for 'do', 'sub', 'my', 'our', 'state', 'local', 'map', 'grep', 'sort';
my %tab;
sub Perlito5::Perl6::PrettyPrinter::tab {
    my $level = $_[0];
    $tab{$level} //= '    ' x $level
}
sub Perlito5::Perl6::PrettyPrinter::render {
    my($data, $level, $out) = @_;
    if (ref($data)) {
        $dispatch{$data->[0]}->($data, $level, $out)
    }
    else {
        push(@{$out}, $data)
    }
}
sub Perlito5::Perl6::PrettyPrinter::op_precedence {
    my($data) = @_;
    !ref($data) && return 0;
    $data->[0] ne 'op' && return 0;
    return $op{$data->[1]}->{'prec'} || 0
}
sub Perlito5::Perl6::PrettyPrinter::statement_need_semicolon {
    my($data) = @_;
    !ref($data) && return 1;
    ($data->[0] eq 'block' || $data->[0] eq 'comment' || $data->[0] eq 'label') && return 0;
    if ($data->[0] eq 'stmt') {
        if (ref($data->[1])) {
            my $dd = $data->[1];
            if ($dd->[0] eq 'keyword') {
                ref($data->[-1]) && $data->[-1]->[0] eq 'block' && return 0
            }
        }
    }
    return 1
}
sub Perlito5::Perl6::PrettyPrinter::op_render {
    my($data, $level, $out, $current_op) = @_;
    if (ref($data)) {
        my $this_prec = op_precedence($data);
        $this_prec && $current_op->{'prec'} && $current_op->{'prec'} < $this_prec && push(@{$out}, '(');
        render($data, $level, $out);
        $this_prec && $current_op->{'prec'} && $current_op->{'prec'} < $this_prec && push(@{$out}, ')')
    }
    else {
        push(@{$out}, $data)
    }
}
sub Perlito5::Perl6::PrettyPrinter::op {
    my($data, $level, $out) = @_;
    my $op = $data->[1];
    my $spec = $op{$op} || die('unknown op: ' . $op);
    if ($spec->{'fix'} eq 'infix') {
        op_render($data->[2], $level, $out, $spec);
        push(@{$out}, $spec->{'str'});
        op_render($data->[3], $level, $out, $spec)
    }
    elsif ($spec->{'fix'} eq 'prefix') {
        push(@{$out}, $spec->{'str'});
        op_render($data->[2], $level, $out, $spec)
    }
    elsif ($spec->{'fix'} eq 'postfix') {
        op_render($data->[2], $level, $out, $spec);
        push(@{$out}, $spec->{'str'})
    }
    elsif ($spec->{'fix'} eq 'ternary') {
        op_render($data->[2], $level, $out, $spec);
        push(@{$out}, ' ?? ');
        op_render($data->[3], $level, $out, $spec);
        push(@{$out}, ' !! ');
        op_render($data->[4], $level, $out, $spec)
    }
    elsif ($spec->{'fix'} eq 'deref') {
        push(@{$out}, $spec->{'str'}, '(');
        op_render($data->[2], $level, $out, $spec);
        push(@{$out}, ')')
    }
    elsif ($spec->{'fix'} eq 'circumfix') {
        push(@{$out}, $spec->{'str'});
        for my $line (2 .. $#{$data}) {
            op_render($data->[$line], $level, $out, $spec);
            $line != $#{$data} && push(@{$out}, ', ')
        }
        push(@{$out}, $pair{$spec->{'str'}})
    }
    elsif ($spec->{'fix'} eq 'list') {
        for my $line (2 .. $#{$data}) {
            op_render($data->[$line], $level, $out, $spec);
            $line != $#{$data} && push(@{$out}, $spec->{'str'})
        }
    }
    elsif ($spec->{'fix'} eq 'parsed') {
        push(@{$out}, $spec->{'str'});
        for my $line (2 .. $#{$data}) {
            my $d = $data->[$line];
            push(@{$out}, ' ');
            render($d, $level, $out)
        }
    }
    else {
        die('unknown fixity: ' . $spec->{'fix'})
    }
    return 
}
sub Perlito5::Perl6::PrettyPrinter::call {
    my($data, $level, $out) = @_;
    my @dd = @{$data};
    shift(@dd);
    my $open = '(';
    render(shift(@dd), $level, $out);
    push(@{$out}, '.');
    my $d = $dd[0];
    render($d, $level, $out);
    if ($open eq '(' && @dd == 1) {
        return 
    }
    $dd[0] = 'list:<,>';
    push(@{$out}, $open);
    op(['op' => @dd], $level, $out);
    push(@{$out}, $pair{$open})
}
sub Perlito5::Perl6::PrettyPrinter::apply {
    my($data, $level, $out) = @_;
    my @dd = @{$data};
    shift(@dd);
    my $open = shift(@dd);
    my $d = $dd[0];
    render($d, $level, $out);
    if ($open eq '(' && @dd == 1) {
        return 
    }
    $dd[0] = 'list:<,>';
    push(@{$out}, $open);
    op(['op' => @dd], $level, $out);
    push(@{$out}, $pair{$open})
}
sub Perlito5::Perl6::PrettyPrinter::paren {
    my($data, $level, $out) = @_;
    my @dd = @{$data};
    shift(@dd);
    my $open = $dd[0];
    $dd[0] = 'list:<,>';
    push(@{$out}, $open);
    op(['op' => @dd], $level, $out);
    push(@{$out}, $pair{$open})
}
sub Perlito5::Perl6::PrettyPrinter::paren_semicolon {
    my($data, $level, $out) = @_;
    push(@{$out}, $data->[1]);
    for my $line (2 .. $#{$data}) {
        @{$data->[$line]} && render($data->[$line], $level, $out);
        if ($line != $#{$data}) {
            if (@{$data->[$line + 1]}) {
                push(@{$out}, '; ')
            }
            else {
                push(@{$out}, ';')
            }
        }
    }
    push(@{$out}, $pair{$data->[1]})
}
sub Perlito5::Perl6::PrettyPrinter::var {
    my($data, $level, $out) = @_;
    push(@{$out}, @{$data}[1 .. $#{$data}]);
    return 
}
sub Perlito5::Perl6::PrettyPrinter::label {
    my($data, $level, $out) = @_;
    push(@{$out}, $data->[1], ':');
    return 
}
sub Perlito5::Perl6::PrettyPrinter::keyword {
    my($data, $level, $out) = @_;
    push(@{$out}, $data->[1]);
    return 
}
sub Perlito5::Perl6::PrettyPrinter::bareword {
    my($data, $level, $out) = @_;
    push(@{$out}, $data->[1]);
    return 
}
sub Perlito5::Perl6::PrettyPrinter::number {
    my($data, $level, $out) = @_;
    push(@{$out}, $data->[1]);
    return 
}
sub Perlito5::Perl6::PrettyPrinter::comment {
    my($data, $level, $out) = @_;
    push(@{$out}, $data->[1]);
    return 
}
sub Perlito5::Perl6::PrettyPrinter::statement {
    my($data, $level, $out) = @_;
    for my $line (1 .. $#{$data}) {
        my $d = $data->[$line];
        render($d, $level, $out);
        $line != $#{$data} && push(@{$out}, ' ')
    }
}
sub Perlito5::Perl6::PrettyPrinter::statement_modifier {
    my($data, $level, $out) = @_;
    render($data->[1], $level, $out);
    push(@{$out}, chr(10), tab($level + 1));
    render($data->[2], $level, $out)
}
sub Perlito5::Perl6::PrettyPrinter::block {
    my($data, $level, $out) = @_;
    if (@{$data} == 1) {
        push(@{$out}, '{}');
        return 
    }
    push(@{$out}, '{', chr(10));
    $level++;
    for my $line (1 .. $#{$data}) {
        my $d = $data->[$line];
        push(@{$out}, tab($level));
        render($d, $level, $out);
        $line != $#{$data} && statement_need_semicolon($d) && push(@{$out}, ';');
        push(@{$out}, chr(10))
    }
    $level--;
    push(@{$out}, tab($level), '}')
}
sub Perlito5::Perl6::PrettyPrinter::pretty_print {
    my($data, $level, $out) = @_;
    for my $line (0 .. $#{$data}) {
        my $d = $data->[$line];
        push(@{$out}, tab($level));
        render($d, $level, $out);
        $line != $#{$data} && statement_need_semicolon($d) && push(@{$out}, ';');
        push(@{$out}, chr(10))
    }
}
1;
# use Perlito5::Perl6::PrettyPrinter
package main;
undef();
# use Perlito5::AST
package Perlito5::XS;
{
    sub Perlito5::XS::tab {
        my $level = shift;
        '    ' x $level
    }
    my %safe_char = (' ' => 1, '!' => 1, '"' => 1, '#' => 1, '$' => 1, '%' => 1, '&' => 1, '(' => 1, ')' => 1, '*' => 1, '+' => 1, ',' => 1, '-' => 1, '.' => 1, '/' => 1, ':' => 1, ';' => 1, '<' => 1, '=' => 1, '>' => 1, '?' => 1, '@' => 1, '[' => 1, ']' => 1, '^' => 1, '_' => 1, '`' => 1, '{' => 1, '|' => 1, '}' => 1, '~' => 1);
    sub Perlito5::XS::escape_string {
        my $s = shift;
        my $tmp = '';
        $s eq '' && return '""';
        for my $i (0 .. length($s) - 1) {
            my $c = substr($s, $i, 1);
            if (($c ge 'a' && $c le 'z') || ($c ge 'A' && $c le 'Z') || ($c ge 0 && $c le 9) || exists($safe_char{$c})) {
                $tmp = $tmp . $c
            }
            else {
                $tmp .= sprintf(chr(92) . 'x%02x', ord($c))
            }
        }
        return '"' . $tmp . '"'
    }
}
package Perlito5::AST::CompUnit;
{
    sub Perlito5::AST::CompUnit::emit_xs {
        my $self = $_[0];
        my $level = $_[1];
        my @body;
        for $_ (@{$self->{'body'}}) {
            if (defined($_)) {
                push(@body, $_)
            }
        }
        join(chr(10), map(Perlito5::XS::tab($level) . $_->emit_xs($level), @body)) . chr(10) . chr(10) . chr(10)
    }
    sub Perlito5::AST::CompUnit::emit_xs_program {
        my $comp_units = $_[0];
        my $str = '#include "EXTERN.h"' . chr(10) . '#include "perl.h"' . chr(10) . '#include "XSUB.h"' . chr(10) . chr(10);
        for my $comp_unit (@{$comp_units}) {
            $str .= $comp_unit->emit_xs(0)
        }
        $str .= chr(10);
        return $str
    }
}
package Perlito5::AST::Int;
{
    sub Perlito5::AST::Int::emit_xs {
        my $self = $_[0];
        my $level = $_[1];
        'newSViv(' . $self->{'int'} . ')'
    }
}
package Perlito5::AST::Num;
{
    sub Perlito5::AST::Num::emit_xs {
        my $self = $_[0];
        my $level = $_[1];
        'newSVnv(' . $self->{'num'} . ')'
    }
}
package Perlito5::AST::Buf;
{
    sub Perlito5::AST::Buf::emit_xs {
        my $self = $_[0];
        my $level = $_[1];
        'newSVpv(' . Perlito5::XS::escape_string($self->{'buf'}) . ', 0)'
    }
}
package Perlito5::AST::Block;
{
    sub Perlito5::AST::Block::emit_xs {
        my $self = $_[0];
        my $level = $_[1];
        'do {{' . chr(10) . join(';' . chr(10), map(Perlito5::XS::tab($level + 1) . $_->emit_xs($level + 1), @{$self->{'stmts'}})) . chr(10) . Perlito5::XS::tab($level) . '}}'
    }
}
package Perlito5::AST::Index;
{
    sub Perlito5::AST::Index::emit_xs {
        my $self = $_[0];
        my $level = $_[1];
        if ($self->{'obj'}->isa('Perlito5::AST::Var') && $self->{'obj'}->sigil() eq '$') {
            my $v = $self->{'obj'};
            return $v->emit_xs($level) . '[' . $self->{'index_exp'}->emit_xs($level + 1) . ']'
        }
        if ($self->{'obj'}->isa('Perlito5::AST::Apply') && $self->{'obj'}->{'code'} eq 'prefix:<$>') {
            return $self->{'obj'}->{'arguments'}->[0]->emit_xs($level) . '->[' . $self->{'index_exp'}->emit_xs($level) . ']'
        }
        $self->{'obj'}->emit_xs($level) . '->[' . $self->{'index_exp'}->emit_xs($level + 1) . ']'
    }
}
package Perlito5::AST::Lookup;
{
    sub Perlito5::AST::Lookup::emit_xs {
        my $self = $_[0];
        my $level = $_[1];
        if ($self->{'obj'}->isa('Perlito5::AST::Var') && $self->{'obj'}->sigil() eq '$') {
            my $v = $self->{'obj'};
            return $v->emit_xs($level) . '{' . $self->autoquote($self->{'index_exp'})->emit_xs($level) . '}'
        }
        if ($self->{'obj'}->isa('Perlito5::AST::Apply') && $self->{'obj'}->{'code'} eq 'prefix:<$>') {
            return $self->{'obj'}->{'arguments'}->[0]->emit_xs($level) . '->{' . $self->autoquote($self->{'index_exp'})->emit_xs($level) . '}'
        }
        $self->{'obj'}->emit_xs($level) . '->{' . $self->autoquote($self->{'index_exp'})->emit_xs($level) . '}'
    }
}
package Perlito5::AST::Var;
{
    sub Perlito5::AST::Var::emit_xs {
        my $self = $_[0];
        my $level = $_[1];
        my $str_name = $self->{'name'};
        $str_name eq chr(92) && ($str_name = chr(92) . chr(92));
        $str_name eq '"' && ($str_name = chr(92) . '"');
        my $ns = '';
        if (0 && $self->{'namespace'}) {
            if ($self->{'namespace'} eq 'main' && substr($self->{'name'}, 0, 1) eq '^') {
                return $self->{'sigil'} . '{' . $self->{'name'} . '}'
            }
            else {
                $ns = $self->{'namespace'} . '::'
            }
        }
        my $c = substr($self->{'name'}, 0, 1);
        if (($c ge 'a' && $c le 'z') || ($c ge 'A' && $c le 'Z') || ($c eq '_')) {
            return $self->{'name'};
            $self->{'sigil'} = '*';
            return $self->{'sigil'} . $ns . $self->{'name'}
        }
        return $self->{'sigil'} . '{' . chr(39) . $ns . $str_name . chr(39) . '}'
    }
}
package Perlito5::AST::Call;
{
    sub Perlito5::AST::Call::emit_xs {
        my $self = $_[0];
        my $level = $_[1];
        my $invocant = $self->{'invocant'}->emit_xs();
        if ($self->{'method'} eq 'postcircumfix:<[ ]>') {
            return $invocant . '->[' . $self->{'arguments'}->emit_xs($level + 1) . ']'
        }
        if ($self->{'method'} eq 'postcircumfix:<{ }>') {
            return $invocant . '->{' . Perlito5::AST::Lookup::->autoquote($self->{'arguments'})->emit_xs($level) . '}'
        }
        my $meth = $self->{'method'};
        if ($meth eq 'postcircumfix:<( )>') {
            $meth = ''
        }
        if (ref($meth) eq 'Perlito5::AST::Var') {
            $meth = $meth->emit_xs($level + 1)
        }
        $invocant . '->' . $meth . '(' . join(', ', map($_->emit_xs($level + 1), @{$self->{'arguments'}})) . ')'
    }
}
package Perlito5::AST::Apply;
{
    my %op_prefix_xs = ('say' => 'say', 'keys' => 'keys', 'values' => 'values', 'prefix:<!>' => '!', 'prefix:<++>' => '++', 'prefix:<-->' => '--', 'prefix:<+>' => '+', 'prefix:<->' => '-', 'prefix:<-d>' => '-d', 'prefix:<-e>' => '-e', 'prefix:<-f>' => '-f', 'prefix:<not>' => 'not', 'prefix:<~>' => '~');
    my %op_infix_xs = ('list:<,>' => ', ', 'list:<.>' => ' . ', 'infix:<+>' => ' + ', 'infix:<->' => ' - ', 'infix:<*>' => ' * ', 'infix:</>' => ' / ', 'infix:<%>' => ' % ', 'infix:<**>' => ' ** ', 'infix:<>>' => ' > ', 'infix:<<>' => ' < ', 'infix:<>=>' => ' >= ', 'infix:<<=>' => ' <= ', 'infix:<&>' => ' & ', 'infix:<|>' => ' | ', 'infix:<^>' => ' ^ ', 'infix:<&&>' => ' && ', 'infix:<||>' => ' || ', 'infix:<and>' => ' and ', 'infix:<or>' => ' or ', 'infix:<//>' => ' // ', 'infix:<eq>' => ' eq ', 'infix:<ne>' => ' ne ', 'infix:<le>' => ' le ', 'infix:<ge>' => ' ge ', 'infix:<lt>' => ' lt ', 'infix:<gt>' => ' gt ', 'infix:<==>' => ' == ', 'infix:<!=>' => ' != ', 'infix:<=~>' => ' =~ ', 'infix:<!~>' => ' !~ ');
    sub Perlito5::AST::Apply::emit_xs {
        my $self = $_[0];
        my $level = $_[1];
        my $apply = $self->op_assign();
        if ($apply) {
            return $apply->emit_xs($level)
        }
        my $ns = '';
        if ($self->{'namespace'}) {
            $ns = $self->{'namespace'} . '::'
        }
        my $code = $ns . $self->{'code'};
        if (ref($code) ne '') {
            return '(' . $self->{'code'}->emit_xs($level + 1) . ')->(' . join(', ', map($_->emit_xs($level + 1), @{$self->{'arguments'}})) . ')'
        }
        if (exists($op_infix_xs{$code})) {
            return '(' . join($op_infix_xs{$code}, (map($_->emit_xs($level + 1), @{$self->{'arguments'}}))) . ')'
        }
        if (exists($op_prefix_xs{$code})) {
            return $op_prefix_xs{$code} . '(' . join(', ', map($_->emit_xs($level + 1), @{$self->{'arguments'}})) . ')'
        }
        if ($self->{'code'} eq 'p5:s') {
            return 's!' . $self->{'arguments'}->[0]->{'buf'} . '!' . $self->{'arguments'}->[1]->{'buf'} . '!' . $self->{'arguments'}->[2]
        }
        if ($self->{'code'} eq 'p5:m') {
            my $s;
            if ($self->{'arguments'}->[0]->isa('Perlito5::AST::Buf')) {
                $s = $self->{'arguments'}->[0]->{'buf'}
            }
            else {
                for my $ast (@{$self->{'arguments'}->[0]->{'arguments'}}) {
                    if ($ast->isa('Perlito5::AST::Buf')) {
                        $s .= $ast->{'buf'}
                    }
                    else {
                        $s .= $ast->emit_xs($level + 1)
                    }
                }
            }
            return 'm!' . $s . '!' . $self->{'arguments'}->[1]
        }
        if ($self->{'code'} eq 'p5:tr') {
            return 'tr!' . $self->{'arguments'}->[0]->{'buf'} . '!' . $self->{'arguments'}->[1]->{'buf'} . '!'
        }
        if ($code eq '__PACKAGE__') {
            return '"' . $Perlito5::PKG_NAME . '"'
        }
        if ($self->{'code'} eq 'package') {
            return 'MODULE = ' . $self->{'namespace'} . ' PACKAGE = ' . $self->{'namespace'}
        }
        if ($code eq 'undef') {
            return 'undef()'
        }
        if ($code eq 'scalar') {
            return 'scalar(' . ($self->{'arguments'}->[0]->emit_xs()) . ')'
        }
        if ($code eq 'pop') {
            return 'pop(' . ($self->{'arguments'}->[0]->emit_xs()) . ')'
        }
        if ($code eq 'push') {
            return 'push(' . ($self->{'arguments'}->[0]->emit_xs()) . ', ' . ($self->{'arguments'}->[1])->emit_xs($level + 1) . ' )'
        }
        if ($code eq 'shift') {
            if ($self->{'arguments'} && @{$self->{'arguments'}}) {
                return 'shift(' . join(' ', map($_->emit_xs($level + 1), @{$self->{'arguments'}})) . ')'
            }
            return 'shift()'
        }
        if ($code eq 'unshift') {
            return 'unshift(' . $self->{'arguments'}->[0]->emit_xs($level + 1) . ', ' . $self->{'arguments'}->[1]->emit_xs($level + 1) . ')'
        }
        if ($code eq 'map') {
            if ($self->{'special_arg'}) {
                return 'map {' . chr(10) . join(';' . chr(10), map {
                    Perlito5::XS::tab($level + 1) . $_->emit_xs($level + 1)
                } @{$self->{'special_arg'}->{'stmts'}}) . chr(10) . Perlito5::XS::tab($level) . '} ' . join(',', map {
                    $_->emit_xs($level + 1)
                } @{$self->{'arguments'}})
            }
            my $str = shift(@{$self->{'arguments'}});
            return 'map(' . $str->emit_xs($level + 1) . ', ' . join(',', map {
                $_->emit_xs($level + 1)
            } @{$self->{'arguments'}}) . ')'
        }
        if ($code eq 'infix:<x>') {
            return 'join("", ' . join(' x ', map($_->emit_xs($level + 1), @{$self->{'arguments'}})) . ')'
        }
        if ($code eq 'infix:<=>>') {
            return Perlito5::AST::Lookup::->autoquote($self->{'arguments'}->[0])->emit_xs($level) . ', ' . $self->{'arguments'}->[1]->emit_xs($level)
        }
        if ($code eq 'join') {
            my $str = shift(@{$self->{'arguments'}});
            return 'join(' . $str->emit_xs() . ', ' . join(',', map($_->emit_xs($level + 1), @{$self->{'arguments'}})) . ')'
        }
        if ($code eq 'circumfix:<[ ]>') {
            return '[' . join(', ', map($_->emit_xs($level + 1), @{$self->{'arguments'}})) . ']'
        }
        if ($code eq 'circumfix:<{ }>') {
            return '{' . join(', ', map($_->emit_xs($level + 1), @{$self->{'arguments'}})) . '}'
        }
        if ($code eq 'prefix:<' . chr(92) . '>') {
            return chr(92) . join(' ', map($_->emit_xs($level + 1), @{$self->{'arguments'}})) . ''
        }
        if ($code eq 'prefix:<$>') {
            return '${' . join(' ', map($_->emit_xs($level + 1), @{$self->{'arguments'}})) . '}'
        }
        if ($code eq 'prefix:<@>') {
            return '@{' . join(' ', map($_->emit_xs($level + 1), @{$self->{'arguments'}})) . '}'
        }
        if ($code eq 'prefix:<%>') {
            return '%{' . join(' ', map($_->emit_xs($level + 1), @{$self->{'arguments'}})) . '}'
        }
        if ($code eq 'prefix:<&>') {
            return '&{' . join(' ', map($_->emit_xs($level + 1), @{$self->{'arguments'}})) . '}'
        }
        if ($code eq 'prefix:<$#>') {
            return '$#{' . join(' ', map($_->emit_xs($level + 1), @{$self->{'arguments'}})) . '}'
        }
        if ($code eq 'postfix:<++>') {
            return '(' . join(' ', map($_->emit_xs($level + 1), @{$self->{'arguments'}})) . ')++'
        }
        if ($code eq 'postfix:<-->') {
            return '(' . join(' ', map($_->emit_xs($level + 1), @{$self->{'arguments'}})) . ')--'
        }
        if ($code eq 'infix:<..>') {
            return '(' . join(' .. ', map($_->emit_xs($level + 1), @{$self->{'arguments'}})) . ')'
        }
        if ($code eq 'ternary:<? :>') {
            return '(' . $self->{'arguments'}->[0]->emit_xs($level + 1) . ' ? ' . $self->{'arguments'}->[1]->emit_xs($level + 1) . ' : ' . $self->{'arguments'}->[2]->emit_xs($level + 1) . ')'
        }
        if ($code eq 'circumfix:<( )>') {
            return '(' . join(', ', map($_->emit_xs($level + 1), @{$self->{'arguments'}})) . ')'
        }
        if ($code eq 'infix:<=>') {
            return emit_xs_bind($self->{'arguments'}->[0], $self->{'arguments'}->[1], $level)
        }
        if ($code eq 'require') {
            return 'Perlito5::Grammar::Use::require(' . $self->{'arguments'}->[0]->emit_xs($level + 1) . ')'
        }
        if ($code eq 'do') {
            my $ast = Perlito5::AST::Apply::->new('code' => 'eval', 'namespace' => '', 'arguments' => [Perlito5::AST::Apply::->new('code' => 'do_file', 'namespace' => 'Perlito5::Grammar::Use', 'arguments' => $self->{'arguments'})]);
            return $ast->emit_xs($level)
        }
        if ($code eq 'eval') {
            my $arg = $self->{'arguments'}->[0];
            my $eval;
            if ($arg->isa('Perlito5::AST::Block')) {
                $eval = $arg->emit_xs($level + 1)
            }
            else {
                $eval = '(do { ' . 'my $m = Perlito5::Grammar::exp_stmts(' . $arg->emit_xs($level + 1, 'scalar') . ', 0);' . 'my $source; ' . '$source .= (defined $_ ? $_->emit_xs(0, "scalar") : "") . ";' . chr(92) . 'n" ' . 'for @{ Perlito5::Match::flat($m) }; ' . 'eval $source;' . '})'
            }
            return $eval
        }
        if ($code eq 'return') {
            return 'PUSHs(' . join(', ', map($_->emit_xs($level + 1), @{$self->{'arguments'}})) . ')'
        }
        if ($code eq 'print') {
            return 'puts( SvPVx_nolen( ' . join(', ', map($_->emit_xs($level + 1), @{$self->{'arguments'}})) . ') )'
        }
        if ($code eq 'warn') {
            return 'warn( SvPVx_nolen( ' . join(', ', map($_->emit_xs($level + 1), @{$self->{'arguments'}})) . ') )'
        }
        if ($self->{'bareword'} && !@{$self->{'arguments'}}) {
            return $code
        }
        $code . '(' . join(', ', map($_->emit_xs($level + 1), @{$self->{'arguments'}})) . ')'
    }
    sub Perlito5::AST::Apply::emit_xs_bind {
        my $parameters = shift;
        my $arguments = shift;
        my $level = shift;
        if ($parameters->isa('Perlito5::AST::Call')) {
            if ($parameters->method() eq 'postcircumfix:<{ }>' || $parameters->method() eq 'postcircumfix:<[ ]>') {
                return '(' . $parameters->emit_xs($level + 1) . ' = ' . $arguments->emit_xs($level + 1) . ')'
            }
        }
        $parameters->emit_xs($level + 1) . ' = ' . $arguments->emit_xs($level + 1)
    }
}
package Perlito5::AST::If;
{
    sub Perlito5::AST::If::emit_xs {
        my $self = $_[0];
        my $level = $_[1];
        return 'if (' . $self->{'cond'}->emit_xs($level + 1) . ') {' . chr(10) . ($self->{'body'} ? join(';' . chr(10), map(Perlito5::XS::tab($level + 1) . $_->emit_xs($level + 1), @{$self->{'body'}->stmts()})) . chr(10) : '') . Perlito5::XS::tab($level) . '}' . ($self->{'otherwise'} && scalar(@{$self->{'otherwise'}->stmts()}) ? (chr(10) . Perlito5::XS::tab($level) . 'else {' . chr(10) . join(';' . chr(10), map(Perlito5::XS::tab($level + 1) . $_->emit_xs($level + 1), @{$self->{'otherwise'}->stmts()})) . chr(10) . Perlito5::XS::tab($level) . '}') : '')
    }
}
package Perlito5::AST::When;
{
    sub Perlito5::AST::When::emit_xs {
        my $self = $_[0];
        my $level = $_[1];
        return 'when (' . $self->{'cond'}->emit_xs($level + 1) . ') {' . chr(10) . ($self->{'body'} ? join(';' . chr(10), map(Perlito5::XS::tab($level + 1) . $_->emit_xs($level + 1), @{$self->{'body'}->stmts()})) . chr(10) : '') . Perlito5::XS::tab($level) . '}'
    }
}
package Perlito5::AST::While;
{
    sub Perlito5::AST::While::emit_xs {
        my $self = $_[0];
        my $level = $_[1];
        my $cond = $self->{'cond'};
        'for ( ' . ($self->{'init'} ? $self->{'init'}->emit_xs($level + 1) . '; ' : '; ') . ($cond ? $cond->emit_xs($level + 1) . '; ' : '; ') . ($self->{'continue'} ? $self->{'continue'}->emit_xs($level + 1) . ' ' : ' ') . ') {' . chr(10) . join(';' . chr(10), map(Perlito5::XS::tab($level + 1) . $_->emit_xs($level + 1), @{$self->{'body'}->stmts()})) . chr(10) . Perlito5::XS::tab($level) . '}'
    }
}
package Perlito5::AST::For;
{
    sub Perlito5::AST::For::emit_xs {
        my $self = $_[0];
        my $level = $_[1];
        my $cond;
        if (ref($self->{'cond'}) eq 'ARRAY') {
            $cond = ($self->{'cond'}->[0] ? $self->{'cond'}->[0]->emit_javascript($level + 1) . '; ' : '; ') . ($self->{'cond'}->[1] ? $self->{'cond'}->[1]->emit_javascript($level + 1) . '; ' : '; ') . ($self->{'cond'}->[2] ? $self->{'cond'}->[2]->emit_javascript($level + 1) . ' ' : ' ')
        }
        else {
            $cond = $self->{'cond'}->emit_xs($level + 1)
        }
        my $sig = '';
        my $sig_ast = $self->{'body'}->sig();
        if (!$sig_ast) {}
        elsif ($sig_ast->{'decl'}) {
            $sig = $sig_ast->{'decl'} . ' ' . $sig_ast->{'type'} . ' ' . $sig_ast->{'var'}->emit_xs($level + 1) . ' '
        }
        else {
            $sig = $sig_ast->emit_xs($level + 1) . ' '
        }
        return 'for ' . $sig . '(' . $cond . ') {' . chr(10) . join(';' . chr(10), map(Perlito5::XS::tab($level + 1) . $_->emit_xs($level + 1), @{$self->{'body'}->stmts()})) . chr(10) . Perlito5::XS::tab($level) . '}'
    }
}
package Perlito5::AST::Decl;
{
    sub Perlito5::AST::Decl::emit_xs {
        my $self = $_[0];
        my $level = $_[1];
        $self->{'type'} = 'SV *';
        my $decl = $self->{'decl'};
        my $str = $self->{'type'} . $self->{'var'}->emit_xs($level + 1);
        return $str
    }
}
package Perlito5::AST::Sub;
{
    sub Perlito5::AST::Sub::emit_xs {
        my $self = $_[0];
        my $level = $_[1];
        my $name = '';
        $self->{'name'} && ($name = $self->{'name'} . ' ');
        my $sig = $self->{'sig'};
        my $i = 0;
        'void ' . $name . '()' . chr(10) . 'PPCODE:' . chr(10) . join(';' . chr(10), map(Perlito5::XS::tab($level + 1) . $_->emit_xs($level + 1), @{$self->{'block'}})) . ';' . chr(10)
    }
}
package Perlito5::AST::Use;
{
    sub Perlito5::AST::Use::emit_xs {
        my $self = shift;
        my $level = shift;
        Perlito5::Grammar::Use::emit_time_eval($self);
        return chr(10) . Perlito5::XS::tab($level) . '# ' . $self->{'code'} . ' ' . $self->{'mod'} . chr(10)
    }
}
# use Perlito5::XS::Emitter
package main;
undef();
# use Perlito5::AST
# use Perlito5::Dumper
# use strict
package Perlito5::Java;
{
    my %label;
    my %Java_class;
    our %Java_var_name;
    my %Java_var;
    our @Java_init;
    sub Perlito5::Java::pkg {
        Perlito5::Java::escape_string($Perlito5::PKG_NAME)
    }
    sub Perlito5::Java::get_label {
        'tmp' . $Perlito5::ID++
    }
    sub Perlito5::Java::tab {
        my $level = shift;
        '    ' x $level
    }
    sub Perlito5::Java::get_java_class_info {
        return \%Java_class
    }
    sub Perlito5::Java::get_java_var_info {
        return \%Java_var
    }
    our %op_prefix_js_str = ('prefix:<-A>' => 'p5atime', 'prefix:<-C>' => 'p5ctime', 'prefix:<-M>' => 'p5mtime', 'prefix:<-d>' => 'p5is_directory', 'prefix:<-e>' => 'p5file_exists', 'prefix:<-f>' => 'p5is_file', 'prefix:<-s>' => 'p5size');
    our %op_infix_js_str = ('infix:<eq>' => ' == ', 'infix:<ne>' => ' != ', 'infix:<le>' => ' <= ', 'infix:<ge>' => ' >= ', 'infix:<lt>' => ' < ', 'infix:<gt>' => ' > ');
    our %op_to_bool = map(+($_ => 1), 'prefix:<!>', 'infix:<!=>', 'infix:<==>', 'infix:<<=>', 'infix:<>=>', 'infix:<>>', 'infix:<<>', 'infix:<eq>', 'infix:<ne>', 'infix:<ge>', 'infix:<le>', 'infix:<gt>', 'infix:<lt>', 'prefix:<not>', 'exists', 'defined');
    our %op_to_str = map(+($_ => 1), 'substr', 'join', 'list:<.>', 'chr', 'lc', 'uc', 'lcfirst', 'ucfirst', 'ref');
    our %op_to_num = map(+($_ => 1), 'length', 'index', 'ord', 'oct', 'infix:<->', 'infix:<+>', 'infix:<*>', 'infix:</>', 'infix:<%>', 'infix:<**>');
    my %safe_char = (' ' => 1, '!' => 1, '#' => 1, '$' => 1, '%' => 1, '&' => 1, '(' => 1, ')' => 1, '*' => 1, '+' => 1, ',' => 1, '-' => 1, '.' => 1, '/' => 1, ':' => 1, ';' => 1, '<' => 1, '=' => 1, '>' => 1, '?' => 1, '@' => 1, '[' => 1, ']' => 1, '^' => 1, '_' => 1, '`' => 1, '{' => 1, '|' => 1, '}' => 1, '~' => 1);
    sub Perlito5::Java::escape_string {
        my $s = shift;
        my @out;
        my $tmp = '';
        $s eq '' && return '""';
        for my $i (0 .. length($s) - 1) {
            my $c = substr($s, $i, 1);
            if (($c ge 'a' && $c le 'z') || ($c ge 'A' && $c le 'Z') || ($c ge 0 && $c le 9) || exists($safe_char{$c})) {
                $tmp = $tmp . $c
            }
            else {
                $tmp ne '' && push(@out, '"' . $tmp . '"');
                push(@out, '(char)' . ord($c) . '');
                $tmp = ''
            }
        }
        $tmp ne '' && push(@out, '"' . $tmp . '"');
        return join(' + ', @out)
    }
    sub Perlito5::Java::is_native {
        my $self = shift;
        if (ref($self->{'invocant'}) eq 'Perlito5::AST::Var' && $self->{'invocant'}->{'sigil'} eq '::') {
            my $Java_class = Perlito5::Java::get_java_class_info();
            if (exists($Java_class->{$self->{'invocant'}->{'namespace'}})) {
                return 1
            }
        }
        if (ref($self->{'invocant'}) eq 'Perlito5::AST::Var' && $self->{'invocant'}->{'_id'}) {
            my $id = $self->{'invocant'}->{'_id'};
            my $Java_var = Perlito5::Java::get_java_var_info();
            my $type = $Java_var->{$id}->{'type'} || 'pLvalue';
            if ($type ne 'pLvalue') {
                return 1
            }
        }
        my $meth = $self->{'method'};
        if ($meth =~ m!^to!) {
            my $Java_class = Perlito5::Java::get_java_class_info();
            for my $info (values(%{$Java_class})) {
                if ($meth eq $info->{'perl_to_java'}) {
                    return 1
                }
            }
        }
        return 0
    }
    sub Perlito5::Java::to_native_args {
        my $args = shift;
        my $level = shift;
        my $wantarray = 'scalar';
        my $s = '';
        my @out;
        for my $cond (@{$args}) {
            if ($cond->isa('Perlito5::AST::Apply') && $cond->code() eq 'circumfix:<( )>' && $cond->{'arguments'} && @{$cond->{'arguments'}}) {
                push(@out, to_native_args($cond->{'arguments'}->[0], $level))
            }
            if ($cond->isa('Perlito5::AST::Buf')) {
                push(@out, Perlito5::Java::escape_string($cond->{'buf'}))
            }
            elsif ($cond->isa('Perlito5::AST::Int')) {
                push(@out, $cond->{'int'})
            }
            elsif ($cond->isa('Perlito5::AST::Num')) {
                push(@out, $cond->{'num'})
            }
            else {
                push(@out, $cond->emit_java($level, $wantarray))
            }
        }
        return join(', ', @out)
    }
    sub Perlito5::Java::to_native_str {
        my $cond = shift;
        my $level = shift;
        my $wantarray = shift;
        if ($cond->isa('Perlito5::AST::Apply') && $cond->code() eq 'circumfix:<( )>' && $cond->{'arguments'} && @{$cond->{'arguments'}}) {
            return to_native_str($cond->{'arguments'}->[0], $level, $wantarray)
        }
        if ($cond->isa('Perlito5::AST::Buf')) {
            return Perlito5::Java::escape_string($cond->{'buf'})
        }
        elsif ($cond->isa('Perlito5::AST::Int')) {
            return Perlito5::Java::escape_string($cond->{'int'})
        }
        elsif ($cond->isa('Perlito5::AST::Num')) {
            return Perlito5::Java::escape_string($cond->{'num'})
        }
        else {
            return $cond->emit_java($level, $wantarray) . '.to_string()'
        }
    }
    sub Perlito5::Java::to_str {
        my $cond = shift;
        my $level = shift;
        my $wantarray = 'scalar';
        if ($cond->isa('Perlito5::AST::Apply') && $cond->code() eq 'circumfix:<( )>' && $cond->{'arguments'} && @{$cond->{'arguments'}}) {
            return to_str($cond->{'arguments'}->[0], $level)
        }
        if (($cond->isa('Perlito5::AST::Buf')) || ($cond->isa('Perlito5::AST::Apply') && exists($op_to_str{$cond->code()}))) {
            return $cond->emit_java($level, $wantarray)
        }
        else {
            return 'new pString(' . $cond->emit_java($level, $wantarray) . '.to_string())'
        }
    }
    sub Perlito5::Java::to_num {
        my $cond = shift;
        my $level = shift;
        my $wantarray = 'scalar';
        if ($cond->isa('Perlito5::AST::Int') || $cond->isa('Perlito5::AST::Num') || ($cond->isa('Perlito5::AST::Apply') && exists($op_to_num{$cond->code()}))) {
            return $cond->emit_java($level, $wantarray)
        }
        else {
            return 'new pDouble(' . $cond->emit_java($level, $wantarray) . '.to_double())'
        }
    }
    sub Perlito5::Java::to_bool {
        my $cond = shift;
        my $level = shift;
        my $wantarray = 'scalar';
        if ($cond->isa('Perlito5::AST::Apply') && $cond->code() eq 'circumfix:<( )>' && $cond->{'arguments'} && @{$cond->{'arguments'}}) {
            return to_bool($cond->{'arguments'}->[0], $level)
        }
        if ($cond->isa('Perlito5::AST::Apply') && ($cond->code() eq 'infix:<&&>' || $cond->code() eq 'infix:<and>')) {
            return '(' . to_bool($cond->{'arguments'}->[0], $level) . ' && ' . to_bool($cond->{'arguments'}->[1], $level) . ')'
        }
        if ($cond->isa('Perlito5::AST::Apply') && ($cond->code() eq 'infix:<||>' || $cond->code() eq 'infix:<or>')) {
            return '(' . to_bool($cond->{'arguments'}->[0], $level) . ' || ' . to_bool($cond->{'arguments'}->[1], $level) . ')'
        }
        if (($cond->isa('Perlito5::AST::Int')) || ($cond->isa('Perlito5::AST::Num')) || ($cond->isa('Perlito5::AST::Apply') && exists($op_to_bool{$cond->code()}))) {
            return $cond->emit_java($level, $wantarray) . '.to_bool()'
        }
        else {
            return $cond->emit_java($level, $wantarray) . '.to_bool()'
        }
    }
    sub Perlito5::Java::is_scalar {
        !$_[0]->isa('Perlito5::AST::Int') && !$_[0]->isa('Perlito5::AST::Num') && !$_[0]->isa('Perlito5::AST::Buf') && !$_[0]->isa('Perlito5::AST::Sub') && !($_[0]->isa('Perlito5::AST::Var') && $_[0]->{'sigil'} eq '$') && !($_[0]->isa('Perlito5::AST::Apply') && (exists($op_to_str{$_[0]->{'code'}}) || exists($op_to_num{$_[0]->{'code'}}) || exists($op_to_bool{$_[0]->{'code'}})))
    }
    sub Perlito5::Java::to_list {
        my $items = to_list_preprocess($_[0]);
        my $level = $_[1];
        return 'new pArray(' . join(', ', map($_->emit_java($level, 'list'), @{$items})) . ')'
    }
    sub Perlito5::Java::to_list_preprocess {
        my @items;
        for my $item (@{$_[0]}) {
            if ($item->isa('Perlito5::AST::Apply') && ($item->code() eq 'circumfix:<( )>' || $item->code() eq 'list:<,>' || $item->code() eq 'infix:<=>>')) {
                if ($item->isa('Perlito5::AST::Apply') && $item->code() eq 'infix:<=>>') {
                    $item->{'arguments'}->[0] = Perlito5::AST::Lookup::->autoquote($item->{'arguments'}->[0])
                }
                for my $arg (@{to_list_preprocess($item->arguments())}) {
                    push(@items, $arg)
                }
            }
            else {
                push(@items, $item)
            }
        }
        return \@items
    }
    sub Perlito5::Java::to_scalar {
        my $items = to_scalar_preprocess($_[0]);
        my $level = $_[1];
        my $wantarray = 'scalar';
        @{$items} ? '(' . join(', ', map($_->emit_java($level, $wantarray), @{$items})) . ')' : 'null'
    }
    sub Perlito5::Java::to_scalar_preprocess {
        my @items;
        for my $item (@{$_[0]}) {
            if ($item->isa('Perlito5::AST::Apply') && ($item->code() eq 'list:<,>' || $item->code() eq 'infix:<=>>')) {
                if ($item->isa('Perlito5::AST::Apply') && $item->code() eq 'infix:<=>>') {
                    $item->{'arguments'}->[0] = Perlito5::AST::Lookup::->autoquote($item->{'arguments'}->[0])
                }
                for my $arg (@{to_scalar_preprocess($item->arguments())}) {
                    push(@items, $arg)
                }
            }
            else {
                push(@items, $item)
            }
        }
        return \@items
    }
    sub Perlito5::Java::to_runtime_context {
        my $items = to_scalar_preprocess($_[0]);
        my $level = $_[1];
        my $wantarray = 'runtime';
        @{$items} == 1 && is_scalar($items->[0]) && return $items->[0]->emit_java($level, $wantarray);
        'PerlOp.context(want, ' . join(', ', map($_->emit_java($level, $wantarray), @{$items})) . ')'
    }
    sub Perlito5::Java::to_context {
        my $wantarray = shift;
        $wantarray eq 'list' ? 'pCx.LIST' : $wantarray eq 'scalar' ? 'pCx.SCALAR' : $wantarray eq 'void' ? 'pCx.VOID' : 'want'
    }
    sub Perlito5::Java::autoquote {
        my $index = shift;
        my $level = shift;
        $index = Perlito5::AST::Lookup::->autoquote($index);
        return to_str($index, $level)
    }
    sub Perlito5::Java::emit_java_autovivify {
        my $obj = shift;
        my $level = shift;
        my $type = shift;
        if ($obj->isa('Perlito5::AST::Index') || $obj->isa('Perlito5::AST::Lookup') || $obj->isa('Perlito5::AST::Call')) {
            return $obj->emit_java($level, 0, $type)
        }
        if ($obj->isa('Perlito5::AST::Apply') && $obj->code() eq 'prefix:<$>') {
            my $arg = $obj->{'arguments'}->[0];
            return 'get_scalarref(' . $arg->emit_java($level) . ', ' . Perlito5::Java::escape_string($Perlito5::PKG_NAME) . ', ' . Perlito5::Java::escape_string($type) . ')'
        }
        $obj->emit_java($level)
    }
    sub Perlito5::Java::emit_java_list_with_tabs {
        my($level, $argument) = @_;
        my $tab = Perlito5::Java::tab($level);
        return map {
            ref($_) eq 'ARRAY' ? emit_java_list_with_tabs($level + 1, $_) : $tab . $_
        } @{$argument}
    }
    sub Perlito5::Java::emit_func_java {
        my($level, $wantarray, @argument) = @_;
        return join(chr(10), 'function () {', emit_java_list_with_tabs($level, [\@argument, '}']))
    }
    sub Perlito5::Java::emit_wrap_java {
        my($level, $wantarray, @argument) = @_;
        my $s;
        !ref($argument[0]) && ($s = shift(@argument));
        return join(chr(10), ($s ? $s : ()), emit_java_list_with_tabs($level, [\@argument]))
    }
    sub Perlito5::Java::emit_function_java {
        my($level, $wantarray, $argument) = @_;
        if ($argument->isa('Perlito5::AST::Apply') && ($argument->code() eq 'return' || $argument->code() eq 'last' || $argument->code() eq 'next' || $argument->code() eq 'redo')) {
            emit_func_java($level, $wantarray, $argument->emit_java($level, $wantarray))
        }
        else {
            emit_func_java($level, $wantarray, 'return ' . $argument->emit_java($level + 1, $wantarray))
        }
    }
    sub Perlito5::Java::emit_wrap_statement_java {
        my($level, $wantarray, $argument) = @_;
        if ($wantarray eq 'void') {
            return $argument
        }
        emit_wrap_java($level, $wantarray, $argument)
    }
}
package Perlito5::Java::LexicalBlock;
{
    sub Perlito5::Java::LexicalBlock::new {
        my $class = shift;
        bless({@_}, $class)
    }
    sub Perlito5::Java::LexicalBlock::block {
        $_[0]->{'block'}
    }
    sub Perlito5::Java::LexicalBlock::has_decl {
        my $self = $_[0];
        my $type = $_[1];
        for my $decl (@{$self->{'block'}}) {
            grep {
                $_->{'decl'} eq $type
            } $decl->emit_java_get_decl() && return 1
        }
        return 0
    }
    sub Perlito5::Java::LexicalBlock::emit_java_subroutine_body {
        my($self, $level, $wantarray) = @_;
        $self->{'top_level'} = 1;
        my $outer_throw = $Perlito5::THROW;
        $Perlito5::THROW = 0;
        my $s = $self->emit_java($level, $wantarray);
        $Perlito5::THROW = $outer_throw;
        return $s
    }
    sub Perlito5::Java::LexicalBlock::emit_java {
        my($self, $level, $wantarray) = @_;
        my $original_level = $level;
        my @block;
        for my $stmt (@{$self->{'block'}}) {
            if (defined($stmt)) {
                if (ref($stmt) eq 'Perlito5::AST::Apply' && $stmt->code() eq 'undef' && !@{$stmt->{'arguments'}}) {}
                else {
                    push(@block, $stmt)
                }
            }
        }
        if ($self->{'top_level'} && !@block) {
            push(@block, Perlito5::AST::Apply::->new('code' => 'return', 'arguments' => []))
        }
        my @str;
        my $has_local = $self->has_decl('local');
        my $has_regex = 0;
        if (grep {
            $_->emit_java_has_regex()
        } @block) {
            $has_local = 1;
            $has_regex = 1
        }
        $has_local = 0;
        my $create_context = $self->{'create_context'} && $self->has_decl('my');
        my $outer_pkg = $Perlito5::PKG_NAME;
        if ($self->{'top_level'} || $create_context) {
            $level++
        }
        my $last_statement;
        if ($wantarray ne 'void') {
            $last_statement = pop(@block)
        }
        for my $decl (@block) {
            if (ref($decl) eq 'Perlito5::AST::Apply' && $decl->code() eq 'package') {
                $Perlito5::PKG_NAME = $decl->{'namespace'}
            }
            my @var_decl = $decl->emit_java_get_decl();
            for my $arg (@var_decl) {
                push(@str, $arg->emit_java_init($level, $wantarray))
            }
            if (!($decl->isa('Perlito5::AST::Decl') && $decl->decl() eq 'my')) {
                if ($decl->isa('Perlito5::AST::Apply') && !($decl->{'namespace'} eq 'Java' && $decl->{'code'} eq 'inline') && !($decl->{'code'} eq 'infix:<=>' || $decl->{'code'} eq 'print' || $decl->{'code'} eq 'say')) {
                    push(@str, 'PerlOp.statement(' . $decl->emit_java($level, 'void') . ');')
                }
                else {
                    push(@str, $decl->emit_java($level, 'void') . ';')
                }
            }
        }
        if ($last_statement) {
            my @var_decl = $last_statement->emit_java_get_decl();
            for my $arg (@var_decl) {
                push(@str, $arg->emit_java_init($level, $wantarray))
            }
            if ($last_statement->isa('Perlito5::AST::For') || $last_statement->isa('Perlito5::AST::While') || $last_statement->isa('Perlito5::AST::If') || $last_statement->isa('Perlito5::AST::Block') || $last_statement->isa('Perlito5::AST::Use') || $last_statement->isa('Perlito5::AST::Apply') && $last_statement->code() eq 'goto') {
                push(@str, $last_statement->emit_java($level, 'void') . ';');
                push(@str, 'return (PerlOp.context(want));')
            }
            elsif ($last_statement->isa('Perlito5::AST::Apply') && $last_statement->code() eq 'return') {
                if (!@{$last_statement->{'arguments'}}) {
                    push(@str, 'return (PerlOp.context(want));')
                }
                else {
                    push(@str, 'return (' . ($wantarray eq 'runtime' ? Perlito5::Java::to_runtime_context([$last_statement->{'arguments'}->[0]], $level + 1) : $wantarray eq 'scalar' ? Perlito5::Java::to_scalar([$last_statement->{'arguments'}->[0]], $level + 1) : $last_statement->{'arguments'}->[0]->emit_java($level, $wantarray)) . ');')
                }
            }
            elsif ($has_local) {
                push(@str, 'return p5cleanup_local(local_idx, (' . ($wantarray eq 'runtime' ? Perlito5::Java::to_runtime_context([$last_statement], $level + 1) : $wantarray eq 'scalar' ? Perlito5::Java::to_scalar([$last_statement], $level + 1) : $last_statement->emit_java($level, $wantarray)) . '));')
            }
            else {
                push(@str, 'return (' . ($wantarray eq 'runtime' ? Perlito5::Java::to_runtime_context([$last_statement], $level + 1) : $wantarray eq 'scalar' ? Perlito5::Java::to_scalar([$last_statement], $level + 1) : $last_statement->emit_java($level, $wantarray)) . ');')
            }
        }
        if ($has_local) {
            unshift(@str, ('// var local_idx = p5LOCAL.length;', ($has_regex ? ('var regex_tmp = p5_regex_capture;', 'p5LOCAL.push(function(){ p5_regex_capture = regex_tmp });') : ())));
            push(@str, '// p5cleanup_local(local_idx, null);')
        }
        my $out;
        if ($self->{'top_level'} && $Perlito5::THROW) {
            $level = $original_level;
            my $tab = chr(10) . Perlito5::Java::tab($level + 1);
            $out = 'try {' . $tab . join($tab, @str) . chr(10) . Perlito5::Java::tab($level) . '}' . chr(10) . Perlito5::Java::tab($level) . 'catch(pReturnException e) {' . chr(10) . Perlito5::Java::tab($level + 1) . 'return e.ret;' . chr(10) . Perlito5::Java::tab($level) . '}'
        }
        elsif ($create_context) {
            $level = $original_level;
            my $tab = chr(10) . Perlito5::Java::tab($level + 1);
            $out = '(function () {' . $tab . join($tab, @str) . chr(10) . Perlito5::Java::tab($level) . '})();'
        }
        else {
            $level = $original_level;
            my $tab = chr(10) . Perlito5::Java::tab($level);
            $out = join($tab, @str)
        }
        $Perlito5::PKG_NAME = $outer_pkg;
        return $out
    }
    sub Perlito5::Java::LexicalBlock::emit_java_has_regex {
        ()
    }
    sub Perlito5::Java::LexicalBlock::emit_java_get_captures {
        my($self) = @_;
        my @var;
        for my $stmt (@{$self->{'block'}}) {
            push(@var, $stmt->emit_java_get_captures())
        }
        return @var
    }
}
package Perlito5::AST::CompUnit;
{
    sub Perlito5::AST::CompUnit::emit_java {
        my($self, $level, $wantarray) = @_;
        return Perlito5::Java::emit_wrap_java($level, $wantarray, Perlito5::Java::LexicalBlock::->new('block' => $self->{'body'})->emit_java($level + 1, $wantarray))
    }
    sub Perlito5::AST::CompUnit::emit_java_program {
        my($comp_units, %options) = @_;
        $Perlito5::PKG_NAME = 'main';
        my $level = 0;
        my $wantarray = 'void';
        my $str;
        my $Java_class = Perlito5::Java::get_java_class_info();
        for my $comp_unit (@{$comp_units}) {
            for my $unit_stmt (@{$comp_unit->{'body'}}) {
                if (ref($unit_stmt) eq 'Perlito5::AST::Block') {
                    my $stmt = $unit_stmt->{'stmts'} // [];
                    @{$stmt} != 2 && next;
                    ($stmt->[0] && ref($stmt->[0]) eq 'Perlito5::AST::Apply' && $stmt->[0]->{'code'} eq 'package') || next;
                    ($stmt->[1] && ref($stmt->[1]) eq 'Perlito5::AST::Apply' && ($stmt->[1]->{'code'} eq 'infix:<=>>' || $stmt->[1]->{'code'} eq 'list:<,>')) || next;
                    my $class = $stmt->[0]->{'namespace'};
                    my $args_ast = Perlito5::AST::Apply::->new('arguments' => [$stmt->[1]], 'code' => 'circumfix:<{ }>');
                    my $out = [];
                    Perlito5::Perl5::PrettyPrinter::pretty_print([$args_ast->emit_perl5()], 0, $out);
                    my $args_perl5 = join('', @{$out});
                    $Java_class->{$class} = eval($args_perl5) or die('error in arguments to generate Java class:' . chr(10) . ${'@'} . chr(10) . $args_perl5);
                    $Java_class->{$class}->{'import'} || die('missing ' . chr(39) . 'import' . chr(39) . ' argument to generate Java class');
                    my @parts = split(m!\.!, $Java_class->{$class}->{'import'});
                    $Java_class->{$class}->{'java_type'} //= $parts[-1];
                    $Java_class->{$class}->{'java_native_to_perl'} //= 'p' . $Java_class->{$class}->{'java_type'};
                    $Java_class->{$class}->{'java_native_to_perl'} =~ s![<>]!_!g;
                    my $perl_to_java = $class;
                    $perl_to_java =~ s!::!!g;
                    $Java_class->{$class}->{'perl_to_java'} //= 'to_' . $perl_to_java;
                    $Java_class->{$class}->{'perl_package'} = $class;
                    $unit_stmt->{'stmts'} = []
                }
            }
        }
        my $init = '';
        my $main = '';
        for my $comp_unit (@{$comp_units}) {
            $main = $main . $comp_unit->emit_java($level + 1, $wantarray) . chr(10)
        }
        $init = join(chr(10), @Perlito5::Java::Java_init);
        if ($options{'expand_use'}) {
            $str .= Perlito5::Java::Runtime::->emit_java('java_classes' => $Java_class, 'java_constants' => \@Perlito5::Java::Java_constants)
        }
        $str .= 'class Test {' . chr(10) . '    public static void main(String[] args) throws Exception {' . chr(10) . '        pEnv.init(args);' . chr(10) . '        ' . $init . chr(10) . '        ' . $main . chr(10) . '    }' . chr(10) . '}' . chr(10);
        return $str
    }
    sub Perlito5::AST::CompUnit::emit_java_get_decl {
        ()
    }
    sub Perlito5::AST::CompUnit::emit_java_has_regex {
        ()
    }
    sub Perlito5::AST::CompUnit::emit_java_get_captures {
        ()
    }
}
package Perlito5::AST::Int;
{
    sub Perlito5::AST::Int::emit_java {
        my($self, $level, $wantarray) = @_;
        my $v = $self->{'int'};
        if ($v > (2**31 - 1)) {
            return 'new pDouble(' . $v . '.0)'
        }
        'new pInt(' . $v . ')'
    }
    sub Perlito5::AST::Int::emit_java_get_decl {
        ()
    }
    sub Perlito5::AST::Int::emit_java_has_regex {
        ()
    }
    sub Perlito5::AST::Int::emit_java_get_captures {
        ()
    }
}
package Perlito5::AST::Num;
{
    sub Perlito5::AST::Num::emit_java {
        my($self, $level, $wantarray) = @_;
        'new pDouble(' . $self->{'num'} . ')'
    }
    sub Perlito5::AST::Num::emit_java_get_decl {
        ()
    }
    sub Perlito5::AST::Num::emit_java_has_regex {
        ()
    }
    sub Perlito5::AST::Num::emit_java_get_captures {
        ()
    }
}
package Perlito5::AST::Buf;
{
    sub Perlito5::AST::Buf::emit_java {
        my($self, $level, $wantarray) = @_;
        'new pString(' . Perlito5::Java::escape_string($self->{'buf'}) . ')'
    }
    sub Perlito5::AST::Buf::emit_java_get_decl {
        ()
    }
    sub Perlito5::AST::Buf::emit_java_has_regex {
        ()
    }
    sub Perlito5::AST::Buf::emit_java_get_captures {
        ()
    }
}
package Perlito5::AST::Block;
{
    sub Perlito5::AST::Block::emit_java {
        my($self, $level, $wantarray) = @_;
        my $body;
        if ($wantarray ne 'void') {
            $body = Perlito5::Java::LexicalBlock::->new('block' => $self->{'stmts'})
        }
        else {
            $body = Perlito5::Java::LexicalBlock::->new('block' => $self->{'stmts'})
        }
        my $init = '';
        if ($self->{'name'} eq 'INIT') {
            my $tmp = 'p5pkg.main.' . Perlito5::Java::get_label();
            $init = Perlito5::Java::tab($level + 2) . 'if (' . $tmp . ') { return }; ' . $tmp . ' = 1;' . chr(10)
        }
        return '// TODO - Perlito5::AST::Block' . chr(10) . Perlito5::Java::tab($level + 2) . $body->emit_java($level + 1, $wantarray) . chr(10);
        return 'p5for_lex(' . 'function () {' . chr(10) . $init . Perlito5::Java::tab($level + 2) . $body->emit_java($level + 2, $wantarray) . chr(10) . Perlito5::Java::tab($level + 1) . '}, ' . '[0], ' . $self->emit_java_continue($level, $wantarray) . ', ' . Perlito5::Java::escape_string($self->{'label'} || '') . chr(10) . Perlito5::Java::tab($level) . ')'
    }
    sub Perlito5::AST::Block::emit_java_continue {
        my $self = shift;
        my $level = shift;
        my $wantarray = shift;
        if (!$self->{'continue'} || !@{$self->{'continue'}->{'stmts'}}) {
            return 'false'
        }
        return 'function () {' . chr(10) . (Perlito5::Java::LexicalBlock::->new('block' => $self->{'continue'}->stmts()))->emit_java($level + 2, $wantarray) . chr(10) . Perlito5::Java::tab($level + 1) . '}'
    }
    sub Perlito5::AST::Block::emit_java_get_decl {
        ()
    }
    sub Perlito5::AST::Block::emit_java_has_regex {
        ()
    }
    sub Perlito5::AST::Block::emit_java_get_captures {
        my($self) = @_;
        my @var;
        for my $stmt (@{$self->{'block'}}) {
            push(@var, $stmt->emit_java_get_captures())
        }
        return @var
    }
}
package Perlito5::AST::Index;
{
    sub Perlito5::AST::Index::emit_java {
        my($self, $level, $wantarray, $autovivification_type) = @_;
        my $method = $autovivification_type || 'aget';
        $autovivification_type eq 'scalar' && ($method = 'aget_scalarref');
        $autovivification_type eq 'array' && ($method = 'aget_arrayref');
        $autovivification_type eq 'hash' && ($method = 'aget_hashref');
        if (($self->{'obj'}->isa('Perlito5::AST::Apply') && $self->{'obj'}->{'code'} eq 'prefix:<@>') || ($self->{'obj'}->isa('Perlito5::AST::Var') && $self->{'obj'}->sigil() eq '@') || ($self->{'obj'}->isa('Perlito5::AST::Apply') && $self->{'obj'}->code() eq 'circumfix:<( )>')) {
            return 'p5list_slice(' . $self->{'obj'}->emit_java($level, 'list') . ', ' . Perlito5::Java::to_list([$self->{'index_exp'}], $level) . ', ' . Perlito5::Java::to_context($wantarray) . ')'
        }
        if (($self->{'obj'}->isa('Perlito5::AST::Apply') && $self->{'obj'}->{'code'} eq 'prefix:<%>') || ($self->{'obj'}->isa('Perlito5::AST::Var') && $self->{'obj'}->sigil() eq '%')) {
            my $obj = $self->{'obj'};
            $obj->{'sigil'} eq '%' && ($obj->{'sigil'} = '@');
            $obj->{'code'} eq 'prefix:<%>' && ($obj->{'code'} = 'prefix:<@>');
            return 'p5hash_slice(' . $self->{'obj'}->emit_java($level, 'list') . ', ' . Perlito5::Java::to_list([$self->{'index_exp'}], $level) . ', ' . Perlito5::Java::to_context($wantarray) . ')'
        }
        return $self->emit_java_container($level) . '.' . $method . '(' . Perlito5::Java::to_num($self->{'index_exp'}, $level) . ')'
    }
    sub Perlito5::AST::Index::emit_java_set {
        my($self, $arguments, $level, $wantarray) = @_;
        if (($self->{'obj'}->isa('Perlito5::AST::Apply') && $self->{'obj'}->{'code'} eq 'prefix:<@>') || ($self->{'obj'}->isa('Perlito5::AST::Var') && $self->{'obj'}->sigil() eq '@')) {
            return Perlito5::Java::emit_wrap_java($level, $wantarray, 'var a = [];', 'var v = ' . Perlito5::Java::to_list([$self->{'index_exp'}], $level) . ';', 'var src=' . Perlito5::Java::to_list([$arguments], $level) . ';', 'var out=' . Perlito5::Java::emit_java_autovivify($self->{'obj'}, $level, 'array') . ';', 'var tmp' . ';', 'for (var i=0, l=v.length; i<l; ++i) {', ['tmp = src.aget(i);', 'out.aset(v[i], tmp);', 'a.push(tmp)'], '}', 'return a')
        }
        return $self->emit_java_container($level) . '.aset(' . Perlito5::Java::to_num($self->{'index_exp'}, $level + 1) . ', ' . Perlito5::Java::to_scalar([$arguments], $level + 1) . ')'
    }
    sub Perlito5::AST::Index::emit_java_set_list {
        my($self, $level, $list) = @_;
        my $wantarray = 'list';
        if (($self->{'obj'}->isa('Perlito5::AST::Apply') && $self->{'obj'}->{'code'} eq 'prefix:<@>') || ($self->{'obj'}->isa('Perlito5::AST::Var') && $self->{'obj'}->sigil() eq '@')) {
            return Perlito5::Java::emit_wrap_java($level, $wantarray, 'var a = [];', 'var v = ' . Perlito5::Java::to_list([$self->{'index_exp'}], $level) . ';', 'var out=' . Perlito5::Java::emit_java_autovivify($self->{'obj'}, $level, 'array') . ';', 'var tmp' . ';', 'for (var i=0, l=v.length; i<l; ++i) {', ['tmp = ' . $list . '.shift();', 'out.aset(v[i], tmp);', 'a.push(tmp)'], '}', 'return a')
        }
        return $self->emit_java_container($level) . '.aset(' . Perlito5::Java::to_num($self->{'index_exp'}, $level + 1) . ', ' . $list . '.shift()' . ')'
    }
    sub Perlito5::AST::Index::emit_java_container {
        my $self = shift;
        my $level = shift;
        if ($self->{'obj'}->isa('Perlito5::AST::Apply') && $self->{'obj'}->{'code'} eq 'prefix:<$>') {
            my $v = Perlito5::AST::Apply::->new(%{$self->{'obj'}}, 'code' => 'prefix:<@>');
            return $v->emit_java($level)
        }
        if ($self->{'obj'}->isa('Perlito5::AST::Apply') && $self->{'obj'}->code() eq 'circumfix:<( )>') {
            return Perlito5::Java::to_list([$self->{'obj'}], $level)
        }
        if ($self->{'obj'}->isa('Perlito5::AST::Var') && $self->{'obj'}->sigil() eq '$') {
            $self->{'obj'}->{'sigil'} = '@';
            return $self->{'obj'}->emit_java($level)
        }
        else {
            return Perlito5::Java::emit_java_autovivify($self->{'obj'}, $level, 'array')
        }
    }
    sub Perlito5::AST::Index::emit_java_get_decl {
        ()
    }
    sub Perlito5::AST::Index::emit_java_has_regex {
        ()
    }
    sub Perlito5::AST::Index::emit_java_get_captures {
        my $self = shift;
        my @var;
        push(@var, $self->{'obj'}->emit_java_get_captures());
        push(@var, $self->{'index_exp'}->emit_java_get_captures());
        return @var
    }
}
package Perlito5::AST::Lookup;
{
    sub Perlito5::AST::Lookup::emit_java {
        my($self, $level, $wantarray, $autovivification_type) = @_;
        my $method = $autovivification_type || 'hget';
        $autovivification_type eq 'scalar' && ($method = 'hget_scalarref');
        $autovivification_type eq 'array' && ($method = 'hget_arrayref');
        $autovivification_type eq 'hash' && ($method = 'hget_hashref');
        if (($self->{'obj'}->isa('Perlito5::AST::Apply') && $self->{'obj'}->{'code'} eq 'prefix:<@>') || ($self->{'obj'}->isa('Perlito5::AST::Var') && $self->{'obj'}->sigil() eq '@')) {
            my $v;
            if ($self->{'obj'}->isa('Perlito5::AST::Var')) {
                $v = $self->{'obj'}
            }
            $self->{'obj'}->isa('Perlito5::AST::Apply') && ($v = Perlito5::AST::Apply::->new('code' => 'prefix:<%>', 'namespace' => $self->{'obj'}->namespace(), 'arguments' => $self->{'obj'}->arguments()));
            return 'p5list_lookup_slice(' . $v->emit_java($level, 'list') . ', ' . Perlito5::Java::to_list([$self->{'index_exp'}], $level) . ', ' . Perlito5::Java::to_context($wantarray) . ')'
        }
        if (($self->{'obj'}->isa('Perlito5::AST::Apply') && $self->{'obj'}->{'code'} eq 'prefix:<%>') || ($self->{'obj'}->isa('Perlito5::AST::Var') && $self->{'obj'}->sigil() eq '%')) {
            my $v;
            if ($self->{'obj'}->isa('Perlito5::AST::Var')) {
                $v = $self->{'obj'}
            }
            $self->{'obj'}->isa('Perlito5::AST::Apply') && ($v = Perlito5::AST::Apply::->new('code' => 'prefix:<%>', 'namespace' => $self->{'obj'}->namespace(), 'arguments' => $self->{'obj'}->arguments()));
            return 'p5hash_lookup_slice(' . $v->emit_java($level, 'list') . ', ' . Perlito5::Java::to_list([$self->{'index_exp'}], $level) . ', ' . Perlito5::Java::to_context($wantarray) . ')'
        }
        return $self->emit_java_container($level) . '.' . $method . '(' . Perlito5::Java::autoquote($self->{'index_exp'}, $level) . ')'
    }
    sub Perlito5::AST::Lookup::emit_java_set {
        my($self, $arguments, $level, $wantarray) = @_;
        if (($self->{'obj'}->isa('Perlito5::AST::Apply') && $self->{'obj'}->{'code'} eq 'prefix:<@>') || ($self->{'obj'}->isa('Perlito5::AST::Var') && $self->{'obj'}->sigil() eq '@')) {
            my $v;
            $self->{'obj'}->isa('Perlito5::AST::Var') && ($v = $self->{'obj'});
            $self->{'obj'}->isa('Perlito5::AST::Apply') && ($v = Perlito5::AST::Apply::->new('code' => 'prefix:<%>', 'namespace' => $self->{'obj'}->namespace(), 'arguments' => $self->{'obj'}->arguments()));
            return Perlito5::Java::emit_wrap_java($level, $wantarray, 'var a = [];', 'var v = ' . Perlito5::Java::to_list([$self->{'index_exp'}], $level) . ';', 'var src=' . Perlito5::Java::to_list([$arguments], $level) . ';', 'var out=' . $v->emit_java($level) . ';', 'var tmp' . ';', 'for (var i=0, l=v.length; i<l; ++i)' . '{', ['tmp = src.hget(i);', 'out.hset(v[i], tmp);', 'a.push(tmp)'], '}', 'return a')
        }
        return $self->emit_java_container($level) . '.hset(' . Perlito5::Java::autoquote($self->{'index_exp'}, $level) . ', ' . Perlito5::Java::to_scalar([$arguments], $level + 1) . ')'
    }
    sub Perlito5::AST::Lookup::emit_java_set_list {
        my($self, $level, $list) = @_;
        my $wantarray = 'list';
        if (($self->{'obj'}->isa('Perlito5::AST::Apply') && $self->{'obj'}->{'code'} eq 'prefix:<@>') || ($self->{'obj'}->isa('Perlito5::AST::Var') && $self->{'obj'}->sigil() eq '@')) {
            my $v;
            $self->{'obj'}->isa('Perlito5::AST::Var') && ($v = $self->{'obj'});
            $self->{'obj'}->isa('Perlito5::AST::Apply') && ($v = Perlito5::AST::Apply::->new('code' => 'prefix:<%>', 'namespace' => $self->{'obj'}->namespace(), 'arguments' => $self->{'obj'}->arguments()));
            return Perlito5::Java::emit_wrap_java($level, $wantarray, 'var a = [];', 'var v = ' . Perlito5::Java::to_list([$self->{'index_exp'}], $level) . ';', 'var out=' . $v->emit_java($level) . ';', 'var tmp' . ';', 'for (var i=0, l=v.length; i<l; ++i)' . '{', ['tmp = ' . $list . '.shift();', 'out.hset(v[i], tmp);', 'a.push(tmp)'], '}', 'return a')
        }
        return $self->emit_java_container($level) . '.hset(' . Perlito5::Java::autoquote($self->{'index_exp'}, $level) . ', ' . $list . '.shift()' . ')'
    }
    sub Perlito5::AST::Lookup::emit_java_container {
        my $self = shift;
        my $level = shift;
        if ($self->{'obj'}->isa('Perlito5::AST::Apply') && $self->{'obj'}->{'code'} eq 'prefix:<$>') {
            my $v = Perlito5::AST::Apply::->new(%{$self->{'obj'}}, 'code' => 'prefix:<%>');
            return $v->emit_java($level)
        }
        if ($self->{'obj'}->isa('Perlito5::AST::Var') && $self->{'obj'}->sigil() eq '$') {
            my $v = Perlito5::AST::Var::->new(%{$self->{'obj'}}, 'sigil' => '%');
            return $v->emit_java($level)
        }
        else {
            return Perlito5::Java::emit_java_autovivify($self->{'obj'}, $level, 'hash')
        }
    }
    sub Perlito5::AST::Lookup::emit_java_get_decl {
        ()
    }
    sub Perlito5::AST::Lookup::emit_java_has_regex {
        ()
    }
    sub Perlito5::AST::Lookup::emit_java_get_captures {
        ()
    }
}
package Perlito5::AST::Var;
{
    my $table = {'$' => 'v_', '@' => 'List_', '%' => 'Hash_', '&' => ''};
    sub Perlito5::AST::Var::emit_java_global {
        my($self, $level, $wantarray) = @_;
        my $str_name = $self->{'name'};
        my $sigil = $self->{'_real_sigil'} || $self->{'sigil'};
        my $namespace = $self->{'namespace'} || $self->{'_namespace'};
        if ($sigil eq '@' && $self->{'name'} eq '_' && $namespace eq 'main') {
            my $s = 'List__';
            if ($self->{'sigil'} eq '$#') {
                return $s . '.end_of_array_index()'
            }
            if ($wantarray eq 'scalar') {
                return $s . '.length_of_array()'
            }
            if ($wantarray eq 'runtime') {
                return '(p5want' . ' ? ' . $s . ' : ' . $s . '.to_int()' . ')'
            }
            return $s
        }
        if ($sigil eq '$' && $self->{'name'} > 0) {
            return 'p5_regex_capture[' . ($self->{'name'} - 1) . ']'
        }
        if ($sigil eq '::') {
            return Perlito5::Java::escape_string($namespace)
        }
        my $index = Perlito5::Java::escape_string($namespace . '|' . $table->{$sigil} . $str_name);
        if ($sigil eq '$') {
            return 'pV.get(' . $index . ')'
        }
        if ($sigil eq '*') {}
        if ($sigil eq '&') {}
        if ($sigil eq '@') {
            if ($self->{'sigil'} eq '$#') {
                return 'pV.array_get(' . $index . ').end_of_array_index()'
            }
            my $s = 'pV.array_get(' . $index . ')';
            if ($wantarray eq 'scalar') {
                return $s . '.length_of_array()'
            }
            return $s
        }
        if ($sigil eq '%') {
            return 'pV.hash_get(' . $index . ')'
        }
        die('don' . chr(39) . 't know how to access variable ', $sigil, $self->name())
    }
    sub Perlito5::AST::Var::emit_java_global_set {
        my($self, $arguments, $level, $wantarray) = @_;
        my $str_name = $self->{'name'};
        my $sigil = $self->{'_real_sigil'} || $self->{'sigil'};
        my $namespace = $self->{'namespace'} || $self->{'_namespace'};
        if ($sigil eq '@' && $self->{'name'} eq '_' && $namespace eq 'main') {
            my $s = 'List__';
            if ($self->{'sigil'} eq '$#') {
                return $s . '.set_end_of_array_index(' . Perlito5::Java::to_scalar([$arguments], $level + 1) . ')'
            }
            if ($wantarray eq 'scalar') {
                return $s . '.to_int()'
            }
            if ($wantarray eq 'runtime') {
                return '(p5want' . ' ? ' . $s . ' : ' . $s . '.to_int()' . ')'
            }
            return $s
        }
        if ($sigil eq '$' && $self->{'name'} > 0) {
            return 'p5_regex_capture[' . ($self->{'name'} - 1) . ']'
        }
        if ($sigil eq '::') {
            return Perlito5::Java::escape_string($namespace)
        }
        my $index = Perlito5::Java::escape_string($namespace . '|' . $table->{$sigil} . $str_name);
        if ($sigil eq '$') {
            return 'pV.set(' . $index . ', ' . Perlito5::Java::to_scalar([$arguments], $level + 1) . ')'
        }
        if ($sigil eq '@') {
            if ($self->{'sigil'} eq '$#') {
                $self->{'sigil'} = '@';
                return 'pV.array_get(' . $index . ').set_end_of_array_index(' . Perlito5::Java::to_scalar([$arguments], $level + 1) . ')'
            }
            return 'pV.array_set(' . $index . ', ' . Perlito5::Java::to_list([$arguments], $level + 1) . ')'
        }
        if ($sigil eq '%') {
            return 'pV.hash_set(' . $index . ', ' . Perlito5::Java::to_list([$arguments], $level + 1) . ')'
        }
        if ($sigil eq '*') {
            die('don' . chr(39) . 't know how to assign to variable ', $sigil, $self->name())
        }
        if ($sigil eq '&') {}
        die('don' . chr(39) . 't know how to assign to variable ', $sigil, $self->name())
    }
    sub Perlito5::AST::Var::emit_java {
        my($self, $level, $wantarray) = @_;
        my $sigil = $self->{'_real_sigil'} || $self->{'sigil'};
        my $decl_type = $self->{'_decl'} || 'global';
        if ($decl_type ne 'my') {
            return $self->emit_java_global($level, $wantarray)
        }
        my $str_name = $table->{$sigil} . $self->{'name'} . '_' . $self->{'_id'};
        exists($Perlito5::Java::Java_var_name{$self->{'_id'}}) && ($str_name = $Perlito5::Java::Java_var_name{$self->{'_id'}});
        if ($sigil eq '@') {
            if ($wantarray eq 'scalar') {
                return $self->emit_java($level, 'list') . '.length_of_array()'
            }
            if ($wantarray eq 'runtime') {
                return '(p5want' . ' ? ' . $self->emit_java($level, 'list') . ' : ' . $self->emit_java($level, 'list') . '.length_of_array()' . ')'
            }
        }
        if ($self->{'sigil'} eq '$#') {
            return $str_name . '.end_of_array_index()'
        }
        return $str_name
    }
    sub Perlito5::AST::Var::emit_java_set {
        my($self, $arguments, $level, $wantarray) = @_;
        my $decl_type = $self->{'_decl'} || 'global';
        if ($decl_type ne 'my') {
            return $self->emit_java_global_set($arguments, $level, $wantarray)
        }
        my $open = $wantarray eq 'void' ? '' : '(';
        my $close = $wantarray eq 'void' ? '' : ')';
        my $sigil = $self->{'_real_sigil'} || $self->{'sigil'};
        if ($sigil eq '$') {
            my $id = $self->{'_id'};
            my $Java_var = Perlito5::Java::get_java_var_info();
            my $type = $Java_var->{$id}->{'type'} || 'pLvalue';
            if ($type ne 'pLvalue') {
                return $self->emit_java() . ' = ' . Perlito5::Java::to_native_args([$arguments])
            }
            return $self->emit_java() . '.set(' . Perlito5::Java::to_scalar([$arguments], $level + 1) . ')'
        }
        if ($sigil eq '@') {
            if ($self->{'sigil'} eq '$#') {
                $self->{'sigil'} = '@';
                return $open . $self->emit_java() . '.set_end_of_array_index(' . Perlito5::Java::to_scalar([$arguments], $level + 1) . ')' . $close
            }
            return $open . $self->emit_java() . ' = ' . Perlito5::Java::to_list([$arguments], $level + 1) . $close
        }
        if ($sigil eq '%') {
            return $open . $self->emit_java() . ' = new pHash(' . Perlito5::Java::to_list([$arguments], $level + 1, 'hash') . ')' . $close
        }
        if ($sigil eq '*') {
            my $namespace = $self->{'namespace'} || $self->{'_namespace'};
            return 'p5typeglob_set(' . Perlito5::Java::escape_string($namespace) . ', ' . Perlito5::Java::escape_string($self->{'name'}) . ', ' . Perlito5::Java::to_scalar([$arguments], $level + 1) . ')'
        }
        die('don' . chr(39) . 't know how to assign to variable ', $sigil, $self->name())
    }
    sub Perlito5::AST::Var::emit_java_set_list {
        my($self, $level, $list) = @_;
        my $sigil = $self->{'_real_sigil'} || $self->{'sigil'};
        if ($sigil eq '$') {
            return $self->emit_java() . ' = ' . $list . '.shift()'
        }
        if ($sigil eq '@') {
            return join(';' . chr(10) . Perlito5::Java::tab($level), $self->emit_java() . ' = ' . $list, $list . ' = []')
        }
        if ($sigil eq '%') {
            return join(';' . chr(10) . Perlito5::Java::tab($level), $self->emit_java() . ' = new pHash(' . $list . ')', $list . ' = []')
        }
        die('don' . chr(39) . 't know how to assign to variable ', $sigil, $self->name())
    }
    sub Perlito5::AST::Var::emit_java_get_decl {
        ()
    }
    sub Perlito5::AST::Var::emit_java_has_regex {
        ()
    }
    sub Perlito5::AST::Var::emit_java_get_captures {
        my $self = shift;
        return ($self)
    }
}
package Perlito5::AST::Decl;
{
    sub Perlito5::AST::Decl::emit_java {
        my($self, $level, $wantarray) = @_;
        $self->{'var'}->emit_java($level)
    }
    sub Perlito5::AST::Decl::emit_java_init {
        my($self, $level, $wantarray) = @_;
        my $Java_var = Perlito5::Java::get_java_var_info();
        my $type = $self->{'type'} || 'pLvalue';
        my $id = $self->{'var'}->{'_id'};
        if ($id) {
            $Java_var->{$id} = {'id' => $id, 'type' => $type}
        }
        if ($self->{'decl'} eq 'local') {
            my $var = $self->{'var'};
            my $var_set;
            my $tmp_name = Perlito5::Java::get_label();
            if (ref($var) eq 'Perlito5::AST::Var') {
                $var_set = $var->emit_java() . ' = v_' . $tmp_name
            }
            else {
                my $tmp = Perlito5::AST::Var::->new('sigil' => '$', 'name' => $tmp_name, '_decl' => 'my');
                $var_set = $var->emit_java_set($tmp)
            }
            return Perlito5::Java::emit_wrap_java($level, $wantarray, 'var v_' . $tmp_name . ' = ' . $var->emit_java() . ';', 'p5LOCAL.push(function(){ ' . $var_set . ' });', 'return ' . $var->emit_java_set(Perlito5::AST::Apply::->new('code' => 'undef', 'arguments' => [], 'namespace' => ''), $level + 1) . ';') . ';'
        }
        if ($self->{'decl'} eq 'my') {
            if ($self->{'var'}->sigil() eq '%') {
                return 'pHash ' . $self->{'var'}->emit_java() . ' = new pHash();'
            }
            elsif ($self->{'var'}->sigil() eq '@') {
                return 'pArray ' . $self->{'var'}->emit_java() . ' = new pArray();'
            }
            else {
                my $Java_class = Perlito5::Java::get_java_class_info();
                my $java_type = $Java_class->{$type}->{'java_type'} || 'pLvalue';
                if ($java_type eq 'pLvalue') {
                    return $java_type . ' ' . $self->{'var'}->emit_java() . ' = new ' . $java_type . '();'
                }
                else {
                    return $java_type . ' ' . $self->{'var'}->emit_java() . ';'
                }
            }
        }
        elsif ($self->{'decl'} eq 'our') {
            my $str = $self->{'var'}->emit_java();
            if ($self->{'var'}->sigil() eq '%') {
                $str = $str . ' = {};'
            }
            elsif ($self->{'var'}->sigil() eq '@') {
                $str = $str . ' = [];'
            }
            else {
                return '// our ' . $str
            }
            return 'if (typeof ' . $self->{'var'}->emit_java() . ' == "undefined" ) { ' . $str . '}'
        }
        elsif ($self->{'decl'} eq 'state') {
            return '// state ' . $self->{'var'}->emit_java()
        }
        else {
            die('not implemented: Perlito5::AST::Decl ' . chr(39) . $self->{'decl'} . chr(39))
        }
    }
    sub Perlito5::AST::Decl::emit_java_set {
        my($self, $arguments, $level, $wantarray) = @_;
        $self->var()->emit_java_set($arguments, $level, $wantarray)
    }
    sub Perlito5::AST::Decl::emit_java_set_list {
        my($self, $level, $list) = @_;
        $self->var()->emit_java_set_list($level, $list)
    }
    sub Perlito5::AST::Decl::emit_java_get_decl {
        my $self = shift;
        return ($self)
    }
    sub Perlito5::AST::Decl::emit_java_has_regex {
        ()
    }
    sub Perlito5::AST::Decl::emit_java_get_captures {
        return {'dont' => $_[0]->{'var'}->{'_id'}}
    }
}
package Perlito5::AST::Call;
{
    sub Perlito5::AST::Call::emit_java {
        my($self, $level, $wantarray, $autovivification_type) = @_;
        my $meth = $self->{'method'};
        if ($meth eq 'postcircumfix:<[ ]>') {
            my $method = $autovivification_type || 'aget';
            $autovivification_type eq 'scalar' && ($method = 'aget_scalarref');
            $autovivification_type eq 'array' && ($method = 'aget_arrayref');
            $autovivification_type eq 'hash' && ($method = 'aget_hashref');
            return Perlito5::Java::emit_java_autovivify($self->{'invocant'}, $level, 'array') . '.' . $method . '(' . Perlito5::Java::to_num($self->{'arguments'}, $level + 1) . ')'
        }
        if ($meth eq 'postcircumfix:<{ }>') {
            my $method = $autovivification_type || 'hget';
            $autovivification_type eq 'scalar' && ($method = 'hget_scalarref');
            $autovivification_type eq 'array' && ($method = 'hget_arrayref');
            $autovivification_type eq 'hash' && ($method = 'hget_hashref');
            return Perlito5::Java::emit_java_autovivify($self->{'invocant'}, $level, 'hash') . '.' . $method . '(' . Perlito5::Java::autoquote($self->{'arguments'}, $level + 1, 'list') . ')'
        }
        if ($meth eq 'postcircumfix:<( )>') {
            my $invocant;
            if (ref($self->{'invocant'}) eq 'Perlito5::AST::Apply' && $self->{'invocant'}->{'code'} eq 'prefix:<&>') {
                my $arg = $self->{'invocant'}->{'arguments'}->[0];
                $invocant = 'p5code_lookup_by_name(' . Perlito5::Java::escape_string($Perlito5::PKG_NAME) . ', ' . $arg->emit_java($level) . ')'
            }
            elsif (ref($self->{'invocant'}) eq 'Perlito5::AST::Var' && $self->{'invocant'}->{'sigil'} eq '&') {
                $invocant = 'p5pkg[' . Perlito5::Java::escape_string(($self->{'invocant'}->{'namespace'} || $Perlito5::PKG_NAME)) . '][' . Perlito5::Java::escape_string($self->{'invocant'}->{'name'}) . ']'
            }
            elsif (ref($self->{'invocant'}) eq 'Perlito5::AST::Var' && $self->{'invocant'}->{'sigil'} eq '::' && $self->{'invocant'}->{'namespace'} eq '__SUB__') {
                $invocant = 'this'
            }
            else {
                $invocant = $self->{'invocant'}->emit_java($level, 'scalar')
            }
            return $invocant . '.apply(' . Perlito5::Java::to_context($wantarray) . ', ' . Perlito5::Java::to_list($self->{'arguments'}) . ')'
        }
        if (ref($self->{'invocant'}) eq 'Perlito5::AST::Var' && $self->{'invocant'}->{'sigil'} eq '::') {
            my $Java_class = Perlito5::Java::get_java_class_info();
            if (exists($Java_class->{$self->{'invocant'}->{'namespace'}})) {
                my $info = $Java_class->{$self->{'invocant'}->{'namespace'}};
                if ($meth eq 'new') {
                    return 'new ' . $info->{'java_type'} . '(' . Perlito5::Java::to_native_args($self->{'arguments'}) . ')'
                }
                return $info->{'java_type'} . '.' . $meth . '(' . Perlito5::Java::to_native_args($self->{'arguments'}) . ')'
            }
        }
        my $invocant = $self->{'invocant'}->emit_java($level, 'scalar');
        if (ref($self->{'invocant'}) eq 'Perlito5::AST::Var' && $self->{'invocant'}->{'_id'}) {
            my $id = $self->{'invocant'}->{'_id'};
            my $Java_var = Perlito5::Java::get_java_var_info();
            my $type = $Java_var->{$id}->{'type'} || 'pLvalue';
            if ($type ne 'pLvalue') {
                return $invocant . '.' . $meth . '(' . Perlito5::Java::to_native_args($self->{'arguments'}) . ')'
            }
        }
        if ($meth =~ m!^to!) {
            my $Java_class = Perlito5::Java::get_java_class_info();
            for my $info (values(%{$Java_class})) {
                if ($meth eq $info->{'perl_to_java'}) {
                    return $invocant . '.' . $meth . '()'
                }
            }
        }
        if (ref($meth) eq 'Perlito5::AST::Var') {
            $meth = $meth->emit_java($level, 'scalar')
        }
        else {
            $meth = Perlito5::Java::escape_string($meth)
        }
        return 'p5call(' . $invocant . ', ' . $meth . ', ' . Perlito5::Java::to_list($self->{'arguments'}) . ', ' . Perlito5::Java::to_context($wantarray) . ')'
    }
    sub Perlito5::AST::Call::emit_java_set {
        my($self, $arguments, $level, $wantarray) = @_;
        if ($self->{'method'} eq 'postcircumfix:<[ ]>') {
            return Perlito5::Java::emit_java_autovivify($self->{'invocant'}, $level, 'array') . '.aset(' . Perlito5::Java::to_num($self->{'arguments'}, $level + 1) . ', ' . Perlito5::Java::to_scalar([$arguments], $level + 1) . ')'
        }
        if ($self->{'method'} eq 'postcircumfix:<{ }>') {
            return Perlito5::Java::emit_java_autovivify($self->{'invocant'}, $level, 'hash') . '.hset(' . Perlito5::Java::autoquote($self->{'arguments'}, $level + 1, 'list') . ', ' . Perlito5::Java::to_scalar([$arguments], $level + 1) . ')'
        }
        die('don' . chr(39) . 't know how to assign to method ', $self->{'method'})
    }
    sub Perlito5::AST::Call::emit_java_set_list {
        my($self, $level, $list) = @_;
        if ($self->{'method'} eq 'postcircumfix:<[ ]>') {
            return Perlito5::Java::emit_java_autovivify($self->{'invocant'}, $level, 'array') . '.aset(' . Perlito5::Java::to_num($self->{'arguments'}, $level + 1) . ', ' . $list . '.shift()' . ')'
        }
        if ($self->{'method'} eq 'postcircumfix:<{ }>') {
            return Perlito5::Java::emit_java_autovivify($self->{'invocant'}, $level, 'hash') . '.hset(' . Perlito5::Java::autoquote($self->{'arguments'}, $level + 1, 'list') . ', ' . $list . '.shift()' . ')'
        }
        die('don' . chr(39) . 't know how to assign to method ', $self->{'method'})
    }
    sub Perlito5::AST::Call::emit_java_get_decl {
        ()
    }
    sub Perlito5::AST::Call::emit_java_has_regex {
        ()
    }
    sub Perlito5::AST::Call::emit_java_get_captures {
        ()
    }
}
package Perlito5::AST::Apply;
{
    sub Perlito5::AST::Apply::emit_qr_java {
        my($regex, $modifier, $level) = @_;
        if ($modifier->{'buf'} eq '' && ref($regex) eq 'Perlito5::AST::Var' && $regex->{'sigil'} eq '$') {
            return $regex->emit_java($level)
        }
        my %flags = map {
            $_ => 1
        } split(m!!, $modifier->{'buf'});
        my $flag_string = join(' | ', ($flags{'i'} ? 'Pattern.CASE_INSENSITIVE' : ()), ($flags{'x'} ? 'Pattern.COMMENTS' : ()), ($flags{'m'} ? 'Pattern.MULTILINE' : ()), ($flags{'s'} ? 'Pattern.DOTALL' : ())) || 0;
        my $s = 'new pRegex(' . Perlito5::Java::to_str($regex) . ', ' . $flag_string . ')';
        if (ref($regex) eq 'Perlito5::AST::Buf') {
            my $label = Perlito5::Java::get_label();
            push(@Perlito5::Java::Java_constants, 'public static final pRegex ' . $label . ' = ' . $s . ';');
            return 'pCx.' . $label
        }
        return $s
    }
    sub Perlito5::AST::Apply::emit_regex_java {
        my $op = shift;
        my $var = shift;
        my $regex = shift;
        my $level = shift;
        my $wantarray = shift;
        if ($regex->isa('Perlito5::AST::Var')) {
            $regex = {'code' => 'p5:m', 'arguments' => [$regex, '']}
        }
        my $str;
        my $code = $regex->{'code'};
        my $regex_args = $regex->{'arguments'};
        if ($code eq 'p5:s') {
            my $replace = $regex_args->[1];
            my $modifier = $regex_args->[2]->{'buf'};
            if (ref($replace) eq 'Perlito5::AST::Block') {
                $replace = Perlito5::AST::Apply::->new('code' => 'do', 'arguments' => [$replace]);
                $modifier =~ s!e!!g
            }
            $str = 'PerlOp.replace(' . $var->emit_java() . ', ' . emit_qr_java($regex_args->[0], $modifier, $level) . ', ' . $replace->emit_java() . ', ' . Perlito5::Java::to_context($wantarray) . ')'
        }
        elsif ($code eq 'p5:m') {
            $str = 'PerlOp.match(' . $var->emit_java() . ', ' . emit_qr_java($regex_args->[0], $regex_args->[1], $level) . ', ' . Perlito5::Java::to_context($wantarray) . ')'
        }
        elsif ($code eq 'p5:tr') {
            $str = Perlito5::Java::emit_wrap_java($level + 1, $wantarray, 'var tmp = p5tr(' . $var->emit_java() . ', ' . $regex_args->[0]->emit_java() . ', ' . $regex_args->[1]->emit_java() . ', ' . Perlito5::Java::escape_string($regex_args->[2]->{'buf'}) . ', ' . Perlito5::Java::to_context($wantarray) . ');', $var->emit_java() . ' = tmp[0];', 'return tmp[1];')
        }
        else {
            die('Error: regex emitter - unknown operator ' . $code)
        }
        if ($op eq '=~') {
            return $str
        }
        if ($op eq '!~') {
            return '!(' . $str . ')'
        }
        die('Error: regex emitter')
    }
    sub Perlito5::AST::Apply::emit_java_set {
        my($self, $arguments, $level, $wantarray) = @_;
        my $code = $self->{'code'};
        if ($code eq 'prefix:<$>') {
            return Perlito5::Java::emit_java_autovivify($self->{'arguments'}->[0], $level + 1, 'scalar') . '.scalar_deref_set(' . Perlito5::Java::to_scalar([$arguments], $level + 1) . ')'
        }
        if ($code eq 'prefix:<@>') {
            return Perlito5::Java::emit_java_autovivify($self->{'arguments'}->[0], $level + 1, 'array') . '.array_deref_set(' . Perlito5::Java::to_list([$arguments], $level + 1) . ')'
        }
        if ($code eq 'prefix:<%>') {
            return Perlito5::Java::emit_java_autovivify($self->{'arguments'}->[0], $level + 1, 'hash') . '.hash_deref_set(' . Perlito5::Java::to_list([$arguments], $level + 1) . ')'
        }
        if ($code eq 'prefix:<*>') {
            return 'p5typeglob_deref_set(' . Perlito5::Java::to_scalar($self->{'arguments'}, $level + 1) . ', ' . Perlito5::Java::to_scalar([$arguments], $level + 1) . ', ' . Perlito5::Java::escape_string($Perlito5::PKG_NAME) . ')'
        }
        my $open = $wantarray eq 'void' ? '' : '(';
        my $close = $wantarray eq 'void' ? '' : ')';
        $open . $self->emit_java($level + 1) . ' = ' . $arguments->emit_java($level + 1) . $close
    }
    my %emit_js = ('infix:<=~>' => sub {
        my($self, $level, $wantarray) = @_;
        emit_regex_java('=~', $self->{'arguments'}->[0], $self->{'arguments'}->[1], $level, $wantarray)
    }, 'infix:<!~>' => sub {
        my($self, $level, $wantarray) = @_;
        emit_regex_java('!~', $self->{'arguments'}->[0], $self->{'arguments'}->[1], $level, $wantarray)
    }, 'p5:s' => sub {
        my($self, $level, $wantarray) = @_;
        emit_regex_java('=~', $self->{'arguments'}->[3], $self, $level, $wantarray)
    }, 'p5:m' => sub {
        my($self, $level, $wantarray) = @_;
        emit_regex_java('=~', $self->{'arguments'}->[2], $self, $level, $wantarray)
    }, 'p5:tr' => sub {
        my($self, $level, $wantarray) = @_;
        emit_regex_java('=~', $self->{'arguments'}->[3], $self, $level, $wantarray)
    }, 'p5:qr' => sub {
        my($self, $level, $wantarray) = @_;
        return emit_qr_java($self->{'arguments'}->[0], $self->{'arguments'}->[1], $level)
    }, '__PACKAGE__' => sub {
        my($self, $level, $wantarray) = @_;
        Perlito5::Java::escape_string($Perlito5::PKG_NAME)
    }, '__SUB__' => sub {
        my($self, $level, $wantarray) = @_;
        $Perlito5::AST::Sub::SUB_REF // 'this'
    }, 'wantarray' => sub {
        my($self, $level, $wantarray) = @_;
        '(want == pCx.VOID ? pCx.UNDEF : new pInt(want-1))'
    }, 'package' => sub {
        ''
    }, 'uc' => sub {
        my($self, $level, $wantarray) = @_;
        'new pString(' . $self->{'arguments'}->[0]->emit_java($level, 'scalar') . '.to_string().toUpperCase())'
    }, 'lc' => sub {
        my($self, $level, $wantarray) = @_;
        'new pString(' . $self->{'arguments'}->[0]->emit_java($level, 'scalar') . '.to_string().toLowerCase())'
    }, 'ucfirst' => sub {
        my($self, $level, $wantarray) = @_;
        $self->{'arguments'}->[0]->emit_java($level, 'scalar') . '.ucfirst()'
    }, 'lcfirst' => sub {
        my($self, $level, $wantarray) = @_;
        $self->{'arguments'}->[0]->emit_java($level, 'scalar') . '.lcfirst()'
    }, 'quotemeta' => sub {
        my($self, $level, $wantarray) = @_;
        $self->{'arguments'}->[0]->emit_java($level, 'scalar') . '.quotemeta()'
    }, 'index' => sub {
        my($self, $level, $wantarray) = @_;
        'new pInt(' . $self->{'arguments'}->[0]->emit_java($level, 'scalar') . '.to_string().indexOf(' . $self->{'arguments'}->[1]->emit_java($level, 'scalar') . '.to_string()))'
    }, 'chr' => sub {
        my($self, $level, $wantarray) = @_;
        'new pString((char)' . $self->{'arguments'}->[0]->emit_java($level, 'scalar') . '.to_int())'
    }, 'int' => sub {
        my($self, $level, $wantarray) = @_;
        'new pInt(' . $self->{'arguments'}->[0]->emit_java($level, 'scalar') . '.to_int())'
    }, (map {
        my $op = $_;
        ($op => sub {
            my($self, $level, $wantarray) = @_;
            $self->{'arguments'}->[0]->emit_java($level, 'scalar') . '.' . $op . '()'
        })
    } 'abs', 'sqrt', 'cos', 'sin', 'exp', 'log'), 'infix:<%>' => sub {
        my($self, $level, $wantarray) = @_;
        'new pInt(' . $self->{'arguments'}->[0]->emit_java($level, 'scalar') . '.to_int() % ' . $self->{'arguments'}->[1]->emit_java($level, 'scalar') . '.to_int())'
    }, 'infix:<>>>' => sub {
        my($self, $level, $wantarray) = @_;
        'new pInt(' . $self->{'arguments'}->[0]->emit_java($level, 'scalar') . '.to_int() >>> ' . $self->{'arguments'}->[1]->emit_java($level, 'scalar') . '.to_int())'
    }, 'infix:<<<>' => sub {
        my($self, $level, $wantarray) = @_;
        'new pInt(' . $self->{'arguments'}->[0]->emit_java($level, 'scalar') . '.to_int() << ' . $self->{'arguments'}->[1]->emit_java($level, 'scalar') . '.to_int())'
    }, 'infix:<^>' => sub {
        my($self, $level, $wantarray) = @_;
        'new pInt(' . $self->{'arguments'}->[0]->emit_java($level, 'scalar') . '.to_int() ^ ' . $self->{'arguments'}->[1]->emit_java($level, 'scalar') . '.to_int())'
    }, 'infix:<&>' => sub {
        my($self, $level, $wantarray) = @_;
        'new pInt(' . $self->{'arguments'}->[0]->emit_java($level, 'scalar') . '.to_int() & ' . $self->{'arguments'}->[1]->emit_java($level, 'scalar') . '.to_int())'
    }, 'infix:<|>' => sub {
        my($self, $level, $wantarray) = @_;
        'new pInt(' . $self->{'arguments'}->[0]->emit_java($level, 'scalar') . '.to_int() | ' . $self->{'arguments'}->[1]->emit_java($level, 'scalar') . '.to_int())'
    }, 'infix:<+>' => sub {
        my($self, $level, $wantarray) = @_;
        $self->{'arguments'}->[0]->emit_java($level, 'scalar') . '.add(' . $self->{'arguments'}->[1]->emit_java($level, 'scalar') . ')'
    }, 'infix:<->' => sub {
        my($self, $level, $wantarray) = @_;
        $self->{'arguments'}->[0]->emit_java($level, 'scalar') . '.sub(' . $self->{'arguments'}->[1]->emit_java($level, 'scalar') . ')'
    }, 'infix:<*>' => sub {
        my($self, $level, $wantarray) = @_;
        $self->{'arguments'}->[0]->emit_java($level, 'scalar') . '.mul(' . $self->{'arguments'}->[1]->emit_java($level, 'scalar') . ')'
    }, 'infix:</>' => sub {
        my($self, $level, $wantarray) = @_;
        $self->{'arguments'}->[0]->emit_java($level, 'scalar') . '.div(' . $self->{'arguments'}->[1]->emit_java($level, 'scalar') . ')'
    }, 'infix:<==>' => sub {
        my($self, $level, $wantarray) = @_;
        $self->{'arguments'}->[0]->emit_java($level, 'scalar') . '.num_eq(' . $self->{'arguments'}->[1]->emit_java($level, 'scalar') . ')'
    }, 'infix:<!=>' => sub {
        my($self, $level, $wantarray) = @_;
        $self->{'arguments'}->[0]->emit_java($level, 'scalar') . '.num_ne(' . $self->{'arguments'}->[1]->emit_java($level, 'scalar') . ')'
    }, 'infix:<>>' => sub {
        my($self, $level, $wantarray) = @_;
        $self->{'arguments'}->[0]->emit_java($level, 'scalar') . '.num_gt(' . $self->{'arguments'}->[1]->emit_java($level, 'scalar') . ')'
    }, 'infix:<>=>' => sub {
        my($self, $level, $wantarray) = @_;
        $self->{'arguments'}->[0]->emit_java($level, 'scalar') . '.num_ge(' . $self->{'arguments'}->[1]->emit_java($level, 'scalar') . ')'
    }, 'infix:<<>' => sub {
        my($self, $level, $wantarray) = @_;
        $self->{'arguments'}->[0]->emit_java($level, 'scalar') . '.num_lt(' . $self->{'arguments'}->[1]->emit_java($level, 'scalar') . ')'
    }, 'infix:<<=>' => sub {
        my($self, $level, $wantarray) = @_;
        $self->{'arguments'}->[0]->emit_java($level, 'scalar') . '.num_le(' . $self->{'arguments'}->[1]->emit_java($level, 'scalar') . ')'
    }, 'infix:<eq>' => sub {
        my($self, $level, $wantarray) = @_;
        $self->{'arguments'}->[0]->emit_java($level, 'scalar') . '.str_eq(' . $self->{'arguments'}->[1]->emit_java($level, 'scalar') . ')'
    }, 'infix:<ne>' => sub {
        my($self, $level, $wantarray) = @_;
        $self->{'arguments'}->[0]->emit_java($level, 'scalar') . '.str_ne(' . $self->{'arguments'}->[1]->emit_java($level, 'scalar') . ')'
    }, 'infix:<gt>' => sub {
        my($self, $level, $wantarray) = @_;
        $self->{'arguments'}->[0]->emit_java($level, 'scalar') . '.str_gt(' . $self->{'arguments'}->[1]->emit_java($level, 'scalar') . ')'
    }, 'infix:<ge>' => sub {
        my($self, $level, $wantarray) = @_;
        $self->{'arguments'}->[0]->emit_java($level, 'scalar') . '.str_ge(' . $self->{'arguments'}->[1]->emit_java($level, 'scalar') . ')'
    }, 'infix:<lt>' => sub {
        my($self, $level, $wantarray) = @_;
        $self->{'arguments'}->[0]->emit_java($level, 'scalar') . '.str_lt(' . $self->{'arguments'}->[1]->emit_java($level, 'scalar') . ')'
    }, 'infix:<le>' => sub {
        my($self, $level, $wantarray) = @_;
        $self->{'arguments'}->[0]->emit_java($level, 'scalar') . '.str_le(' . $self->{'arguments'}->[1]->emit_java($level, 'scalar') . ')'
    }, 'infix:<&&>' => sub {
        my($self, $level, $wantarray) = @_;
        if ($wantarray eq 'void') {
            return Perlito5::Java::to_bool($self->{'arguments'}->[0], $level) . ' ? ' . $self->{'arguments'}->[1]->emit_java($level, 'scalar') . ' : pCx.UNDEF'
        }
        'PerlOp.and1(' . $self->{'arguments'}->[0]->emit_java($level, 'scalar') . ') ? ' . $self->{'arguments'}->[1]->emit_java($level, 'scalar') . ' : PerlOp.and3()'
    }, 'infix:<and>' => sub {
        my($self, $level, $wantarray) = @_;
        if ($wantarray eq 'void') {
            return Perlito5::Java::to_bool($self->{'arguments'}->[0], $level) . ' ? ' . $self->{'arguments'}->[1]->emit_java($level, 'scalar') . ' : pCx.UNDEF'
        }
        'PerlOp.and1(' . $self->{'arguments'}->[0]->emit_java($level, 'scalar') . ') ? ' . $self->{'arguments'}->[1]->emit_java($level, 'scalar') . ' : PerlOp.and3()'
    }, 'infix:<||>' => sub {
        my($self, $level, $wantarray) = @_;
        if ($wantarray eq 'void') {
            return Perlito5::Java::to_bool($self->{'arguments'}->[0], $level) . ' ? ' . ' pCx.UNDEF : ' . $self->{'arguments'}->[1]->emit_java($level, 'scalar')
        }
        'PerlOp.or1(' . $self->{'arguments'}->[0]->emit_java($level, 'scalar') . ') ? PerlOp.or2() : ' . $self->{'arguments'}->[1]->emit_java($level, 'scalar') . ''
    }, 'infix:<or>' => sub {
        my($self, $level, $wantarray) = @_;
        if ($wantarray eq 'void') {
            return Perlito5::Java::to_bool($self->{'arguments'}->[0], $level) . ' ? ' . ' pCx.UNDEF : ' . $self->{'arguments'}->[1]->emit_java($level, 'scalar')
        }
        'PerlOp.or1(' . $self->{'arguments'}->[0]->emit_java($level, 'scalar') . ') ? PerlOp.or2() : ' . $self->{'arguments'}->[1]->emit_java($level, 'scalar') . ''
    }, 'infix:<xor>' => sub {
        my($self, $level, $wantarray) = @_;
        '( ' . Perlito5::Java::to_bool($self->{'arguments'}->[0], $level) . ' ? new pBool(!' . Perlito5::Java::to_bool($self->{'arguments'}->[1], $level) . ') : ' . ($self->{'arguments'}->[1])->emit_java($level, $wantarray) . ')'
    }, 'infix:<=>>' => sub {
        my($self, $level, $wantarray) = @_;
        Perlito5::AST::Lookup::->autoquote($self->{'arguments'}->[0])->emit_java($level) . ', ' . $self->{'arguments'}->[1]->emit_java($level)
    }, 'infix:<cmp>' => sub {
        my($self, $level, $wantarray) = @_;
        $self->{'arguments'}->[0]->emit_java($level, 'scalar') . '.str_cmp(' . $self->{'arguments'}->[1]->emit_java($level, 'scalar') . ')'
    }, 'infix:<<=>>' => sub {
        my($self, $level, $wantarray) = @_;
        $self->{'arguments'}->[0]->emit_java($level, 'scalar') . '.num_cmp(' . $self->{'arguments'}->[1]->emit_java($level, 'scalar') . ')'
    }, 'infix:<**>' => sub {
        my($self, $level, $wantarray) = @_;
        $self->{'arguments'}->[0]->emit_java($level, 'scalar') . '.pow(' . $self->{'arguments'}->[1]->emit_java($level, 'scalar') . ')'
    }, 'atan2' => sub {
        my($self, $level, $wantarray) = @_;
        $self->{'arguments'}->[0]->emit_java($level, 'scalar') . '.atan2(' . $self->{'arguments'}->[1]->emit_java($level, 'scalar') . ')'
    }, 'prefix:<!>' => sub {
        my $self = shift;
        my $level = shift;
        'new pBool(!(' . Perlito5::Java::to_bool($self->{'arguments'}->[0], $level) . '))'
    }, 'prefix:<not>' => sub {
        my $self = shift;
        my $level = shift;
        my $arg = pop(@{$self->{'arguments'}});
        if (!$arg) {
            return 'pCx.TRUE'
        }
        'new pBool(!( ' . Perlito5::Java::to_bool($arg, $level) . '))'
    }, 'prefix:<~>' => sub {
        my $self = $_[0];
        'new pInt(~' . Perlito5::Java::to_num($self->{'arguments'}->[0]) . '.to_int())'
    }, 'prefix:<->' => sub {
        my($self, $level, $wantarray) = @_;
        $self->{'arguments'}->[0]->emit_java($level, 'scalar') . '.neg()'
    }, 'prefix:<+>' => sub {
        my($self, $level, $wantarray) = @_;
        $self->{'arguments'}->[0]->emit_java($level, $wantarray)
    }, 'require' => sub {
        my($self, $level, $wantarray) = @_;
        my $arg = $self->{'arguments'}->[0];
        if ($arg->{'is_version_string'}) {
            return 'p5pkg["Perlito5"]["test_perl_version"]([' . Perlito5::Java::to_str($self->{'arguments'}->[0]) . '], ' . Perlito5::Java::to_context($wantarray) . ')'
        }
        'p5pkg["Perlito5::Grammar::Use"]["require"]([' . Perlito5::Java::to_str($self->{'arguments'}->[0]) . ', ' . ($self->{'arguments'}->[0]->{'bareword'} ? 1 : 0) . '], ' . Perlito5::Java::to_context($wantarray) . ')'
    }, 'select' => sub {
        my($self, $level, $wantarray) = @_;
        'p5pkg["CORE"]["select"]([' . ($self->{'arguments'}->[0]->{'bareword'} ? Perlito5::Java::to_str($self->{'arguments'}->[0]) : $self->{'arguments'}->[0]->emit_java($level, 'scalar')) . '])'
    }, 'prefix:<$>' => sub {
        my($self, $level, $wantarray) = @_;
        my $arg = $self->{'arguments'}->[0];
        return $arg->emit_java($level) . '.scalar_deref()'
    }, 'prefix:<@>' => sub {
        my($self, $level, $wantarray) = @_;
        my $arg = $self->{'arguments'}->[0];
        my $s = Perlito5::Java::emit_java_autovivify($arg, $level, 'array') . '.array_deref()';
        return $wantarray eq 'scalar' ? $s . '.scalar()' : $s
    }, 'prefix:<$#>' => sub {
        my($self, $level, $wantarray) = @_;
        my $arg = $self->{'arguments'}->[0];
        return Perlito5::Java::emit_java_autovivify($arg, $level, 'array') . '.array_deref().end_of_array_index()'
    }, 'prefix:<%>' => sub {
        my($self, $level, $wantarray) = @_;
        my $arg = $self->{'arguments'}->[0];
        return Perlito5::Java::emit_java_autovivify($arg, $level, 'hash') . '.hash_deref()'
    }, 'prefix:<&>' => sub {
        my($self, $level, $wantarray) = @_;
        my $arg = $self->{'arguments'}->[0];
        'p5code_lookup_by_name(' . Perlito5::Java::escape_string($Perlito5::PKG_NAME) . ', ' . $arg->emit_java($level) . ')([])'
    }, 'circumfix:<[ ]>' => sub {
        my($self, $level, $wantarray) = @_;
        'new pArrayRef(' . Perlito5::Java::to_list($self->{'arguments'}) . ')'
    }, 'circumfix:<{ }>' => sub {
        my($self, $level, $wantarray) = @_;
        '(new pHashRef(new pHash(' . Perlito5::Java::to_list($self->{'arguments'}, $level) . ')))'
    }, 'prefix:<' . chr(92) . '>' => sub {
        my($self, $level, $wantarray) = @_;
        my $arg = $self->{'arguments'}->[0];
        if ($arg->isa('Perlito5::AST::Apply')) {
            if ($arg->{'code'} eq 'prefix:<@>') {
                return 'new pArrayRef(' . $arg->emit_java($level) . ')'
            }
            if ($arg->{'code'} eq 'prefix:<%>') {
                return 'new pHashRef(' . $arg->emit_java($level) . ')'
            }
            if ($arg->{'code'} eq 'circumfix:<( )>') {
                return 'p5_list_of_refs(' . Perlito5::Java::to_list($arg->{'arguments'}) . ')'
            }
            if ($arg->{'code'} eq 'prefix:<&>') {
                return 'p5code_lookup_by_name(' . Perlito5::Java::escape_string($Perlito5::PKG_NAME) . ', ' . $arg->{'arguments'}->[0]->emit_java($level) . ')'
            }
        }
        if ($arg->isa('Perlito5::AST::Var')) {
            if ($arg->sigil() eq '@') {
                return 'new pArrayRef(' . $arg->emit_java($level) . ')'
            }
            if ($arg->sigil() eq '%') {
                return '(new pHashRef(' . $arg->emit_java($level) . '))'
            }
            if ($arg->sigil() eq '*') {
                return '(new pGlobRef(' . $arg->emit_java($level) . '))'
            }
            if ($arg->sigil() eq '&') {
                if ($arg->{'namespace'}) {
                    return 'p5pkg[' . Perlito5::Java::escape_string($arg->{'namespace'}) . '].' . $arg->{'name'}
                }
                else {
                    return Perlito5::Java::pkg() . '.' . $arg->{'name'}
                }
            }
        }
        return '(new pLvalueRef(' . $arg->emit_java($level) . '))'
    }, 'postfix:<++>' => sub {
        my($self, $level, $wantarray) = @_;
        my $arg = $self->{'arguments'}->[0];
        $arg->emit_java($level, 'scalar') . '.post_incr()'
    }, 'postfix:<-->' => sub {
        my($self, $level, $wantarray) = @_;
        my $arg = $self->{'arguments'}->[0];
        $arg->emit_java($level, 'scalar') . '.post_decr()'
    }, 'prefix:<++>' => sub {
        my($self, $level, $wantarray) = @_;
        my $arg = $self->{'arguments'}->[0];
        $arg->emit_java($level, 'scalar') . '.pre_incr()'
    }, 'prefix:<-->' => sub {
        my($self, $level, $wantarray) = @_;
        my $arg = $self->{'arguments'}->[0];
        $arg->emit_java($level, 'scalar') . '.pre_decr()'
    }, 'infix:<x>' => sub {
        my($self, $level, $wantarray) = @_;
        my $arg = $self->{'arguments'}->[0];
        if (ref($arg) eq 'Perlito5::AST::Apply' && ($arg->{'code'} eq 'circumfix:<( )>' || $arg->{'code'} eq 'list:<,>')) {
            return 'PerlOp.list_replicate(' . Perlito5::Java::to_list([$self->{'arguments'}->[0]], $level) . ', ' . Perlito5::Java::to_num($self->{'arguments'}->[1], $level) . ', ' . Perlito5::Java::to_context($wantarray) . ')'
        }
        'PerlOp.string_replicate(' . Perlito5::Java::to_str($self->{'arguments'}->[0], $level) . ',' . Perlito5::Java::to_num($self->{'arguments'}->[1], $level) . ')'
    }, 'list:<.>' => sub {
        my($self, $level, $wantarray) = @_;
        'new pString(' . join(' + ', map(Perlito5::Java::to_native_str($_, $level, 'scalar'), @{$self->{'arguments'}})) . ')'
    }, 'list:<,>' => sub {
        my($self, $level, $wantarray) = @_;
        Perlito5::Java::to_list($self->{'arguments'})
    }, 'infix:<..>' => sub {
        my($self, $level, $wantarray) = @_;
        return 'PerlOp.range(' . $self->{'arguments'}->[0]->emit_java($level) . ', ' . $self->{'arguments'}->[1]->emit_java($level) . ', ' . Perlito5::Java::to_context($wantarray) . ', ' . '"' . Perlito5::Java::get_label() . '"' . ', ' . 0 . ')'
    }, 'infix:<...>' => sub {
        my($self, $level, $wantarray) = @_;
        return 'PerlOp.range(' . $self->{'arguments'}->[0]->emit_java($level) . ', ' . $self->{'arguments'}->[1]->emit_java($level) . ', ' . Perlito5::Java::to_context($wantarray) . ', ' . '"' . Perlito5::Java::get_label() . '"' . ', ' . 1 . ')'
    }, 'delete' => sub {
        my($self, $level, $wantarray) = @_;
        my $arg = $self->{'arguments'}->[0];
        if ($arg->isa('Perlito5::AST::Lookup')) {
            my $v = $arg->obj();
            if ($v->isa('Perlito5::AST::Var') && $v->sigil() eq '$') {
                return $v->emit_java($level, $wantarray) . '.delete(' . $arg->autoquote($arg->{'index_exp'})->emit_java($level) . ')'
            }
            return $v->emit_java($level, $wantarray, 'hash') . '.delete(' . $arg->autoquote($arg->{'index_exp'})->emit_java($level) . ')'
        }
        if ($arg->isa('Perlito5::AST::Index')) {
            my $v = $arg->obj();
            if ($v->isa('Perlito5::AST::Var') && $v->sigil() eq '$') {
                return $v->emit_java($level, $wantarray) . '.delete(' . $arg->{'index_exp'}->emit_java($level) . ')'
            }
            return $v->emit_java($level, $wantarray, 'array') . '.delete(' . $arg->{'index_exp'}->emit_java($level) . ')'
        }
        if ($arg->isa('Perlito5::AST::Call')) {
            if ($arg->method() eq 'postcircumfix:<{ }>') {
                return $arg->invocant()->emit_java($level, $wantarray, 'hash') . '.delete(' . Perlito5::AST::Lookup::->autoquote($arg->{'arguments'})->emit_java($level) . ')'
            }
            if ($arg->method() eq 'postcircumfix:<[ ]>') {
                return $arg->invocant()->emit_java($level, $wantarray, 'array') . '.delete(' . $arg->{'arguments'}->emit_java($level) . ')'
            }
        }
        if ($arg->isa('Perlito5::AST::Var') && $arg->sigil() eq '&') {
            die('TODO delete &code')
        }
        if ($arg->isa('Perlito5::AST::Apply') && $arg->{'code'} eq 'prefix:<&>') {
            die('TODO delete &$code')
        }
    }, 'scalar' => sub {
        my($self, $level, $wantarray) = @_;
        Perlito5::Java::to_scalar($self->{'arguments'}, $level + 1)
    }, 'ternary:<? :>' => sub {
        my($self, $level, $wantarray) = @_;
        '( ' . Perlito5::Java::to_bool($self->{'arguments'}->[0], $level) . ' ? ' . ($self->{'arguments'}->[1])->emit_java($level, $wantarray) . ' : ' . ($self->{'arguments'}->[2])->emit_java($level, $wantarray) . ')'
    }, 'my' => sub {
        my($self, $level, $wantarray) = @_;
        'PerlOp.context(' . join(', ', Perlito5::Java::to_context($wantarray), map($_->emit_java($level, $wantarray), @{$self->{'arguments'}})) . ')'
    }, 'our' => sub {
        my($self, $level, $wantarray) = @_;
        'PerlOp.context(' . join(', ', Perlito5::Java::to_context($wantarray), map($_->emit_java($level, $wantarray), @{$self->{'arguments'}})) . ')'
    }, 'local' => sub {
        my($self, $level, $wantarray) = @_;
        'PerlOp.context(' . join(', ', Perlito5::Java::to_context($wantarray), map($_->emit_java($level, $wantarray), @{$self->{'arguments'}})) . ')'
    }, 'circumfix:<( )>' => sub {
        my($self, $level, $wantarray) = @_;
        'PerlOp.context(' . join(', ', Perlito5::Java::to_context($wantarray), map($_->emit_java($level, $wantarray), @{$self->{'arguments'}})) . ')'
    }, 'infix:<=>' => sub {
        my($self, $level, $wantarray) = @_;
        my $parameters = $self->{'arguments'}->[0];
        my $arguments = $self->{'arguments'}->[1];
        if ($parameters->isa('Perlito5::AST::Apply') && ($parameters->code() eq 'my' || $parameters->code() eq 'local' || $parameters->code() eq 'circumfix:<( )>')) {
            if ($wantarray eq 'void') {
                my $tmp = Perlito5::Java::get_label();
                return join(';' . chr(10) . Perlito5::Java::tab($level), 'var ' . $tmp . ' = ' . Perlito5::Java::to_list([$arguments], $level + 1), (map($_->emit_java_set_list($level, $tmp), @{$parameters->arguments()})))
            }
            my $tmp = Perlito5::Java::get_label();
            my $tmp2 = Perlito5::Java::get_label();
            return Perlito5::Java::emit_wrap_java($level, $wantarray, 'var ' . $tmp . ' = ' . Perlito5::Java::to_list([$arguments], $level + 1) . ';', 'var ' . $tmp2 . ' = ' . $tmp . '.slice(0);', (map($_->emit_java_set_list($level + 1, $tmp) . ';', @{$parameters->arguments()})), 'return ' . $tmp2)
        }
        return $parameters->emit_java_set($arguments, $level + 1, $wantarray)
    }, 'break' => sub {
        my($self, $level, $wantarray) = @_;
        $Perlito5::THROW = 1;
        die('TODO - break() not implemented')
    }, 'next' => sub {
        my($self, $level, $wantarray) = @_;
        $Perlito5::THROW = 1;
        my $label = $self->{'arguments'}->[0]->{'code'} || '';
        'PerlOp.next(' . 123 . ')'
    }, 'last' => sub {
        my($self, $level, $wantarray) = @_;
        $Perlito5::THROW = 1;
        my $label = $self->{'arguments'}->[0]->{'code'} || '';
        'PerlOp.last(' . 123 . ')'
    }, 'redo' => sub {
        my($self, $level, $wantarray) = @_;
        $Perlito5::THROW = 1;
        my $label = $self->{'arguments'}->[0]->{'code'} || '';
        'PerlOp.redo(' . 123 . ')'
    }, 'return' => sub {
        my($self, $level, $wantarray) = @_;
        $Perlito5::THROW = 1;
        if (!@{$self->{'arguments'}}) {
            return 'PerlOp.ret(PerlOp.context(want))'
        }
        'PerlOp.ret(' . Perlito5::Java::to_runtime_context($self->{'arguments'}, $level + 1) . ')'
    }, 'goto' => sub {
        my($self, $level, $wantarray) = @_;
        $Perlito5::THROW = 1;
        die('TODO - goto() not implemented')
    }, 'do' => sub {
        my($self, $level, $wantarray) = @_;
        my $arg = $self->{'arguments'}->[0];
        if ($arg->isa('Perlito5::AST::Block')) {
            my $ast = Perlito5::AST::Call::->new('method' => 'postcircumfix:<( )>', 'invocant' => Perlito5::AST::Sub::->new('block' => $arg, 'attributes' => []), 'arguments' => []);
            return $ast->emit_java($level + 1, $wantarray)
        }
        my $tmp_strict = $Perlito5::STRICT;
        $Perlito5::STRICT = 0;
        my $ast = Perlito5::AST::Apply::->new('code' => 'eval', 'namespace' => '', 'arguments' => [Perlito5::AST::Apply::->new('code' => 'do_file', 'namespace' => 'Perlito5::Grammar::Use', 'arguments' => $self->{'arguments'})], '_scope' => Perlito5::Grammar::Scope::->new_base_scope());
        my $js = $ast->emit_java($level, $wantarray);
        $Perlito5::STRICT = $tmp_strict;
        return $js
    }, 'eval' => sub {
        my($self, $level, $wantarray) = @_;
        $Perlito5::THROW = 1;
        my $arg = $self->{'arguments'}->[0];
        my $eval;
        if ($arg->isa('Perlito5::AST::Block')) {
            $eval = Perlito5::AST::Apply::->new('code' => 'do', 'arguments' => [$arg])->emit_java($level + 1, $wantarray)
        }
        else {
            die('Java eval string not yet implemented')
        }
        my $context = Perlito5::Java::to_context($wantarray);
        Perlito5::Java::emit_wrap_java($level, $wantarray, ($context eq 'p5want' ? () : 'var p5want = ' . $context . ';'), 'var r;', 'p5pkg["main"]["v_@"] = "";', 'var p5strict = p5pkg["Perlito5"]["v_STRICT"];', 'p5pkg["Perlito5"]["v_STRICT"] = ' . $Perlito5::STRICT . ';', 'try {', ['r = ' . $eval . ''], '}', 'catch(err) {', ['if ( err instanceof p5_error || err instanceof Error ) {', ['p5pkg["main"]["v_@"] = err;', 'if (p5str(p5pkg["main"]["v_@"]).substr(-1, 1) != "' . chr(92) . 'n") {', ['try {' . '', ['p5pkg["main"]["v_@"] = p5pkg["main"]["v_@"] + "' . chr(92) . 'n" + err.stack + "' . chr(92) . 'n";'], '}', 'catch(err) { }'], '}'], '}', 'else {', ['return(err);'], '}'], '}', 'p5pkg["Perlito5"]["v_STRICT"] = p5strict;', 'return r;')
    }, 'substr' => sub {
        my($self, $level, $wantarray) = @_;
        my $arg = shift(@{$self->{'arguments'}});
        return Perlito5::Java::to_str($arg) . '.substr(' . join(', ', map($_->emit_java($level, 'scalar'), @{$self->{'arguments'}})) . ')'
    }, 'undef' => sub {
        my($self, $level, $wantarray) = @_;
        if ($self->{'arguments'} && @{$self->{'arguments'}}) {
            my $arg = $self->{'arguments'}->[0];
            if (ref($arg) eq 'Perlito5::AST::Var' && $arg->{'sigil'} eq '&') {
                return '(delete p5pkg[' . Perlito5::Java::escape_string(($arg->{'namespace'} || $Perlito5::PKG_NAME)) . '][' . Perlito5::Java::escape_string($arg->{'name'}) . '])'
            }
            $self->{'arguments'} = [];
            return $arg->emit_java_set($self, $level, $wantarray)
        }
        return 'pCx.UNDEF'
    }, 'defined' => sub {
        my($self, $level, $wantarray) = @_;
        my $arg = $self->{'arguments'}->[0];
        my $invocant;
        if (ref($arg) eq 'Perlito5::AST::Apply' && $arg->{'code'} eq 'prefix:<&>') {
            my $arg2 = $arg->{'arguments'}->[0];
            $invocant = 'p5code_lookup_by_name(' . Perlito5::Java::escape_string($Perlito5::PKG_NAME) . ', ' . $arg2->emit_java($level) . ')'
        }
        elsif (ref($arg) eq 'Perlito5::AST::Var' && $arg->{'sigil'} eq '&') {
            $invocant = 'p5pkg[' . Perlito5::Java::escape_string(($arg->{'namespace'} || $Perlito5::PKG_NAME)) . '][' . Perlito5::Java::escape_string($arg->{'name'}) . ']'
        }
        else {
            $invocant = $arg->emit_java($level, 'scalar')
        }
        'new pBool(!' . $invocant . '.is_undef())'
    }, 'shift' => sub {
        my($self, $level, $wantarray) = @_;
        if ($self->{'arguments'} && @{$self->{'arguments'}}) {
            return $self->{'arguments'}->[0]->emit_java($level) . '.shift()'
        }
        return 'List__.shift()'
    }, 'pop' => sub {
        my($self, $level, $wantarray) = @_;
        if ($self->{'arguments'} && @{$self->{'arguments'}}) {
            return $self->{'arguments'}->[0]->emit_java($level) . '.pop()'
        }
        return 'List__.pop()'
    }, 'unshift' => sub {
        my($self, $level, $wantarray) = @_;
        my @arguments = @{$self->{'arguments'}};
        my $v = shift(@arguments);
        return $v->emit_java($level) . '.unshift(' . Perlito5::Java::to_list(\@arguments) . ')'
    }, 'push' => sub {
        my($self, $level, $wantarray) = @_;
        my @arguments = @{$self->{'arguments'}};
        my $v = shift(@arguments);
        return $v->emit_java($level) . '.push(' . Perlito5::Java::to_list(\@arguments) . ')'
    }, 'time' => sub {
        my($self, $level, $wantarray) = @_;
        'pCORE.time(' . Perlito5::Java::to_context($wantarray) . ', ' . Perlito5::Java::to_list($self->{'arguments'}) . ')'
    }, 'sleep' => sub {
        my($self, $level, $wantarray) = @_;
        'pCORE.sleep(' . Perlito5::Java::to_context($wantarray) . ', ' . Perlito5::Java::to_list($self->{'arguments'}) . ')'
    }, 'ref' => sub {
        my($self, $level, $wantarray) = @_;
        'pCORE.ref(' . Perlito5::Java::to_context($wantarray) . ', ' . Perlito5::Java::to_list($self->{'arguments'}) . ')'
    }, 'die' => sub {
        my($self, $level, $wantarray) = @_;
        'pCORE.die(' . Perlito5::Java::to_context($wantarray) . ', ' . Perlito5::Java::to_list($self->{'arguments'}) . ')'
    }, 'tie' => sub {
        my($self, $level, $wantarray) = @_;
        my @arguments = @{$self->{'arguments'}};
        my $v = shift(@arguments);
        my $meth;
        if ($v->isa('Perlito5::AST::Var') && $v->sigil() eq '%') {
            $meth = 'hash'
        }
        elsif ($v->isa('Perlito5::AST::Var') && $v->sigil() eq '@') {
            $meth = 'array'
        }
        elsif ($v->isa('Perlito5::AST::Var') && $v->sigil() eq '$') {
            $meth = 'scalar'
        }
        else {
            die('tie ' . chr(39), ref($v), chr(39) . ' not implemented')
        }
        return 'p5tie_' . $meth . '(' . $v->emit_java($level) . ', ' . Perlito5::Java::to_list(\@arguments) . ')'
    }, 'untie' => sub {
        my($self, $level, $wantarray) = @_;
        my @arguments = @{$self->{'arguments'}};
        my $v = shift(@arguments);
        my $meth;
        if ($v->isa('Perlito5::AST::Var') && $v->sigil() eq '%') {
            $meth = 'hash'
        }
        elsif ($v->isa('Perlito5::AST::Var') && $v->sigil() eq '@') {
            $meth = 'array'
        }
        elsif ($v->isa('Perlito5::AST::Var') && $v->sigil() eq '$') {
            $meth = 'scalar'
        }
        else {
            die('tie ' . chr(39), ref($v), chr(39) . ' not implemented')
        }
        return 'p5untie_' . $meth . '(' . $v->emit_java($level) . ')'
    }, 'print' => sub {
        my($self, $level, $wantarray) = @_;
        my @in = @{$self->{'arguments'}};
        my $fun;
        if ($self->{'special_arg'}) {
            $fun = $self->{'special_arg'}->emit_java($level)
        }
        else {
            $fun = 'pCx.STDOUT'
        }
        my $list = Perlito5::Java::to_list(\@in);
        'pCORE.print(' . Perlito5::Java::to_context($wantarray) . ', ' . $fun . ', ' . $list . ')'
    }, 'say' => sub {
        my($self, $level, $wantarray) = @_;
        my @in = @{$self->{'arguments'}};
        my $fun;
        if ($self->{'special_arg'}) {
            $fun = $self->{'special_arg'}->emit_java($level)
        }
        else {
            $fun = 'pCx.STDOUT'
        }
        my $list = Perlito5::Java::to_list(\@in);
        'pCORE.say(' . Perlito5::Java::to_context($wantarray) . ', ' . $fun . ', ' . $list . ')'
    }, 'printf' => sub {
        my($self, $level, $wantarray) = @_;
        my @in = @{$self->{'arguments'}};
        my $fun;
        if ($self->{'special_arg'}) {
            $fun = $self->{'special_arg'}->emit_java($level)
        }
        else {
            $fun = 'pCx.STDOUT'
        }
        my $list = Perlito5::Java::to_list(\@in);
        'pCORE.printf(' . Perlito5::Java::to_context($wantarray) . ', ' . $fun . ', ' . $list . ')'
    }, 'join' => sub {
        my($self, $level, $wantarray) = @_;
        my @in = @{$self->{'arguments'}};
        my $list = Perlito5::Java::to_list(\@in);
        'pCORE.join(' . Perlito5::Java::to_context($wantarray) . ', ' . $list . ')'
    }, 'values' => sub {
        my($self, $level, $wantarray) = @_;
        'pCORE.values(' . Perlito5::Java::to_context($wantarray) . ', ' . $self->{'arguments'}->[0]->emit_java($level) . ')'
    }, 'keys' => sub {
        my($self, $level, $wantarray) = @_;
        'pCORE.keys(' . Perlito5::Java::to_context($wantarray) . ', ' . $self->{'arguments'}->[0]->emit_java($level) . ')'
    }, 'each' => sub {
        my($self, $level, $wantarray) = @_;
        'pCORE.each(' . Perlito5::Java::to_context($wantarray) . ', ' . $self->{'arguments'}->[0]->emit_java($level) . ')'
    }, 'close' => sub {
        my($self, $level, $wantarray) = @_;
        my @in = @{$self->{'arguments'}};
        my $fun = shift(@in);
        'p5pkg["Perlito5::IO"].close(' . $fun->emit_java($level) . ', [])'
    }, 'open' => sub {
        my($self, $level, $wantarray) = @_;
        my @in = @{$self->{'arguments'}};
        my $fun = shift(@in);
        if (ref($fun) ne 'Perlito5::AST::Apply') {
            return Perlito5::Java::emit_wrap_java($level, $wantarray, $fun->emit_java($level) . ' = CORE.bless([ {file_handle : {id : null}}, "GLOB" ]);', 'return CORE.open(' . Perlito5::Java::to_list($self->{'arguments'}, $level) . ')')
        }
        else {
            $Perlito5::STRICT = 0;
            return 'CORE.open(' . Perlito5::Java::to_list($self->{'arguments'}, $level) . ')'
        }
    }, 'chomp' => sub {
        my($self, $level, $wantarray) = @_;
        my $v = $self->{'arguments'}->[0];
        return Perlito5::Java::emit_wrap_java($level, $wantarray, 'var r = p5chomp(' . $v->emit_java($level) . ');', $v->emit_java($level) . ' = r[1];', 'return r[0]')
    }, 'chop' => sub {
        my($self, $level, $wantarray) = @_;
        my $v = $self->{'arguments'}->[0];
        return Perlito5::Java::emit_wrap_java($level, $wantarray, 'var r = p5chop(' . $v->emit_java($level) . ');', $v->emit_java($level) . ' = r[1];', 'return r[0]')
    }, 'read' => sub {
        my($self, $level, $wantarray) = @_;
        my @in = @{$self->{'arguments'}};
        my $fun = shift(@in);
        my $scalar = shift(@in);
        my $length = shift(@in);
        return Perlito5::Java::emit_wrap_java($level, $wantarray, 'var r = p5pkg["Perlito5::IO"].read(' . $fun->emit_java($level) . ', [' . $length->emit_java($level) . ']);', $scalar->emit_java($level) . ' = r[1];', 'return r[0]')
    }, 'readline' => sub {
        my($self, $level, $wantarray) = @_;
        my @in = @{$self->{'arguments'}};
        my $fun = shift(@in) || bless({'arguments' => [], 'bareword' => 1, 'code' => 'ARGV', 'namespace' => ''}, 'Perlito5::AST::Apply');
        return 'CORE.readline([' . $fun->emit_java($level) . '])'
    }, 'map' => sub {
        my($self, $level, $wantarray) = @_;
        my @in = @{$self->{'arguments'}};
        my $fun;
        if ($self->{'special_arg'}) {
            $fun = $self->{'special_arg'}
        }
        else {
            $fun = shift(@in)
        }
        my $list = Perlito5::Java::to_list(\@in);
        if (ref($fun) eq 'Perlito5::AST::Block') {
            $fun = $fun->{'stmts'}
        }
        else {
            $fun = [$fun]
        }
        my $sub = Perlito5::AST::Sub::->new('block' => Perlito5::AST::Block::->new('stmts' => $fun));
        'PerlOp.map(' . $sub->emit_java($level + 1) . ', ' . $list . ', ' . Perlito5::Java::to_context($wantarray) . ')'
    }, 'grep' => sub {
        my($self, $level, $wantarray) = @_;
        my @in = @{$self->{'arguments'}};
        my $fun;
        if ($self->{'special_arg'}) {
            $fun = $self->{'special_arg'}
        }
        else {
            $fun = shift(@in)
        }
        my $list = Perlito5::Java::to_list(\@in);
        if (ref($fun) eq 'Perlito5::AST::Block') {
            $fun = $fun->{'stmts'}
        }
        else {
            $fun = [$fun]
        }
        my $sub = Perlito5::AST::Sub::->new('block' => Perlito5::AST::Block::->new('stmts' => $fun));
        'PerlOp.grep(' . $sub->emit_java($level + 1) . ', ' . $list . ', ' . Perlito5::Java::to_context($wantarray) . ')'
    }, 'sort' => sub {
        my($self, $level, $wantarray) = @_;
        my @in = @{$self->{'arguments'}};
        my $fun;
        my $list;
        if ($self->{'special_arg'}) {
            $fun = $self->{'special_arg'}
        }
        elsif (ref($in[0]) eq 'Perlito5::AST::Block') {
            $fun = shift(@in)
        }
        if (ref($fun) eq 'Perlito5::AST::Block') {
            $fun = $fun->{'stmts'}
        }
        else {
            die('TODO: sort without block not implemented yet')
        }
        $list = Perlito5::Java::to_list(\@in);
        my $sub = Perlito5::AST::Sub::->new('block' => Perlito5::AST::Block::->new('stmts' => $fun));
        'PerlOp.sort(' . $sub->emit_java($level + 1) . ', ' . $list . ', ' . Perlito5::Java::to_context($wantarray) . ')'
    }, 'infix:<//>' => sub {
        my($self, $level, $wantarray) = @_;
        'PerlOp.defined_or1(' . $self->{'arguments'}->[0]->emit_java($level, 'scalar') . ') ? PerlOp.defined_or2() : ' . $self->{'arguments'}->[1]->emit_java($level, 'scalar') . ''
    }, 'exists' => sub {
        my($self, $level, $wantarray) = @_;
        my $arg = $self->{'arguments'}->[0];
        if ($arg->isa('Perlito5::AST::Lookup')) {
            my $v = $arg->obj();
            if ($v->isa('Perlito5::AST::Var') && $v->sigil() eq '$') {
                return $v->emit_java($level, $wantarray) . '.exists(' . $arg->autoquote($arg->{'index_exp'})->emit_java($level) . ')'
            }
            return $v->emit_java($level, $wantarray, 'hash') . '.exists(' . $arg->autoquote($arg->{'index_exp'})->emit_java($level) . ')'
        }
        if ($arg->isa('Perlito5::AST::Index')) {
            my $v = $arg->obj();
            if ($v->isa('Perlito5::AST::Var') && $v->sigil() eq '$') {
                return $v->emit_java($level, $wantarray) . '.exists(' . $arg->{'index_exp'}->emit_java($level) . ')'
            }
            return $v->emit_java($level, $wantarray, 'array') . '.exists(' . $arg->{'index_exp'}->emit_java($level) . ')'
        }
        if ($arg->isa('Perlito5::AST::Call')) {
            if ($arg->method() eq 'postcircumfix:<{ }>') {
                return $arg->invocant()->emit_java($level, $wantarray, 'hash') . '.exists(' . Perlito5::AST::Lookup::->autoquote($arg->{'arguments'})->emit_java($level) . ')'
            }
            if ($arg->method() eq 'postcircumfix:<[ ]>') {
                return $arg->invocant()->emit_java($level, $wantarray, 'array') . '.exists(' . $arg->{'arguments'}->emit_java($level) . ')'
            }
        }
        if ($arg->isa('Perlito5::AST::Var') && $arg->sigil() eq '&') {
            my $name = $arg->{'name'};
            my $namespace = $arg->{'namespace'} || $Perlito5::PKG_NAME;
            return 'p5pkg[' . Perlito5::Java::escape_string($namespace) . '].hasOwnProperty(' . Perlito5::Java::escape_string($name) . ')'
        }
        if ($arg->isa('Perlito5::AST::Apply') && $arg->{'code'} eq 'prefix:<&>') {
            my $arg2 = $arg->{'arguments'}->[0];
            return 'p5sub_exists(' . Perlito5::Java::to_str($arg2) . ', ' . Perlito5::Java::escape_string($Perlito5::PKG_NAME) . ')'
        }
    }, 'prototype' => sub {
        my($self, $level, $wantarray) = @_;
        my $arg = $self->{'arguments'}->[0];
        return 'p5sub_prototype(' . $arg->emit_java() . ', ' . Perlito5::Java::escape_string($Perlito5::PKG_NAME) . ')'
    }, 'split' => sub {
        my($self, $level, $wantarray) = @_;
        my @js;
        my $arg = $self->{'arguments'}->[0];
        if ($arg && $arg->isa('Perlito5::AST::Apply') && $arg->{'code'} eq 'p5:m') {
            push(@js, 'new RegExp(' . $arg->{'arguments'}->[0]->emit_java() . ', ' . Perlito5::Java::escape_string($arg->{'arguments'}->[1]->{'buf'}) . ')');
            shift(@{$self->{'arguments'}})
        }
        return 'CORE.split(' . '[' . join(', ', @js, map($_->emit_java(), @{$self->{'arguments'}})) . '], ' . Perlito5::Java::to_context($wantarray) . ')'
    });
    sub Perlito5::AST::Apply::emit_java {
        my($self, $level, $wantarray) = @_;
        my $apply = $self->op_assign();
        if ($apply) {
            return $apply->emit_java($level)
        }
        my $apply = $self->op_auto();
        if ($apply) {
            return $apply->emit_java($level)
        }
        my $code = $self->{'code'};
        if (ref($code) ne '') {
            my @args = ();
            push(@args, $_->emit_java())
                for @{$self->{'arguments'}};
            return $self->{'code'}->emit_java($level) . '.apply(' . join(',', @args) . ')'
        }
        exists($emit_js{$code}) && return $emit_js{$code}->($self, $level, $wantarray);
        if (exists($Perlito5::Java::op_prefix_js_str{$code})) {
            return $Perlito5::Java::op_prefix_js_str{$code} . '(' . Perlito5::Java::to_str($self->{'arguments'}->[0]) . ')'
        }
        if ($self->{'namespace'}) {
            if ($self->{'namespace'} eq 'Java' && $code eq 'inline') {
                if ($self->{'arguments'}->[0]->isa('Perlito5::AST::Buf')) {
                    return $self->{'arguments'}->[0]->{'buf'}
                }
                else {
                    die('Java::inline needs a string constant')
                }
            }
            $code = 'pV.get(' . Perlito5::Java::escape_string($self->{'namespace'} . '|' . $code) . ')'
        }
        else {
            $code = 'pV.get(' . Perlito5::Java::escape_string($Perlito5::PKG_NAME . '|' . $code) . ')'
        }
        my $sig;
        my $may_need_autoload;
        {
            my $name = $self->{'code'};
            my $namespace = $self->{'namespace'} || $Perlito5::PKG_NAME;
            my $effective_name = $namespace . '::' . $self->{'code'};
            if (exists($Perlito5::PROTO->{$effective_name})) {
                $sig = $Perlito5::PROTO->{$effective_name}
            }
            elsif ((!$self->{'namespace'} || $namespace eq 'CORE') && exists($Perlito5::CORE_PROTO->{'CORE::' . $name})) {
                $effective_name = 'CORE::' . $name;
                $sig = $Perlito5::CORE_PROTO->{$effective_name}
            }
            else {
                if ($self->{'bareword'}) {
                    if ($Perlito5::STRICT) {
                        die('Bareword ' . Perlito5::Java::escape_string($name) . ' not allowed while "strict subs" in use')
                    }
                    return Perlito5::Java::escape_string(($self->{'namespace'} ? $self->{'namespace'} . '::' : '') . $name)
                }
                $may_need_autoload = 1
            }
            (exists($self->{'proto'})) && ($sig = $self->{'proto'})
        }
        if ($sig) {
            my @out = ();
            my @in = @{$self->{'arguments'} || []};
            my $close = ']';
            my $optional = 0;
            while (length($sig)) {
                my $c = substr($sig, 0, 1);
                if ($c eq ';') {
                    $optional = 1
                }
                elsif ($c eq '$' || $c eq '_') {
                    (@in || !$optional) && push(@out, shift(@in)->emit_java($level + 1, 'scalar'))
                }
                elsif ($c eq '@') {
                    (@in || !$optional) && ($close = '].concat(' . Perlito5::Java::to_list(\@in, $level + 1) . ')');
                    @in = ()
                }
                elsif ($c eq '&') {
                    push(@out, shift(@in)->emit_java($level + 1, 'scalar'))
                }
                elsif ($c eq '*') {
                    if (@in || !$optional) {
                        my $arg = shift(@in);
                        if ($arg->{'bareword'}) {
                            push(@out, Perlito5::Java::escape_string($arg->{'code'}))
                        }
                        else {
                            push(@out, $arg->emit_java($level + 1, 'scalar'))
                        }
                    }
                }
                elsif ($c eq chr(92)) {
                    if (substr($sig, 0, 2) eq chr(92) . '$') {
                        $sig = substr($sig, 1);
                        (@in || !$optional) && push(@out, shift(@in)->emit_java($level + 1, 'scalar'))
                    }
                    elsif (substr($sig, 0, 2) eq chr(92) . '@' || substr($sig, 0, 2) eq chr(92) . '%') {
                        $sig = substr($sig, 1);
                        (@in || !$optional) && push(@out, shift(@in)->emit_java($level + 1, 'list'))
                    }
                    elsif (substr($sig, 0, 5) eq chr(92) . '[@%]') {
                        $sig = substr($sig, 4);
                        (@in || !$optional) && push(@out, shift(@in)->emit_java($level + 1, 'list'))
                    }
                    elsif (substr($sig, 0, 6) eq chr(92) . '[$@%]') {
                        $sig = substr($sig, 5);
                        (@in || !$optional) && push(@out, shift(@in)->emit_java($level + 1, 'list'))
                    }
                }
                $sig = substr($sig, 1)
            }
            return $code . '(' . Perlito5::Java::to_context($wantarray) . ', [' . join(', ', @out) . $close . ')'
        }
        my $arg_list = Perlito5::Java::to_list_preprocess($self->{'arguments'});
        my $arg_code = Perlito5::Java::to_list($arg_list);
        $code . '.apply(' . Perlito5::Java::to_context($wantarray) . ', ' . $arg_code . ')'
    }
    sub Perlito5::AST::Apply::emit_java_set_list {
        my($self, $level, $list) = @_;
        if ($self->code() eq 'undef') {
            return $list . '.shift()'
        }
        if ($self->code() eq 'prefix:<$>') {
            return Perlito5::Java::emit_java_autovivify($self->{'arguments'}->[0], $level + 1, 'scalar') . '.scalar_deref_set(' . $list->emit_java($level + 1, 'scalar') . ')'
        }
        die('not implemented: assign to ', $self->code())
    }
    sub Perlito5::AST::Apply::emit_java_get_decl {
        my $self = shift;
        my $code = $self->{'code'};
        if ($code eq 'my' || $code eq 'our' || $code eq 'state' || $code eq 'local') {
            return (map {
                ref($_) eq 'Perlito5::AST::Var' ? Perlito5::AST::Decl::->new('decl' => $code, 'type' => '', 'var' => $_) : ()
            } @{$self->{'arguments'}})
        }
        if ($code ne 'do' && $code ne 'eval') {
            $self->{'arguments'} && return (map(+($_->emit_java_get_decl()), @{$self->{'arguments'}}))
        }
        return ()
    }
    sub Perlito5::AST::Apply::emit_java_has_regex {
        my $self = shift;
        my $code = $self->{'code'};
        if ($code eq 'p5:m' || $code eq 'p5:s' || $code eq 'infix:<=~>' || $code eq 'infix:<!~>') {
            return 1
        }
        return ()
    }
    sub Perlito5::AST::Apply::emit_java_get_captures {
        my $self = shift;
        my $code = $self->{'code'};
        my @var;
        ref($code) && push(@var, $code->emit_java_get_captures());
        $self->{'arguments'} && push(@var, map {
            $_->emit_java_get_captures()
        } @{$self->{'arguments'}});
        if ($code eq 'my' || $code eq 'our' || $code eq 'state') {
            push(@var, (map {
                ref($_) eq 'Perlito5::AST::Var' ? ({'dont' => $_->{'_id'}}) : ()
            } @{$self->{'arguments'}}))
        }
        return @var
    }
}
package Perlito5::AST::If;
{
    sub Perlito5::AST::If::emit_java {
        my($self, $level, $wantarray) = @_;
        my $cond = $self->{'cond'};
        my @str;
        my $old_level = $level;
        if ($cond) {
            my @var_decl = $cond->emit_java_get_decl();
            for my $arg (@var_decl) {
                $level = $old_level + 1;
                push(@str, $arg->emit_java_init($level, $wantarray))
            }
        }
        my $body = ref($self->{'body'}) ne 'Perlito5::AST::Block' ? $self->{'body'} : (!@{$self->{'body'}->stmts()}) ? undef : $wantarray ne 'void' ? Perlito5::Java::LexicalBlock::->new('block' => $self->{'body'}->stmts()) : Perlito5::Java::LexicalBlock::->new('block' => $self->{'body'}->stmts(), 'create_context' => 1);
        my $otherwise = ref($self->{'otherwise'}) ne 'Perlito5::AST::Block' ? $self->{'otherwise'} : (!@{$self->{'otherwise'}->stmts()}) ? undef : $wantarray ne 'void' ? Perlito5::Java::LexicalBlock::->new('block' => $self->{'otherwise'}->stmts()) : Perlito5::Java::LexicalBlock::->new('block' => $self->{'otherwise'}->stmts(), 'create_context' => 1);
        my $s = 'if (' . Perlito5::Java::to_bool($cond, $level + 1) . ') {';
        if ($body) {
            $s = $s . chr(10) . Perlito5::Java::tab($level + 1) . $body->emit_java($level + 1, $wantarray) . chr(10) . Perlito5::Java::tab($level) . '}'
        }
        else {
            $s = $s . '}'
        }
        if ($otherwise) {
            if (@{$otherwise->{'block'}} == 1 && ref($otherwise->{'block'}->[0]) eq 'Perlito5::AST::If') {
                $s = $s . chr(10) . Perlito5::Java::tab($level) . 'else ' . $otherwise->{'block'}->[0]->emit_java($level, $wantarray)
            }
            else {
                $s = $s . chr(10) . Perlito5::Java::tab($level) . 'else {' . chr(10) . Perlito5::Java::tab($level + 1) . $otherwise->emit_java($level + 1, $wantarray) . chr(10) . Perlito5::Java::tab($level) . '}'
            }
        }
        push(@str, $s);
        if (@str) {
            $level = $old_level;
            return ($wantarray ne 'void' ? 'return ' : '') . Perlito5::Java::emit_wrap_java($level, $wantarray, @str)
        }
        else {
            return join(chr(10) . Perlito5::Java::tab($level), @str)
        }
    }
    sub Perlito5::AST::If::emit_java_get_decl {
        ()
    }
    sub Perlito5::AST::If::emit_java_has_regex {
        ()
    }
    sub Perlito5::AST::If::emit_java_get_captures {
        ()
    }
}
package Perlito5::AST::When;
{
    sub Perlito5::AST::When::emit_java {
        die(chr(39) . 'when' . chr(39) . ' is not implemented')
    }
    sub Perlito5::AST::When::emit_java_get_decl {
        ()
    }
    sub Perlito5::AST::When::emit_java_has_regex {
        ()
    }
    sub Perlito5::AST::When::emit_java_get_captures {
        ()
    }
}
package Perlito5::AST::While;
{
    sub Perlito5::AST::While::emit_java {
        my($self, $level, $wantarray) = @_;
        my $cond = $self->{'cond'};
        my $do_at_least_once = ref($self->{'body'}) eq 'Perlito5::AST::Apply' && $self->{'body'}->{'code'} eq 'do' ? 1 : 0;
        my $body = ref($self->{'body'}) ne 'Perlito5::AST::Block' ? [$self->{'body'}] : $self->{'body'}->{'stmts'};
        my @str;
        my $old_level = $level;
        if ($cond) {
            my @var_decl = $cond->emit_java_get_decl();
            for my $arg (@var_decl) {
                $level = $old_level + 1;
                push(@str, $arg->emit_java_init($level, $wantarray))
            }
        }
        my $expression;
        if (Perlito5::Java::is_native($cond)) {
            $expression = Perlito5::Java::to_native_args([$cond], $level + 1)
        }
        else {
            $expression = Perlito5::Java::to_bool($cond, $level + 1)
        }
        push(@str, 'while (' . $expression . ') ' . '{' . chr(10) . Perlito5::Java::tab($level + 2) . (Perlito5::Java::LexicalBlock::->new('block' => $body))->emit_java($level + 2, $wantarray) . chr(10) . Perlito5::Java::tab($level + 1) . '}');
        if (@str) {
            $level = $old_level;
            return Perlito5::Java::emit_wrap_java($level, $wantarray, @str)
        }
        else {
            return join(chr(10) . Perlito5::Java::tab($level), @str)
        }
    }
    sub Perlito5::AST::While::emit_java_get_decl {
        ()
    }
    sub Perlito5::AST::While::emit_java_has_regex {
        ()
    }
    sub Perlito5::AST::While::emit_java_get_captures {
        ()
    }
}
package Perlito5::AST::For;
{
    sub Perlito5::AST::For::emit_java {
        my($self, $level, $wantarray) = @_;
        my $body = ref($self->{'body'}) ne 'Perlito5::AST::Block' ? [$self->{'body'}] : $self->{'body'}->{'stmts'};
        my @str;
        my $old_level = $level;
        my $cond = ref($self->{'cond'}) eq 'ARRAY' ? $self->{'cond'} : [$self->{'cond'}];
        for my $expr (@{$cond}, $self->{'topic'}) {
            if ($expr) {
                my @var_decl = $expr->emit_java_get_decl();
                for my $arg (@var_decl) {
                    $level = $old_level + 1;
                    push(@str, $arg->emit_java_init($level, $wantarray))
                }
            }
        }
        if (ref($self->{'cond'}) eq 'ARRAY') {
            push(@str, Perlito5::Java::emit_wrap_java($level, $wantarray, 'var label = ' . Perlito5::Java::escape_string(($self->{'label'} || '')) . ';', 'for ( ' . ($self->{'cond'}->[0] ? $self->{'cond'}->[0]->emit_java($level + 1) . '; ' : '; ') . ($self->{'cond'}->[1] ? Perlito5::Java::to_bool($self->{'cond'}->[1], $level + 1) . '; ' : '; ') . ($self->{'cond'}->[2] ? $self->{'cond'}->[2]->emit_java($level + 1) . ' ' : '') . ') {', ['var _redo = true;', 'while(_redo) {', ['_redo = false;', 'try {', [Perlito5::Java::LexicalBlock::->new('block' => $body)->emit_java($level + 4, $wantarray)], '}', 'catch(err) {', ['if (err instanceof p5_error && (err.v == label || err.v == ' . chr(39) . chr(39) . ')) {', ['if (err.type == ' . chr(39) . 'last' . chr(39) . ') { return }', 'else if (err.type == ' . chr(39) . 'redo' . chr(39) . ') { _redo = true }', 'else if (err.type != ' . chr(39) . 'next' . chr(39) . ') { throw(err) }'], '}', 'else {', ['throw(err)'], '}'], '}'], '}'], '}'))
        }
        else {
            my $cond = Perlito5::Java::to_list([$self->{'cond'}], $level + 1);
            my $topic = $self->{'topic'};
            my $decl = '';
            my $v = $topic;
            if ($v->{'decl'}) {
                $decl = $v->{'decl'};
                $v = $v->{'var'}
            }
            else {
                $decl = $v->{'_decl'} || 'global'
            }
            my $namespace = $v->{'namespace'} || $v->{'_namespace'} || $Perlito5::PKG_NAME;
            my $s;
            if ($decl eq 'my' || $decl eq 'state') {
                my $sig = $v->emit_java($level + 1);
                push(@str, 'p5for_lex(' . 'function (' . $sig . ') {' . chr(10) . Perlito5::Java::tab($level + 2) . (Perlito5::Java::LexicalBlock::->new('block' => $body))->emit_java($level + 2, $wantarray) . chr(10) . Perlito5::Java::tab($level + 1) . '}, ' . $cond . ', ' . Perlito5::AST::Block::emit_java_continue($self, $level, $wantarray) . ', ' . Perlito5::Java::escape_string($self->{'label'} || '') . ')')
            }
            else {
                push(@str, 'p5for(' . 'p5make_package(' . Perlito5::Java::escape_string($namespace) . '), ' . '"v_' . $v->{'name'} . '", ' . 'function () {' . chr(10) . Perlito5::Java::tab($level + 2) . (Perlito5::Java::LexicalBlock::->new('block' => $body))->emit_java($level + 2, $wantarray) . chr(10) . Perlito5::Java::tab($level + 1) . '}, ' . $cond . ', ' . Perlito5::AST::Block::emit_java_continue($self, $level, $wantarray) . ', ' . Perlito5::Java::escape_string($self->{'label'} || '') . ')')
            }
        }
        if (@str > 1) {
            $level = $old_level;
            return Perlito5::Java::emit_wrap_java($level, $wantarray, @str)
        }
        else {
            return join(chr(10) . Perlito5::Java::tab($level), @str)
        }
    }
    sub Perlito5::AST::For::emit_java_get_decl {
        ()
    }
    sub Perlito5::AST::For::emit_java_has_regex {
        ()
    }
    sub Perlito5::AST::For::emit_java_get_captures {
        ()
    }
}
package Perlito5::AST::Sub;
{
    sub Perlito5::AST::Sub::emit_java {
        my($self, $level, $wantarray) = @_;
        my $prototype = defined($self->{'sig'}) ? 'new pString(' . Perlito5::Java::escape_string($self->{'sig'}) . ')' : 'pCx.UNDEF';
        my $sub_ref = Perlito5::Java::get_label();
        local $Perlito5::AST::Sub::SUB_REF = $sub_ref;
        my $block = Perlito5::Java::LexicalBlock::->new('block' => $self->{'block'}->{'stmts'});
        my @captured = $block->emit_java_get_captures();
        my %dont_capture = map {
            $_->{'dont'} ? ($_->{'dont'} => 1) : ()
        } @captured;
        my %capture = map {
            $_->{'dont'} ? () : $dont_capture{$_->{'_id'}} ? () : ($_->{'_decl'} eq 'local' || $_->{'_decl'} eq 'global' || $_->{'_decl'} eq '') ? () : ($_->{'_id'} => $_)
        } @captured;
        my @captures_ast = values(%capture);
        my @captures_java = map {
            $_->emit_java($level, 'list')
        } @captures_ast;
        local %Perlito5::Java::Java_var_name;
        my $i = 0;
        for $_ (@captures_ast) {
            $Perlito5::Java::Java_var_name{$_->{'_id'}} = 'this.env[' . $i . ']';
            $i++
        }
        my $js_block = $block->emit_java_subroutine_body($level + 3, 'runtime');
        my $s = Perlito5::Java::emit_wrap_java($level, 'scalar', 'new pClosure(' . $prototype . ', new pObject[]{ ' . join(', ', @captures_java) . ' } ) {', ['public pObject apply(int want, pArray List__) {', [$js_block], '}'], '}');
        if ($self->{'name'}) {
            return 'pV.set(' . Perlito5::Java::escape_string($self->{'namespace'} . '|' . $self->{'name'}) . ', ' . $s . ')'
        }
        else {
            return $s
        }
    }
    sub Perlito5::AST::Sub::emit_java_get_decl {
        ()
    }
    sub Perlito5::AST::Sub::emit_java_has_regex {
        ()
    }
    sub Perlito5::AST::Sub::emit_java_get_captures {
        $_[0]->{'block'}->emit_java_get_captures()
    }
}
package Perlito5::AST::Use;
{
    sub Perlito5::AST::Use::emit_java {
        my($self, $level, $wantarray) = @_;
        Perlito5::Grammar::Use::emit_time_eval($self);
        if ($wantarray ne 'void') {
            return 'pCx.UNDEF'
        }
        else {
            return '// ' . $self->{'code'} . ' ' . $self->{'mod'} . chr(10)
        }
    }
    sub Perlito5::AST::Use::emit_java_get_decl {
        ()
    }
    sub Perlito5::AST::Use::emit_java_has_regex {
        ()
    }
    sub Perlito5::AST::Use::emit_java_get_captures {
        ()
    }
}
# use Perlito5::Java::Emitter
package main;
undef();
package Perlito5::Java::Runtime;
sub Perlito5::Java::Runtime::emit_java {
    my($self, %args) = @_;
    my %java_classes = %{$args{'java_classes'} // {}};
    my %number_binop = ('add' => {'op' => '+', 'returns' => 'pInt', 'num_returns' => 'pDouble'}, 'sub' => {'op' => '-', 'returns' => 'pInt', 'num_returns' => 'pDouble'}, 'mul' => {'op' => '*', 'returns' => 'pInt', 'num_returns' => 'pDouble'}, 'div' => {'op' => '/', 'returns' => 'pDouble', 'num_returns' => 'pDouble'}, 'num_eq' => {'op' => '==', 'returns' => 'pBool', 'num_returns' => 'pBool'}, 'num_ne' => {'op' => '!=', 'returns' => 'pBool', 'num_returns' => 'pBool'}, 'num_lt' => {'op' => '<', 'returns' => 'pBool', 'num_returns' => 'pBool'}, 'num_le' => {'op' => '<=', 'returns' => 'pBool', 'num_returns' => 'pBool'}, 'num_gt' => {'op' => '>', 'returns' => 'pBool', 'num_returns' => 'pBool'}, 'num_ge' => {'op' => '>=', 'returns' => 'pBool', 'num_returns' => 'pBool'});
    my %string_binop = ('str_eq' => {'op' => '== 0', 'returns' => 'pBool'}, 'str_ne' => {'op' => '!= 0', 'returns' => 'pBool'}, 'str_lt' => {'op' => '< 0', 'returns' => 'pBool'}, 'str_le' => {'op' => '<= 0', 'returns' => 'pBool'}, 'str_gt' => {'op' => '> 0', 'returns' => 'pBool'}, 'str_ge' => {'op' => '>= 0', 'returns' => 'pBool'});
    my %native_to_perl = ('int' => 'pInt', 'double' => 'pDouble', 'boolean' => 'pBool', 'String' => 'pString');
    for $_ (values(%java_classes)) {
        $native_to_perl{$_->{'java_type'}} = $_->{'java_native_to_perl'}
    }
    return '// start Perl-Java runtime' . chr(10) . '// this is generated code - see: lib/Perlito5/Java/Runtime.pm' . chr(10) . chr(10) . 'import java.lang.Math;' . chr(10) . 'import java.lang.System;' . chr(10) . 'import java.util.ArrayList;' . chr(10) . 'import java.util.HashMap;' . chr(10) . 'import java.util.Map;' . chr(10) . 'import java.util.Iterator;' . chr(10) . 'import java.util.Comparator;' . chr(10) . 'import java.util.Collections;' . chr(10) . 'import java.util.regex.Pattern;' . chr(10) . 'import java.util.regex.Matcher;' . chr(10) . 'import java.util.concurrent.TimeUnit;' . chr(10) . join('', (map {
        my $class = $_;
        $class->{'import'} ? 'import ' . $class->{'import'} . ';' . chr(10) : ()
    } values(%java_classes))) . 'class pControlException extends RuntimeException {' . chr(10) . '}' . chr(10) . 'class pNextException    extends pControlException {' . chr(10) . '    public int label_id;' . chr(10) . chr(10) . '    public pNextException(int i) {' . chr(10) . '        this.label_id = i;' . chr(10) . '    }' . chr(10) . '}' . chr(10) . 'class pLastException    extends pControlException {' . chr(10) . '    public int label_id;' . chr(10) . chr(10) . '    public pLastException(int i) {' . chr(10) . '        this.label_id = i;' . chr(10) . '    }' . chr(10) . '}' . chr(10) . 'class pRedoException    extends pControlException {' . chr(10) . '    public int label_id;' . chr(10) . chr(10) . '    public pRedoException(int i) {' . chr(10) . '        this.label_id = i;' . chr(10) . '    }' . chr(10) . '}' . chr(10) . 'class pReturnException  extends pControlException {' . chr(10) . '    public pObject ret;' . chr(10) . chr(10) . '    public pReturnException(pObject ret) {' . chr(10) . '        this.ret = ret;' . chr(10) . '    }' . chr(10) . '}' . chr(10) . 'class pCx {' . chr(10) . '    public static final int     VOID   = 0;' . chr(10) . '    public static final int     SCALAR = 1;' . chr(10) . '    public static final int     LIST   = 2;' . chr(10) . '    public static final pUndef  UNDEF  = new pUndef();' . chr(10) . '    public static final pBool   TRUE   = new pBool(true);' . chr(10) . '    public static final pBool   FALSE  = new pBool(false);' . chr(10) . '    public static final pString STDOUT = new pString("STDOUT");' . chr(10) . '    public static final pString STDERR = new pString("STDERR");' . chr(10) . '    public static final pString STDIN  = new pString("STDIN");' . chr(10) . '    ' . join(chr(10) . '    ', @{$args{'java_constants'} // []}) . chr(10) . '}' . chr(10) . 'class pCORE {' . chr(10) . '    public static final pObject print(int want, pObject filehandle, pArray List__) {' . chr(10) . '        // TODO - write to filehandle' . chr(10) . '        for (int i = 0; i < List__.to_int(); i++) {' . chr(10) . '            System.out.print(List__.aget(i).to_string());' . chr(10) . '        }' . chr(10) . '        return new pInt(1);' . chr(10) . '    }' . chr(10) . '    public static final pObject say(int want, pObject filehandle, pArray List__) {' . chr(10) . '        // TODO - write to filehandle' . chr(10) . '        for (int i = 0; i < List__.to_int(); i++) {' . chr(10) . '            System.out.print(List__.aget(i).to_string());' . chr(10) . '        }' . chr(10) . '        System.out.println("");' . chr(10) . '        return new pInt(1);' . chr(10) . '    }' . chr(10) . '    public static final pObject say(String s) {' . chr(10) . '        // say() shortcut' . chr(10) . '        return pCORE.say(pCx.VOID, pCx.STDOUT, new pArray(new pString(s)));' . chr(10) . '    }' . chr(10) . '    public static final pObject die(int want, pArray List__) {' . chr(10) . '        for (int i = 0; i < List__.to_int(); i++) {' . chr(10) . '            System.err.print(List__.aget(i).to_string());' . chr(10) . '        }' . chr(10) . '        System.err.println("");' . chr(10) . '        throw new RuntimeException();' . chr(10) . '    }' . chr(10) . '    public static final pObject die(String s) {' . chr(10) . '        // die() shortcut' . chr(10) . '        return pCORE.die(pCx.VOID, new pArray(new pString(s)));' . chr(10) . '    }' . chr(10) . '    public static final pObject ref(int want, pArray List__) {' . chr(10) . '        return List__.aget(0).ref();' . chr(10) . '    }' . chr(10) . '    public static final pObject values(int want, pObject List__) {' . chr(10) . '        return want == pCx.LIST ? List__.values() : List__.values().scalar();' . chr(10) . '    }' . chr(10) . '    public static final pObject keys(int want, pObject List__) {' . chr(10) . '        return want == pCx.LIST ? List__.keys() : List__.keys().scalar();' . chr(10) . '    }' . chr(10) . '    public static final pObject each(int want, pObject List__) {' . chr(10) . '        return want == pCx.LIST ? List__.each() : List__.each().aget(0);' . chr(10) . '    }' . chr(10) . '    public static final pObject scalar(int want, pArray List__) {' . chr(10) . '        if (List__.to_int() == 0) {' . chr(10) . '            return pCx.UNDEF;' . chr(10) . '        }' . chr(10) . '        return List__.aget(-1).scalar();' . chr(10) . '    }' . chr(10) . '    public static final pObject join(int want, pArray List__) {' . chr(10) . '        String s = List__.shift().to_string();' . chr(10) . '        StringBuilder sb = new StringBuilder();' . chr(10) . '        boolean first = true;' . chr(10) . '        for (int i = 0; i < List__.to_int(); i++) {' . chr(10) . '            String item = List__.aget(i).to_string();' . chr(10) . '            if (first)' . chr(10) . '                first = false;' . chr(10) . '            else' . chr(10) . '                sb.append(s);' . chr(10) . '            sb.append(item);' . chr(10) . '        }' . chr(10) . '        return new pString(sb.toString());' . chr(10) . '    }' . chr(10) . '    public static final pObject time(int want, pArray List__) {' . chr(10) . '        return new pDouble( System.currentTimeMillis() * 0.001 );' . chr(10) . '    }' . chr(10) . '    public static final pObject sleep(int want, pArray List__) {' . chr(10) . '        long s = (new Double(List__.shift().to_double() * 1000)).longValue();' . chr(10) . '        try {' . chr(10) . '            TimeUnit.MILLISECONDS.sleep(s);' . chr(10) . '        } catch (InterruptedException e) {' . chr(10) . '            //Handle exception' . chr(10) . '        }' . chr(10) . '        return new pDouble(s / 1000.0);' . chr(10) . '    }' . chr(10) . '}' . chr(10) . 'class PerlCompare implements Comparator<pObject> {' . chr(10) . '    public pClosure sorter;' . chr(10) . '    public PerlCompare (pClosure sorter) {' . chr(10) . '        this.sorter = sorter;' . chr(10) . '    }' . chr(10) . '    public int compare (pObject a, pObject b) {' . chr(10) . '        pV.set("main|v_a", a);' . chr(10) . '        pV.set("main|v_b", b);' . chr(10) . '        return this.sorter.apply( pCx.SCALAR, new pArray() ).to_int();' . chr(10) . '    }' . chr(10) . '}' . chr(10) . 'class PerlOp {' . chr(10) . '    // PerlOp implements operators: && || ' . chr(10) . '    //      and auxiliary functions' . chr(10) . '    //' . chr(10) . '    // note: ' . chr(39) . '+' . chr(39) . ' add() and ' . chr(39) . '-' . chr(39) . ' sub() are pObject methods, not implemented here.' . chr(10) . '    //' . chr(10) . '    // TODO - ' . chr(39) . 'stack' . chr(39) . ' should be reset when an exception happens' . chr(10) . '    // TODO - see Perlito5/Javascript2/Runtime.pm for more operator implementations' . chr(10) . chr(10) . '    private static ArrayList<pObject> stack = new ArrayList<pObject>();' . chr(10) . chr(10) . '    // context()' . chr(10) . '    //      - handles run-time scalar/list/void context in expression results' . chr(10) . '    public static final pObject context(int want, pObject arg) {' . chr(10) . '        if (want == pCx.LIST) {' . chr(10) . '            return arg;' . chr(10) . '        }' . chr(10) . '        return arg.scalar();' . chr(10) . '    }' . chr(10) . '    public static final pObject context(int want) {' . chr(10) . '        if (want == pCx.LIST) {' . chr(10) . '            return new pArray();' . chr(10) . '        }' . chr(10) . '        return pCx.UNDEF;' . chr(10) . '    }' . chr(10) . chr(10) . '    // statement()' . chr(10) . '    //      - workaround for "Error: not a statement"' . chr(10) . '    //      - this is the compile-time version of context(null, arg)' . chr(10) . '    public static final void statement(pObject arg) { }' . chr(10) . '    public static final void statement() { }' . chr(10) . chr(10) . '    // control-flow exceptions' . chr(10) . '    public static final pObject next(int label_id) {' . chr(10) . '        throw new pNextException(label_id);' . chr(10) . '    }' . chr(10) . '    public static final pObject last(int label_id) {' . chr(10) . '        throw new pLastException(label_id);' . chr(10) . '    }' . chr(10) . '    public static final pObject redo(int label_id) {' . chr(10) . '        throw new pRedoException(label_id);' . chr(10) . '    }' . chr(10) . '    public static final pObject ret(pObject ret) {' . chr(10) . '        throw new pReturnException(ret);' . chr(10) . '    }' . chr(10) . chr(10) . '    // and1(x) ? y : and3()' . chr(10) . '    public static final boolean and1(pObject arg1) {' . chr(10) . '        if (arg1.to_bool()) {' . chr(10) . '            return true;' . chr(10) . '        }' . chr(10) . '        else {' . chr(10) . '            stack.add(0, arg1);' . chr(10) . '            return false;' . chr(10) . '        }' . chr(10) . '    }' . chr(10) . '    public static final pObject and3() {' . chr(10) . '        return stack.remove(0);' . chr(10) . '    }' . chr(10) . chr(10) . '    // or1(x) ? or2() : y' . chr(10) . '    public static final boolean or1(pObject arg1) {' . chr(10) . '        if (arg1.to_bool()) {' . chr(10) . '            stack.add(0, arg1);' . chr(10) . '            return true;' . chr(10) . '        }' . chr(10) . '        else {' . chr(10) . '            return false;' . chr(10) . '        }' . chr(10) . '    }' . chr(10) . '    public static final pObject or2() {' . chr(10) . '        return stack.remove(0);' . chr(10) . '    }' . chr(10) . chr(10) . '    // defined_or1(x) ? defined_or2() : y' . chr(10) . '    public static final boolean defined_or1(pObject arg1) {' . chr(10) . '        if (!arg1.is_undef()) {' . chr(10) . '            stack.add(0, arg1);' . chr(10) . '            return true;' . chr(10) . '        }' . chr(10) . '        else {' . chr(10) . '            return false;' . chr(10) . '        }' . chr(10) . '    }' . chr(10) . '    public static final pObject defined_or2() {' . chr(10) . '        return stack.remove(0);' . chr(10) . '    }' . chr(10) . chr(10) . '    // $x++ when $x is pString' . chr(10) . '    public static final String string_increment(String s) {' . chr(10) . '        if (s.length() < 2) {' . chr(10) . '            final int c = s.codePointAt(0);' . chr(10) . '            if ((c >= ' . chr(39) . '0' . chr(39) . ' && c <= ' . chr(39) . '8' . chr(39) . ') || (c >= ' . chr(39) . 'A' . chr(39) . ' && c <= ' . chr(39) . 'Y' . chr(39) . ') || (c >= ' . chr(39) . 'a' . chr(39) . ' && c <= ' . chr(39) . 'y' . chr(39) . ')) {' . chr(10) . '                return "" + Character.toChars(c + 1)[0];' . chr(10) . '            }' . chr(10) . '            if (c == ' . chr(39) . '9' . chr(39) . ') {' . chr(10) . '                return "10";' . chr(10) . '            }' . chr(10) . '            if (c == ' . chr(39) . 'Z' . chr(39) . ') {' . chr(10) . '                return "AA";' . chr(10) . '            }' . chr(10) . '            if (c == ' . chr(39) . 'z' . chr(39) . ') {' . chr(10) . '                return "aa";' . chr(10) . '            }' . chr(10) . '            return "1";' . chr(10) . '        }' . chr(10) . '        String c = string_increment(s.substring(s.length()-1, s.length()));' . chr(10) . '        if (c.length() == 1) {' . chr(10) . '            return s.substring(0, s.length()-1) + c;' . chr(10) . '        }' . chr(10) . '        return string_increment(s.substring(0, s.length()-1)) + c.substring(c.length()-1, c.length());' . chr(10) . '    }' . chr(10) . chr(10) . '    public static final pString string_replicate(pObject s, pObject c) {' . chr(10) . '        int count = c.to_int();' . chr(10) . '        if ( count < 1 ) {' . chr(10) . '            return new pString("");' . chr(10) . '        }' . chr(10) . '        else {' . chr(10) . '            String raw_s = s.to_string();' . chr(10) . '            StringBuilder sb = new StringBuilder();' . chr(10) . '            for (int i = 0; i < count; i++) {' . chr(10) . '                sb.append(raw_s);' . chr(10) . '            }' . chr(10) . '            return new pString(sb.toString());' . chr(10) . '        }' . chr(10) . '    }' . chr(10) . '    public static final pObject list_replicate(pArray o, pObject c, int wantarray) {' . chr(10) . '        int count = c.to_int();' . chr(10) . '        pArray a = new pArray();' . chr(10) . '        if (count > 0) {' . chr(10) . '            for (int i = 0; i < count; i++) {' . chr(10) . '                a.push( o );' . chr(10) . '            }' . chr(10) . '        }' . chr(10) . '        return (wantarray == pCx.LIST ) ? a : a.length_of_array();' . chr(10) . '    }' . chr(10) . '    public static final pObject grep(pClosure c, pArray a, int wantarray) {' . chr(10) . '        pArray ret = new pArray();' . chr(10) . '        int size = a.to_int();' . chr(10) . '        pObject underline = pV.get("main|v__");' . chr(10) . '        for (int i = 0; i < size; i++) {' . chr(10) . '            boolean result;' . chr(10) . '            pObject temp = a.aget(i);' . chr(10) . '            pV.set("main|v__", temp);' . chr(10) . '            result = c.apply(pCx.SCALAR, new pArray()).to_bool();' . chr(10) . '            if (result) {' . chr(10) . '                ret.push(temp);' . chr(10) . '            }' . chr(10) . '        }' . chr(10) . '        pV.set("main|v__", underline);' . chr(10) . '        return (wantarray == pCx.LIST ) ? ret : ret.length_of_array();' . chr(10) . '    }' . chr(10) . '    public static final pObject map(pClosure c, pArray a, int wantarray) {' . chr(10) . '        pArray ret = new pArray();' . chr(10) . '        int size = a.to_int();' . chr(10) . '        pObject underline = pV.get("main|v__");' . chr(10) . '        for (int i = 0; i < size; i++) {' . chr(10) . '            pV.set("main|v__", a.aget(i));' . chr(10) . '            ret.push(c.apply(pCx.LIST, new pArray()));' . chr(10) . '        }' . chr(10) . '        pV.set("main|v__", underline);' . chr(10) . '        return (wantarray == pCx.LIST ) ? ret : ret.length_of_array();' . chr(10) . '    }' . chr(10) . '    public static final pObject sort(pClosure c, pArray a, int wantarray) {' . chr(10) . '        pArray ret = new pArray(a);' . chr(10) . '        int size = a.to_int();' . chr(10) . '        PerlCompare comp = new PerlCompare(c);' . chr(10) . '        pObject sort_a = pV.get("main|v_a");' . chr(10) . '        pObject sort_b = pV.get("main|v_b");' . chr(10) . '        Collections.sort(ret.a, comp);' . chr(10) . '        pV.set("main|v_a", sort_a);' . chr(10) . '        pV.set("main|v_b", sort_b);' . chr(10) . '        return (wantarray == pCx.LIST ) ? ret : ret.length_of_array();' . chr(10) . '    }' . chr(10) . '    public static final pObject match(pObject s, pRegex pat, int want) {' . chr(10) . '        if (want != pCx.LIST) {' . chr(10) . '            return pat.p.matcher(s.to_string()).find() ? pCx.TRUE : pCx.FALSE;' . chr(10) . '        }' . chr(10) . '        pCORE.die("not implemented string match in list context");' . chr(10) . '        return s;' . chr(10) . '    }' . chr(10) . '    public static final pObject match(pObject s, pLvalue pat, int want) {' . chr(10) . '        return match(s, pat.get(), want);' . chr(10) . '    }' . chr(10) . '    public static final pObject match(pObject s, pObject pat, int want) {' . chr(10) . '        // TODO - cache the compiled pattern' . chr(10) . '        return match(s, new pRegex(pat, 0), want);' . chr(10) . '    }' . chr(10) . chr(10) . '    public static final pObject replace(pLvalue s, pRegex pat, pObject rep, int want) {' . chr(10) . '        if (want != pCx.LIST) {' . chr(10) . '            return s.set(new pString(pat.p.matcher(s.to_string()).replaceAll(rep.to_string())));' . chr(10) . '        }' . chr(10) . '        pCORE.die("not implemented string replace in list context");' . chr(10) . '        return s;' . chr(10) . '    }' . chr(10) . '    public static final pObject replace(pObject s, pObject pat, pObject rep, int want) {' . chr(10) . '        // TODO - cache the compiled pattern' . chr(10) . '        return replace(s, new pRegex(pat, 0), rep, want);' . chr(10) . '    }' . chr(10) . chr(10) . '}' . chr(10) . 'class pV {' . chr(10) . '    // pV implements namespaces and global variables' . chr(10) . '    //' . chr(10) . '    // TODO - import CORE subroutines in new namespaces, if needed' . chr(10) . '    // TODO - cache lookups in lexical variables (see pClosure implementation)' . chr(10) . chr(10) . '    public static final String ARGV = "main|List_ARGV";' . chr(10) . chr(10) . '    public static final pHash var = new pHash();' . chr(10) . chr(10) . '    public static final pObject get(String name) {' . chr(10) . '        return var.hget_lvalue(name);' . chr(10) . '    }' . chr(10) . '    public static final pObject set(String name, pObject v) {' . chr(10) . '        return var.hset(name, v);' . chr(10) . '    }' . chr(10) . chr(10) . '    public static final pObject hash_get(String name) {' . chr(10) . '        return var.hget_hashref(name).get();' . chr(10) . '    }' . chr(10) . '    public static final pObject hash_set(String name, pObject v) {' . chr(10) . '        return var.hget_hashref(name).hash_deref_set(v);' . chr(10) . '    }' . chr(10) . chr(10) . '    public static final pObject array_get(String name) {' . chr(10) . '        return var.hget_arrayref(name).get();' . chr(10) . '    }' . chr(10) . '    public static final pObject array_set(String name, pObject v) {' . chr(10) . '        return var.hget_arrayref(name).array_deref_set(v);' . chr(10) . '    }' . chr(10) . '}' . chr(10) . 'class pEnv {' . chr(10) . '    public static final void init(String[] args) {' . chr(10) . '        pV.array_set(pV.ARGV, new pArray(args));' . chr(10) . '        pV.set("main|v_" + (char)34, new pString(" "));   // $" = " "' . chr(10) . '    }' . chr(10) . '}' . chr(10) . 'class pObject {' . chr(10) . '    // extends java object ???' . chr(10) . '    public static final pString REF = new pString("");' . chr(10) . chr(10) . '    public pObject() {' . chr(10) . '    }' . chr(10) . join('', (map {
        my $class = $_;
        my $java_class_name = $class->{'java_type'};
        my $perl_to_java = $class->{'perl_to_java'};
        $class->{'import'} ? '    public ' . $java_class_name . ' ' . $perl_to_java . '() {' . chr(10) . '        pCORE.die("error .' . $perl_to_java . '!");' . chr(10) . '        return null;' . chr(10) . '    }' . chr(10) : ()
    } values(%java_classes))) . '    public String to_string() {' . chr(10) . '        return this.toString();' . chr(10) . '    }' . chr(10) . '    public int to_int() {' . chr(10) . '        pCORE.die("error .to_int!");' . chr(10) . '        return 0;' . chr(10) . '    }' . chr(10) . '    public pObject end_of_array_index() {' . chr(10) . '        return pCORE.die("Not an ARRAY reference");' . chr(10) . '    }' . chr(10) . '    public double to_double() {' . chr(10) . '        pCORE.die("error .to_double!");' . chr(10) . '        return 0.0;' . chr(10) . '    }' . chr(10) . '    public boolean to_bool() {' . chr(10) . '        pCORE.die("error .to_bool!");' . chr(10) . '        return true;' . chr(10) . '    }' . chr(10) . '    public boolean is_undef() {' . chr(10) . '        return false;' . chr(10) . '    }' . chr(10) . '    public pObject apply(int want, pArray List__) {' . chr(10) . '        // $ perl -e ' . chr(39) . ' $a = 5; $a->() ' . chr(39) . chr(10) . '        // Undefined subroutine &main::5 called' . chr(10) . '        pCORE.die("subroutine call error");' . chr(10) . '        return this;' . chr(10) . '    }' . chr(10) . chr(10) . '    public pObject get_arrayref() {' . chr(10) . '        return pCORE.die("Not an ARRAY reference");' . chr(10) . '    }' . chr(10) . chr(10) . '    public pObject shift() {' . chr(10) . '        return pCORE.die("Not an ARRAY reference");' . chr(10) . '    }' . chr(10) . chr(10) . '    public pObject get_hashref() {' . chr(10) . '        return pCORE.die("Not a HASH reference");' . chr(10) . '    }' . chr(10) . chr(10) . '    public pObject hget_scalarref(pObject i) {' . chr(10) . '        pCORE.die("Not a SCALAR reference");' . chr(10) . '        return this;' . chr(10) . '    }' . chr(10) . '    public pObject hget_scalarref(String i) {' . chr(10) . '        pCORE.die("Not a SCALAR reference");' . chr(10) . '        return this;' . chr(10) . '    }' . chr(10) . '    public pObject scalar_deref_set(pObject v) {' . chr(10) . '        pCORE.die("Not a SCALAR reference");' . chr(10) . '        return this;' . chr(10) . '    }' . chr(10) . '    public pObject aget_scalarref(pObject i) {' . chr(10) . '        pCORE.die("Not a SCALAR reference");' . chr(10) . '        return this;' . chr(10) . '    }' . chr(10) . '    public pObject aget_scalarref(int i) {' . chr(10) . '        pCORE.die("Not a SCALAR reference");' . chr(10) . '        return this;' . chr(10) . '    }' . chr(10) . chr(10) . '    public pObject array_deref() {' . chr(10) . '        pCORE.die("Not an ARRAY reference");' . chr(10) . '        return this;' . chr(10) . '    }' . chr(10) . '    public pObject array_deref_set(pObject i) {' . chr(10) . '        pCORE.die("Not an ARRAY reference");' . chr(10) . '        return this;' . chr(10) . '    }' . chr(10) . chr(10) . '    public pObject hget_arrayref(pObject i) {' . chr(10) . '        pCORE.die("Not a HASH reference");' . chr(10) . '        return this;' . chr(10) . '    }' . chr(10) . '    public pObject hget_arrayref(String i) {' . chr(10) . '        pCORE.die("Not a HASH reference");' . chr(10) . '        return this;' . chr(10) . '    }' . chr(10) . '    public pObject hget_hashref(pObject i) {' . chr(10) . '        pCORE.die("Not a HASH reference");' . chr(10) . '        return this;' . chr(10) . '    }' . chr(10) . '    public pObject hget_hashref(String i) {' . chr(10) . '        pCORE.die("Not a HASH reference");' . chr(10) . '        return this;' . chr(10) . '    }' . chr(10) . chr(10) . '    public pObject aget_arrayref(pObject i) {' . chr(10) . '        pCORE.die("Not an ARRAY reference");' . chr(10) . '        return this;' . chr(10) . '    }' . chr(10) . '    public pObject aget_arrayref(int i) {' . chr(10) . '        pCORE.die("Not an ARRAY reference");' . chr(10) . '        return this;' . chr(10) . '    }' . chr(10) . '    public pObject aget_hashref(pObject i) {' . chr(10) . '        pCORE.die("Not an ARRAY reference");' . chr(10) . '        return this;' . chr(10) . '    }' . chr(10) . '    public pObject aget_hashref(int i) {' . chr(10) . '        pCORE.die("Not an ARRAY reference");' . chr(10) . '        return this;' . chr(10) . '    }' . chr(10) . chr(10) . '    public pObject hash_deref() {' . chr(10) . '        pCORE.die("Not a HASH reference");' . chr(10) . '        return this;' . chr(10) . '    }' . chr(10) . '    public pObject hash_deref_set(pObject i) {' . chr(10) . '        pCORE.die("Not a HASH reference");' . chr(10) . '        return this;' . chr(10) . '    }' . chr(10) . chr(10) . '    public pObject hget(pObject i) {' . chr(10) . '        pCORE.die("Not a HASH reference");' . chr(10) . '        return this;' . chr(10) . '    }' . chr(10) . '    public pObject hget(String i) {' . chr(10) . '        pCORE.die("Not a HASH reference");' . chr(10) . '        return this;' . chr(10) . '    }' . chr(10) . '    public pObject hget_lvalue(pObject i) {' . chr(10) . '        pCORE.die("Not a HASH reference");' . chr(10) . '        return this;' . chr(10) . '    }' . chr(10) . '    public pObject hget_lvalue(String i) {' . chr(10) . '        pCORE.die("Not a HASH reference");' . chr(10) . '        return this;' . chr(10) . '    }' . chr(10) . chr(10) . '    public pObject hset(pObject s, pObject v) {' . chr(10) . '        pCORE.die("Not a HASH reference");' . chr(10) . '        return this;' . chr(10) . '    }' . chr(10) . '    public pObject hset(String s, pObject v) {' . chr(10) . '        pCORE.die("Not a HASH reference");' . chr(10) . '        return this;' . chr(10) . '    }' . chr(10) . chr(10) . '    public pObject aget(pObject i) {' . chr(10) . '        pCORE.die("Not an ARRAY reference");' . chr(10) . '        return this;' . chr(10) . '    }' . chr(10) . '    public pObject aget(int i) {' . chr(10) . '        pCORE.die("Not an ARRAY reference");' . chr(10) . '        return this;' . chr(10) . '    }' . chr(10) . '    public pObject aset(pObject i, pObject v) {' . chr(10) . '        pCORE.die("Not an ARRAY reference");' . chr(10) . '        return this;' . chr(10) . '    }' . chr(10) . '    public pObject to_array() {' . chr(10) . '        pCORE.die("Not an ARRAY reference");' . chr(10) . '        return this;' . chr(10) . '    }' . chr(10) . '    public pObject length_of_array() {' . chr(10) . '        pCORE.die("Not an ARRAY reference");' . chr(10) . '        return this;' . chr(10) . '    }' . chr(10) . '    public pObject values() {' . chr(10) . '        pCORE.die("Type of argument to values on reference must be unblessed hashref or arrayref");' . chr(10) . '        return this;' . chr(10) . '    }' . chr(10) . '    public pObject keys() {' . chr(10) . '        pCORE.die("Type of argument to keys on reference must be unblessed hashref or arrayref");' . chr(10) . '        return this;' . chr(10) . '    }' . chr(10) . '    public pObject each() {' . chr(10) . '        pCORE.die("Type of argument to each on reference must be unblessed hashref or arrayref");' . chr(10) . '        return this;' . chr(10) . '    }' . chr(10) . '    public pObject exists(pObject i) {' . chr(10) . '        pCORE.die("exists argument is not a HASH or ARRAY element or a subroutine");' . chr(10) . '        return this;' . chr(10) . '    }' . chr(10) . '    public pObject delete(pObject i) {' . chr(10) . '        pCORE.die("delete argument is not a HASH or ARRAY element or slice");' . chr(10) . '        return this;' . chr(10) . '    }' . chr(10) . '    public pObject set(pObject o) {' . chr(10) . '        pCORE.die("Modification of a read-only value attempted");' . chr(10) . '        return this;' . chr(10) . '    }' . chr(10) . '    public pObject get() {' . chr(10) . '        pCORE.die("error .get!");' . chr(10) . '        return this;' . chr(10) . '    }' . chr(10) . '    public boolean is_int() {' . chr(10) . '        return false;' . chr(10) . '    }' . chr(10) . '    public boolean is_num() {' . chr(10) . '        return false;' . chr(10) . '    }' . chr(10) . '    public boolean is_string() {' . chr(10) . '        return false;' . chr(10) . '    }' . chr(10) . '    public boolean is_bool() {' . chr(10) . '        return false;' . chr(10) . '    }' . chr(10) . '    public boolean is_hash() {' . chr(10) . '        return false;' . chr(10) . '    }' . chr(10) . '    public boolean is_array() {' . chr(10) . '        return false;' . chr(10) . '    }' . chr(10) . '    public boolean is_scalar() {' . chr(10) . '        return false;' . chr(10) . '    }' . chr(10) . '    public boolean is_scalarref() {' . chr(10) . '        return false;' . chr(10) . '    }' . chr(10) . '    public boolean is_arrayref() {' . chr(10) . '        return false;' . chr(10) . '    }' . chr(10) . '    public boolean is_hashref() {' . chr(10) . '        return false;' . chr(10) . '    }' . chr(10) . chr(10) . '    public pObject _decr() {' . chr(10) . '        // --$x' . chr(10) . '        return new pInt(-1);' . chr(10) . '    }' . chr(10) . '    public pObject _incr() {' . chr(10) . '        // ++$x' . chr(10) . '        return new pInt(1);' . chr(10) . '    }' . chr(10) . '    public pObject neg() {' . chr(10) . '        return new pInt(-this.to_int());' . chr(10) . '    }' . chr(10) . '    public pObject abs() {' . chr(10) . '        int c = this.to_int();' . chr(10) . '        return new pInt(c < 0 ? -c : c);' . chr(10) . '    }' . chr(10) . chr(10) . '    public pObject sqrt() { return new pDouble(Math.sqrt(this.to_double())); }' . chr(10) . '    public pObject cos()  { return new pDouble(Math.cos(this.to_double())); }' . chr(10) . '    public pObject sin()  { return new pDouble(Math.sin(this.to_double())); }' . chr(10) . '    public pObject exp()  { return new pDouble(Math.exp(this.to_double())); }' . chr(10) . '    public pObject log()  { return new pDouble(Math.log(this.to_double())); }' . chr(10) . '    public pObject pow(pObject arg)    { return new pDouble(Math.pow(this.to_double(), arg.to_double())); }' . chr(10) . '    public pObject atan2(pObject arg)  { return new pDouble(Math.atan2(this.to_double(), arg.to_double())); }' . chr(10) . chr(10) . '    public pObject pre_decr() {' . chr(10) . '        // --$x' . chr(10) . '        pCORE.die("Can' . chr(39) . 't modify constant item in predecrement (--)");' . chr(10) . '        return this;' . chr(10) . '    }' . chr(10) . '    public pObject post_decr() {' . chr(10) . '        // $x--' . chr(10) . '        pCORE.die("Can' . chr(39) . 't modify constant item in postdecrement (--)");' . chr(10) . '        return this;' . chr(10) . '    }' . chr(10) . '    public pObject pre_incr() {' . chr(10) . '        // ++$x' . chr(10) . '        pCORE.die("Can' . chr(39) . 't modify constant item in preincrement (++)");' . chr(10) . '        return this;' . chr(10) . '    }' . chr(10) . '    public pObject post_incr() {' . chr(10) . '        // $x++' . chr(10) . '        pCORE.die("Can' . chr(39) . 't modify constant item in postincrement (++)");' . chr(10) . '        return this;' . chr(10) . '    }' . chr(10) . chr(10) . '    public pObject lcfirst() {' . chr(10) . '        String s = this.to_string();' . chr(10) . '        int len = s.length();' . chr(10) . '        if (len == 0) {' . chr(10) . '            return new pString(s);' . chr(10) . '        }' . chr(10) . '        if (len == 1) {' . chr(10) . '            return new pString(s.toLowerCase());' . chr(10) . '        }' . chr(10) . '        return new pString( s.substring(0,1).toLowerCase() + s.substring(1) );' . chr(10) . '    }' . chr(10) . '    public pObject ucfirst() {' . chr(10) . '        String s = this.to_string();' . chr(10) . '        int len = s.length();' . chr(10) . '        if (len == 0) {' . chr(10) . '            return new pString(s);' . chr(10) . '        }' . chr(10) . '        if (len == 1) {' . chr(10) . '            return new pString(s.toUpperCase());' . chr(10) . '        }' . chr(10) . '        return new pString( s.substring(0,1).toUpperCase() + s.substring(1) );' . chr(10) . '    }' . chr(10) . '    public pObject quotemeta() {' . chr(10) . '        String s = this.to_string();' . chr(10) . '        return new pString(Matcher.quoteReplacement(s));' . chr(10) . '    }' . chr(10) . chr(10) . '    public pObject substr(pObject offset) {' . chr(10) . '        // substr EXPR,OFFSET' . chr(10) . '        String s = this.to_string();' . chr(10) . '        int ofs = offset.to_int();' . chr(10) . '        if (ofs < 0) {' . chr(10) . '            ofs = s.length() + ofs;' . chr(10) . '        }' . chr(10) . '        if (ofs < 0) {' . chr(10) . '            ofs = 0;' . chr(10) . '        }' . chr(10) . '        if (ofs >= s.length()) {' . chr(10) . '            return pCx.UNDEF;' . chr(10) . '        }' . chr(10) . '        return new pString(s.substring(ofs));' . chr(10) . '    }' . chr(10) . '    public pObject substr(pObject offset, pObject length) {' . chr(10) . '        // substr EXPR,OFFSET,LENGTH' . chr(10) . '        String s = this.to_string();' . chr(10) . '        int ofs = offset.to_int();' . chr(10) . '        int len = length.to_int();' . chr(10) . '        if (ofs < 0) {' . chr(10) . '            ofs = s.length() + ofs;' . chr(10) . '        }' . chr(10) . '        if (ofs >= s.length()) {' . chr(10) . '            return pCx.UNDEF;' . chr(10) . '        }' . chr(10) . chr(10) . '        if (len < 0) {' . chr(10) . '            len = s.length() + len;' . chr(10) . '        }' . chr(10) . '        else {' . chr(10) . '            len = ofs + len;' . chr(10) . '        }' . chr(10) . chr(10) . '        if (len >= s.length()) {' . chr(10) . '            len = s.length();' . chr(10) . '        }' . chr(10) . '        if (len <= 0) {' . chr(10) . '            return pCx.UNDEF;' . chr(10) . '        }' . chr(10) . '        if (ofs < 0) {' . chr(10) . '            ofs = 0;' . chr(10) . '        }' . chr(10) . '        return new pString(s.substring(ofs, len));' . chr(10) . '    }' . chr(10) . '    public pObject substr(pObject offset, pObject length, pObject replacement) {' . chr(10) . '        // substr EXPR,OFFSET,LENGTH,REPLACEMENT' . chr(10) . '        pCORE.die("TODO substr EXPR,OFFSET,LENGTH,REPLACEMENT");' . chr(10) . '        return this;' . chr(10) . '    }' . chr(10) . chr(10) . '    public pObject ref() {' . chr(10) . '        return REF;' . chr(10) . '    }' . chr(10) . '    public pObject scalar() {' . chr(10) . '        return this;' . chr(10) . '    }' . chr(10) . '    public pObject str_cmp(pObject b) {' . chr(10) . '        int c = this.to_string().compareTo(b.to_string());' . chr(10) . '        return new pInt(c == 0 ? c : c < 0 ? -1 : 1);' . chr(10) . '    }' . chr(10) . '    public pObject num_cmp(pObject b) {' . chr(10) . '        return b.num_cmp2(this);' . chr(10) . '    }' . chr(10) . '    public pObject num_cmp2(pObject b) {' . chr(10) . '        int c = new Integer(b.to_int()).compareTo(this.to_int());' . chr(10) . '        return new pInt(c == 0 ? c : c < 0 ? -1 : 1);' . chr(10) . '    }' . chr(10) . (join('', map {
        my $perl = $_;
        my $native = $number_binop{$perl}->{'op'};
        my $returns = $number_binop{$perl}->{'returns'};
        '    public pObject ' . $perl . '(pObject s) {' . chr(10) . '        return s.' . $perl . '2(this);' . chr(10) . '    }' . chr(10) . '    public pObject ' . $perl . '2(pObject s) {' . chr(10) . '        return new ' . $returns . '( s.to_int() ' . $native . ' this.to_int() );' . chr(10) . '    }' . chr(10)
    } keys(%number_binop))) . (join('', map {
        my $perl = $_;
        my $native = $string_binop{$perl}->{'op'};
        my $returns = $string_binop{$perl}->{'returns'};
        '    public pObject ' . $perl . '(pObject b) {' . chr(10) . '        return new ' . $returns . '(this.to_string().compareTo(b.to_string()) ' . $native . ');' . chr(10) . '    }' . chr(10)
    } keys(%string_binop))) . '}' . chr(10) . 'class pReference extends pObject {' . chr(10) . '    public static final pString REF = new pString("REF");' . chr(10) . chr(10) . '    public String to_string() {' . chr(10) . '        return this.ref().to_string() + "(0x" + Integer.toHexString(this.hashCode()) + ")";' . chr(10) . '    }' . chr(10) . '    public pObject ref() {' . chr(10) . '        return REF;' . chr(10) . '    }' . chr(10) . '}' . chr(10) . 'class pRegex extends pReference {' . chr(10) . '    public Pattern p;' . chr(10) . '    // public Matcher m;' . chr(10) . '    public static final pString REF = new pString("Regexp");' . chr(10) . chr(10) . '    public pRegex(String p, int flags) {' . chr(10) . '        this.p = Pattern.compile(p, flags);' . chr(10) . '    }' . chr(10) . '    public pRegex(pObject p, int flags) {' . chr(10) . '        this.p = Pattern.compile(p.to_string(), flags);' . chr(10) . '    }' . chr(10) . '    public String to_string() {' . chr(10) . '        // TODO - show flags' . chr(10) . '        return this.p.toString();' . chr(10) . '    }' . chr(10) . '    public pObject ref() {' . chr(10) . '        return REF;' . chr(10) . '    }' . chr(10) . '}' . chr(10) . 'class pClosure extends pReference {' . chr(10) . '    public pObject[] env;       // new pObject[]{ v1, v2, v3 }' . chr(10) . '    public pObject prototype;    // ' . chr(39) . '$$$' . chr(39) . chr(10) . '    public static final pString REF = new pString("CODE");' . chr(10) . chr(10) . '    public pClosure(pObject prototype, pObject[] env) {' . chr(10) . '        this.prototype = prototype;' . chr(10) . '        this.env = env;' . chr(10) . '    }' . chr(10) . '    // Note: apply() is inherited from pObject' . chr(10) . '    public pObject apply(int want, pArray List__) {' . chr(10) . '        pCORE.die("it looks like you have a closure without a block");' . chr(10) . '        return this;' . chr(10) . '    }' . chr(10) . '    public pObject ref() {' . chr(10) . '        return REF;' . chr(10) . '    }' . chr(10) . '}' . chr(10) . 'class pLvalueRef extends pReference {' . chr(10) . '    private pObject o;' . chr(10) . '    public static final pString REF = new pString("SCALAR");' . chr(10) . chr(10) . '    public pLvalueRef(pLvalue o) {' . chr(10) . '        this.o = o;' . chr(10) . '    }' . chr(10) . '    public pLvalueRef(pObject o) {' . chr(10) . '        this.o = o;' . chr(10) . '    }' . chr(10) . '    public pObject scalar_deref_set(pObject v) {' . chr(10) . '        return this.o.set(v);' . chr(10) . '    }' . chr(10) . '    public boolean is_scalarref() {' . chr(10) . '        return true;' . chr(10) . '    }' . chr(10) . '    public pObject get() {' . chr(10) . '        return this.o;' . chr(10) . '    }' . chr(10) . '    public pObject ref() {' . chr(10) . '        return REF;' . chr(10) . '    }' . chr(10) . '}' . chr(10) . 'class pArrayRef extends pArray {' . chr(10) . '    public static final pString REF = new pString("ARRAY");' . chr(10) . chr(10) . '    public String to_string() {' . chr(10) . '        return this.ref().to_string() + "(0x" + Integer.toHexString(this.hashCode()) + ")";' . chr(10) . '    }' . chr(10) . '    public pArrayRef() {' . chr(10) . '        this.each_iterator = 0;' . chr(10) . '        this.a = new ArrayList<pObject>();' . chr(10) . '    }' . chr(10) . '    public pArrayRef(pArray o) {' . chr(10) . '        this.a = o.a;' . chr(10) . '        this.each_iterator = o.each_iterator;' . chr(10) . '    }' . chr(10) . '    public pObject set(pArray o) {' . chr(10) . '        this.a = o.a;' . chr(10) . '        this.each_iterator = o.each_iterator;' . chr(10) . '        return o;' . chr(10) . '    }' . chr(10) . '    public pObject get() {' . chr(10) . '        pArray o = new pArray();' . chr(10) . '        o.a = this.a;' . chr(10) . '        return o;' . chr(10) . '    }' . chr(10) . '    public pObject array_deref() {' . chr(10) . '        pArray o = new pArray();' . chr(10) . '        o.a = this.a;' . chr(10) . '        return o;' . chr(10) . '    }' . chr(10) . '    public pObject array_deref_set(pObject v) {' . chr(10) . '        super.set(v);' . chr(10) . '        return v;' . chr(10) . '    }' . chr(10) . '    public boolean is_array() {' . chr(10) . '        return false;' . chr(10) . '    }' . chr(10) . '    public boolean is_arrayref() {' . chr(10) . '        return true;' . chr(10) . '    }' . chr(10) . '    public pObject scalar() {' . chr(10) . '        return this;' . chr(10) . '    }' . chr(10) . '    public pObject ref() {' . chr(10) . '        return REF;' . chr(10) . '    }' . chr(10) . '}' . chr(10) . 'class pHashRef extends pHash {' . chr(10) . '    public static final pString REF = new pString("HASH");' . chr(10) . chr(10) . '    public String to_string() {' . chr(10) . '        return this.ref().to_string() + "(0x" + Integer.toHexString(this.hashCode()) + ")";' . chr(10) . '    }' . chr(10) . '    public pHashRef() {' . chr(10) . '        this.h = new HashMap<String, pObject>();' . chr(10) . '        this.each_iterator = null;' . chr(10) . '    }' . chr(10) . '    public pHashRef(pHash o) {' . chr(10) . '        this.h = o.h;' . chr(10) . '        this.each_iterator = o.each_iterator;' . chr(10) . '    }' . chr(10) . '    public pObject set(pHash o) {' . chr(10) . '        this.h = o.h;' . chr(10) . '        this.each_iterator = o.each_iterator;' . chr(10) . '        return o;' . chr(10) . '    }' . chr(10) . '    public pObject get() {' . chr(10) . '        pHash o = new pHash();' . chr(10) . '        o.h = this.h;' . chr(10) . '        return o;' . chr(10) . '    }' . chr(10) . '    public pObject hash_deref() {' . chr(10) . '        pHash o = new pHash();' . chr(10) . '        o.h = this.h;' . chr(10) . '        return o;' . chr(10) . '    }' . chr(10) . '    public pObject hash_deref_set(pObject v) {' . chr(10) . '        super.set(v);' . chr(10) . '        return v;' . chr(10) . '    }' . chr(10) . '    public boolean is_hash() {' . chr(10) . '        return false;' . chr(10) . '    }' . chr(10) . '    public boolean is_hashref() {' . chr(10) . '        return true;' . chr(10) . '    }' . chr(10) . '    public pObject scalar() {' . chr(10) . '        return this;' . chr(10) . '    }' . chr(10) . '    public pObject ref() {' . chr(10) . '        return REF;' . chr(10) . '    }' . chr(10) . '}' . chr(10) . 'class pLvalue extends pObject {' . chr(10) . '    private pObject o;' . chr(10) . chr(10) . '    // Note: several versions of pLvalue()' . chr(10) . '    public pLvalue() {' . chr(10) . '        this.o = pCx.UNDEF;' . chr(10) . '    }' . chr(10) . '    public pLvalue(pObject o) {' . chr(10) . '        this.o = o;' . chr(10) . '    }' . chr(10) . '    public pLvalue(pLvalue o) {' . chr(10) . '        this.o = o.get();' . chr(10) . '    }' . chr(10) . '    public pLvalue(pArray o) {' . chr(10) . '        // $a = @x' . chr(10) . '        this.o = o.scalar();' . chr(10) . '    }' . chr(10) . '    public pLvalue(pHash o) {' . chr(10) . '        // $a = %x' . chr(10) . '        this.o = o.scalar();' . chr(10) . '    }' . chr(10) . chr(10) . '    public pObject get() {' . chr(10) . '        return this.o;' . chr(10) . '    }' . chr(10) . '    public pObject get_scalarref() {' . chr(10) . '        if (this.o.is_undef()) {' . chr(10) . '            pLvalueRef ar = new pLvalueRef(new pLvalue());' . chr(10) . '            this.o = ar;' . chr(10) . '            return ar;' . chr(10) . '        }' . chr(10) . '        else if (this.o.is_scalarref()) {' . chr(10) . '            return this.o;' . chr(10) . '        }' . chr(10) . '        // Modification of a read-only value attempted' . chr(10) . '        return this.o;' . chr(10) . '    }' . chr(10) . '    public pObject get_arrayref() {' . chr(10) . '        if (this.o.is_undef()) {' . chr(10) . '            pArrayRef ar = new pArrayRef();' . chr(10) . '            this.o = ar;' . chr(10) . '            return ar;' . chr(10) . '        }' . chr(10) . '        else if (this.o.is_arrayref()) {' . chr(10) . '            return this.o;' . chr(10) . '        }' . chr(10) . '        return pCORE.die("Not an ARRAY reference");' . chr(10) . '    }' . chr(10) . '    public pObject get_hashref() {' . chr(10) . '        if (this.o.is_undef()) {' . chr(10) . '            pHashRef hr = new pHashRef();' . chr(10) . '            this.o = hr;' . chr(10) . '            return this.o;' . chr(10) . '        }' . chr(10) . '        else if (this.o.is_hashref()) {' . chr(10) . '            return this.o;' . chr(10) . '        }' . chr(10) . '        return pCORE.die("Not a HASH reference");' . chr(10) . '    }' . chr(10) . '    public pObject aget(pObject i) {' . chr(10) . '        return this.o.aget(i);' . chr(10) . '    }' . chr(10) . '    public pObject aget(int i) {' . chr(10) . '        return this.o.aget(i);' . chr(10) . '    }' . chr(10) . chr(10) . '    public pObject aget_scalarref(pObject i) {' . chr(10) . '        if (this.o.is_undef()) {' . chr(10) . '            this.o = new pArrayRef();' . chr(10) . '        }' . chr(10) . '        return this.o.aget_scalarref(i);' . chr(10) . '    }' . chr(10) . '    public pObject aget_arrayref(pObject i) {' . chr(10) . '        if (this.o.is_undef()) {' . chr(10) . '            this.o = new pArrayRef();' . chr(10) . '        }' . chr(10) . '        return this.o.aget_arrayref(i);' . chr(10) . '    }' . chr(10) . '    public pObject aget_hashref(pObject i) {' . chr(10) . '        if (this.o.is_undef()) {' . chr(10) . '            this.o = new pArrayRef();' . chr(10) . '        }' . chr(10) . '        return this.o.aget_hashref(i);' . chr(10) . '    }' . chr(10) . chr(10) . '    public pObject aset(pObject i, pObject v) {' . chr(10) . '        return this.o.aset(i, v);' . chr(10) . '    }' . chr(10) . '    public pObject hget(pObject i) {' . chr(10) . '        return this.o.hget(i);' . chr(10) . '    }' . chr(10) . '    public pObject hget(String i) {' . chr(10) . '        return this.o.hget(i);' . chr(10) . '    }' . chr(10) . chr(10) . '    public pObject hget_scalarref(pObject i) {' . chr(10) . '        if (this.o.is_undef()) {' . chr(10) . '            this.o = new pHashRef();' . chr(10) . '        }' . chr(10) . '        return this.o.hget_scalarref(i);' . chr(10) . '    }' . chr(10) . '    public pObject hget_arrayref(pObject i) {' . chr(10) . '        if (this.o.is_undef()) {' . chr(10) . '            this.o = new pHashRef();' . chr(10) . '        }' . chr(10) . '        return this.o.hget_arrayref(i);' . chr(10) . '    }' . chr(10) . '    public pObject hget_hashref(pObject i) {' . chr(10) . '        if (this.o.is_undef()) {' . chr(10) . '            this.o = new pHashRef();' . chr(10) . '        }' . chr(10) . '        return this.o.hget_hashref(i);' . chr(10) . '    }' . chr(10) . chr(10) . '    public pObject hset(pObject s, pObject v) {' . chr(10) . '        return this.o.hset(s, v);' . chr(10) . '    }' . chr(10) . '    public pObject hset(String s, pObject v) {' . chr(10) . '        return this.o.hset(s, v);' . chr(10) . '    }' . chr(10) . chr(10) . '    public pObject scalar_deref() {' . chr(10) . '        return this.get_scalarref().get();' . chr(10) . '    }' . chr(10) . '    public pObject scalar_deref_set(pObject v) {' . chr(10) . '        return this.get_scalarref().scalar_deref_set(v);' . chr(10) . '    }' . chr(10) . chr(10) . '    public pObject array_deref() {' . chr(10) . '        // @$x doesn' . chr(39) . 't autovivify' . chr(10) . '        if (this.o.is_undef()) {' . chr(10) . '            return new pArray();' . chr(10) . '        }' . chr(10) . '        else if (this.o.is_arrayref()) {' . chr(10) . '            return this.o.get();' . chr(10) . '        }' . chr(10) . '        return pCORE.die("Not an ARRAY reference");' . chr(10) . '    }' . chr(10) . '    public pObject array_deref_set(pObject v) {' . chr(10) . '        // @$x = ...' . chr(10) . '        if (this.o.is_undef()) {' . chr(10) . '            this.o = new pArrayRef();' . chr(10) . '            return this.o.array_deref_set(v);' . chr(10) . '        }' . chr(10) . '        else if (this.o.is_arrayref()) {' . chr(10) . '            return this.o.array_deref_set(v);' . chr(10) . '        }' . chr(10) . '        return pCORE.die("Not an ARRAY reference");' . chr(10) . '    }' . chr(10) . chr(10) . '    public pObject hash_deref() {' . chr(10) . '        // %$x doesn' . chr(39) . 't autovivify' . chr(10) . '        if (this.o.is_undef()) {' . chr(10) . '            return new pHash();' . chr(10) . '        }' . chr(10) . '        else if (this.o.is_hashref()) {' . chr(10) . '            return this.o.get();' . chr(10) . '        }' . chr(10) . '        return pCORE.die("Not a HASH reference");' . chr(10) . '    }' . chr(10) . '    public pObject hash_deref_set(pObject v) {' . chr(10) . '        // %$x = ...' . chr(10) . '        if (this.o.is_undef()) {' . chr(10) . '            this.o = new pHashRef();' . chr(10) . '            return this.o.hash_deref_set(v);' . chr(10) . '        }' . chr(10) . '        else if (this.o.is_hashref()) {' . chr(10) . '            return this.o.hash_deref_set(v);' . chr(10) . '        }' . chr(10) . '        return pCORE.die("Not a HASH reference");' . chr(10) . '    }' . chr(10) . '    public pObject apply(int want, pArray List__) {' . chr(10) . '        return this.o.apply(want, List__);' . chr(10) . '    }' . chr(10) . chr(10) . '    // Note: several versions of set()' . chr(10) . '    public pObject set(pObject o) {' . chr(10) . '        this.o = o;' . chr(10) . '        return this;' . chr(10) . '    }' . chr(10) . '    public pObject set(pLvalue o) {' . chr(10) . '        this.o = o.get();' . chr(10) . '        return this;' . chr(10) . '    }' . chr(10) . '    public pObject set(pArray o) {' . chr(10) . '        // $a = @x' . chr(10) . '        this.o = o.scalar();' . chr(10) . '        return this;' . chr(10) . '    }' . chr(10) . '    public pObject set(pHash o) {' . chr(10) . '        // $a = %x' . chr(10) . '        this.o = o.scalar();' . chr(10) . '        return this;' . chr(10) . '    }' . chr(10) . (join('', map {
        my $native = $_;
        my $perl = $native_to_perl{$native};
        $native && $perl ? '    public pObject set(' . $native . ' s) {' . chr(10) . '        this.o = new ' . $perl . '(s);' . chr(10) . '        return this;' . chr(10) . '    }' . chr(10) : ()
    } keys(%native_to_perl))) . '    public String to_string() {' . chr(10) . '        return this.o.to_string();' . chr(10) . '    }' . chr(10) . '    public int to_int() {' . chr(10) . '        return this.o.to_int();' . chr(10) . '    }' . chr(10) . '    public double to_double() {' . chr(10) . '        return this.o.to_double();' . chr(10) . '    }' . chr(10) . '    public boolean to_bool() {' . chr(10) . '        return this.o.to_bool();' . chr(10) . '    }' . chr(10) . '    public pObject num_cmp(pObject b) {' . chr(10) . '        return this.o.num_cmp(b);' . chr(10) . '    }' . chr(10) . '    public pObject num_cmp2(pObject b) {' . chr(10) . '        return b.num_cmp(this.o);' . chr(10) . '    }' . chr(10) . (join('', map {
        my $perl = $_;
        my $native = $number_binop{$perl}->{'op'};
        '    public pObject ' . $perl . '(pObject s) {' . chr(10) . '        return this.o.' . $perl . '(s);' . chr(10) . '    }' . chr(10) . '    public pObject ' . $perl . '2(pObject s) {' . chr(10) . '        return s.' . $perl . '(this.o);' . chr(10) . '    }' . chr(10)
    } keys(%number_binop))) . '    public boolean is_int() {' . chr(10) . '        return this.o.is_int();' . chr(10) . '    }' . chr(10) . '    public boolean is_num() {' . chr(10) . '        return this.o.is_num();' . chr(10) . '    }' . chr(10) . '    public boolean is_string() {' . chr(10) . '        return this.o.is_string();' . chr(10) . '    }' . chr(10) . '    public boolean is_bool() {' . chr(10) . '        return this.o.is_bool();' . chr(10) . '    }' . chr(10) . '    public boolean is_undef() {' . chr(10) . '        return this.o.is_undef();' . chr(10) . '    }' . chr(10) . '    public boolean is_scalar() {' . chr(10) . '        return true;' . chr(10) . '    }' . chr(10) . chr(10) . '    public pObject pre_decr() {' . chr(10) . '        // --$x' . chr(10) . '        this.o = this.o._decr();' . chr(10) . '        return this.o;' . chr(10) . '    }' . chr(10) . '    public pObject post_decr() {' . chr(10) . '        // $x--' . chr(10) . '        pObject res = this.o;' . chr(10) . '        this.o = this.o._decr();' . chr(10) . '        return res;' . chr(10) . '    }' . chr(10) . '    public pObject pre_incr() {' . chr(10) . '        // ++$x' . chr(10) . '        this.o = this.o._incr();' . chr(10) . '        return this.o;' . chr(10) . '    }' . chr(10) . '    public pObject post_incr() {' . chr(10) . '        // $x++' . chr(10) . '        pObject res = this.o;' . chr(10) . '        this.o = this.o._incr();' . chr(10) . '        return res;' . chr(10) . '    }' . chr(10) . '    public pObject neg() {' . chr(10) . '        return this.o.neg();' . chr(10) . '    }' . chr(10) . '    public pObject abs() {' . chr(10) . '        return this.o.abs();' . chr(10) . '    }' . chr(10) . chr(10) . '    public pObject scalar() {' . chr(10) . '        return this.o;' . chr(10) . '    }' . chr(10) . '    public pObject ref() {' . chr(10) . '        return this.o.ref();' . chr(10) . '    }' . chr(10) . join('', (map {
        my $class = $_;
        my $java_class_name = $class->{'java_type'};
        my $perl_to_java = $class->{'perl_to_java'};
        $class->{'import'} ? '    public ' . $java_class_name . ' ' . $perl_to_java . '() {' . chr(10) . '        return this.o.' . $perl_to_java . '();' . chr(10) . '    }' . chr(10) : ()
    } values(%java_classes))) . '}' . chr(10) . 'class pArray extends pObject {' . chr(10) . '    public ArrayList<pObject> a;' . chr(10) . '    public int each_iterator;' . chr(10) . '    public pArray( ArrayList<pObject> a ) {' . chr(10) . '        this.each_iterator = 0;' . chr(10) . '        this.a = a;' . chr(10) . '    }' . chr(10) . '    public pArray() {' . chr(10) . '        this.each_iterator = 0;' . chr(10) . '        this.a = new ArrayList<pObject>();' . chr(10) . '    }' . chr(10) . '    public pArray(pObject... args) {' . chr(10) . '        ArrayList<pObject> aa = new ArrayList<pObject>();' . chr(10) . '        for (pObject s : args) {' . chr(10) . '            if (s.is_hash()) {' . chr(10) . '                // @x = %x;' . chr(10) . '                s = s.to_array();' . chr(10) . '            }' . chr(10) . '            if (s.is_array()) {' . chr(10) . '                // @x = ( @x, @y );' . chr(10) . '                for (int i = 0; i < s.to_int(); i++) {' . chr(10) . '                    aa.add(s.aget(i));' . chr(10) . '                }' . chr(10) . '            }' . chr(10) . '            else {' . chr(10) . '                aa.add(s);' . chr(10) . '            }' . chr(10) . '        }' . chr(10) . '        this.each_iterator = 0;' . chr(10) . '        this.a = aa;' . chr(10) . '    }' . chr(10) . '    public pObject set(pObject s) {' . chr(10) . '        this.a.clear();' . chr(10) . '        if (s.is_hash()) {' . chr(10) . '            // @x = %x;' . chr(10) . '            s = s.to_array();' . chr(10) . '        }' . chr(10) . '        if (s.is_array()) {' . chr(10) . '            // @x = ( @x, @y );' . chr(10) . '            for (int i = 0; i < s.to_int(); i++) {' . chr(10) . '                this.a.add(s.aget(i));' . chr(10) . '            }' . chr(10) . '        }' . chr(10) . '        else {' . chr(10) . '            this.a.add(s);' . chr(10) . '        }' . chr(10) . '        this.each_iterator = 0;' . chr(10) . '        return this;' . chr(10) . '    }' . chr(10) . '    public pObject set(byte[] bs) {' . chr(10) . '        this.a.clear();' . chr(10) . '        // @x = byte[] native;' . chr(10) . '        for(byte b : bs){' . chr(10) . '            int i = b;' . chr(10) . '            this.a.add(new pInt(i));' . chr(10) . '        }' . chr(10) . '        this.each_iterator = 0;' . chr(10) . '        return this;' . chr(10) . '    }' . chr(10) . '    public pArray(byte[] bs) {' . chr(10) . '        pArray aa = new pArray();' . chr(10) . '        aa.set(bs);' . chr(10) . '        this.each_iterator = aa.each_iterator;' . chr(10) . '        this.a = aa.a;' . chr(10) . '    }' . chr(10) . '    public pObject set(int[] ints) {' . chr(10) . '        this.a.clear();' . chr(10) . '        // @x = int[] native;' . chr(10) . '        for(int i : ints){' . chr(10) . '            this.a.add(new pInt(i));' . chr(10) . '        }' . chr(10) . '        this.each_iterator = 0;' . chr(10) . '        return this;' . chr(10) . '    }' . chr(10) . '    public pArray(int[] ints) {' . chr(10) . '        pArray aa = new pArray();' . chr(10) . '        aa.set(ints);' . chr(10) . '        this.each_iterator = aa.each_iterator;' . chr(10) . '        this.a = aa.a;' . chr(10) . '    }' . chr(10) . '    public pObject set(String[] strings) {' . chr(10) . '        this.a.clear();' . chr(10) . '        for (String s : strings) {' . chr(10) . '            this.a.add(new pString(s));' . chr(10) . '        }' . chr(10) . '        this.each_iterator = 0;' . chr(10) . '        return this;' . chr(10) . '    }' . chr(10) . '    public pArray(String[] strings) {' . chr(10) . '        pArray arr = new pArray();' . chr(10) . '        arr.set(strings);' . chr(10) . '        this.each_iterator = arr.each_iterator;' . chr(10) . '        this.a = arr.a;' . chr(10) . '    }' . chr(10) . '    // TODO - Double[]' . chr(10) . join('', (map {
        my $class = $_;
        my $java_class_name = $class->{'java_type'};
        my $perl_to_java = $class->{'perl_to_java'};
        my $perl_package = $class->{'perl_package'};
        my $java_native_to_perl = $class->{'java_native_to_perl'};
        $class->{'import'} ? '    public pObject set(' . $java_class_name . '[] stuffs) {' . chr(10) . '        this.a.clear();' . chr(10) . '        // @x = ' . $java_class_name . '[] native;' . chr(10) . '        for(' . $java_class_name . ' i : stuffs){' . chr(10) . '            this.a.add(new ' . $java_native_to_perl . '(i));' . chr(10) . '        }' . chr(10) . '        this.each_iterator = 0;' . chr(10) . '        return this;' . chr(10) . '    }' . chr(10) . '    public pArray(' . $java_class_name . '[] stuffs) {' . chr(10) . '        pArray aa = new pArray();' . chr(10) . '        aa.set(stuffs);' . chr(10) . '        this.each_iterator = aa.each_iterator;' . chr(10) . '        this.a = aa.a;' . chr(10) . '    }' . chr(10) : ()
    } values(%java_classes))) . '    public pObject aget(pObject i) {' . chr(10) . '        int pos  = i.to_int();' . chr(10) . '        if (pos < 0) {' . chr(10) . '            pos = this.a.size() + pos;' . chr(10) . '        }' . chr(10) . '        if (pos < 0 || pos >= this.a.size()) {' . chr(10) . '            return pCx.UNDEF;' . chr(10) . '        }' . chr(10) . '        return this.a.get(pos);' . chr(10) . '    }' . chr(10) . '    public pObject aget(int i) {' . chr(10) . '        int pos  = i;' . chr(10) . '        if (pos < 0) {' . chr(10) . '            pos = this.a.size() + pos;' . chr(10) . '        }' . chr(10) . '        if (pos < 0 || pos >= this.a.size()) {' . chr(10) . '            return pCx.UNDEF;' . chr(10) . '        }' . chr(10) . '        return this.a.get(pos);' . chr(10) . '    }' . chr(10) . chr(10) . '    public pObject get_scalar(pObject i) {' . chr(10) . '        // $$x' . chr(10) . '        pObject o = this.aget(i);' . chr(10) . '        if (o.is_undef()) {' . chr(10) . '            pLvalue a = new pLvalue();' . chr(10) . '            this.aset(i, new pLvalueRef(a));' . chr(10) . '            return a;' . chr(10) . '        }' . chr(10) . '        else if (o.is_scalarref()) {' . chr(10) . '            return o.get();' . chr(10) . '        }' . chr(10) . '        // Modification of a read-only value attempted' . chr(10) . '        // return pCORE.die("Not an SCALAR reference");' . chr(10) . '        return o;' . chr(10) . '    }' . chr(10) . '    public pObject aget_scalarref(pObject i) {' . chr(10) . '        pObject o = this.aget(i);' . chr(10) . '        if (o.is_undef()) {' . chr(10) . '            pLvalueRef ar = new pLvalueRef(new pLvalue());' . chr(10) . '            this.aset(i, ar);' . chr(10) . '            return ar;' . chr(10) . '        }' . chr(10) . '        else if (o.is_scalarref()) {' . chr(10) . '            return o;' . chr(10) . '        }' . chr(10) . '        return pCORE.die("Not a SCALAR reference");' . chr(10) . '    }' . chr(10) . '    public pObject aget_scalarref(int i) {' . chr(10) . '        pObject o = this.aget(i);' . chr(10) . '        if (o.is_undef()) {' . chr(10) . '            pLvalueRef ar = new pLvalueRef(new pLvalue());' . chr(10) . '            this.aset(i, ar);' . chr(10) . '            return ar;' . chr(10) . '        }' . chr(10) . '        else if (o.is_scalarref()) {' . chr(10) . '            return o;' . chr(10) . '        }' . chr(10) . '        return pCORE.die("Not a SCALAR reference");' . chr(10) . '    }' . chr(10) . chr(10) . '    public pObject aget_arrayref(pObject i) {' . chr(10) . '        pObject o = this.aget(i);' . chr(10) . '        if (o.is_undef()) {' . chr(10) . '            pArrayRef ar = new pArrayRef();' . chr(10) . '            this.aset(i, ar);' . chr(10) . '            return ar;' . chr(10) . '        }' . chr(10) . '        else if (o.is_arrayref()) {' . chr(10) . '            return o;' . chr(10) . '        }' . chr(10) . '        return pCORE.die("Not an ARRAY reference");' . chr(10) . '    }' . chr(10) . '    public pObject aget_arrayref(int i) {' . chr(10) . '        pObject o = this.aget(i);' . chr(10) . '        if (o.is_undef()) {' . chr(10) . '            pArrayRef ar = new pArrayRef();' . chr(10) . '            this.aset(i, ar);' . chr(10) . '            return ar;' . chr(10) . '        }' . chr(10) . '        else if (o.is_arrayref()) {' . chr(10) . '            return o;' . chr(10) . '        }' . chr(10) . '        return pCORE.die("Not an ARRAY reference");' . chr(10) . '    }' . chr(10) . chr(10) . '    public pObject aget_hashref(pObject i) {' . chr(10) . '        pObject o = this.aget(i);' . chr(10) . '        if (o.is_undef()) {' . chr(10) . '            pHashRef hr = new pHashRef();' . chr(10) . '            this.aset(i, hr);' . chr(10) . '            return hr;' . chr(10) . '        }' . chr(10) . '        else if (o.is_hashref()) {' . chr(10) . '            return o;' . chr(10) . '        }' . chr(10) . '        return pCORE.die("Not a HASH reference");' . chr(10) . '    }' . chr(10) . '    public pObject aget_hashref(int i) {' . chr(10) . '        pObject o = this.aget(i);' . chr(10) . '        if (o.is_undef()) {' . chr(10) . '            pHashRef hr = new pHashRef();' . chr(10) . '            this.aset(i, hr);' . chr(10) . '            return hr;' . chr(10) . '        }' . chr(10) . '        else if (o.is_hashref()) {' . chr(10) . '            return o;' . chr(10) . '        }' . chr(10) . '        return pCORE.die("Not a HASH reference");' . chr(10) . '    }' . chr(10) . chr(10) . '    public pObject get_hash(int i) {' . chr(10) . '        pObject o = this.aget(i);' . chr(10) . '        if (o.is_undef()) {' . chr(10) . '            pHashRef hr = new pHashRef();' . chr(10) . '            this.aset(i, hr);' . chr(10) . '            return hr;' . chr(10) . '        }' . chr(10) . '        else if (o.is_hashref()) {' . chr(10) . '            return o;' . chr(10) . '        }' . chr(10) . '        return pCORE.die("Not a HASH reference");' . chr(10) . '    }' . chr(10) . chr(10) . '    // Note: multiple versions of set()' . chr(10) . '    public pObject aset(pObject i, pObject v) {' . chr(10) . '        int size = this.a.size();' . chr(10) . '        int pos  = i.to_int();' . chr(10) . '        if (pos < 0) {' . chr(10) . '            pos = size + pos;' . chr(10) . '        }' . chr(10) . '        while (size < pos) {' . chr(10) . '            this.a.add( pCx.UNDEF );' . chr(10) . '            size++;' . chr(10) . '        }' . chr(10) . '        this.a.add(pos, v.scalar());' . chr(10) . '        return v;' . chr(10) . '    }' . chr(10) . '    public pObject aset(int i, pObject v) {' . chr(10) . '        int size = this.a.size();' . chr(10) . '        int pos  = i;' . chr(10) . '        if (pos < 0) {' . chr(10) . '            pos = size + pos;' . chr(10) . '        }' . chr(10) . '        while (size < pos) {' . chr(10) . '            this.a.add( pCx.UNDEF );' . chr(10) . '            size++;' . chr(10) . '        }' . chr(10) . '        this.a.add(pos, v.scalar());' . chr(10) . '        return v;' . chr(10) . '    }' . chr(10) . '    public pObject aset(pObject i, pLvalue v) {' . chr(10) . '        int size = this.a.size();' . chr(10) . '        int pos  = i.to_int();' . chr(10) . '        if (pos < 0) {' . chr(10) . '            pos = size + pos;' . chr(10) . '        }' . chr(10) . '        while (size < pos) {' . chr(10) . '            this.a.add( pCx.UNDEF );' . chr(10) . '            size++;' . chr(10) . '        }' . chr(10) . '        this.a.add(pos, v.get());' . chr(10) . '        return v;' . chr(10) . '    }' . chr(10) . (join('', map {
        my $native = $_;
        my $perl = $native_to_perl{$native};
        $native && $perl ? '    public pObject aset(pObject i, ' . $native . ' s) {' . chr(10) . '        return this.aset(i, new ' . $perl . '(s));' . chr(10) . '    }' . chr(10) . '    public pObject aset(int i, ' . $native . ' s) {' . chr(10) . '        return this.aset(i, new ' . $perl . '(s));' . chr(10) . '    }' . chr(10) : ()
    } keys(%native_to_perl))) . chr(10) . '    // Note: multiple versions of push()' . chr(10) . '    public pObject push(pObject v) {' . chr(10) . '        if (v.is_array()) {' . chr(10) . '            return this.push( (pArray)v );' . chr(10) . '        }' . chr(10) . '        this.a.add(v.scalar());' . chr(10) . '        return this.length_of_array();' . chr(10) . '    }' . chr(10) . '    public pObject push(pLvalue v) {' . chr(10) . '        this.a.add(v.get());' . chr(10) . '        return this.length_of_array();' . chr(10) . '    }' . chr(10) . '    public pObject push(pArray args) {' . chr(10) . '        for (int i = 0; i < args.to_int(); i++) {' . chr(10) . '            pObject s = args.aget(i);' . chr(10) . '            if (s.is_hash()) {' . chr(10) . '                // @x = %x;' . chr(10) . '                s = s.to_array();' . chr(10) . '            }' . chr(10) . '            if (s.is_array()) {' . chr(10) . '                this.push(s);' . chr(10) . '            }' . chr(10) . '            else {' . chr(10) . '                this.a.add(s);' . chr(10) . '            }' . chr(10) . '        }' . chr(10) . '        return this.length_of_array();' . chr(10) . '    }' . chr(10) . chr(10) . '    // Note: multiple versions of unshift()' . chr(10) . '    public pObject unshift(pObject v) {' . chr(10) . '        if (v.is_array()) {' . chr(10) . '            return this.unshift( (pArray)v );' . chr(10) . '        }' . chr(10) . '        this.a.add(0, v.scalar());' . chr(10) . '        return this.length_of_array();' . chr(10) . '    }' . chr(10) . '    public pObject unshift(pLvalue v) {' . chr(10) . '        this.a.add(0, v.get());' . chr(10) . '        return this.length_of_array();' . chr(10) . '    }' . chr(10) . '    public pObject unshift(pArray args) {' . chr(10) . '        for (int i = args.to_int() - 1; i >= 0; i--) {' . chr(10) . '            pObject s = args.aget(i);' . chr(10) . '            if (s.is_hash()) {' . chr(10) . '                // @x = %x;' . chr(10) . '                s = s.to_array();' . chr(10) . '            }' . chr(10) . '            if (s.is_array()) {' . chr(10) . '                this.unshift(s);' . chr(10) . '            }' . chr(10) . '            else {' . chr(10) . '                this.a.add(0, s);' . chr(10) . '            }' . chr(10) . '        }' . chr(10) . '        return this.length_of_array();' . chr(10) . '    }' . chr(10) . chr(10) . '    public pObject pop() {' . chr(10) . '        int size = this.a.size() - 1;' . chr(10) . '        if (size >= 0) {' . chr(10) . '            return this.a.remove(size);' . chr(10) . '        }' . chr(10) . '        else {' . chr(10) . '            return pCx.UNDEF;' . chr(10) . '        }' . chr(10) . '    }' . chr(10) . '    public pObject shift() {' . chr(10) . '        int size = this.a.size();' . chr(10) . '        if (size > 0) {' . chr(10) . '            return this.a.remove(0);' . chr(10) . '        }' . chr(10) . '        else {' . chr(10) . '            return pCx.UNDEF;' . chr(10) . '        }' . chr(10) . '    }' . chr(10) . '    public pObject exists(pObject i) {' . chr(10) . '        pCORE.die("TODO - array exists");' . chr(10) . '        return this;' . chr(10) . '    }' . chr(10) . '    public pObject delete(pObject i) {' . chr(10) . '        pCORE.die("TODO - array delete");' . chr(10) . '        return this;' . chr(10) . '    }' . chr(10) . '    public pObject values() {' . chr(10) . '        // return a copy' . chr(10) . '        return new pArray(this);' . chr(10) . '    }' . chr(10) . '    public pObject keys() {' . chr(10) . '        pArray aa = new pArray();' . chr(10) . '        int size = this.a.size();' . chr(10) . '        for (int i = 0; i < size; i++) {' . chr(10) . '            aa.push(new pInt(i));' . chr(10) . '        }' . chr(10) . '        return aa;' . chr(10) . '    }' . chr(10) . '    public pObject each() {' . chr(10) . '        pArray aa = new pArray();' . chr(10) . '        int size = this.a.size();' . chr(10) . '        if (this.each_iterator < size) {' . chr(10) . '            aa.push(new pInt(this.each_iterator));' . chr(10) . '            aa.push(this.aget(this.each_iterator));' . chr(10) . '            this.each_iterator++;' . chr(10) . '        }' . chr(10) . '        else {' . chr(10) . '            // return empty list' . chr(10) . '            this.each_iterator = 0;' . chr(10) . '        }' . chr(10) . '        return aa;' . chr(10) . '    }' . chr(10) . '    public String to_string() {' . chr(10) . '        StringBuilder sb = new StringBuilder();' . chr(10) . '        int size = this.a.size();' . chr(10) . '        for (int i = 0; i < size; i++) {' . chr(10) . '            String item = this.a.get(i).to_string();' . chr(10) . '            sb.append(item);' . chr(10) . '        }' . chr(10) . '        return sb.toString();' . chr(10) . '    }' . chr(10) . '    public int to_int() {' . chr(10) . '        return this.a.size();' . chr(10) . '    }' . chr(10) . '    public pObject length_of_array() {' . chr(10) . '        return new pInt(this.a.size());' . chr(10) . '    }' . chr(10) . '    public pObject end_of_array_index() {' . chr(10) . '        return new pInt(this.a.size() - 1);' . chr(10) . '    }' . chr(10) . '    public double to_double() {' . chr(10) . '        return 0.0 + this.to_int();' . chr(10) . '    }' . chr(10) . '    public boolean to_bool() {' . chr(10) . '        return (this.a.size() > 0);' . chr(10) . '    }' . chr(10) . '    public boolean is_int() {' . chr(10) . '        return false;' . chr(10) . '    }' . chr(10) . '    public boolean is_num() {' . chr(10) . '        return false;' . chr(10) . '    }' . chr(10) . '    public boolean is_string() {' . chr(10) . '        return false;' . chr(10) . '    }' . chr(10) . '    public boolean is_bool() {' . chr(10) . '        return false;' . chr(10) . '    }' . chr(10) . '    public boolean is_array() {' . chr(10) . '        return true;' . chr(10) . '    }' . chr(10) . '    public pObject scalar() {' . chr(10) . '        return this.length_of_array();' . chr(10) . '    }' . chr(10) . '}' . chr(10) . 'class pHash extends pObject {' . chr(10) . '    public HashMap<String, pObject> h;' . chr(10) . '    public Iterator<Map.Entry<String, pObject>> each_iterator;' . chr(10) . chr(10) . '    public pHash() {' . chr(10) . '        this.each_iterator = null;' . chr(10) . '        this.h = new HashMap<String, pObject>();' . chr(10) . '    }' . chr(10) . '    public pHash(pObject... args) {' . chr(10) . '        pHash hh = new pHash();' . chr(10) . '        int args_size = args.length;' . chr(10) . '        for (int i = 0; i < args_size; i++) {' . chr(10) . '            pObject s = args[i];' . chr(10) . '            if (s.is_hash()) {' . chr(10) . '                // @x = %x;' . chr(10) . '                s = s.to_array();' . chr(10) . '            }' . chr(10) . '            if (s.is_array()) {' . chr(10) . '                // %x = ( @x, @y );' . chr(10) . '                int array_size = s.to_int();' . chr(10) . '                for (int j = 0; j < array_size; j++) {' . chr(10) . '                    pObject key = s.aget(j);' . chr(10) . '                    j++;' . chr(10) . '                    pObject value;' . chr(10) . '                    if ( j >= array_size ) {' . chr(10) . '                        // TODO - emit warning about odd number of arguments' . chr(10) . '                        value = pCx.UNDEF;' . chr(10) . '                    }' . chr(10) . '                    else {' . chr(10) . '                        value = s.aget(j);' . chr(10) . '                    }' . chr(10) . '                    hh.hset(key, value);' . chr(10) . '                }' . chr(10) . '            }' . chr(10) . '            else {' . chr(10) . '                i++;' . chr(10) . '                pObject value;' . chr(10) . '                if ( i >= args_size ) {' . chr(10) . '                    // TODO - emit warning about odd number of arguments' . chr(10) . '                    value = pCx.UNDEF;' . chr(10) . '                }' . chr(10) . '                else {' . chr(10) . '                    value = args[i];' . chr(10) . '                }' . chr(10) . '                hh.hset(s, value);' . chr(10) . '            }' . chr(10) . '        }' . chr(10) . '        this.each_iterator = null;' . chr(10) . '        this.h = hh.to_HashMap();' . chr(10) . '    }' . chr(10) . '    private HashMap<String, pObject> to_HashMap() {' . chr(10) . '        return this.h;' . chr(10) . '    }' . chr(10) . '    public pObject set(pObject s) {' . chr(10) . '        this.h.clear();' . chr(10) . '        if (s.is_hash()) {' . chr(10) . '            // @x = %x;' . chr(10) . '            s = s.to_array();' . chr(10) . '        }' . chr(10) . '        if (s.is_array()) {' . chr(10) . '            // %x = ( @x, @y );' . chr(10) . '            int array_size = s.to_int();' . chr(10) . '            for (int j = 0; j < array_size; j++) {' . chr(10) . '                pObject key = s.aget(j);' . chr(10) . '                j++;' . chr(10) . '                pObject value;' . chr(10) . '                if ( j >= array_size ) {' . chr(10) . '                    // TODO - emit warning about odd number of arguments' . chr(10) . '                    value = pCx.UNDEF;' . chr(10) . '                }' . chr(10) . '                else {' . chr(10) . '                    value = s.aget(j);' . chr(10) . '                }' . chr(10) . '                this.hset(key, value);' . chr(10) . '            }' . chr(10) . '        }' . chr(10) . '        else {' . chr(10) . '            // TODO - emit warning about odd number of arguments' . chr(10) . '            this.hset(s, pCx.UNDEF);' . chr(10) . '        }' . chr(10) . '        this.each_iterator = null;' . chr(10) . '        return this;' . chr(10) . '    }' . chr(10) . chr(10) . '    public pObject to_array() {' . chr(10) . '        pArray aa = new pArray();' . chr(10) . '        for (Map.Entry<String, pObject> entry : this.h.entrySet()) {' . chr(10) . '            String key = entry.getKey();' . chr(10) . '            pObject value = entry.getValue();' . chr(10) . '            aa.push(new pString(key));' . chr(10) . '            aa.push(value);' . chr(10) . '        }' . chr(10) . '        return aa;' . chr(10) . '    }' . chr(10) . chr(10) . '    public pObject hget(pObject i) {' . chr(10) . '        pObject o = this.h.get(i.to_string());' . chr(10) . '        if (o == null) {' . chr(10) . '            return pCx.UNDEF;' . chr(10) . '        }' . chr(10) . '        return o;' . chr(10) . '    }' . chr(10) . '    public pObject hget(String i) {' . chr(10) . '        pObject o = this.h.get(i);' . chr(10) . '        if (o == null) {' . chr(10) . '            return pCx.UNDEF;' . chr(10) . '        }' . chr(10) . '        return o;' . chr(10) . '    }' . chr(10) . '    public pObject hget_lvalue(pObject i) {' . chr(10) . '        pObject o = this.h.get(i.to_string());' . chr(10) . '        if (o == null) {' . chr(10) . '            pLvalue a = new pLvalue();' . chr(10) . '            this.h.put(i.to_string(), a);' . chr(10) . '            return a;' . chr(10) . '        }' . chr(10) . '        else if (o.is_scalar()) {' . chr(10) . '            return o;' . chr(10) . '        }' . chr(10) . '        pLvalue a = new pLvalue(o);' . chr(10) . '        this.h.put(i.to_string(), a);' . chr(10) . '        return a;' . chr(10) . '    }' . chr(10) . '    public pObject hget_lvalue(String i) {' . chr(10) . '        pObject o = this.h.get(i);' . chr(10) . '        if (o == null) {' . chr(10) . '            pLvalue a = new pLvalue();' . chr(10) . '            this.h.put(i, a);' . chr(10) . '            return a;' . chr(10) . '        }' . chr(10) . '        else if (o.is_scalar()) {' . chr(10) . '            return o;' . chr(10) . '        }' . chr(10) . '        pLvalue a = new pLvalue(o);' . chr(10) . '        this.h.put(i, a);' . chr(10) . '        return a;' . chr(10) . '    }' . chr(10) . chr(10) . '    public pObject get_scalar(pObject i) {' . chr(10) . '        // $$x' . chr(10) . '        pObject o = this.hget(i);' . chr(10) . '        if (o.is_undef()) {' . chr(10) . '            pLvalue a = new pLvalue();' . chr(10) . '            this.hset(i, new pLvalueRef(a));' . chr(10) . '            return a;' . chr(10) . '        }' . chr(10) . '        else if (o.is_scalarref()) {' . chr(10) . '            return o.get();' . chr(10) . '        }' . chr(10) . '        // Modification of a read-only value attempted' . chr(10) . '        // return pCORE.die("Not an SCALAR reference");' . chr(10) . '        return o;' . chr(10) . '    }' . chr(10) . chr(10) . '    public pObject hget_scalarref(pObject i) {' . chr(10) . '        pObject o = this.hget(i);' . chr(10) . '        if (o.is_undef()) {' . chr(10) . '            pLvalueRef ar = new pLvalueRef(new pLvalue());' . chr(10) . '            this.hset(i, ar);' . chr(10) . '            return ar;' . chr(10) . '        }' . chr(10) . '        else if (o.is_scalarref()) {' . chr(10) . '            return o;' . chr(10) . '        }' . chr(10) . '        // Modification of a read-only value attempted' . chr(10) . '        return o;' . chr(10) . '    }' . chr(10) . '    public pObject hget_scalarref(String i) {' . chr(10) . '        pObject o = this.hget(i);' . chr(10) . '        if (o.is_undef()) {' . chr(10) . '            pLvalueRef ar = new pLvalueRef(new pLvalue());' . chr(10) . '            this.hset(i, ar);' . chr(10) . '            return ar;' . chr(10) . '        }' . chr(10) . '        else if (o.is_scalarref()) {' . chr(10) . '            return o;' . chr(10) . '        }' . chr(10) . '        // Modification of a read-only value attempted' . chr(10) . '        return o;' . chr(10) . '    }' . chr(10) . chr(10) . '    public pObject hget_arrayref(pObject i) {' . chr(10) . '        pObject o = this.hget(i);' . chr(10) . '        if (o.is_undef()) {' . chr(10) . '            pArrayRef ar = new pArrayRef();' . chr(10) . '            this.hset(i, ar);' . chr(10) . '            return ar;' . chr(10) . '        }' . chr(10) . '        else if (o.is_arrayref()) {' . chr(10) . '            return o;' . chr(10) . '        }' . chr(10) . '        return pCORE.die("Not an ARRAY reference");' . chr(10) . '    }' . chr(10) . '    public pObject hget_arrayref(String i) {' . chr(10) . '        pObject o = this.hget(i);' . chr(10) . '        if (o.is_undef()) {' . chr(10) . '            pArrayRef ar = new pArrayRef();' . chr(10) . '            this.hset(i, ar);' . chr(10) . '            return ar;' . chr(10) . '        }' . chr(10) . '        else if (o.is_arrayref()) {' . chr(10) . '            return o;' . chr(10) . '        }' . chr(10) . '        return pCORE.die("Not an ARRAY reference");' . chr(10) . '    }' . chr(10) . chr(10) . '    public pObject hget_hashref(pObject i) {' . chr(10) . '        pObject o = this.hget(i);' . chr(10) . '        if (o.is_undef()) {' . chr(10) . '            pHashRef hr = new pHashRef();' . chr(10) . '            this.hset(i, hr);' . chr(10) . '            return hr;' . chr(10) . '        }' . chr(10) . '        else if (o.is_hashref()) {' . chr(10) . '            return o;' . chr(10) . '        }' . chr(10) . '        return pCORE.die("Not a HASH reference");' . chr(10) . '    }' . chr(10) . '    public pObject hget_hashref(String i) {' . chr(10) . '        pObject o = this.hget(i);' . chr(10) . '        if (o.is_undef()) {' . chr(10) . '            pHashRef hr = new pHashRef();' . chr(10) . '            this.hset(i, hr);' . chr(10) . '            return hr;' . chr(10) . '        }' . chr(10) . '        else if (o.is_hashref()) {' . chr(10) . '            return o;' . chr(10) . '        }' . chr(10) . '        return pCORE.die("Not a HASH reference");' . chr(10) . '    }' . chr(10) . chr(10) . '    // Note: multiple versions of set()' . chr(10) . '    public pObject hset(pObject s, pObject v) {' . chr(10) . '        this.h.put(s.to_string(), v.scalar());' . chr(10) . '        return v;' . chr(10) . '    }' . chr(10) . '    public pObject hset(String s, pObject v) {' . chr(10) . '        this.h.put(s, v.scalar());' . chr(10) . '        return v;' . chr(10) . '    }' . chr(10) . '    public pObject hset(pObject s, pLvalue v) {' . chr(10) . '        this.h.put(s.to_string(), v.get());' . chr(10) . '        return v;' . chr(10) . '    }' . chr(10) . '    public pObject hset(String s, pLvalue v) {' . chr(10) . '        this.h.put(s, v.get());' . chr(10) . '        return v;' . chr(10) . '    }' . chr(10) . chr(10) . '    public pObject exists(pObject i) {' . chr(10) . '        return this.h.containsKey(i) ? pCx.TRUE : pCx.FALSE;' . chr(10) . '    }' . chr(10) . '    public pObject delete(pObject i) {' . chr(10) . '        pObject r = this.h.remove(i);' . chr(10) . '        if (r == null) {' . chr(10) . '            return pCx.UNDEF;' . chr(10) . '        }' . chr(10) . '        return r;' . chr(10) . '    }' . chr(10) . '    public pObject values() {' . chr(10) . '        pArray aa = new pArray();' . chr(10) . '        for (Map.Entry<String, pObject> entry : this.h.entrySet()) {' . chr(10) . '            pObject value = entry.getValue();' . chr(10) . '            aa.push(value);' . chr(10) . '        }' . chr(10) . '        return aa;' . chr(10) . '    }' . chr(10) . '    public pObject keys() {' . chr(10) . '        pArray aa = new pArray();' . chr(10) . '        for (Map.Entry<String, pObject> entry : this.h.entrySet()) {' . chr(10) . '            String key = entry.getKey();' . chr(10) . '            aa.push(new pString(key));' . chr(10) . '        }' . chr(10) . '        return aa;' . chr(10) . '    }' . chr(10) . '    public pObject each() {' . chr(10) . '        if (this.each_iterator == null) {' . chr(10) . '            this.each_iterator = this.h.entrySet().iterator();' . chr(10) . '        }' . chr(10) . '        pArray aa = new pArray();' . chr(10) . '        if (this.each_iterator.hasNext()) {' . chr(10) . '            Map.Entry<String, pObject> entry = this.each_iterator.next();' . chr(10) . '            String key = entry.getKey();' . chr(10) . '            aa.push(new pString(key));' . chr(10) . '            pObject value = entry.getValue();' . chr(10) . '            aa.push(value);' . chr(10) . '        }' . chr(10) . '        else {' . chr(10) . '             // return empty list' . chr(10) . '             this.each_iterator = null;' . chr(10) . '        }' . chr(10) . '        return aa;' . chr(10) . '    }' . chr(10) . (join('', map {
        my $native = $_;
        my $perl = $native_to_perl{$native};
        $native && $perl ? '    public pObject hset(pObject s, ' . $native . ' v) {' . chr(10) . '        return this.hset(s, new ' . $perl . '(v));' . chr(10) . '    }' . chr(10) . '    public pObject hset(String s, ' . $native . ' v) {' . chr(10) . '        return this.hset(s, new ' . $perl . '(v));' . chr(10) . '    }' . chr(10) : ()
    } keys(%native_to_perl))) . chr(10) . '    public String to_string() {' . chr(10) . '        // TODO' . chr(10) . '        return "" + this.hashCode();' . chr(10) . '    }' . chr(10) . '    public int to_int() {' . chr(10) . '        // TODO' . chr(10) . '        return this.hashCode();' . chr(10) . '    }' . chr(10) . '    public double to_double() {' . chr(10) . '        return 0.0 + this.to_int();' . chr(10) . '    }' . chr(10) . '    public boolean to_bool() {' . chr(10) . '        return true;' . chr(10) . '    }' . chr(10) . '    public boolean is_int() {' . chr(10) . '        return false;' . chr(10) . '    }' . chr(10) . '    public boolean is_num() {' . chr(10) . '        return false;' . chr(10) . '    }' . chr(10) . '    public boolean is_string() {' . chr(10) . '        return false;' . chr(10) . '    }' . chr(10) . '    public boolean is_bool() {' . chr(10) . '        return false;' . chr(10) . '    }' . chr(10) . '    public boolean is_hash() {' . chr(10) . '        return true;' . chr(10) . '    }' . chr(10) . '    public pObject scalar() {' . chr(10) . '        return new pString(this.to_string());' . chr(10) . '    }' . chr(10) . '}' . chr(10) . 'class pUndef extends pObject {' . chr(10) . '    public pUndef() {' . chr(10) . '    }' . chr(10) . '    public pObject apply(int want, pArray List__) {' . chr(10) . '        // $a->()' . chr(10) . '        pCORE.die("Can' . chr(39) . 't use an undefined value as a subroutine reference");' . chr(10) . '        return this;' . chr(10) . '    }' . chr(10) . '    public int to_int() {' . chr(10) . '        return 0;' . chr(10) . '    }' . chr(10) . '    public double to_double() {' . chr(10) . '        return 0.0;' . chr(10) . '    }' . chr(10) . '    public String to_string() {' . chr(10) . '        return "";' . chr(10) . '    }' . chr(10) . '    public boolean to_bool() {' . chr(10) . '        return false;' . chr(10) . '    }' . chr(10) . '    public boolean is_bool() {' . chr(10) . '        return false;' . chr(10) . '    }' . chr(10) . '    public boolean is_undef() {' . chr(10) . '        return true;' . chr(10) . '    }' . chr(10) . '}' . chr(10) . 'class pBool extends pObject {' . chr(10) . '    private boolean i;' . chr(10) . '    public pBool(boolean i) {' . chr(10) . '        this.i = i;' . chr(10) . '    }' . chr(10) . '    public int to_int() {' . chr(10) . '        if (this.i) {' . chr(10) . '            return 1;' . chr(10) . '        }' . chr(10) . '        else {' . chr(10) . '            return 0;' . chr(10) . '        }' . chr(10) . '    }' . chr(10) . '    public double to_double() {' . chr(10) . '        if (this.i) {' . chr(10) . '            return 1.0;' . chr(10) . '        }' . chr(10) . '        else {' . chr(10) . '            return 0.0;' . chr(10) . '        }' . chr(10) . '    }' . chr(10) . '    public String to_string() {' . chr(10) . '        if (this.i) {' . chr(10) . '            return "1";' . chr(10) . '        }' . chr(10) . '        else {' . chr(10) . '            return "";' . chr(10) . '        }' . chr(10) . '    }' . chr(10) . '    public boolean to_bool() {' . chr(10) . '        return this.i;' . chr(10) . '    }' . chr(10) . '    public boolean is_bool() {' . chr(10) . '        return true;' . chr(10) . '    }' . chr(10) . '    public pObject _decr() {' . chr(10) . '        // --$x' . chr(10) . '        if (i) {' . chr(10) . '            return new pInt(0);' . chr(10) . '        }' . chr(10) . '        else {' . chr(10) . '            return new pInt(-1);' . chr(10) . '        }' . chr(10) . '    }' . chr(10) . '    public pObject _incr() {' . chr(10) . '        // ++$x' . chr(10) . '        if (i) {' . chr(10) . '            return new pInt(2);' . chr(10) . '        }' . chr(10) . '        else {' . chr(10) . '            return new pInt(1);' . chr(10) . '        }' . chr(10) . '    }' . chr(10) . '    public pObject neg() {' . chr(10) . '        if (i) {' . chr(10) . '            return new pInt(-1);' . chr(10) . '        }' . chr(10) . '        else {' . chr(10) . '            return new pInt(0);' . chr(10) . '        }' . chr(10) . '    }' . chr(10) . '}' . chr(10) . 'class pInt extends pObject {' . chr(10) . '    private int i;' . chr(10) . '    public pInt(int i) {' . chr(10) . '        this.i = i;' . chr(10) . '    }' . chr(10) . '    public int to_int() {' . chr(10) . '        return this.i;' . chr(10) . '    }' . chr(10) . '    public double to_double() {' . chr(10) . '        return (double)(this.i);' . chr(10) . '    }' . chr(10) . '    public String to_string() {' . chr(10) . '        return "" + this.i;' . chr(10) . '    }' . chr(10) . '    public boolean to_bool() {' . chr(10) . '        return this.i != 0;' . chr(10) . '    }' . chr(10) . '    public boolean is_int() {' . chr(10) . '        return true;' . chr(10) . '    }' . chr(10) . '    public pObject _decr() {' . chr(10) . '        // --$x' . chr(10) . '        return new pInt(i-1);' . chr(10) . '    }' . chr(10) . '    public pObject _incr() {' . chr(10) . '        // ++$x' . chr(10) . '        return new pInt(i+1);' . chr(10) . '    }' . chr(10) . '    public pObject neg() {' . chr(10) . '        return new pInt(-i);' . chr(10) . '    }' . chr(10) . '}' . chr(10) . 'class pDouble extends pObject {' . chr(10) . '    private double i;' . chr(10) . '    public pDouble(double i) {' . chr(10) . '        this.i = i;' . chr(10) . '    }' . chr(10) . '    public int to_int() {' . chr(10) . '        return (int)(this.i);' . chr(10) . '    }' . chr(10) . '    public double to_double() {' . chr(10) . '        return this.i;' . chr(10) . '    }' . chr(10) . '    public String to_string() {' . chr(10) . '        String s = "" + this.i;' . chr(10) . '        final int length = s.length();' . chr(10) . '        final int dot = s.indexOf(' . chr(39) . '.' . chr(39) . ');' . chr(10) . '        if (dot == -1) {' . chr(10) . '            return s;' . chr(10) . '        }' . chr(10) . '        for (int i = dot + 1; i < length; ++i) {' . chr(10) . '            if (s.charAt(i) != ' . chr(39) . '0' . chr(39) . ') {' . chr(10) . '                return s;' . chr(10) . '            }' . chr(10) . '        }' . chr(10) . '        return s.substring(0, dot);' . chr(10) . '    }' . chr(10) . '    public boolean to_bool() {' . chr(10) . '        return this.i != 0.0;' . chr(10) . '    }' . chr(10) . '    public pObject _decr() {' . chr(10) . '        // --$x' . chr(10) . '        return new pDouble(i-1);' . chr(10) . '    }' . chr(10) . '    public pObject _incr() {' . chr(10) . '        // ++$x' . chr(10) . '        return new pDouble(i+1);' . chr(10) . '    }' . chr(10) . '    public pObject neg() {' . chr(10) . '        return new pDouble(-i);' . chr(10) . '    }' . chr(10) . '    public pObject abs() {' . chr(10) . '        return new pDouble(i < 0.0 ? -i : i);' . chr(10) . '    }' . chr(10) . '    public pObject num_cmp(pObject b) {' . chr(10) . '        int c = new Double(this.i).compareTo(b.to_double());' . chr(10) . '        return new pInt(c == 0 ? c : c < 0 ? -1 : 1);' . chr(10) . '    }' . chr(10) . '    public pObject num_cmp2(pObject b) {' . chr(10) . '        int c = new Double(b.to_double()).compareTo(this.i);' . chr(10) . '        return new pInt(c == 0 ? c : c < 0 ? -1 : 1);' . chr(10) . '    }' . chr(10) . (join('', map {
        my $perl = $_;
        my $native = $number_binop{$perl}->{'op'};
        my $returns = $number_binop{$perl}->{'num_returns'};
        '    public pObject ' . $perl . '(pObject s) {' . chr(10) . '        // num - int, num - num' . chr(10) . '        return new ' . $returns . '( this.i ' . $native . ' s.to_double() );' . chr(10) . '    }' . chr(10) . '    public pObject ' . $perl . '2(pObject s) {' . chr(10) . '        // int - num' . chr(10) . '        return new ' . $returns . '( s.to_double() ' . $native . ' this.i );' . chr(10) . '    }' . chr(10)
    } keys(%number_binop))) . '    public boolean is_num() {' . chr(10) . '        return true;' . chr(10) . '    }' . chr(10) . '}' . chr(10) . 'class pString extends pObject {' . chr(10) . '    private java.lang.String s;' . chr(10) . '    public pString(String s) {' . chr(10) . '        this.s = s;' . chr(10) . '    }' . chr(10) . '    public pString(char s) {' . chr(10) . '        this.s = "" + s;' . chr(10) . '    }' . chr(10) . '    private pObject _parse_exp(int length, int signal, int offset, int next) {' . chr(10) . '        // 123.45E^^^' . chr(10) . '        int offset3 = next;' . chr(10) . '        for ( ; offset3 < length; ) {' . chr(10) . '            final int c3 = s.codePointAt(offset3);' . chr(10) . '            switch (c3) {        ' . chr(10) . '                case ' . chr(39) . '+' . chr(39) . ': case ' . chr(39) . '-' . chr(39) . ':' . chr(10) . '                    // TODO' . chr(10) . '                    break;' . chr(10) . '                case ' . chr(39) . '0' . chr(39) . ': case ' . chr(39) . '1' . chr(39) . ': case ' . chr(39) . '2' . chr(39) . ': case ' . chr(39) . '3' . chr(39) . ': case ' . chr(39) . '4' . chr(39) . ':' . chr(10) . '                case ' . chr(39) . '5' . chr(39) . ': case ' . chr(39) . '6' . chr(39) . ': case ' . chr(39) . '7' . chr(39) . ': case ' . chr(39) . '8' . chr(39) . ': case ' . chr(39) . '9' . chr(39) . ':' . chr(10) . '                    break;' . chr(10) . '                default:    // invalid' . chr(10) . '                    return new pDouble(Double.parseDouble(this.s.substring(0, offset3)));' . chr(10) . '            }' . chr(10) . '            offset3++;' . chr(10) . '        }' . chr(10) . '        return new pDouble(Double.parseDouble(this.s.substring(0, offset3)));' . chr(10) . '    }' . chr(10) . '    private pObject _parse_dot(int length, int signal, int offset, int next) {' . chr(10) . '        // 123.^^^' . chr(10) . '        int offset3 = next;' . chr(10) . '        for ( ; offset3 < length; ) {' . chr(10) . '            final int c3 = s.codePointAt(offset3);' . chr(10) . '            switch (c3) {        ' . chr(10) . '                case ' . chr(39) . '0' . chr(39) . ': case ' . chr(39) . '1' . chr(39) . ': case ' . chr(39) . '2' . chr(39) . ': case ' . chr(39) . '3' . chr(39) . ': case ' . chr(39) . '4' . chr(39) . ':' . chr(10) . '                case ' . chr(39) . '5' . chr(39) . ': case ' . chr(39) . '6' . chr(39) . ': case ' . chr(39) . '7' . chr(39) . ': case ' . chr(39) . '8' . chr(39) . ': case ' . chr(39) . '9' . chr(39) . ':' . chr(10) . '                    break;' . chr(10) . '                case ' . chr(39) . 'E' . chr(39) . ': case ' . chr(39) . 'e' . chr(39) . ':' . chr(10) . '                    // start exponential part' . chr(10) . '                    return _parse_exp(length, signal, offset, offset3+1);' . chr(10) . '                default:    // invalid' . chr(10) . '                    return new pDouble(Double.parseDouble(this.s.substring(0, offset3)));' . chr(10) . '            }' . chr(10) . '            offset3++;' . chr(10) . '        }' . chr(10) . '        return new pDouble(Double.parseDouble(this.s.substring(0, offset3)));' . chr(10) . '    }' . chr(10) . '    public pObject parse() {' . chr(10) . '        final int length = s.length();' . chr(10) . '        int signal = 0;' . chr(10) . '        for (int offset = 0; offset < length; ) {' . chr(10) . '            final int c = s.codePointAt(offset);' . chr(10) . '            switch (c) {        ' . chr(10) . '                case ' . chr(39) . 'i' . chr(39) . ': case ' . chr(39) . 'I' . chr(39) . ':' . chr(10) . '                            if (this.s.substring(offset, offset+3).equalsIgnoreCase("inf")) {' . chr(10) . '                                if (signal < 0) {' . chr(10) . '                                    return new pDouble(Double.NEGATIVE_INFINITY);' . chr(10) . '                                }' . chr(10) . '                                else {' . chr(10) . '                                    return new pDouble(Double.POSITIVE_INFINITY);' . chr(10) . '                                }' . chr(10) . '                            }' . chr(10) . '                            return new pInt(0);' . chr(10) . '                case ' . chr(39) . 'n' . chr(39) . ': case ' . chr(39) . 'N' . chr(39) . ':' . chr(10) . '                            if (this.s.substring(offset, offset+3).equalsIgnoreCase("nan")) {' . chr(10) . '                                return new pDouble(Double.NaN);' . chr(10) . '                            }' . chr(10) . '                            return new pInt(0);' . chr(10) . '                case ' . chr(39) . '.' . chr(39) . ':   // starts with dot' . chr(10) . '                            if (signal != 0) {' . chr(10) . '                                signal = 1;' . chr(10) . '                            }' . chr(10) . '                            return _parse_dot(length, signal, offset, offset+1);' . chr(10) . '                case ' . chr(39) . '0' . chr(39) . ': case ' . chr(39) . '1' . chr(39) . ': case ' . chr(39) . '2' . chr(39) . ': case ' . chr(39) . '3' . chr(39) . ': case ' . chr(39) . '4' . chr(39) . ':' . chr(10) . '                case ' . chr(39) . '5' . chr(39) . ': case ' . chr(39) . '6' . chr(39) . ': case ' . chr(39) . '7' . chr(39) . ': case ' . chr(39) . '8' . chr(39) . ': case ' . chr(39) . '9' . chr(39) . ':' . chr(10) . '                            // starts with number' . chr(10) . '                            if (signal == 0) {' . chr(10) . '                                signal = 1;' . chr(10) . '                            }' . chr(10) . '                            int offset2 = offset+1;' . chr(10) . '                            for ( ; offset2 < length; ) {' . chr(10) . '                                final int c2 = s.codePointAt(offset2);' . chr(10) . '                                switch (c2) {        ' . chr(10) . '                                    case ' . chr(39) . '0' . chr(39) . ': case ' . chr(39) . '1' . chr(39) . ': case ' . chr(39) . '2' . chr(39) . ': case ' . chr(39) . '3' . chr(39) . ': case ' . chr(39) . '4' . chr(39) . ':' . chr(10) . '                                    case ' . chr(39) . '5' . chr(39) . ': case ' . chr(39) . '6' . chr(39) . ': case ' . chr(39) . '7' . chr(39) . ': case ' . chr(39) . '8' . chr(39) . ': case ' . chr(39) . '9' . chr(39) . ':' . chr(10) . '                                        // more numbers' . chr(10) . '                                        break;' . chr(10) . '                                    case ' . chr(39) . '.' . chr(39) . ':' . chr(10) . '                                        // start decimal part' . chr(10) . '                                        return _parse_dot(length, signal, offset, offset2+1);' . chr(10) . '                                    case ' . chr(39) . 'E' . chr(39) . ': case ' . chr(39) . 'e' . chr(39) . ':' . chr(10) . '                                        // start exponential part' . chr(10) . '                                        return _parse_exp(length, signal, offset, offset2+1);' . chr(10) . '                                    default:' . chr(10) . '                                        // return integer' . chr(10) . '                                        if (signal < 0) {' . chr(10) . '                                            return new pInt(-Integer.parseInt(this.s.substring(offset, offset2)));' . chr(10) . '                                        }' . chr(10) . '                                        else {' . chr(10) . '                                            return new pInt(Integer.parseInt(this.s.substring(offset, offset2)));' . chr(10) . '                                        }' . chr(10) . '                                }' . chr(10) . '                                offset2++;' . chr(10) . '                            }' . chr(10) . '                            // integer' . chr(10) . '                            if (signal < 0) {' . chr(10) . '                                return new pInt(-Integer.parseInt(this.s.substring(offset, offset2)));' . chr(10) . '                            }' . chr(10) . '                            else {' . chr(10) . '                                return new pInt(Integer.parseInt(this.s.substring(offset, offset2)));' . chr(10) . '                            }' . chr(10) . '                case ' . chr(39) . '+' . chr(39) . ':   // starts with +' . chr(10) . '                            if (signal != 0) {' . chr(10) . '                                // invalid' . chr(10) . '                                return new pInt(0);' . chr(10) . '                            }' . chr(10) . '                            signal = 1;' . chr(10) . '                            break;' . chr(10) . '                case ' . chr(39) . '-' . chr(39) . ':   // starts with -' . chr(10) . '                            if (signal != 0) {' . chr(10) . '                                // invalid' . chr(10) . '                                return new pInt(0);' . chr(10) . '                            }' . chr(10) . '                            signal = -1;' . chr(10) . '                            break;' . chr(10) . '                case ' . chr(39) . ' ' . chr(39) . ': case ' . chr(39) . chr(92) . 't' . chr(39) . ': case ' . chr(39) . chr(92) . 'n' . chr(39) . ': case ' . chr(39) . chr(92) . 'r' . chr(39) . ':' . chr(10) . '                            // starts with space' . chr(10) . '                            if (signal != 0) {' . chr(10) . '                                // invalid' . chr(10) . '                                return new pInt(0);' . chr(10) . '                            }' . chr(10) . '                            break;' . chr(10) . '                default:    // invalid' . chr(10) . '                            return new pInt(0);' . chr(10) . '            }' . chr(10) . '            offset++;' . chr(10) . '        }' . chr(10) . '        return new pInt(0);' . chr(10) . '    }' . chr(10) . '    public int to_int() {' . chr(10) . '        return this.parse().to_int();' . chr(10) . '    }' . chr(10) . '    public double to_double() {' . chr(10) . '        return this.parse().to_double();' . chr(10) . '    }' . chr(10) . '    public String to_string() {' . chr(10) . '        return this.s;' . chr(10) . '    }' . chr(10) . '    public boolean to_bool() {' . chr(10) . '        return this.s != ""' . chr(10) . '            && this.s != "0";' . chr(10) . '    }' . chr(10) . '    public boolean is_string() {' . chr(10) . '        return true;' . chr(10) . '    }' . chr(10) . '    public pObject _decr() {' . chr(10) . '        // --$x' . chr(10) . '        return this.add(new pInt(-1));' . chr(10) . '    }' . chr(10) . '    public pObject _incr() {' . chr(10) . '        // ++$x' . chr(10) . '        final int length = s.length();' . chr(10) . '        if (length == 0) {' . chr(10) . '            return new pInt(1);' . chr(10) . '        }' . chr(10) . '        final int c = this.s.codePointAt(0);' . chr(10) . '        switch (c) {        ' . chr(10) . '            case ' . chr(39) . ' ' . chr(39) . ': case ' . chr(39) . chr(92) . 't' . chr(39) . ': case ' . chr(39) . chr(92) . 'n' . chr(39) . ': case ' . chr(39) . chr(92) . 'r' . chr(39) . ':' . chr(10) . '            case ' . chr(39) . '+' . chr(39) . ': case ' . chr(39) . '-' . chr(39) . ': case ' . chr(39) . '.' . chr(39) . ':' . chr(10) . '            case ' . chr(39) . '0' . chr(39) . ': case ' . chr(39) . '1' . chr(39) . ': case ' . chr(39) . '2' . chr(39) . ': case ' . chr(39) . '3' . chr(39) . ': case ' . chr(39) . '4' . chr(39) . ':' . chr(10) . '            case ' . chr(39) . '5' . chr(39) . ': case ' . chr(39) . '6' . chr(39) . ': case ' . chr(39) . '7' . chr(39) . ': case ' . chr(39) . '8' . chr(39) . ': case ' . chr(39) . '9' . chr(39) . ':' . chr(10) . '                return this.add(new pInt(1));' . chr(10) . '        }' . chr(10) . '        return new pString(PerlOp.string_increment(this.s));' . chr(10) . '    }' . chr(10) . '    public pObject neg() {' . chr(10) . '        final int length = s.length();' . chr(10) . '        if (length == 0) {' . chr(10) . '            return new pInt(0);' . chr(10) . '        }' . chr(10) . '        final int c = this.s.codePointAt(0);' . chr(10) . '        switch (c) {        ' . chr(10) . '            case ' . chr(39) . '+' . chr(39) . ': case ' . chr(39) . '-' . chr(39) . ':' . chr(10) . '                if (c == ' . chr(39) . '+' . chr(39) . ') {' . chr(10) . '                    return new pString( ' . chr(39) . '-' . chr(39) . ' + s.substring(1) );' . chr(10) . '                }' . chr(10) . '                if (c == ' . chr(39) . '-' . chr(39) . ') {' . chr(10) . '                    return new pString( ' . chr(39) . '+' . chr(39) . ' + s.substring(1) );' . chr(10) . '                }' . chr(10) . '            case ' . chr(39) . '.' . chr(39) . ':' . chr(10) . '            case ' . chr(39) . ' ' . chr(39) . ': case ' . chr(39) . chr(92) . 't' . chr(39) . ': case ' . chr(39) . chr(92) . 'n' . chr(39) . ': case ' . chr(39) . chr(92) . 'r' . chr(39) . ':' . chr(10) . '            case ' . chr(39) . '0' . chr(39) . ': case ' . chr(39) . '1' . chr(39) . ': case ' . chr(39) . '2' . chr(39) . ': case ' . chr(39) . '3' . chr(39) . ': case ' . chr(39) . '4' . chr(39) . ':' . chr(10) . '            case ' . chr(39) . '5' . chr(39) . ': case ' . chr(39) . '6' . chr(39) . ': case ' . chr(39) . '7' . chr(39) . ': case ' . chr(39) . '8' . chr(39) . ': case ' . chr(39) . '9' . chr(39) . ':' . chr(10) . '                return this.parse().neg();' . chr(10) . '        }' . chr(10) . '        if ((c >= ' . chr(39) . 'A' . chr(39) . ' && c <= ' . chr(39) . 'Z' . chr(39) . ') || (c >= ' . chr(39) . 'a' . chr(39) . ' && c <= ' . chr(39) . 'z' . chr(39) . ')) {' . chr(10) . '            return new pString( ' . chr(39) . '-' . chr(39) . ' + s );' . chr(10) . '        }' . chr(10) . '        return new pInt(0);' . chr(10) . '    }' . chr(10) . '    public pObject abs() {' . chr(10) . '        return this.parse().abs();' . chr(10) . '    }' . chr(10) . '    public pObject num_cmp(pObject b) {' . chr(10) . '        return this.parse().num_cmp(b);' . chr(10) . '    }' . chr(10) . '    public pObject num_cmp2(pObject b) {' . chr(10) . '        return b.num_cmp2(this.parse());' . chr(10) . '    }' . chr(10) . (join('', map {
        my $perl = $_;
        my $native = $number_binop{$perl}->{'op'};
        my $returns = $number_binop{$perl}->{'returns'};
        my $num_returns = $number_binop{$perl}->{'num_returns'};
        if ($returns eq 'pDouble') {
            '    public pObject ' . $perl . '(pObject b) {' . chr(10) . '        // ' . chr(39) . 'num' . chr(39) . ' - int, ' . chr(39) . 'num' . chr(39) . ' - num' . chr(10) . '        return this.parse().' . $perl . '(b);' . chr(10) . '    }' . chr(10) . '    public pObject ' . $perl . '2(pObject b) {' . chr(10) . '        // int - ' . chr(39) . 'num' . chr(39) . chr(10) . '        return b.' . $perl . '(this.parse());' . chr(10) . '    }' . chr(10)
        }
        else {
            '    public pObject ' . $perl . '(pObject b) {' . chr(10) . '        // ' . chr(39) . 'num' . chr(39) . ' - int, ' . chr(39) . 'num' . chr(39) . ' - num' . chr(10) . '        return this.parse().' . $perl . '(b);' . chr(10) . '    }' . chr(10) . '    public pObject ' . $perl . '2(pObject b) {' . chr(10) . '        // int - ' . chr(39) . 'num' . chr(39) . chr(10) . '        return b.' . $perl . '(this.parse());' . chr(10) . '    }' . chr(10)
        }
    } keys(%number_binop))) . '}' . chr(10) . join('', (map {
        my $class = $_;
        my $java_class_name = $class->{'java_type'};
        my $perl_to_java = $class->{'perl_to_java'};
        my $perl_package = $class->{'perl_package'};
        my $java_native_to_perl = $class->{'java_native_to_perl'};
        $class->{'import'} ? 'class ' . $java_native_to_perl . ' extends pReference {' . chr(10) . '    public static final pString REF = new pString("' . $perl_package . '");' . chr(10) . '    private ' . $java_class_name . ' stuff;' . chr(10) . chr(10) . '    public ' . $java_native_to_perl . '(' . $java_class_name . ' stuff) {' . chr(10) . '        this.stuff = stuff;' . chr(10) . '    }' . chr(10) . '    public ' . $java_class_name . ' ' . $perl_to_java . '() {' . chr(10) . '        return this.stuff;' . chr(10) . '    }' . chr(10) . '    public boolean is_undef() {' . chr(10) . '        return stuff == null;' . chr(10) . '    }' . chr(10) . '    public pObject ref() {' . chr(10) . '        return REF;' . chr(10) . '    }' . chr(10) . '}' . chr(10) : ()
    } values(%java_classes))) . '// end Perl-Java runtime' . chr(10)
}
1;
# use Perlito5::Java::Runtime
# use strict
my $_V5_COMPILER_NAME = 'Perlito5';
my $_V5_COMPILER_VERSION = '9.0';
my $source = '';
my $backend = ${chr(15)};
my $execute = 1;
my $verbose = 0;
my $expand_use = 1;
my $boilerplate = 1;
my $bootstrapping = 0;
my $wrapper_begin = '';
my $wrapper_end = '';
my $wrapper_priority = 0;
my @Use;
if ($verbose) {
    warn('// Perlito5 compiler');
    warn('// ARGV: ' . join(${'"'}, @ARGV))
}
my $help_message = chr(10) . 'perlito5 [switches] [programfile]' . chr(10) . '  switches:' . chr(10) . '    -e program      one line of program (omit programfile)' . chr(10) . '    -h --help' . chr(10) . '    -Idirectory     specify @INC/include directory (several -I' . chr(39) . 's allowed)' . chr(10) . '    -[mM][-]module  execute "use/no module..." before executing program' . chr(10) . '    -n              assume "while (<>) { ... }" loop around program' . chr(10) . '    -p              assume loop like -n but print line also, like sed' . chr(10) . '    -V --version' . chr(10) . '    -v' . chr(10) . '    --verbose' . chr(10) . '    -Ctarget        target backend: js, perl5, perl6, xs, java' . chr(10) . '    -Cast-perl5     emits a dump of the abstract syntax tree' . chr(10) . '    --expand_use --noexpand_use' . chr(10) . '                    expand ' . chr(39) . 'use' . chr(39) . ' statements at compile time' . chr(10) . '    --boilerplate --noboilerplate' . chr(10) . '                    emits or not boilerplate code' . chr(10) . '    --bootstrapping set this when compiling the compiler' . chr(10);
my $copyright_message = 'This is Perlito5 ' . $_V5_COMPILER_VERSION . ', an implementation of the Perl language.' . chr(10) . chr(10) . 'The Perl language is Copyright 1987-2012, Larry Wall' . chr(10) . 'The Perlito5 implementation is Copyright 2011, 2012 by Flavio Soibelmann Glock and others.' . chr(10) . chr(10) . 'Perl may be copied only under the terms of either the Artistic License or the' . chr(10) . 'GNU General Public License, which may be found in the Perl 5 source kit.' . chr(10) . chr(10) . 'Complete documentation for Perl, including FAQ lists, should be found on' . chr(10) . 'this system using "man perl" or "perldoc perl".  If you have access to the' . chr(10) . 'Internet, point your browser at http://www.perl.org/, the Perl Home Page.' . chr(10);
sub Perlito5::chomp_switch {
    my $s = substr($ARGV[0], 2);
    if ($s) {
        $ARGV[0] = '-' . $s
    }
    else {
        shift(@ARGV)
    }
}
push(@Use, 'no warnings');
push(@Use, 'no strict');
while (substr($ARGV[0], 0, 1) eq '-' && substr($ARGV[0], 0, 2) ne '-e') {
    if ($ARGV[0] eq '--verbose') {
        $verbose = 1;
        shift(@ARGV)
    }
    elsif ($ARGV[0] eq '-I') {
        shift(@ARGV);
        my $lib = shift(@ARGV);
        unshift(@INC, $lib)
    }
    elsif (substr($ARGV[0], 0, 2) eq '-I') {
        my $lib = substr($ARGV[0], 2);
        unshift(@INC, $lib);
        shift(@ARGV)
    }
    elsif (substr($ARGV[0], 0, 2) eq '-C') {
        $backend = substr($ARGV[0], 2, 10);
        $execute = 0;
        shift(@ARGV)
    }
    elsif ($ARGV[0] eq '-MO=Deparse') {
        $backend = 'perl5';
        $execute = 0;
        $expand_use = 0;
        shift(@ARGV)
    }
    elsif (uc(substr($ARGV[0], 0, 2)) eq '-M') {
        my $s = $ARGV[0];
        my $import = '';
        if (substr($s, 1, 1) eq 'm') {
            $import = '()'
        }
        $s = substr($s, 2);
        my $use = 'use';
        if (substr($s, 0, 1) eq '-') {
            $use = 'no';
            $s = substr($s, 1)
        }
        if (index($s, '=') > -1) {
            ($s, $import) = split('=', $s);
            $import = 'split(/,/,q{' . $import . '})'
        }
        push(@Use, $use . ' ' . $s . ' ' . $import);
        shift(@ARGV)
    }
    elsif (substr($ARGV[0], 0, 2) eq '-w') {
        push(@Use, 'use warnings');
        chomp_switch()
    }
    elsif (substr($ARGV[0], 0, 2) eq '-W') {
        push(@Use, 'use warnings');
        chomp_switch()
    }
    elsif (substr($ARGV[0], 0, 2) eq '-X') {
        push(@Use, 'no warnings');
        chomp_switch()
    }
    elsif (substr($ARGV[0], 0, 2) eq '-n') {
        if ($wrapper_priority < 1) {
            $wrapper_begin = ' LINE: while (<>) { ';
            $wrapper_end = ' } ';
            $wrapper_priority = 1
        }
        chomp_switch()
    }
    elsif (substr($ARGV[0], 0, 2) eq '-p') {
        if ($wrapper_priority < 2) {
            $wrapper_begin = ' LINE: while (<>) { ';
            $wrapper_end = ' } continue { ' . ' print or die "-p destination: $!' . chr(92) . 'n"; ' . ' } ';
            $wrapper_priority = 2
        }
        chomp_switch()
    }
    elsif (($ARGV[0] eq '-V') || ($ARGV[0] eq '--version')) {
        $backend = '';
        say($_V5_COMPILER_NAME, ' ', $_V5_COMPILER_VERSION);
        shift(@ARGV)
    }
    elsif ($ARGV[0] eq '-v') {
        $backend = '';
        say($copyright_message);
        shift(@ARGV)
    }
    elsif ($ARGV[0] eq '-h' || $ARGV[0] eq '--help' || !@ARGV) {
        $backend = '';
        say($_V5_COMPILER_NAME, ' ', $_V5_COMPILER_VERSION, $help_message);
        shift(@ARGV)
    }
    elsif ($ARGV[0] eq '--expand_use') {
        $expand_use = 1;
        shift(@ARGV)
    }
    elsif ($ARGV[0] eq '--noexpand_use') {
        $expand_use = 0;
        shift(@ARGV)
    }
    elsif ($ARGV[0] eq '--boilerplate') {
        $boilerplate = 1;
        shift(@ARGV)
    }
    elsif ($ARGV[0] eq '--noboilerplate') {
        $boilerplate = 0;
        shift(@ARGV)
    }
    elsif ($ARGV[0] eq '--bootstrapping') {
        $bootstrapping = 1;
        shift(@ARGV)
    }
    else {
        die('Unrecognized switch: ' . $ARGV[0] . '  (-h will show valid options).' . chr(10))
    }
}
if ($backend && @ARGV) {
    local $Perlito5::FILE_NAME = $ARGV[0];
    local $Perlito5::LINE_NUMBER = 1;
    if ($ARGV[0] eq '-e') {
        shift(@ARGV);
        if ($verbose) {
            warn('// source from command line: ', $ARGV[0])
        }
        $source = shift(@ARGV)
    }
    else {
        if ($verbose) {
            warn('// source from file: ', $ARGV[0])
        }
        my $source_filename = shift(@ARGV);
        open(FILE, '<', $source_filename) or die('Cannot read ' . $source_filename . ': ' . ${'!'} . chr(10));
        local ${'/'} = undef;
        $source = <FILE>;
        close(FILE)
    }
    if ($verbose) {
        warn('// backend: ', $backend);
        warn('now parsing')
    }
    $Perlito5::PKG_NAME = 'main';
    $Perlito5::PROTO = {};
    $source = chr(10) . '# line 1' . chr(10) . $source;
    if ($wrapper_begin) {
        $source = ' ' . $wrapper_begin . ';' . chr(10) . '                    ' . $source . ';' . chr(10) . '                    ' . $wrapper_end . chr(10) . '                  '
    }
    if ($execute) {
        $Perlito5::EXPAND_USE = 1;
        local ${'@'};
        my $init = join('; ', @Use);
        eval('  package main;' . chr(10) . '                ' . $init . ';' . chr(10) . '                ' . $source . ';' . chr(10) . '                $@ = undef' . chr(10) . '            ');
        if (${'@'}) {
            my $error = ${'@'};
            warn($error);
            exit(255)
        }
    }
    else {
        eval {
            %INC = ();
            $bootstrapping && ($Perlito5::EXPAND_USE = 0);
            # no strict
            my $m;
            my $ok;
            eval {
                $m = Perlito5::Grammar::exp_stmts($source, 0);
                $ok = 1
            };
            if (!$ok || $m->{'to'} < length($source)) {
                my $error = ${'@'} || ($m->{'to'} < length($source) && 'Syntax Error near ' . $m->{'to'}) || 'Unknown error';
                warn($error);
                exit(255)
            }
            else {
                my $comp_units;
                if ($expand_use) {
                    my $ok;
                    eval {
                        $comp_units = Perlito5::Grammar::Use::add_comp_unit(Perlito5::Match::flat($m));
                        $ok = 1
                    };
                    if (!$ok) {
                        my $error = ${'@'} || 'Unknown error loading a module';
                        warn($error);
                        exit(255)
                    }
                }
                else {
                    $comp_units = Perlito5::Match::flat($m)
                }
                $comp_units = [Perlito5::AST::CompUnit::->new('name' => 'main', 'body' => $comp_units)];
                if ($backend eq 'perl5') {
                    say('# Do not edit this file - Generated by ', $_V5_COMPILER_NAME, ' ', $_V5_COMPILER_VERSION);
                    if ($expand_use) {
                        print(Perlito5::Perl5::Runtime::->emit_perl5())
                    }
                    my @data = Perlito5::AST::CompUnit::emit_perl5_program($comp_units);
                    my $out = [];
                    Perlito5::Perl5::PrettyPrinter::pretty_print(\@data, 0, $out);
                    print(join('', @{$out}), chr(10))
                }
                elsif ($backend eq 'perl6') {
                    if ($boilerplate) {
                        say('# Do not edit this file - Generated by ', $_V5_COMPILER_NAME, ' ', $_V5_COMPILER_VERSION);
                        say('use v6;')
                    }
                    if (!$boilerplate) {
                        if (ref($comp_units) eq 'ARRAY' && (@{$comp_units} == 1) && ref($comp_units->[0]) eq 'Perlito5::AST::CompUnit') {
                            $comp_units = $comp_units->[0]->{'body'}
                        }
                    }
                    my @data = Perlito5::AST::CompUnit::emit_perl6_program($comp_units);
                    my $out = [];
                    Perlito5::Perl6::PrettyPrinter::pretty_print(\@data, 0, $out);
                    print(join('', @{$out}));
                    $boilerplate && print(chr(10))
                }
                elsif ($backend eq 'js') {
                    say('// Do not edit this file - Generated by ', $_V5_COMPILER_NAME, ' ', $_V5_COMPILER_VERSION);
                    print(Perlito5::AST::CompUnit::emit_javascript2_program($comp_units, 'expand_use' => $expand_use))
                }
                elsif ($backend eq 'js3') {
                    say('// Do not edit this file - Generated by ', $_V5_COMPILER_NAME, ' ', $_V5_COMPILER_VERSION);
                    print(Perlito5::AST::CompUnit::emit_javascript3_program($comp_units, 'expand_use' => $expand_use))
                }
                elsif ($backend eq 'xs') {
                    say('/* Do not edit this file - Generated by ', $_V5_COMPILER_NAME, ' ', $_V5_COMPILER_VERSION, ' */');
                    print(Perlito5::AST::CompUnit::emit_xs_program($comp_units))
                }
                elsif ($backend eq 'java') {
                    say('// Do not edit this file - Generated by ', $_V5_COMPILER_NAME, ' ', $_V5_COMPILER_VERSION);
                    print(Perlito5::AST::CompUnit::emit_java_program($comp_units, 'expand_use' => $expand_use))
                }
                elsif ($backend eq 'ast-perl5') {
                    say(Perlito5::Dumper::ast_dumper($comp_units))
                }
                elsif ($backend eq 'ast-pretty') {
                    eval('use Data::Printer {colored=>1,class=>{expand=>"all",show_methods=>"none"}};p($comp_units);1');
                    print(${'@'})
                }
                elsif ($backend eq '_comp') {
                    say(Perlito5::Dumper::ast_dumper($Perlito5::SCOPE))
                }
                else {
                    die('don' . chr(39) . 't know what to do with backend ' . chr(39) . $backend . chr(39))
                }
            }
            ${'@'} = undef
        }
    }
    if (${'@'}) {
        my $error = ${'@'};
        warn($error);
        exit(255)
    }
}

