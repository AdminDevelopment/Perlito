// Do not edit this file - Generated by MiniPerl6 2.0
// class Rul
if (typeof Rul != 'object') {
  Rul = function() {};
  Rul = new Rul;
  Rul.f_isa = function (s) { return s == 'Rul' };
  Rul.f_perl = function () { return '::Rul(' + Main._dump(this) + ')' };
}
(function () {
  // sub constant
  Rul.f_constant = function (v_str) {
    try { var v_len;(v_len = Main.chars(v_str));if ( f_bool((v_str == "\\")) ) { (v_str = "\\\\") } else {  };if ( f_bool((v_str == "'")) ) { (v_str = "\\'") } else {  };if ( f_bool(v_len) ) { return(( f_string("( ( '") + f_string(( f_string(v_str) + f_string(( f_string("' eq substr( $str, $MATCH.to, ") + f_string(( f_string(v_len) + f_string(( f_string(")) ") + f_string(( f_string("  ?? (1 + ( $MATCH.to := ") + f_string(( f_string(v_len) + f_string(( f_string(" + $MATCH.to ))") + f_string(( f_string("  !! false ") + f_string(")") )) )) )) )) )) )) )) )) )) } else { throw("1") } } catch(err) { if ( err instanceof Error ) { throw(err) } else { return(err) } } 
  }
})();

// class Rul::Quantifier
if (typeof Rul$Quantifier != 'object') {
  Rul$Quantifier = function() {};
  Rul$Quantifier = new Rul$Quantifier;
  Rul$Quantifier.f_isa = function (s) { return s == 'Rul::Quantifier' };
  Rul$Quantifier.f_perl = function () { return '::Rul::Quantifier(' + Main._dump(this) + ')' };
}
(function () {
  // accessor term
  Rul$Quantifier.v_term = null;
  Rul$Quantifier.f_term = function () { return this.v_term }
  // accessor quant
  Rul$Quantifier.v_quant = null;
  Rul$Quantifier.f_quant = function () { return this.v_quant }
  // accessor greedy
  Rul$Quantifier.v_greedy = null;
  Rul$Quantifier.f_greedy = function () { return this.v_greedy }
  // accessor ws1
  Rul$Quantifier.v_ws1 = null;
  Rul$Quantifier.f_ws1 = function () { return this.v_ws1 }
  // accessor ws2
  Rul$Quantifier.v_ws2 = null;
  Rul$Quantifier.f_ws2 = function () { return this.v_ws2 }
  // accessor ws3
  Rul$Quantifier.v_ws3 = null;
  Rul$Quantifier.f_ws3 = function () { return this.v_ws3 }
  // method emit
  Rul$Quantifier.f_emit = function () {
    var v_self = this;
    try { return(this.v_term.f_emit()) } catch(err) { if ( err instanceof Error ) { throw(err) } else { return(err) } } 
  }
  Rul$Quantifier.f_emit;  // v8 bug workaround
})();

// class Rul::Or
if (typeof Rul$Or != 'object') {
  Rul$Or = function() {};
  Rul$Or = new Rul$Or;
  Rul$Or.f_isa = function (s) { return s == 'Rul::Or' };
  Rul$Or.f_perl = function () { return '::Rul::Or(' + Main._dump(this) + ')' };
}
(function () {
  // accessor or_list
  Rul$Or.v_or_list = null;
  Rul$Or.f_or_list = function () { return this.v_or_list }
  // method emit
  Rul$Or.f_emit = function () {
    var v_self = this;
    try { return(( f_string("do { ") + f_string(( f_string("my $pos1 := $MATCH.to; do{ ") + f_string(( f_string((function (a_) { var out = []; if ( typeof a_ == 'undefined' ) { return out }; for(var i = 0; i < a_.length; i++) { out.push( a_[i].f_emit() ) } return out; })(this.v_or_list).join("} || do { $MATCH.to := $pos1; ")) + f_string("} }") )) )) )) } catch(err) { if ( err instanceof Error ) { throw(err) } else { return(err) } } 
  }
  Rul$Or.f_emit;  // v8 bug workaround
})();

// class Rul::Concat
if (typeof Rul$Concat != 'object') {
  Rul$Concat = function() {};
  Rul$Concat = new Rul$Concat;
  Rul$Concat.f_isa = function (s) { return s == 'Rul::Concat' };
  Rul$Concat.f_perl = function () { return '::Rul::Concat(' + Main._dump(this) + ')' };
}
(function () {
  // accessor concat
  Rul$Concat.v_concat = null;
  Rul$Concat.f_concat = function () { return this.v_concat }
  // method emit
  Rul$Concat.f_emit = function () {
    var v_self = this;
    try { return(( f_string("(") + f_string(( f_string((function (a_) { var out = []; if ( typeof a_ == 'undefined' ) { return out }; for(var i = 0; i < a_.length; i++) { out.push( a_[i].f_emit() ) } return out; })(this.v_concat).join(" && ")) + f_string(")") )) )) } catch(err) { if ( err instanceof Error ) { throw(err) } else { return(err) } } 
  }
  Rul$Concat.f_emit;  // v8 bug workaround
})();

// class Rul::Subrule
if (typeof Rul$Subrule != 'object') {
  Rul$Subrule = function() {};
  Rul$Subrule = new Rul$Subrule;
  Rul$Subrule.f_isa = function (s) { return s == 'Rul::Subrule' };
  Rul$Subrule.f_perl = function () { return '::Rul::Subrule(' + Main._dump(this) + ')' };
}
(function () {
  // accessor metasyntax
  Rul$Subrule.v_metasyntax = null;
  Rul$Subrule.f_metasyntax = function () { return this.v_metasyntax }
  // method emit
  Rul$Subrule.f_emit = function () {
    var v_self = this;
    try { var v_meth;(v_meth = ( f_bool((1 + f_index(this.v_metasyntax, "."))) ? this.v_metasyntax : ( f_string("$grammar.") + f_string(this.v_metasyntax) )));return(( f_string("do { ") + f_string(( f_string("my $m2 := ") + f_string(( f_string(v_meth) + f_string(( f_string("($str, $MATCH.to); ") + f_string(( f_string("if $m2 { $MATCH.to := $m2.to; $MATCH{'") + f_string(( f_string(this.v_metasyntax) + f_string(( f_string("'} := $m2; 1 } else { false } ") + f_string("}") )) )) )) )) )) )) )) } catch(err) { if ( err instanceof Error ) { throw(err) } else { return(err) } } 
  }
  Rul$Subrule.f_emit;  // v8 bug workaround
})();

// class Rul::SubruleNoCapture
if (typeof Rul$SubruleNoCapture != 'object') {
  Rul$SubruleNoCapture = function() {};
  Rul$SubruleNoCapture = new Rul$SubruleNoCapture;
  Rul$SubruleNoCapture.f_isa = function (s) { return s == 'Rul::SubruleNoCapture' };
  Rul$SubruleNoCapture.f_perl = function () { return '::Rul::SubruleNoCapture(' + Main._dump(this) + ')' };
}
(function () {
  // accessor metasyntax
  Rul$SubruleNoCapture.v_metasyntax = null;
  Rul$SubruleNoCapture.f_metasyntax = function () { return this.v_metasyntax }
  // method emit
  Rul$SubruleNoCapture.f_emit = function () {
    var v_self = this;
    try { var v_meth;(v_meth = ( f_bool((1 + f_index(this.v_metasyntax, "."))) ? this.v_metasyntax : ( f_string("$grammar.") + f_string(this.v_metasyntax) )));return(( f_string("do { ") + f_string(( f_string("my $m2 := ") + f_string(( f_string(v_meth) + f_string(( f_string("($str, $MATCH.to); ") + f_string(( f_string("if $m2 { $MATCH.to := $m2.to; 1 } else { false } ") + f_string("}") )) )) )) )) )) } catch(err) { if ( err instanceof Error ) { throw(err) } else { return(err) } } 
  }
  Rul$SubruleNoCapture.f_emit;  // v8 bug workaround
})();

// class Rul::Var
if (typeof Rul$Var != 'object') {
  Rul$Var = function() {};
  Rul$Var = new Rul$Var;
  Rul$Var.f_isa = function (s) { return s == 'Rul::Var' };
  Rul$Var.f_perl = function () { return '::Rul::Var(' + Main._dump(this) + ')' };
}
(function () {
  // accessor sigil
  Rul$Var.v_sigil = null;
  Rul$Var.f_sigil = function () { return this.v_sigil }
  // accessor twigil
  Rul$Var.v_twigil = null;
  Rul$Var.f_twigil = function () { return this.v_twigil }
  // accessor name
  Rul$Var.v_name = null;
  Rul$Var.f_name = function () { return this.v_name }
  // method emit
  Rul$Var.f_emit = function () {
    var v_self = this;
    try { var v_table;(v_table = { "$":"$","@":"$List_","%":"$Hash_","&":"$Code_", });return(( f_string(v_table[this.v_sigil]) + f_string(this.v_name) )) } catch(err) { if ( err instanceof Error ) { throw(err) } else { return(err) } } 
  }
  Rul$Var.f_emit;  // v8 bug workaround
})();

// class Rul::Constant
if (typeof Rul$Constant != 'object') {
  Rul$Constant = function() {};
  Rul$Constant = new Rul$Constant;
  Rul$Constant.f_isa = function (s) { return s == 'Rul::Constant' };
  Rul$Constant.f_perl = function () { return '::Rul::Constant(' + Main._dump(this) + ')' };
}
(function () {
  // accessor constant
  Rul$Constant.v_constant = null;
  Rul$Constant.f_constant = function () { return this.v_constant }
  // method emit
  Rul$Constant.f_emit = function () {
    var v_self = this;
    try { var v_str;(v_str = this.v_constant);return(Rul.f_constant(v_str)) } catch(err) { if ( err instanceof Error ) { throw(err) } else { return(err) } } 
  }
  Rul$Constant.f_emit;  // v8 bug workaround
})();

// class Rul::Dot
if (typeof Rul$Dot != 'object') {
  Rul$Dot = function() {};
  Rul$Dot = new Rul$Dot;
  Rul$Dot.f_isa = function (s) { return s == 'Rul::Dot' };
  Rul$Dot.f_perl = function () { return '::Rul::Dot(' + Main._dump(this) + ')' };
}
(function () {
  // method emit
  Rul$Dot.f_emit = function () {
    var v_self = this;
    try { return(( f_string("( ('' ne substr( $str, $MATCH.to, 1 )) ") + f_string(( f_string("  ?? (1 + ($MATCH.to := 1 + $MATCH.to ))") + f_string(( f_string("  !! false ") + f_string(")") )) )) )) } catch(err) { if ( err instanceof Error ) { throw(err) } else { return(err) } } 
  }
  Rul$Dot.f_emit;  // v8 bug workaround
})();

// class Rul::SpecialChar
if (typeof Rul$SpecialChar != 'object') {
  Rul$SpecialChar = function() {};
  Rul$SpecialChar = new Rul$SpecialChar;
  Rul$SpecialChar.f_isa = function (s) { return s == 'Rul::SpecialChar' };
  Rul$SpecialChar.f_perl = function () { return '::Rul::SpecialChar(' + Main._dump(this) + ')' };
}
(function () {
  // accessor char
  Rul$SpecialChar.v_char = null;
  Rul$SpecialChar.f_char = function () { return this.v_char }
  // method emit
  Rul$SpecialChar.f_emit = function () {
    var v_self = this;
    try { var v_char;(v_char = this.v_char);if ( f_bool((v_char == "n")) ) { (v_rul = { __proto__:Rul$SubruleNoCapture, v_metasyntax: "is_newline",});(v_rul = v_rul.f_emit());throw(v_rul) } else {  };if ( f_bool((v_char == "N")) ) { (v_rul = { __proto__:Rul$SubruleNoCapture, v_metasyntax: "not_newline",});(v_rul = v_rul.f_emit());throw(v_rul) } else {  };if ( f_bool((v_char == "d")) ) { (v_rul = { __proto__:Rul$SubruleNoCapture, v_metasyntax: "digit",});(v_rul = v_rul.f_emit());throw(v_rul) } else {  };if ( f_bool((v_char == "s")) ) { (v_rul = { __proto__:Rul$SubruleNoCapture, v_metasyntax: "space",});(v_rul = v_rul.f_emit());throw(v_rul) } else {  };throw(Rul.f_constant(v_char)) } catch(err) { if ( err instanceof Error ) { throw(err) } else { return(err) } } 
  }
  Rul$SpecialChar.f_emit;  // v8 bug workaround
})();

// class Rul::Block
if (typeof Rul$Block != 'object') {
  Rul$Block = function() {};
  Rul$Block = new Rul$Block;
  Rul$Block.f_isa = function (s) { return s == 'Rul::Block' };
  Rul$Block.f_perl = function () { return '::Rul::Block(' + Main._dump(this) + ')' };
}
(function () {
  // accessor closure
  Rul$Block.v_closure = null;
  Rul$Block.f_closure = function () { return this.v_closure }
  // method emit
  Rul$Block.f_emit = function () {
    var v_self = this;
    try { return(( f_string("(do { ") + f_string(( f_string(this.v_closure) + f_string(" } || 1)") )) )) } catch(err) { if ( err instanceof Error ) { throw(err) } else { return(err) } } 
  }
  Rul$Block.f_emit;  // v8 bug workaround
})();

// class Rul::InterpolateVar
if (typeof Rul$InterpolateVar != 'object') {
  Rul$InterpolateVar = function() {};
  Rul$InterpolateVar = new Rul$InterpolateVar;
  Rul$InterpolateVar.f_isa = function (s) { return s == 'Rul::InterpolateVar' };
  Rul$InterpolateVar.f_perl = function () { return '::Rul::InterpolateVar(' + Main._dump(this) + ')' };
}
(function () {
  // accessor var
  Rul$InterpolateVar.v_var = null;
  Rul$InterpolateVar.f_var = function () { return this.v_var }
  // method emit
  Rul$InterpolateVar.f_emit = function () {
    var v_self = this;
    try { say(( f_string("# TODO: interpolate var ") + f_string(( f_string(this.v_var.f_emit()) + f_string("") )) ));return(f_die()) } catch(err) { if ( err instanceof Error ) { throw(err) } else { return(err) } } 
  }
  Rul$InterpolateVar.f_emit;  // v8 bug workaround
})();

// class Rul::NamedCapture
if (typeof Rul$NamedCapture != 'object') {
  Rul$NamedCapture = function() {};
  Rul$NamedCapture = new Rul$NamedCapture;
  Rul$NamedCapture.f_isa = function (s) { return s == 'Rul::NamedCapture' };
  Rul$NamedCapture.f_perl = function () { return '::Rul::NamedCapture(' + Main._dump(this) + ')' };
}
(function () {
  // accessor rule_exp
  Rul$NamedCapture.v_rule_exp = null;
  Rul$NamedCapture.f_rule_exp = function () { return this.v_rule_exp }
  // accessor capture_ident
  Rul$NamedCapture.v_capture_ident = null;
  Rul$NamedCapture.f_capture_ident = function () { return this.v_capture_ident }
  // method emit
  Rul$NamedCapture.f_emit = function () {
    var v_self = this;
    try { say(( f_string("# TODO: named capture ") + f_string(( f_string(this.v_capture_ident) + f_string(( f_string(" := ") + f_string(( f_string(this.v_rule_exp.f_emit()) + f_string("") )) )) )) ));return(f_die()) } catch(err) { if ( err instanceof Error ) { throw(err) } else { return(err) } } 
  }
  Rul$NamedCapture.f_emit;  // v8 bug workaround
})();

// class Rul::Before
if (typeof Rul$Before != 'object') {
  Rul$Before = function() {};
  Rul$Before = new Rul$Before;
  Rul$Before.f_isa = function (s) { return s == 'Rul::Before' };
  Rul$Before.f_perl = function () { return '::Rul::Before(' + Main._dump(this) + ')' };
}
(function () {
  // accessor rule_exp
  Rul$Before.v_rule_exp = null;
  Rul$Before.f_rule_exp = function () { return this.v_rule_exp }
  // method emit
  Rul$Before.f_emit = function () {
    var v_self = this;
    try { return(( f_string("do { ") + f_string(( f_string("my $tmp := $MATCH; ") + f_string(( f_string("$MATCH := ::MiniPerl6::Match( 'str' => $str, 'from' => $tmp.to, 'to' => $tmp.to, 'bool' => 1  ); ") + f_string(( f_string("$MATCH.bool := ") + f_string(( f_string(this.v_rule_exp.f_emit()) + f_string(( f_string("; ") + f_string(( f_string("$tmp.bool := ?$MATCH; ") + f_string(( f_string("$MATCH := $tmp; ") + f_string(( f_string("?$MATCH; ") + f_string("}") )) )) )) )) )) )) )) )) )) } catch(err) { if ( err instanceof Error ) { throw(err) } else { return(err) } } 
  }
  Rul$Before.f_emit;  // v8 bug workaround
})();

// class Rul::NotBefore
if (typeof Rul$NotBefore != 'object') {
  Rul$NotBefore = function() {};
  Rul$NotBefore = new Rul$NotBefore;
  Rul$NotBefore.f_isa = function (s) { return s == 'Rul::NotBefore' };
  Rul$NotBefore.f_perl = function () { return '::Rul::NotBefore(' + Main._dump(this) + ')' };
}
(function () {
  // accessor rule_exp
  Rul$NotBefore.v_rule_exp = null;
  Rul$NotBefore.f_rule_exp = function () { return this.v_rule_exp }
  // method emit
  Rul$NotBefore.f_emit = function () {
    var v_self = this;
    try { return(( f_string("do { ") + f_string(( f_string("my $tmp := $MATCH; ") + f_string(( f_string("$MATCH := ::MiniPerl6::Match( 'str' => $str, 'from' => $tmp.to, 'to' => $tmp.to, 'bool' => 1  ); ") + f_string(( f_string("$MATCH.bool := ") + f_string(( f_string(this.v_rule_exp.f_emit()) + f_string(( f_string("; ") + f_string(( f_string("$tmp.bool := !$MATCH; ") + f_string(( f_string("$MATCH := $tmp; ") + f_string(( f_string("?$MATCH; ") + f_string("}") )) )) )) )) )) )) )) )) )) } catch(err) { if ( err instanceof Error ) { throw(err) } else { return(err) } } 
  }
  Rul$NotBefore.f_emit;  // v8 bug workaround
})();

// class Rul::NegateCharClass
if (typeof Rul$NegateCharClass != 'object') {
  Rul$NegateCharClass = function() {};
  Rul$NegateCharClass = new Rul$NegateCharClass;
  Rul$NegateCharClass.f_isa = function (s) { return s == 'Rul::NegateCharClass' };
  Rul$NegateCharClass.f_perl = function () { return '::Rul::NegateCharClass(' + Main._dump(this) + ')' };
}
(function () {
  // accessor chars
  Rul$NegateCharClass.v_chars = null;
  Rul$NegateCharClass.f_chars = function () { return this.v_chars }
  // method emit
  Rul$NegateCharClass.f_emit = function () {
    var v_self = this;
    try { say("TODO NegateCharClass");return(f_die()) } catch(err) { if ( err instanceof Error ) { throw(err) } else { return(err) } } 
  }
  Rul$NegateCharClass.f_emit;  // v8 bug workaround
})();

// class Rul::CharClass
if (typeof Rul$CharClass != 'object') {
  Rul$CharClass = function() {};
  Rul$CharClass = new Rul$CharClass;
  Rul$CharClass.f_isa = function (s) { return s == 'Rul::CharClass' };
  Rul$CharClass.f_perl = function () { return '::Rul::CharClass(' + Main._dump(this) + ')' };
}
(function () {
  // accessor chars
  Rul$CharClass.v_chars = null;
  Rul$CharClass.f_chars = function () { return this.v_chars }
  // method emit
  Rul$CharClass.f_emit = function () {
    var v_self = this;
    try { say("TODO CharClass");return(f_die()) } catch(err) { if ( err instanceof Error ) { throw(err) } else { return(err) } } 
  }
  Rul$CharClass.f_emit;  // v8 bug workaround
})();

// class Rul::Capture
if (typeof Rul$Capture != 'object') {
  Rul$Capture = function() {};
  Rul$Capture = new Rul$Capture;
  Rul$Capture.f_isa = function (s) { return s == 'Rul::Capture' };
  Rul$Capture.f_perl = function () { return '::Rul::Capture(' + Main._dump(this) + ')' };
}
(function () {
  // accessor rule_exp
  Rul$Capture.v_rule_exp = null;
  Rul$Capture.f_rule_exp = function () { return this.v_rule_exp }
  // method emit
  Rul$Capture.f_emit = function () {
    var v_self = this;
    try { say("TODO RulCapture");return(f_die()) } catch(err) { if ( err instanceof Error ) { throw(err) } else { return(err) } } 
  }
  Rul$Capture.f_emit;  // v8 bug workaround
})();

// class Rul::CaptureResult
if (typeof Rul$CaptureResult != 'object') {
  Rul$CaptureResult = function() {};
  Rul$CaptureResult = new Rul$CaptureResult;
  Rul$CaptureResult.f_isa = function (s) { return s == 'Rul::CaptureResult' };
  Rul$CaptureResult.f_perl = function () { return '::Rul::CaptureResult(' + Main._dump(this) + ')' };
}
(function () {
  // accessor rule_exp
  Rul$CaptureResult.v_rule_exp = null;
  Rul$CaptureResult.f_rule_exp = function () { return this.v_rule_exp }
  // method emit
  Rul$CaptureResult.f_emit = function () {
    var v_self = this;
    try { say("TODO Rul::CaptureResult");return(f_die()) } catch(err) { if ( err instanceof Error ) { throw(err) } else { return(err) } } 
  }
  Rul$CaptureResult.f_emit;  // v8 bug workaround
})();

// class Rul::After
if (typeof Rul$After != 'object') {
  Rul$After = function() {};
  Rul$After = new Rul$After;
  Rul$After.f_isa = function (s) { return s == 'Rul::After' };
  Rul$After.f_perl = function () { return '::Rul::After(' + Main._dump(this) + ')' };
}
(function () {
  // accessor rule_exp
  Rul$After.v_rule_exp = null;
  Rul$After.f_rule_exp = function () { return this.v_rule_exp }
  // method emit
  Rul$After.f_emit = function () {
    var v_self = this;
    try { say("TODO Rul::After");return(f_die()) } catch(err) { if ( err instanceof Error ) { throw(err) } else { return(err) } } 
  }
  Rul$After.f_emit;  // v8 bug workaround
})();

